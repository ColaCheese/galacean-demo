function ___$insertStyle(css2) {
  if (!css2) {
    return;
  }
  if (typeof window === "undefined") {
    return;
  }
  var style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css2;
  document.head.appendChild(style);
  return css2;
}
function colorToString(color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === "THREE_CHAR_HEX" || colorFormat === "SIX_CHAR_HEX") {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = "0" + str;
    }
    return "#" + str;
  } else if (colorFormat === "CSS_RGB") {
    return "rgb(" + r + "," + g + "," + b + ")";
  } else if (colorFormat === "CSS_RGBA") {
    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
  } else if (colorFormat === "HEX") {
    return "0x" + color.hex.toString(16);
  } else if (colorFormat === "RGB_ARRAY") {
    return "[" + r + "," + g + "," + b + "]";
  } else if (colorFormat === "RGBA_ARRAY") {
    return "[" + r + "," + g + "," + b + "," + a + "]";
  } else if (colorFormat === "RGB_OBJ") {
    return "{r:" + r + ",g:" + g + ",b:" + b + "}";
  } else if (colorFormat === "RGBA_OBJ") {
    return "{r:" + r + ",g:" + g + ",b:" + b + ",a:" + a + "}";
  } else if (colorFormat === "HSV_OBJ") {
    return "{h:" + h + ",s:" + s + ",v:" + v + "}";
  } else if (colorFormat === "HSVA_OBJ") {
    return "{h:" + h + ",s:" + s + ",v:" + v + ",a:" + a + "}";
  }
  return "unknown format";
}
var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function(obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function(key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function(obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function(key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function() {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function() {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately)
          func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray)
      return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === void 0;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function(_isNaN) {
    function isNaN2(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN2.toString = function() {
      return _isNaN.toString();
    };
    return isNaN2;
  }(function(obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function(obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + "";
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};
var INTERPRETATIONS = [
  {
    litmus: Common.isString,
    conversions: {
      THREE_CHAR_HEX: {
        read: function read(original) {
          var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
          if (test === null) {
            return false;
          }
          return {
            space: "HEX",
            hex: parseInt("0x" + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
          };
        },
        write: colorToString
      },
      SIX_CHAR_HEX: {
        read: function read2(original) {
          var test = original.match(/^#([A-F0-9]{6})$/i);
          if (test === null) {
            return false;
          }
          return {
            space: "HEX",
            hex: parseInt("0x" + test[1].toString(), 0)
          };
        },
        write: colorToString
      },
      CSS_RGB: {
        read: function read3(original) {
          var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
          if (test === null) {
            return false;
          }
          return {
            space: "RGB",
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3])
          };
        },
        write: colorToString
      },
      CSS_RGBA: {
        read: function read4(original) {
          var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
          if (test === null) {
            return false;
          }
          return {
            space: "RGB",
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3]),
            a: parseFloat(test[4])
          };
        },
        write: colorToString
      }
    }
  },
  {
    litmus: Common.isNumber,
    conversions: {
      HEX: {
        read: function read5(original) {
          return {
            space: "HEX",
            hex: original,
            conversionName: "HEX"
          };
        },
        write: function write(color) {
          return color.hex;
        }
      }
    }
  },
  {
    litmus: Common.isArray,
    conversions: {
      RGB_ARRAY: {
        read: function read6(original) {
          if (original.length !== 3) {
            return false;
          }
          return {
            space: "RGB",
            r: original[0],
            g: original[1],
            b: original[2]
          };
        },
        write: function write2(color) {
          return [color.r, color.g, color.b];
        }
      },
      RGBA_ARRAY: {
        read: function read7(original) {
          if (original.length !== 4)
            return false;
          return {
            space: "RGB",
            r: original[0],
            g: original[1],
            b: original[2],
            a: original[3]
          };
        },
        write: function write3(color) {
          return [color.r, color.g, color.b, color.a];
        }
      }
    }
  },
  {
    litmus: Common.isObject,
    conversions: {
      RGBA_OBJ: {
        read: function read8(original) {
          if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
            return {
              space: "RGB",
              r: original.r,
              g: original.g,
              b: original.b,
              a: original.a
            };
          }
          return false;
        },
        write: function write4(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b,
            a: color.a
          };
        }
      },
      RGB_OBJ: {
        read: function read9(original) {
          if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
            return {
              space: "RGB",
              r: original.r,
              g: original.g,
              b: original.b
            };
          }
          return false;
        },
        write: function write5(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b
          };
        }
      },
      HSVA_OBJ: {
        read: function read10(original) {
          if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
            return {
              space: "HSV",
              h: original.h,
              s: original.s,
              v: original.v,
              a: original.a
            };
          }
          return false;
        },
        write: function write6(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v,
            a: color.a
          };
        }
      },
      HSV_OBJ: {
        read: function read11(original) {
          if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
            return {
              space: "HSV",
              h: original.h,
              s: original.s,
              v: original.v
            };
          }
          return false;
        },
        write: function write7(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v
          };
        }
      }
    }
  }
];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret2() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function(family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function(conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};
var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1 - s);
    var q2 = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var c = [[v, t, p], [q2, v, p], [p, v, t], [p, q2, v], [t, p, v], [v, p, q2]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 255;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(255 << tmpComponent);
  }
};
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var get = function get2(object, property, receiver) {
  if (object === null)
    object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);
  if (desc === void 0) {
    var parent = Object.getPrototypeOf(object);
    if (parent === null) {
      return void 0;
    } else {
      return get2(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === void 0) {
      return void 0;
    }
    return getter.call(receiver);
  }
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var possibleConstructorReturn = function(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};
var Color$2 = function() {
  function Color2() {
    classCallCheck(this, Color2);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error("Failed to interpret color arguments");
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color2, [{
    key: "toString",
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: "toHexString",
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: "toOriginal",
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color2;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$13() {
      if (this.__state.space === "RGB") {
        return this.__state[component];
      }
      Color$2.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$13(v) {
      if (this.__state.space !== "RGB") {
        Color$2.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = "RGB";
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$13() {
      if (this.__state.space === "HSV") {
        return this.__state[component];
      }
      Color$2.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$13(v) {
      if (this.__state.space !== "HSV") {
        Color$2.recalculateHSV(this);
        this.__state.space = "HSV";
      }
      this.__state[component] = v;
    }
  });
}
Color$2.recalculateRGB = function(color, component, componentHexIndex) {
  if (color.__state.space === "HEX") {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === "HSV") {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error("Corrupted color state");
  }
};
Color$2.recalculateHSV = function(color) {
  var result2 = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result2.s,
    v: result2.v
  });
  if (!Common.isNaN(result2.h)) {
    color.__state.h = result2.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color$2.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"];
defineRGBComponent(Color$2.prototype, "r", 2);
defineRGBComponent(Color$2.prototype, "g", 1);
defineRGBComponent(Color$2.prototype, "b", 0);
defineHSVComponent(Color$2.prototype, "h");
defineHSVComponent(Color$2.prototype, "s");
defineHSVComponent(Color$2.prototype, "v");
Object.defineProperty(Color$2.prototype, "a", {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color$2.prototype, "hex", {
  get: function get$$12() {
    if (this.__state.space !== "HEX") {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = "HEX";
    }
    return this.__state.hex;
  },
  set: function set$$12(v) {
    this.__state.space = "HEX";
    this.__state.hex = v;
  }
});
var Controller = function() {
  function Controller2(object, property) {
    classCallCheck(this, Controller2);
    this.initialValue = object[property];
    this.domElement = document.createElement("div");
    this.object = object;
    this.property = property;
    this.__onChange = void 0;
    this.__onFinishChange = void 0;
  }
  createClass(Controller2, [{
    key: "onChange",
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: "onFinishChange",
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: "setValue",
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: "updateDisplay",
    value: function updateDisplay2() {
      return this;
    }
  }, {
    key: "isModified",
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller2;
}();
var EVENT_MAP = {
  HTMLEvents: ["change"],
  MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
  KeyboardEvents: ["keydown"]
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function(v, k2) {
  Common.each(v, function(e) {
    EVENT_MAP_INV[e] = k2;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === "0" || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === void 0 || elem.style === void 0)
      return;
    elem.onselectstart = selectable ? function() {
      return false;
    } : function() {
    };
    elem.style.MozUserSelect = selectable ? "auto" : "none";
    elem.style.KhtmlUserSelect = selectable ? "auto" : "none";
    elem.unselectable = selectable ? "on" : "off";
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = "absolute";
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error("Event type " + eventType + " not supported.");
    }
    var evt = document.createEvent(className);
    switch (className) {
      case "MouseEvents": {
        var clientX = params.x || params.clientX || 0;
        var clientY = params.y || params.clientY || 0;
        evt.initMouseEvent(
          eventType,
          params.bubbles || false,
          params.cancelable || true,
          window,
          params.clickCount || 1,
          0,
          0,
          clientX,
          clientY,
          false,
          false,
          false,
          false,
          0,
          null
        );
        break;
      }
      case "KeyboardEvents": {
        var init = evt.initKeyboardEvent || evt.initKeyEvent;
        Common.defaults(params, {
          cancelable: true,
          ctrlKey: false,
          altKey: false,
          shiftKey: false,
          metaKey: false,
          keyCode: void 0,
          charCode: void 0
        });
        init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
        break;
      }
      default: {
        evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
        break;
      }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent("on" + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent("on" + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === void 0) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(" ").replace(/^\s+/, "").replace(/\s+$/, "");
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute("class");
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(" ");
        }
      }
    } else {
      elem.className = void 0;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp("(?:^|\\s+)" + className + "(?:\\s+|$)").test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style["border-left-width"]) + cssValueToPixels(style["border-right-width"]) + cssValueToPixels(style["padding-left"]) + cssValueToPixels(style["padding-right"]) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style["border-top-width"]) + cssValueToPixels(style["border-bottom-width"]) + cssValueToPixels(style["padding-top"]) + cssValueToPixels(style["padding-bottom"]) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};
var BooleanController = function(_Controller) {
  inherits(BooleanController2, _Controller);
  function BooleanController2(object, property) {
    classCallCheck(this, BooleanController2);
    var _this2 = possibleConstructorReturn(this, (BooleanController2.__proto__ || Object.getPrototypeOf(BooleanController2)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement("input");
    _this2.__checkbox.setAttribute("type", "checkbox");
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, "change", onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController2, [{
    key: "setValue",
    value: function setValue(v) {
      var toReturn2 = get(BooleanController2.prototype.__proto__ || Object.getPrototypeOf(BooleanController2.prototype), "setValue", this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn2;
    }
  }, {
    key: "updateDisplay",
    value: function updateDisplay2() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute("checked", "checked");
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController2.prototype.__proto__ || Object.getPrototypeOf(BooleanController2.prototype), "updateDisplay", this).call(this);
    }
  }]);
  return BooleanController2;
}(Controller);
var OptionController = function(_Controller) {
  inherits(OptionController2, _Controller);
  function OptionController2(object, property, opts) {
    classCallCheck(this, OptionController2);
    var _this2 = possibleConstructorReturn(this, (OptionController2.__proto__ || Object.getPrototypeOf(OptionController2)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement("select");
    if (Common.isArray(options)) {
      var map2 = {};
      Common.each(options, function(element) {
        map2[element] = element;
      });
      options = map2;
    }
    Common.each(options, function(value, key) {
      var opt = document.createElement("option");
      opt.innerHTML = key;
      opt.setAttribute("value", value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, "change", function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController2, [{
    key: "setValue",
    value: function setValue(v) {
      var toReturn2 = get(OptionController2.prototype.__proto__ || Object.getPrototypeOf(OptionController2.prototype), "setValue", this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn2;
    }
  }, {
    key: "updateDisplay",
    value: function updateDisplay2() {
      if (dom.isActive(this.__select))
        return this;
      this.__select.value = this.getValue();
      return get(OptionController2.prototype.__proto__ || Object.getPrototypeOf(OptionController2.prototype), "updateDisplay", this).call(this);
    }
  }]);
  return OptionController2;
}(Controller);
var StringController = function(_Controller) {
  inherits(StringController2, _Controller);
  function StringController2(object, property) {
    classCallCheck(this, StringController2);
    var _this2 = possibleConstructorReturn(this, (StringController2.__proto__ || Object.getPrototypeOf(StringController2)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement("input");
    _this2.__input.setAttribute("type", "text");
    dom.bind(_this2.__input, "keyup", onChange);
    dom.bind(_this2.__input, "change", onChange);
    dom.bind(_this2.__input, "blur", onBlur);
    dom.bind(_this2.__input, "keydown", function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController2, [{
    key: "updateDisplay",
    value: function updateDisplay2() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController2.prototype.__proto__ || Object.getPrototypeOf(StringController2.prototype), "updateDisplay", this).call(this);
    }
  }]);
  return StringController2;
}(Controller);
function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf(".") > -1) {
    return _x.length - _x.indexOf(".") - 1;
  }
  return 0;
}
var NumberController = function(_Controller) {
  inherits(NumberController2, _Controller);
  function NumberController2(object, property, params) {
    classCallCheck(this, NumberController2);
    var _this = possibleConstructorReturn(this, (NumberController2.__proto__ || Object.getPrototypeOf(NumberController2)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController2, [{
    key: "setValue",
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== void 0 && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== void 0 && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== void 0 && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController2.prototype.__proto__ || Object.getPrototypeOf(NumberController2.prototype), "setValue", this).call(this, _v);
    }
  }, {
    key: "min",
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: "max",
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: "step",
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController2;
}(Controller);
function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function(_NumberController) {
  inherits(NumberControllerBox2, _NumberController);
  function NumberControllerBox2(object, property, params) {
    classCallCheck(this, NumberControllerBox2);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox2.__proto__ || Object.getPrototypeOf(NumberControllerBox2)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, "mousemove", onMouseDrag);
      dom.unbind(window, "mouseup", onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, "mousemove", onMouseDrag);
      dom.bind(window, "mouseup", onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement("input");
    _this2.__input.setAttribute("type", "text");
    dom.bind(_this2.__input, "change", onChange);
    dom.bind(_this2.__input, "blur", onBlur);
    dom.bind(_this2.__input, "mousedown", onMouseDown);
    dom.bind(_this2.__input, "keydown", function(e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox2, [{
    key: "updateDisplay",
    value: function updateDisplay2() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox2.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox2.prototype), "updateDisplay", this).call(this);
    }
  }]);
  return NumberControllerBox2;
}(NumberController);
function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function(_NumberController) {
  inherits(NumberControllerSlider2, _NumberController);
  function NumberControllerSlider2(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider2);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider2.__proto__ || Object.getPrototypeOf(NumberControllerSlider2)).call(this, object, property, { min, max, step }));
    var _this = _this2;
    _this2.__background = document.createElement("div");
    _this2.__foreground = document.createElement("div");
    dom.bind(_this2.__background, "mousedown", onMouseDown);
    dom.bind(_this2.__background, "touchstart", onTouchStart);
    dom.addClass(_this2.__background, "slider");
    dom.addClass(_this2.__foreground, "slider-fg");
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, "mousemove", onMouseDrag);
      dom.bind(window, "mouseup", onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, "mousemove", onMouseDrag);
      dom.unbind(window, "mouseup", onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, "touchmove", onTouchMove);
      dom.bind(window, "touchend", onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, "touchmove", onTouchMove);
      dom.unbind(window, "touchend", onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider2, [{
    key: "updateDisplay",
    value: function updateDisplay2() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + "%";
      return get(NumberControllerSlider2.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider2.prototype), "updateDisplay", this).call(this);
    }
  }]);
  return NumberControllerSlider2;
}(NumberController);
var FunctionController = function(_Controller) {
  inherits(FunctionController2, _Controller);
  function FunctionController2(object, property, text) {
    classCallCheck(this, FunctionController2);
    var _this2 = possibleConstructorReturn(this, (FunctionController2.__proto__ || Object.getPrototypeOf(FunctionController2)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement("div");
    _this2.__button.innerHTML = text === void 0 ? "Fire" : text;
    dom.bind(_this2.__button, "click", function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, "button");
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController2, [{
    key: "fire",
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController2;
}(Controller);
var ColorController = function(_Controller) {
  inherits(ColorController2, _Controller);
  function ColorController2(object, property) {
    classCallCheck(this, ColorController2);
    var _this2 = possibleConstructorReturn(this, (ColorController2.__proto__ || Object.getPrototypeOf(ColorController2)).call(this, object, property));
    _this2.__color = new Color$2(_this2.getValue());
    _this2.__temp = new Color$2(0);
    var _this = _this2;
    _this2.domElement = document.createElement("div");
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement("div");
    _this2.__selector.className = "selector";
    _this2.__saturation_field = document.createElement("div");
    _this2.__saturation_field.className = "saturation-field";
    _this2.__field_knob = document.createElement("div");
    _this2.__field_knob.className = "field-knob";
    _this2.__field_knob_border = "2px solid ";
    _this2.__hue_knob = document.createElement("div");
    _this2.__hue_knob.className = "hue-knob";
    _this2.__hue_field = document.createElement("div");
    _this2.__hue_field.className = "hue-field";
    _this2.__input = document.createElement("input");
    _this2.__input.type = "text";
    _this2.__input_textShadow = "0 1px 1px ";
    dom.bind(_this2.__input, "keydown", function(e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, "blur", onBlur);
    dom.bind(_this2.__selector, "mousedown", function() {
      dom.addClass(this, "drag").bind(window, "mouseup", function() {
        dom.removeClass(_this.__selector, "drag");
      });
    });
    dom.bind(_this2.__selector, "touchstart", function() {
      dom.addClass(this, "drag").bind(window, "touchend", function() {
        dom.removeClass(_this.__selector, "drag");
      });
    });
    var valueField = document.createElement("div");
    Common.extend(_this2.__selector.style, {
      width: "122px",
      height: "102px",
      padding: "3px",
      backgroundColor: "#222",
      boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
    });
    Common.extend(_this2.__field_knob.style, {
      position: "absolute",
      width: "12px",
      height: "12px",
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? "#fff" : "#000"),
      boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
      borderRadius: "12px",
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: "absolute",
      width: "15px",
      height: "2px",
      borderRight: "4px solid #fff",
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: "100px",
      height: "100px",
      border: "1px solid #555",
      marginRight: "3px",
      display: "inline-block",
      cursor: "pointer"
    });
    Common.extend(valueField.style, {
      width: "100%",
      height: "100%",
      background: "none"
    });
    linearGradient(valueField, "top", "rgba(0,0,0,0)", "#000");
    Common.extend(_this2.__hue_field.style, {
      width: "15px",
      height: "100px",
      border: "1px solid #555",
      cursor: "ns-resize",
      position: "absolute",
      top: "3px",
      right: "3px"
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: "none",
      textAlign: "center",
      color: "#fff",
      border: 0,
      fontWeight: "bold",
      textShadow: _this2.__input_textShadow + "rgba(0,0,0,0.7)"
    });
    dom.bind(_this2.__saturation_field, "mousedown", fieldDown);
    dom.bind(_this2.__saturation_field, "touchstart", fieldDown);
    dom.bind(_this2.__field_knob, "mousedown", fieldDown);
    dom.bind(_this2.__field_knob, "touchstart", fieldDown);
    dom.bind(_this2.__hue_field, "mousedown", fieldDownH);
    dom.bind(_this2.__hue_field, "touchstart", fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, "mousemove", setSV);
      dom.bind(window, "touchmove", setSV);
      dom.bind(window, "mouseup", fieldUpSV);
      dom.bind(window, "touchend", fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, "mousemove", setH);
      dom.bind(window, "touchmove", setH);
      dom.bind(window, "mouseup", fieldUpH);
      dom.bind(window, "touchend", fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, "mousemove", setSV);
      dom.unbind(window, "touchmove", setSV);
      dom.unbind(window, "mouseup", fieldUpSV);
      dom.unbind(window, "touchend", fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, "mousemove", setH);
      dom.unbind(window, "touchmove", setH);
      dom.unbind(window, "mouseup", fieldUpH);
      dom.unbind(window, "touchend", fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf("touch") === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e, clientX = _ref.clientX, clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf("touch") === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e, clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController2, [{
    key: "updateDisplay",
    value: function updateDisplay2() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color$2.COMPONENTS, function(component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + "px",
        marginTop: 100 * (1 - this.__color.v) - 7 + "px",
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + "rgb(" + flip + "," + flip + "," + flip + ")"
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + "px";
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, "left", "#fff", this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: "rgb(" + flip + "," + flip + "," + flip + ")",
        textShadow: this.__input_textShadow + "rgba(" + _flip + "," + _flip + "," + _flip + ",.7)"
      });
    }
  }]);
  return ColorController2;
}(Controller);
var vendors = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
function linearGradient(elem, x, a, b) {
  elem.style.background = "";
  Common.each(vendors, function(vendor) {
    elem.style.cssText += "background: " + vendor + "linear-gradient(" + x + ", " + a + " 0%, " + b + " 100%); ";
  });
}
function hueGradient(elem) {
  elem.style.background = "";
  elem.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);";
  elem.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
  elem.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
  elem.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
  elem.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
}
var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement("link");
    link.type = "text/css";
    link.rel = "stylesheet";
    link.href = url;
    doc.getElementsByTagName("head")[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement("style");
    injected.type = "text/css";
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName("head")[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};
var saveDialogContents = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`;
var ControllerFactory = function ControllerFactory2(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, "");
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};
function requestAnimationFrame$1(callback) {
  setTimeout(callback, 1e3 / 60);
}
var requestAnimationFrame$1$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame$1;
var CenteredDiv = function() {
  function CenteredDiv2() {
    classCallCheck(this, CenteredDiv2);
    this.backgroundElement = document.createElement("div");
    Common.extend(this.backgroundElement.style, {
      backgroundColor: "rgba(0,0,0,0.8)",
      top: 0,
      left: 0,
      display: "none",
      zIndex: "1000",
      opacity: 0,
      WebkitTransition: "opacity 0.2s linear",
      transition: "opacity 0.2s linear"
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = "fixed";
    this.domElement = document.createElement("div");
    Common.extend(this.domElement.style, {
      position: "fixed",
      display: "none",
      zIndex: "1001",
      opacity: 0,
      WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
      transition: "transform 0.2s ease-out, opacity 0.2s linear"
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, "click", function() {
      _this.hide();
    });
  }
  createClass(CenteredDiv2, [{
    key: "show",
    value: function show2() {
      var _this = this;
      this.backgroundElement.style.display = "block";
      this.domElement.style.display = "block";
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = "scale(1.1)";
      this.layout();
      Common.defer(function() {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = "scale(1)";
      });
    }
  }, {
    key: "hide",
    value: function hide3() {
      var _this = this;
      var hide4 = function hide5() {
        _this.domElement.style.display = "none";
        _this.backgroundElement.style.display = "none";
        dom.unbind(_this.domElement, "webkitTransitionEnd", hide5);
        dom.unbind(_this.domElement, "transitionend", hide5);
        dom.unbind(_this.domElement, "oTransitionEnd", hide5);
      };
      dom.bind(this.domElement, "webkitTransitionEnd", hide4);
      dom.bind(this.domElement, "transitionend", hide4);
      dom.bind(this.domElement, "oTransitionEnd", hide4);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = "scale(1.1)";
    }
  }, {
    key: "layout",
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + "px";
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + "px";
    }
  }]);
  return CenteredDiv2;
}();
var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");
css.inject(styleSheet);
var CSS_NAMESPACE = "dg";
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = "Default";
var SUPPORTS_LOCAL_STORAGE = function() {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI2(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement("div");
  this.__ul = document.createElement("ul");
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI2.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, "isLocal")) === "true";
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(
    this,
    {
      parent: {
        get: function get$$13() {
          return params.parent;
        }
      },
      scrollable: {
        get: function get$$13() {
          return params.scrollable;
        }
      },
      autoPlace: {
        get: function get$$13() {
          return params.autoPlace;
        }
      },
      closeOnTop: {
        get: function get$$13() {
          return params.closeOnTop;
        }
      },
      preset: {
        get: function get$$13() {
          if (_this.parent) {
            return _this.getRoot().preset;
          }
          return params.load.preset;
        },
        set: function set$$13(v) {
          if (_this.parent) {
            _this.getRoot().preset = v;
          } else {
            params.load.preset = v;
          }
          setPresetSelectIndex(this);
          _this.revert();
        }
      },
      width: {
        get: function get$$13() {
          return params.width;
        },
        set: function set$$13(v) {
          params.width = v;
          setWidth(_this, v);
        }
      },
      name: {
        get: function get$$13() {
          return params.name;
        },
        set: function set$$13(v) {
          params.name = v;
          if (titleRow) {
            titleRow.innerHTML = params.name;
          }
        }
      },
      closed: {
        get: function get$$13() {
          return params.closed;
        },
        set: function set$$13(v) {
          params.closed = v;
          if (params.closed) {
            dom.addClass(_this.__ul, GUI2.CLASS_CLOSED);
          } else {
            dom.removeClass(_this.__ul, GUI2.CLASS_CLOSED);
          }
          this.onResize();
          if (_this.__closeButton) {
            _this.__closeButton.innerHTML = v ? GUI2.TEXT_OPEN : GUI2.TEXT_CLOSED;
          }
        }
      },
      load: {
        get: function get$$13() {
          return params.load;
        }
      },
      useLocalStorage: {
        get: function get$$13() {
          return useLocalStorage;
        },
        set: function set$$13(bool) {
          if (SUPPORTS_LOCAL_STORAGE) {
            useLocalStorage = bool;
            if (bool) {
              dom.bind(window, "unload", saveToLocalStorage);
            } else {
              dom.unbind(window, "unload", saveToLocalStorage);
            }
            localStorage.setItem(getLocalStorageHash(_this, "isLocal"), bool);
          }
        }
      }
    }
  );
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI2.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, "gui"));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement("div");
    this.__closeButton.innerHTML = GUI2.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, "click", function() {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === void 0) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, "controller-name");
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle2(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI2.CLASS_CLOSED);
    dom.addClass(titleRow, "title");
    dom.bind(titleRow, "click", onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement("div");
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI2.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI2.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function() {
    _this.onResizeDebounced();
  };
  dom.bind(window, "resize", this.__resizeHandler);
  dom.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler);
  dom.bind(this.__ul, "transitionend", this.__resizeHandler);
  dom.bind(this.__ul, "oTransitionEnd", this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage2() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, "isLocal")) === "true") {
      localStorage.setItem(getLocalStorageHash(_this, "gui"), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function() {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function() {
  hide = !hide;
  Common.each(hideableGuis, function(gui2) {
    gui2.domElement.style.display = hide ? "none" : "";
  });
};
GUI.CLASS_AUTO_PLACE = "a";
GUI.CLASS_AUTO_PLACE_CONTAINER = "ac";
GUI.CLASS_MAIN = "main";
GUI.CLASS_CONTROLLER_ROW = "cr";
GUI.CLASS_TOO_TALL = "taller-than-window";
GUI.CLASS_CLOSED = "closed";
GUI.CLASS_CLOSE_BUTTON = "close-button";
GUI.CLASS_CLOSE_TOP = "close-top";
GUI.CLASS_CLOSE_BOTTOM = "close-bottom";
GUI.CLASS_DRAG = "drag";
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = "Close Controls";
GUI.TEXT_OPEN = "Open Controls";
GUI._keydownHandler = function(e) {
  if (document.activeElement.type !== "text" && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, "keydown", GUI._keydownHandler, false);
Common.extend(
  GUI.prototype,
  {
    add: function add(object, property) {
      return _add(this, object, property, {
        factoryArgs: Array.prototype.slice.call(arguments, 2)
      });
    },
    addColor: function addColor(object, property) {
      return _add(this, object, property, {
        color: true
      });
    },
    remove: function remove(controller) {
      this.__ul.removeChild(controller.__li);
      this.__controllers.splice(this.__controllers.indexOf(controller), 1);
      var _this = this;
      Common.defer(function() {
        _this.onResize();
      });
    },
    destroy: function destroy() {
      if (this.parent) {
        throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
      }
      if (this.autoPlace) {
        autoPlaceContainer.removeChild(this.domElement);
      }
      var _this = this;
      Common.each(this.__folders, function(subfolder) {
        _this.removeFolder(subfolder);
      });
      dom.unbind(window, "keydown", GUI._keydownHandler, false);
      removeListeners(this);
    },
    addFolder: function addFolder(name2) {
      if (this.__folders[name2] !== void 0) {
        throw new Error('You already have a folder in this GUI by the name "' + name2 + '"');
      }
      var newGuiParams = { name: name2, parent: this };
      newGuiParams.autoPlace = this.autoPlace;
      if (this.load && this.load.folders && this.load.folders[name2]) {
        newGuiParams.closed = this.load.folders[name2].closed;
        newGuiParams.load = this.load.folders[name2];
      }
      var gui2 = new GUI(newGuiParams);
      this.__folders[name2] = gui2;
      var li = addRow(this, gui2.domElement);
      dom.addClass(li, "folder");
      return gui2;
    },
    removeFolder: function removeFolder(folder) {
      this.__ul.removeChild(folder.domElement.parentElement);
      delete this.__folders[folder.name];
      if (this.load && this.load.folders && this.load.folders[folder.name]) {
        delete this.load.folders[folder.name];
      }
      removeListeners(folder);
      var _this = this;
      Common.each(folder.__folders, function(subfolder) {
        folder.removeFolder(subfolder);
      });
      Common.defer(function() {
        _this.onResize();
      });
    },
    open: function open() {
      this.closed = false;
    },
    close: function close() {
      this.closed = true;
    },
    hide: function hide2() {
      this.domElement.style.display = "none";
    },
    show: function show() {
      this.domElement.style.display = "";
    },
    onResize: function onResize() {
      var root = this.getRoot();
      if (root.scrollable) {
        var top = dom.getOffset(root.__ul).top;
        var h = 0;
        Common.each(root.__ul.childNodes, function(node) {
          if (!(root.autoPlace && node === root.__save_row)) {
            h += dom.getHeight(node);
          }
        });
        if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
          dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
          root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + "px";
        } else {
          dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
          root.__ul.style.height = "auto";
        }
      }
      if (root.__resize_handle) {
        Common.defer(function() {
          root.__resize_handle.style.height = root.__ul.offsetHeight + "px";
        });
      }
      if (root.__closeButton) {
        root.__closeButton.style.width = root.width + "px";
      }
    },
    onResizeDebounced: Common.debounce(function() {
      this.onResize();
    }, 50),
    remember: function remember() {
      if (Common.isUndefined(SAVE_DIALOGUE)) {
        SAVE_DIALOGUE = new CenteredDiv();
        SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
      }
      if (this.parent) {
        throw new Error("You can only call remember on a top level GUI.");
      }
      var _this = this;
      Common.each(Array.prototype.slice.call(arguments), function(object) {
        if (_this.__rememberedObjects.length === 0) {
          addSaveMenu(_this);
        }
        if (_this.__rememberedObjects.indexOf(object) === -1) {
          _this.__rememberedObjects.push(object);
        }
      });
      if (this.autoPlace) {
        setWidth(this, this.width);
      }
    },
    getRoot: function getRoot() {
      var gui2 = this;
      while (gui2.parent) {
        gui2 = gui2.parent;
      }
      return gui2;
    },
    getSaveObject: function getSaveObject() {
      var toReturn2 = this.load;
      toReturn2.closed = this.closed;
      if (this.__rememberedObjects.length > 0) {
        toReturn2.preset = this.preset;
        if (!toReturn2.remembered) {
          toReturn2.remembered = {};
        }
        toReturn2.remembered[this.preset] = getCurrentPreset(this);
      }
      toReturn2.folders = {};
      Common.each(this.__folders, function(element, key) {
        toReturn2.folders[key] = element.getSaveObject();
      });
      return toReturn2;
    },
    save: function save() {
      if (!this.load.remembered) {
        this.load.remembered = {};
      }
      this.load.remembered[this.preset] = getCurrentPreset(this);
      markPresetModified(this, false);
      this.saveToLocalStorageIfPossible();
    },
    saveAs: function saveAs(presetName) {
      if (!this.load.remembered) {
        this.load.remembered = {};
        this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
      }
      this.load.remembered[presetName] = getCurrentPreset(this);
      this.preset = presetName;
      addPresetOption(this, presetName, true);
      this.saveToLocalStorageIfPossible();
    },
    revert: function revert(gui2) {
      Common.each(this.__controllers, function(controller) {
        if (!this.getRoot().load.remembered) {
          controller.setValue(controller.initialValue);
        } else {
          recallSavedValue(gui2 || this.getRoot(), controller);
        }
        if (controller.__onFinishChange) {
          controller.__onFinishChange.call(controller, controller.getValue());
        }
      }, this);
      Common.each(this.__folders, function(folder) {
        folder.revert(folder);
      });
      if (!gui2) {
        markPresetModified(this.getRoot(), false);
      }
    },
    listen: function listen(controller) {
      var init = this.__listening.length === 0;
      this.__listening.push(controller);
      if (init) {
        updateDisplays(this.__listening);
      }
    },
    updateDisplay: function updateDisplay() {
      Common.each(this.__controllers, function(controller) {
        controller.updateDisplay();
      });
      Common.each(this.__folders, function(folder) {
        folder.updateDisplay();
      });
    }
  }
);
function addRow(gui2, newDom, liBefore) {
  var li = document.createElement("li");
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui2.__ul.insertBefore(li, liBefore);
  } else {
    gui2.__ul.appendChild(li);
  }
  gui2.onResize();
  return li;
}
function removeListeners(gui2) {
  dom.unbind(window, "resize", gui2.__resizeHandler);
  if (gui2.saveToLocalStorageIfPossible) {
    dom.unbind(window, "unload", gui2.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui2, modified) {
  var opt = gui2.__preset_select[gui2.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + "*";
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui2, li, controller) {
  controller.__li = li;
  controller.__gui = gui2;
  Common.extend(controller, {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui2, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui2, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name2(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen2() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove2() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function() {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, "has-slider");
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r2(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui2, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening)
          newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, "click", function() {
      dom.fakeEvent(controller.__checkbox, "click");
    });
    dom.bind(controller.__checkbox, "click", function(e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, "click", function() {
      dom.fakeEvent(controller.__button, "click");
    });
    dom.bind(li, "mouseover", function() {
      dom.addClass(controller.__button, "hover");
    });
    dom.bind(li, "mouseout", function() {
      dom.removeClass(controller.__button, "hover");
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, "color");
    controller.updateDisplay = Common.compose(function(val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function(val) {
    if (gui2.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui2.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui2, controller) {
  var root = gui2.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === void 0) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui2.preset]) {
        preset = presetMap[gui2.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== void 0) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui2, object, property, params) {
  if (object[property] === void 0) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui2, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui2, controller);
  dom.addClass(controller.domElement, "c");
  var name2 = document.createElement("span");
  dom.addClass(name2, "property-name");
  name2.innerHTML = controller.property;
  var container = document.createElement("div");
  container.appendChild(name2);
  container.appendChild(controller.domElement);
  var li = addRow(gui2, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, "color");
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui2, li, controller);
  gui2.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui2, key) {
  return document.location.href + "." + key;
}
function addPresetOption(gui2, name2, setSelected) {
  var opt = document.createElement("option");
  opt.innerHTML = name2;
  opt.value = name2;
  gui2.__preset_select.appendChild(opt);
  if (setSelected) {
    gui2.__preset_select.selectedIndex = gui2.__preset_select.length - 1;
  }
}
function showHideExplain(gui2, explain) {
  explain.style.display = gui2.useLocalStorage ? "block" : "none";
}
function addSaveMenu(gui2) {
  var div = gui2.__save_row = document.createElement("li");
  dom.addClass(gui2.domElement, "has-save");
  gui2.__ul.insertBefore(div, gui2.__ul.firstChild);
  dom.addClass(div, "save-row");
  var gears = document.createElement("span");
  gears.innerHTML = "&nbsp;";
  dom.addClass(gears, "button gears");
  var button = document.createElement("span");
  button.innerHTML = "Save";
  dom.addClass(button, "button");
  dom.addClass(button, "save");
  var button2 = document.createElement("span");
  button2.innerHTML = "New";
  dom.addClass(button2, "button");
  dom.addClass(button2, "save-as");
  var button3 = document.createElement("span");
  button3.innerHTML = "Revert";
  dom.addClass(button3, "button");
  dom.addClass(button3, "revert");
  var select = gui2.__preset_select = document.createElement("select");
  if (gui2.load && gui2.load.remembered) {
    Common.each(gui2.load.remembered, function(value, key) {
      addPresetOption(gui2, key, key === gui2.preset);
    });
  } else {
    addPresetOption(gui2, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, "change", function() {
    for (var index = 0; index < gui2.__preset_select.length; index++) {
      gui2.__preset_select[index].innerHTML = gui2.__preset_select[index].value;
    }
    gui2.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById("dg-local-explain");
    var localStorageCheckBox = document.getElementById("dg-local-storage");
    var saveLocally = document.getElementById("dg-save-locally");
    saveLocally.style.display = "block";
    if (localStorage.getItem(getLocalStorageHash(gui2, "isLocal")) === "true") {
      localStorageCheckBox.setAttribute("checked", "checked");
    }
    showHideExplain(gui2, explain);
    dom.bind(localStorageCheckBox, "change", function() {
      gui2.useLocalStorage = !gui2.useLocalStorage;
      showHideExplain(gui2, explain);
    });
  }
  var newConstructorTextArea = document.getElementById("dg-new-constructor");
  dom.bind(newConstructorTextArea, "keydown", function(e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, "click", function() {
    newConstructorTextArea.innerHTML = JSON.stringify(gui2.getSaveObject(), void 0, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, "click", function() {
    gui2.save();
  });
  dom.bind(button2, "click", function() {
    var presetName = prompt("Enter a new preset name.");
    if (presetName) {
      gui2.saveAs(presetName);
    }
  });
  dom.bind(button3, "click", function() {
    gui2.revert();
  });
}
function addResizeHandle(gui2) {
  var pmouseX = void 0;
  gui2.__resize_handle = document.createElement("div");
  Common.extend(gui2.__resize_handle.style, {
    width: "6px",
    marginLeft: "-3px",
    height: "200px",
    cursor: "ew-resize",
    position: "absolute"
  });
  function drag(e) {
    e.preventDefault();
    gui2.width += pmouseX - e.clientX;
    gui2.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui2.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, "mousemove", drag);
    dom.unbind(window, "mouseup", dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui2.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, "mousemove", drag);
    dom.bind(window, "mouseup", dragStop);
    return false;
  }
  dom.bind(gui2.__resize_handle, "mousedown", dragStart);
  dom.bind(gui2.__closeButton, "mousedown", dragStart);
  gui2.domElement.insertBefore(gui2.__resize_handle, gui2.domElement.firstElementChild);
}
function setWidth(gui2, w) {
  gui2.domElement.style.width = w + "px";
  if (gui2.__save_row && gui2.autoPlace) {
    gui2.__save_row.style.width = w + "px";
  }
  if (gui2.__closeButton) {
    gui2.__closeButton.style.width = w + "px";
  }
}
function getCurrentPreset(gui2, useInitialValues) {
  var toReturn2 = {};
  Common.each(gui2.__rememberedObjects, function(val, index) {
    var savedValues = {};
    var controllerMap = gui2.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function(controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn2[index] = savedValues;
  });
  return toReturn2;
}
function setPresetSelectIndex(gui2) {
  for (var index = 0; index < gui2.__preset_select.length; index++) {
    if (gui2.__preset_select[index].value === gui2.preset) {
      gui2.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1$1.call(window, function() {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function(c) {
    c.updateDisplay();
  });
}
var GUI$1 = GUI;
function _set_prototype_of$3(o, p) {
  _set_prototype_of$3 = Object.setPrototypeOf || function setPrototypeOf(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _set_prototype_of$3(o, p);
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _set_prototype_of$3(subClass, superClass);
}
var ContainmentType;
(function(ContainmentType2) {
  ContainmentType2[ContainmentType2["Disjoint"] = 0] = "Disjoint";
  ContainmentType2[ContainmentType2["Contains"] = 1] = "Contains";
  ContainmentType2[ContainmentType2["Intersects"] = 2] = "Intersects";
})(ContainmentType || (ContainmentType = {}));
var PlaneIntersectionType;
(function(PlaneIntersectionType2) {
  PlaneIntersectionType2[PlaneIntersectionType2["Back"] = 0] = "Back";
  PlaneIntersectionType2[PlaneIntersectionType2["Front"] = 1] = "Front";
  PlaneIntersectionType2[PlaneIntersectionType2["Intersecting"] = 2] = "Intersecting";
})(PlaneIntersectionType || (PlaneIntersectionType = {}));
var FrustumFace;
(function(FrustumFace2) {
  FrustumFace2[FrustumFace2["Near"] = 0] = "Near";
  FrustumFace2[FrustumFace2["Far"] = 1] = "Far";
  FrustumFace2[FrustumFace2["Left"] = 2] = "Left";
  FrustumFace2[FrustumFace2["Right"] = 3] = "Right";
  FrustumFace2[FrustumFace2["Bottom"] = 4] = "Bottom";
  FrustumFace2[FrustumFace2["Top"] = 5] = "Top";
})(FrustumFace || (FrustumFace = {}));
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  return Constructor;
}
var MathUtil$1 = /* @__PURE__ */ function() {
  function MathUtil2() {
  }
  MathUtil2.clamp = function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  };
  MathUtil2.equals = function equals(a, b) {
    return Math.abs(a - b) <= MathUtil2.zeroTolerance;
  };
  MathUtil2.isPowerOf2 = function isPowerOf2(v) {
    return (v & v - 1) === 0;
  };
  MathUtil2.radianToDegree = function radianToDegree(r) {
    return r * MathUtil2.radToDegreeFactor;
  };
  MathUtil2.degreeToRadian = function degreeToRadian(d) {
    return d * MathUtil2.degreeToRadFactor;
  };
  return MathUtil2;
}();
(function() {
  MathUtil$1.zeroTolerance = 1e-6;
})();
(function() {
  MathUtil$1.radToDegreeFactor = 180 / Math.PI;
})();
(function() {
  MathUtil$1.degreeToRadFactor = Math.PI / 180;
})();
var Vector3 = /* @__PURE__ */ function() {
  function Vector32(x, y, z2) {
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    if (z2 === void 0)
      z2 = 0;
    this._onValueChanged = null;
    this._x = x;
    this._y = y;
    this._z = z2;
  }
  var _proto = Vector32.prototype;
  _proto.set = function set(x, y, z2) {
    this._x = x;
    this._y = y;
    this._z = z2;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.add = function add2(right) {
    this._x += right._x;
    this._y += right._y;
    this._z += right._z;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.subtract = function subtract(right) {
    this._x -= right._x;
    this._y -= right._y;
    this._z -= right._z;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.multiply = function multiply(right) {
    this._x *= right._x;
    this._y *= right._y;
    this._z *= right._z;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.divide = function divide(right) {
    this._x /= right._x;
    this._y /= right._y;
    this._z /= right._z;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.length = function length2() {
    var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
    return Math.sqrt(_x * _x + _y * _y + _z * _z);
  };
  _proto.lengthSquared = function lengthSquared() {
    var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
    return _x * _x + _y * _y + _z * _z;
  };
  _proto.negate = function negate() {
    this._x = -this._x;
    this._y = -this._y;
    this._z = -this._z;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.normalize = function normalize() {
    Vector32.normalize(this, this);
    return this;
  };
  _proto.scale = function scale(s) {
    this._x *= s;
    this._y *= s;
    this._z *= s;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.transformNormal = function transformNormal(m) {
    Vector32.transformNormal(this, m, this);
    return this;
  };
  _proto.transformToVec3 = function transformToVec3(m) {
    Vector32.transformToVec3(this, m, this);
    return this;
  };
  _proto.transformCoordinate = function transformCoordinate(m) {
    Vector32.transformCoordinate(this, m, this);
    return this;
  };
  _proto.transformByQuat = function transformByQuat(quaternion) {
    Vector32.transformByQuat(this, quaternion, this);
    return this;
  };
  _proto.clone = function clone() {
    return new Vector32(this._x, this._y, this._z);
  };
  _proto.copyFrom = function copyFrom(source) {
    this._x = source.x;
    this._y = source.y;
    this._z = source.z;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.copyFromArray = function copyFromArray(array, offset) {
    if (offset === void 0)
      offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.copyToArray = function copyToArray(out, outOffset) {
    if (outOffset === void 0)
      outOffset = 0;
    out[outOffset] = this._x;
    out[outOffset + 1] = this._y;
    out[outOffset + 2] = this._z;
  };
  _proto.toJSON = function toJSON() {
    return {
      x: this._x,
      y: this._y,
      z: this._z
    };
  };
  Vector32.add = function add2(left, right, out) {
    out._x = left._x + right._x;
    out._y = left._y + right._y;
    out._z = left._z + right._z;
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.subtract = function subtract(left, right, out) {
    out._x = left._x - right._x;
    out._y = left._y - right._y;
    out._z = left._z - right._z;
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.multiply = function multiply(left, right, out) {
    out._x = left._x * right._x;
    out._y = left._y * right._y;
    out._z = left._z * right._z;
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.divide = function divide(left, right, out) {
    out._x = left._x / right._x;
    out._y = left._y / right._y;
    out._z = left._z / right._z;
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.dot = function dot(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z;
  };
  Vector32.cross = function cross(left, right, out) {
    var ax = left._x;
    var ay = left._y;
    var az = left._z;
    var bx = right._x;
    var by = right._y;
    var bz = right._z;
    out.set(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
  };
  Vector32.distance = function distance(a, b) {
    var x = b._x - a._x;
    var y = b._y - a._y;
    var z2 = b._z - a._z;
    return Math.sqrt(x * x + y * y + z2 * z2);
  };
  Vector32.distanceSquared = function distanceSquared(a, b) {
    var x = b._x - a._x;
    var y = b._y - a._y;
    var z2 = b._z - a._z;
    return x * x + y * y + z2 * z2;
  };
  Vector32.equals = function equals(left, right) {
    return MathUtil$1.equals(left._x, right._x) && MathUtil$1.equals(left._y, right._y) && MathUtil$1.equals(left._z, right._z);
  };
  Vector32.lerp = function lerp(start, end, t, out) {
    var _x = start._x, _y = start._y, _z = start._z;
    out._x = _x + (end._x - _x) * t;
    out._y = _y + (end._y - _y) * t;
    out._z = _z + (end._z - _z) * t;
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.max = function max(left, right, out) {
    out._x = Math.max(left._x, right._x);
    out._y = Math.max(left._y, right._y);
    out._z = Math.max(left._z, right._z);
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.min = function min(left, right, out) {
    out._x = Math.min(left._x, right._x);
    out._y = Math.min(left._y, right._y);
    out._z = Math.min(left._z, right._z);
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.negate = function negate(a, out) {
    out._x = -a._x;
    out._y = -a._y;
    out._z = -a._z;
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.normalize = function normalize(a, out) {
    var _x = a._x, _y = a._y, _z = a._z;
    var len = Math.sqrt(_x * _x + _y * _y + _z * _z);
    if (len > MathUtil$1.zeroTolerance) {
      len = 1 / len;
      out.set(_x * len, _y * len, _z * len);
    }
  };
  Vector32.scale = function scale(a, s, out) {
    out._x = a._x * s;
    out._y = a._y * s;
    out._z = a._z * s;
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.transformNormal = function transformNormal(v, m, out) {
    var _x = v._x, _y = v._y, _z = v._z;
    var e = m.elements;
    out._x = _x * e[0] + _y * e[4] + _z * e[8];
    out._y = _x * e[1] + _y * e[5] + _z * e[9];
    out._z = _x * e[2] + _y * e[6] + _z * e[10];
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.transformToVec3 = function transformToVec3(v, m, out) {
    var _x = v._x, _y = v._y, _z = v._z;
    var e = m.elements;
    out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
    out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
    out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.transformToVec4 = function transformToVec4(v, m, out) {
    var _x = v._x, _y = v._y, _z = v._z;
    var e = m.elements;
    out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
    out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
    out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
    out._w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.transformCoordinate = function transformCoordinate(v, m, out) {
    var _x = v._x, _y = v._y, _z = v._z;
    var e = m.elements;
    var w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
    w = 1 / w;
    out._x = (_x * e[0] + _y * e[4] + _z * e[8] + e[12]) * w;
    out._y = (_x * e[1] + _y * e[5] + _z * e[9] + e[13]) * w;
    out._z = (_x * e[2] + _y * e[6] + _z * e[10] + e[14]) * w;
    out._onValueChanged && out._onValueChanged();
  };
  Vector32.transformByQuat = function transformByQuat(v, quaternion, out) {
    var _x = v._x, _y = v._y, _z = v._z;
    var qx = quaternion._x, qy = quaternion._y, qz = quaternion._z, qw = quaternion._w;
    var ix = qw * _x + qy * _z - qz * _y;
    var iy = qw * _y + qz * _x - qx * _z;
    var iz = qw * _z + qx * _y - qy * _x;
    var iw = -qx * _x - qy * _y - qz * _z;
    out._x = ix * qw - iw * qx - iy * qz + iz * qy;
    out._y = iy * qw - iw * qy - iz * qx + ix * qz;
    out._z = iz * qw - iw * qz - ix * qy + iy * qx;
    out._onValueChanged && out._onValueChanged();
  };
  _create_class$5(Vector32, [
    {
      key: "x",
      get: function get3() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "y",
      get: function get3() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "z",
      get: function get3() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this._onValueChanged && this._onValueChanged();
      }
    }
  ]);
  return Vector32;
}();
(function() {
  Vector3._zero = new Vector3(0, 0, 0);
})();
(function() {
  Vector3._one = new Vector3(1, 1, 1);
})();
var BoundingSphere = /* @__PURE__ */ function() {
  function BoundingSphere2(center, radius) {
    if (center === void 0)
      center = null;
    if (radius === void 0)
      radius = 0;
    this.center = new Vector3();
    this.radius = 0;
    center && this.center.copyFrom(center);
    this.radius = radius;
  }
  var _proto = BoundingSphere2.prototype;
  _proto.clone = function clone() {
    return new BoundingSphere2(this.center, this.radius);
  };
  _proto.copyFrom = function copyFrom(source) {
    this.center.copyFrom(source.center);
    this.radius = source.radius;
    return this;
  };
  BoundingSphere2.fromPoints = function fromPoints(points, out) {
    if (!points || points.length === 0) {
      throw new Error("points must be array and length must > 0");
    }
    var len = points.length;
    var center = BoundingSphere2._tempVec30;
    center.x = center.y = center.z = 0;
    for (var i = 0; i < len; ++i) {
      Vector3.add(points[i], center, center);
    }
    Vector3.scale(center, 1 / len, out.center);
    var radius = 0;
    for (var i1 = 0; i1 < len; ++i1) {
      var distance = Vector3.distanceSquared(center, points[i1]);
      distance > radius && (radius = distance);
    }
    out.radius = Math.sqrt(radius);
  };
  BoundingSphere2.fromBox = function fromBox(box, out) {
    var center = out.center;
    var min = box.min, max = box.max;
    center.x = (min.x + max.x) * 0.5;
    center.y = (min.y + max.y) * 0.5;
    center.z = (min.z + max.z) * 0.5;
    out.radius = Vector3.distance(center, max);
  };
  return BoundingSphere2;
}();
(function() {
  BoundingSphere._tempVec30 = new Vector3();
})();
var BoundingBox = /* @__PURE__ */ function() {
  function BoundingBox2(min, max) {
    if (min === void 0)
      min = null;
    if (max === void 0)
      max = null;
    this.min = new Vector3();
    this.max = new Vector3();
    min && this.min.copyFrom(min);
    max && this.max.copyFrom(max);
  }
  var _proto = BoundingBox2.prototype;
  _proto.getCenter = function getCenter(out) {
    Vector3.add(this.min, this.max, out);
    Vector3.scale(out, 0.5, out);
    return out;
  };
  _proto.getExtent = function getExtent(out) {
    Vector3.subtract(this.max, this.min, out);
    Vector3.scale(out, 0.5, out);
    return out;
  };
  _proto.getCorners = function getCorners(out) {
    if (out === void 0)
      out = [];
    var _this = this, min = _this.min, max = _this.max;
    var minX = min.x;
    var minY = min.y;
    var minZ = min.z;
    var maxX = max.x;
    var maxY = max.y;
    var maxZ = max.z;
    var len = out.length;
    if (len < 8) {
      for (var i = 0, l = 8 - len; i < l; ++i) {
        out[len + i] = new Vector3();
      }
    }
    out[0].set(minX, maxY, maxZ);
    out[1].set(maxX, maxY, maxZ);
    out[2].set(maxX, minY, maxZ);
    out[3].set(minX, minY, maxZ);
    out[4].set(minX, maxY, minZ);
    out[5].set(maxX, maxY, minZ);
    out[6].set(maxX, minY, minZ);
    out[7].set(minX, minY, minZ);
    return out;
  };
  _proto.transform = function transform(matrix) {
    BoundingBox2.transform(this, matrix, this);
    return this;
  };
  _proto.clone = function clone() {
    return new BoundingBox2(this.min, this.max);
  };
  _proto.copyFrom = function copyFrom(source) {
    this.min.copyFrom(source.min);
    this.max.copyFrom(source.max);
    return this;
  };
  BoundingBox2.fromCenterAndExtent = function fromCenterAndExtent(center, extent, out) {
    Vector3.subtract(center, extent, out.min);
    Vector3.add(center, extent, out.max);
  };
  BoundingBox2.fromPoints = function fromPoints(points, out) {
    if (!points || points.length === 0) {
      throw new Error("points must be array and length must > 0");
    }
    var min = out.min, max = out.max;
    min.x = min.y = min.z = Number.MAX_VALUE;
    max.x = max.y = max.z = -Number.MAX_VALUE;
    for (var i = 0, l = points.length; i < l; ++i) {
      var point = points[i];
      Vector3.min(min, point, min);
      Vector3.max(max, point, max);
    }
  };
  BoundingBox2.fromSphere = function fromSphere(sphere, out) {
    var center = sphere.center, radius = sphere.radius;
    var min = out.min, max = out.max;
    min.x = center.x - radius;
    min.y = center.y - radius;
    min.z = center.z - radius;
    max.x = center.x + radius;
    max.y = center.y + radius;
    max.z = center.z + radius;
  };
  BoundingBox2.transform = function transform(source, matrix, out) {
    var center = BoundingBox2._tempVec30;
    var extent = BoundingBox2._tempVec31;
    source.getCenter(center);
    source.getExtent(extent);
    Vector3.transformCoordinate(center, matrix, center);
    var x = extent.x, y = extent.y, z2 = extent.z;
    var e = matrix.elements;
    extent.x = Math.abs(x * e[0]) + Math.abs(y * e[4]) + Math.abs(z2 * e[8]);
    extent.y = Math.abs(x * e[1]) + Math.abs(y * e[5]) + Math.abs(z2 * e[9]);
    extent.z = Math.abs(x * e[2]) + Math.abs(y * e[6]) + Math.abs(z2 * e[10]);
    Vector3.subtract(center, extent, out.min);
    Vector3.add(center, extent, out.max);
  };
  BoundingBox2.merge = function merge(box1, box2, out) {
    Vector3.min(box1.min, box2.min, out.min);
    Vector3.max(box1.max, box2.max, out.max);
    return out;
  };
  return BoundingBox2;
}();
(function() {
  BoundingBox._tempVec30 = new Vector3();
})();
(function() {
  BoundingBox._tempVec31 = new Vector3();
})();
var CollisionUtil = /* @__PURE__ */ function() {
  function CollisionUtil2() {
  }
  CollisionUtil2.intersectionPointThreePlanes = function intersectionPointThreePlanes(p1, p2, p3, out) {
    var p1Nor = p1.normal;
    var p2Nor = p2.normal;
    var p3Nor = p3.normal;
    Vector3.cross(p2Nor, p3Nor, CollisionUtil2._tempVec30);
    Vector3.cross(p3Nor, p1Nor, CollisionUtil2._tempVec31);
    Vector3.cross(p1Nor, p2Nor, CollisionUtil2._tempVec32);
    var a = -Vector3.dot(p1Nor, CollisionUtil2._tempVec30);
    var b = -Vector3.dot(p2Nor, CollisionUtil2._tempVec31);
    var c = -Vector3.dot(p3Nor, CollisionUtil2._tempVec32);
    Vector3.scale(CollisionUtil2._tempVec30, p1.distance / a, CollisionUtil2._tempVec30);
    Vector3.scale(CollisionUtil2._tempVec31, p2.distance / b, CollisionUtil2._tempVec31);
    Vector3.scale(CollisionUtil2._tempVec32, p3.distance / c, CollisionUtil2._tempVec32);
    Vector3.add(CollisionUtil2._tempVec30, CollisionUtil2._tempVec31, out);
    Vector3.add(out, CollisionUtil2._tempVec32, out);
  };
  CollisionUtil2.distancePlaneAndPoint = function distancePlaneAndPoint(plane, point) {
    return Vector3.dot(plane.normal, point) + plane.distance;
  };
  CollisionUtil2.intersectsPlaneAndPoint = function intersectsPlaneAndPoint(plane, point) {
    var distance = CollisionUtil2.distancePlaneAndPoint(plane, point);
    if (distance > 0) {
      return PlaneIntersectionType.Front;
    }
    if (distance < 0) {
      return PlaneIntersectionType.Back;
    }
    return PlaneIntersectionType.Intersecting;
  };
  CollisionUtil2.intersectsPlaneAndBox = function intersectsPlaneAndBox(plane, box) {
    var min = box.min, max = box.max;
    var normal = plane.normal;
    var front = CollisionUtil2._tempVec30;
    var back = CollisionUtil2._tempVec31;
    if (normal.x >= 0) {
      front.x = max.x;
      back.x = min.x;
    } else {
      front.x = min.x;
      back.x = max.x;
    }
    if (normal.y >= 0) {
      front.y = max.y;
      back.y = min.y;
    } else {
      front.y = min.y;
      back.y = max.y;
    }
    if (normal.z >= 0) {
      front.z = max.z;
      back.z = min.z;
    } else {
      front.z = min.z;
      back.z = max.z;
    }
    if (CollisionUtil2.distancePlaneAndPoint(plane, front) < 0) {
      return PlaneIntersectionType.Back;
    }
    if (CollisionUtil2.distancePlaneAndPoint(plane, back) > 0) {
      return PlaneIntersectionType.Front;
    }
    return PlaneIntersectionType.Intersecting;
  };
  CollisionUtil2.intersectsPlaneAndSphere = function intersectsPlaneAndSphere(plane, sphere) {
    var center = sphere.center, radius = sphere.radius;
    var distance = CollisionUtil2.distancePlaneAndPoint(plane, center);
    if (distance > radius) {
      return PlaneIntersectionType.Front;
    }
    if (distance < -radius) {
      return PlaneIntersectionType.Back;
    }
    return PlaneIntersectionType.Intersecting;
  };
  CollisionUtil2.intersectsRayAndPlane = function intersectsRayAndPlane(ray, plane) {
    var normal = plane.normal;
    var zeroTolerance = MathUtil$1.zeroTolerance;
    var dir = Vector3.dot(normal, ray.direction);
    if (Math.abs(dir) < zeroTolerance) {
      return -1;
    }
    var position = Vector3.dot(normal, ray.origin);
    var distance = (-plane.distance - position) / dir;
    if (distance < 0) {
      if (distance < -zeroTolerance) {
        return -1;
      }
      distance = 0;
    }
    return distance;
  };
  CollisionUtil2.intersectsRayAndBox = function intersectsRayAndBox(ray, box) {
    var zeroTolerance = MathUtil$1.zeroTolerance;
    var origin = ray.origin, direction = ray.direction;
    var min = box.min, max = box.max;
    var dirX = direction.x;
    var dirY = direction.y;
    var dirZ = direction.z;
    var oriX = origin.x;
    var oriY = origin.y;
    var oriZ = origin.z;
    var distance = 0;
    var tmax = Number.MAX_VALUE;
    if (Math.abs(dirX) < zeroTolerance) {
      if (oriX < min.x || oriX > max.x) {
        return -1;
      }
    } else {
      var inverse = 1 / dirX;
      var t1 = (min.x - oriX) * inverse;
      var t2 = (max.x - oriX) * inverse;
      if (t1 > t2) {
        var temp = t1;
        t1 = t2;
        t2 = temp;
      }
      distance = Math.max(t1, distance);
      tmax = Math.min(t2, tmax);
      if (distance > tmax) {
        return -1;
      }
    }
    if (Math.abs(dirY) < zeroTolerance) {
      if (oriY < min.y || oriY > max.y) {
        return -1;
      }
    } else {
      var inverse1 = 1 / dirY;
      var t11 = (min.y - oriY) * inverse1;
      var t21 = (max.y - oriY) * inverse1;
      if (t11 > t21) {
        var temp1 = t11;
        t11 = t21;
        t21 = temp1;
      }
      distance = Math.max(t11, distance);
      tmax = Math.min(t21, tmax);
      if (distance > tmax) {
        return -1;
      }
    }
    if (Math.abs(dirZ) < zeroTolerance) {
      if (oriZ < min.z || oriZ > max.z) {
        return -1;
      }
    } else {
      var inverse2 = 1 / dirZ;
      var t12 = (min.z - oriZ) * inverse2;
      var t22 = (max.z - oriZ) * inverse2;
      if (t12 > t22) {
        var temp2 = t12;
        t12 = t22;
        t22 = temp2;
      }
      distance = Math.max(t12, distance);
      tmax = Math.min(t22, tmax);
      if (distance > tmax) {
        return -1;
      }
    }
    return distance;
  };
  CollisionUtil2.intersectsRayAndSphere = function intersectsRayAndSphere(ray, sphere) {
    var origin = ray.origin, direction = ray.direction;
    var center = sphere.center, radius = sphere.radius;
    var m = CollisionUtil2._tempVec30;
    Vector3.subtract(origin, center, m);
    var b = Vector3.dot(m, direction);
    var c = Vector3.dot(m, m) - radius * radius;
    if (b > 0 && c > 0) {
      return -1;
    }
    var discriminant = b * b - c;
    if (discriminant < 0) {
      return -1;
    }
    var distance = -b - Math.sqrt(discriminant);
    if (distance < 0) {
      distance = 0;
    }
    return distance;
  };
  CollisionUtil2.intersectsBoxAndBox = function intersectsBoxAndBox(boxA, boxB) {
    if (boxA.min.x > boxB.max.x || boxB.min.x > boxA.max.x) {
      return false;
    }
    if (boxA.min.y > boxB.max.y || boxB.min.y > boxA.max.y) {
      return false;
    }
    return !(boxA.min.z > boxB.max.z || boxB.min.z > boxA.max.z);
  };
  CollisionUtil2.intersectsSphereAndSphere = function intersectsSphereAndSphere(sphereA, sphereB) {
    var radiisum = sphereA.radius + sphereB.radius;
    return Vector3.distanceSquared(sphereA.center, sphereB.center) < radiisum * radiisum;
  };
  CollisionUtil2.intersectsSphereAndBox = function intersectsSphereAndBox(sphere, box) {
    var center = sphere.center;
    var max = box.max;
    var min = box.min;
    var closestPoint = CollisionUtil2._tempVec30;
    closestPoint.set(Math.max(min.x, Math.min(center.x, max.x)), Math.max(min.y, Math.min(center.y, max.y)), Math.max(min.z, Math.min(center.z, max.z)));
    var distance = Vector3.distanceSquared(center, closestPoint);
    return distance <= sphere.radius * sphere.radius;
  };
  CollisionUtil2.intersectsFrustumAndBox = function intersectsFrustumAndBox(frustum, box) {
    var min = box.min, max = box.max;
    var p = CollisionUtil2._tempVec30;
    for (var i = 0; i < 6; ++i) {
      var plane = frustum.getPlane(i);
      var normal = plane.normal;
      p.set(normal.x >= 0 ? max.x : min.x, normal.y >= 0 ? max.y : min.y, normal.z >= 0 ? max.z : min.z);
      if (Vector3.dot(normal, p) < -plane.distance) {
        return false;
      }
    }
    return true;
  };
  CollisionUtil2.frustumContainsPoint = function frustumContainsPoint(frustum, point) {
    var distance = CollisionUtil2.distancePlaneAndPoint(frustum.near, point);
    if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
      return ContainmentType.Intersects;
    } else if (distance < 0) {
      return ContainmentType.Disjoint;
    }
    distance = CollisionUtil2.distancePlaneAndPoint(frustum.far, point);
    if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
      return ContainmentType.Intersects;
    } else if (distance < 0) {
      return ContainmentType.Disjoint;
    }
    distance = CollisionUtil2.distancePlaneAndPoint(frustum.left, point);
    if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
      return ContainmentType.Intersects;
    } else if (distance < 0) {
      return ContainmentType.Disjoint;
    }
    distance = CollisionUtil2.distancePlaneAndPoint(frustum.right, point);
    if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
      return ContainmentType.Intersects;
    } else if (distance < 0) {
      return ContainmentType.Disjoint;
    }
    distance = CollisionUtil2.distancePlaneAndPoint(frustum.top, point);
    if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
      return ContainmentType.Intersects;
    } else if (distance < 0) {
      return ContainmentType.Disjoint;
    }
    distance = CollisionUtil2.distancePlaneAndPoint(frustum.bottom, point);
    if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
      return ContainmentType.Intersects;
    } else if (distance < 0) {
      return ContainmentType.Disjoint;
    }
    return ContainmentType.Contains;
  };
  CollisionUtil2.frustumContainsBox = function frustumContainsBox(frustum, box) {
    var min = box.min, max = box.max;
    var p = CollisionUtil2._tempVec30;
    var n = CollisionUtil2._tempVec31;
    var result2 = ContainmentType.Contains;
    for (var i = 0; i < 6; ++i) {
      var plane = frustum.getPlane(i);
      var normal = plane.normal;
      if (normal.x >= 0) {
        p.x = max.x;
        n.x = min.x;
      } else {
        p.x = min.x;
        n.x = max.x;
      }
      if (normal.y >= 0) {
        p.y = max.y;
        n.y = min.y;
      } else {
        p.y = min.y;
        n.y = max.y;
      }
      if (normal.z >= 0) {
        p.z = max.z;
        n.z = min.z;
      } else {
        p.z = min.z;
        n.z = max.z;
      }
      if (CollisionUtil2.intersectsPlaneAndPoint(plane, p) === PlaneIntersectionType.Back) {
        return ContainmentType.Disjoint;
      }
      if (CollisionUtil2.intersectsPlaneAndPoint(plane, n) === PlaneIntersectionType.Back) {
        result2 = ContainmentType.Intersects;
      }
    }
    return result2;
  };
  CollisionUtil2.frustumContainsSphere = function frustumContainsSphere(frustum, sphere) {
    var result2 = ContainmentType.Contains;
    for (var i = 0; i < 6; ++i) {
      var plane = frustum.getPlane(i);
      var intersectionType = CollisionUtil2.intersectsPlaneAndSphere(plane, sphere);
      if (intersectionType === PlaneIntersectionType.Back) {
        return ContainmentType.Disjoint;
      } else if (intersectionType === PlaneIntersectionType.Intersecting) {
        result2 = ContainmentType.Intersects;
        break;
      }
    }
    return result2;
  };
  return CollisionUtil2;
}();
(function() {
  CollisionUtil._tempVec30 = new Vector3();
})();
(function() {
  CollisionUtil._tempVec31 = new Vector3();
})();
(function() {
  CollisionUtil._tempVec32 = new Vector3();
})();
var Plane = /* @__PURE__ */ function() {
  function Plane2(normal, distance) {
    if (normal === void 0)
      normal = null;
    if (distance === void 0)
      distance = 0;
    this.normal = new Vector3();
    this.distance = 0;
    normal && this.normal.copyFrom(normal);
    this.distance = distance;
  }
  var _proto = Plane2.prototype;
  _proto.normalize = function normalize() {
    Plane2.normalize(this, this);
    return this;
  };
  _proto.clone = function clone() {
    var out = new Plane2();
    out.copyFrom(this);
    return out;
  };
  _proto.copyFrom = function copyFrom(source) {
    this.normal.copyFrom(source.normal);
    this.distance = source.distance;
    return this;
  };
  Plane2.normalize = function normalize(p, out) {
    var normal = p.normal;
    var factor = 1 / normal.length();
    Vector3.scale(normal, factor, out.normal);
    out.distance = p.distance * factor;
  };
  Plane2.fromPoints = function fromPoints(point0, point1, point2, out) {
    var x0 = point0.x;
    var y0 = point0.y;
    var z0 = point0.z;
    var x1 = point1.x - x0;
    var y1 = point1.y - y0;
    var z1 = point1.z - z0;
    var x2 = point2.x - x0;
    var y2 = point2.y - y0;
    var z2 = point2.z - z0;
    var yz = y1 * z2 - z1 * y2;
    var xz = z1 * x2 - x1 * z2;
    var xy = x1 * y2 - y1 * x2;
    var invPyth = 1 / Math.sqrt(yz * yz + xz * xz + xy * xy);
    var x = yz * invPyth;
    var y = xz * invPyth;
    var z3 = xy * invPyth;
    var normal = out.normal;
    normal.x = x;
    normal.y = y;
    normal.z = z3;
    out.distance = -(x * x0 + y * y0 + z3 * z0);
  };
  return Plane2;
}();
var BoundingFrustum = /* @__PURE__ */ function() {
  function BoundingFrustum2(matrix) {
    if (matrix === void 0)
      matrix = null;
    this.near = new Plane();
    this.far = new Plane();
    this.left = new Plane();
    this.right = new Plane();
    this.top = new Plane();
    this.bottom = new Plane();
    matrix && this.calculateFromMatrix(matrix);
  }
  var _proto = BoundingFrustum2.prototype;
  _proto.getPlane = function getPlane(face) {
    switch (face) {
      case FrustumFace.Near:
        return this.near;
      case FrustumFace.Far:
        return this.far;
      case FrustumFace.Left:
        return this.left;
      case FrustumFace.Right:
        return this.right;
      case FrustumFace.Bottom:
        return this.bottom;
      case FrustumFace.Top:
        return this.top;
      default:
        return null;
    }
  };
  _proto.calculateFromMatrix = function calculateFromMatrix(matrix) {
    var me = matrix.elements;
    var m11 = me[0];
    var m12 = me[1];
    var m13 = me[2];
    var m14 = me[3];
    var m21 = me[4];
    var m22 = me[5];
    var m23 = me[6];
    var m24 = me[7];
    var m31 = me[8];
    var m32 = me[9];
    var m33 = me[10];
    var m34 = me[11];
    var m41 = me[12];
    var m42 = me[13];
    var m43 = me[14];
    var m44 = me[15];
    var nearNormal = this.near.normal;
    nearNormal.set(m14 + m13, m24 + m23, m34 + m33);
    this.near.distance = m44 + m43;
    this.near.normalize();
    var farNormal = this.far.normal;
    farNormal.set(m14 - m13, m24 - m23, m34 - m33);
    this.far.distance = m44 - m43;
    this.far.normalize();
    var leftNormal = this.left.normal;
    leftNormal.set(m14 + m11, m24 + m21, m34 + m31);
    this.left.distance = m44 + m41;
    this.left.normalize();
    var rightNormal = this.right.normal;
    rightNormal.set(m14 - m11, m24 - m21, m34 - m31);
    this.right.distance = m44 - m41;
    this.right.normalize();
    var bottomNormal = this.bottom.normal;
    bottomNormal.set(m14 + m12, m24 + m22, m34 + m32);
    this.bottom.distance = m44 + m42;
    this.bottom.normalize();
    var topNormal = this.top.normal;
    topNormal.set(m14 - m12, m24 - m22, m34 - m32);
    this.top.distance = m44 - m42;
    this.top.normalize();
  };
  _proto.intersectsBox = function intersectsBox(box) {
    return CollisionUtil.intersectsFrustumAndBox(this, box);
  };
  _proto.intersectsSphere = function intersectsSphere(sphere) {
    return CollisionUtil.frustumContainsSphere(this, sphere) !== ContainmentType.Disjoint;
  };
  _proto.clone = function clone() {
    var out = new BoundingFrustum2();
    out.copyFrom(this);
    return out;
  };
  _proto.copyFrom = function copyFrom(source) {
    this.near.copyFrom(source.near);
    this.far.copyFrom(source.far);
    this.left.copyFrom(source.left);
    this.right.copyFrom(source.right);
    this.bottom.copyFrom(source.bottom);
    this.top.copyFrom(source.top);
    return this;
  };
  return BoundingFrustum2;
}();
var Matrix3x3 = /* @__PURE__ */ function() {
  function Matrix3x32(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
    if (m11 === void 0)
      m11 = 1;
    if (m12 === void 0)
      m12 = 0;
    if (m13 === void 0)
      m13 = 0;
    if (m21 === void 0)
      m21 = 0;
    if (m22 === void 0)
      m22 = 1;
    if (m23 === void 0)
      m23 = 0;
    if (m31 === void 0)
      m31 = 0;
    if (m32 === void 0)
      m32 = 0;
    if (m33 === void 0)
      m33 = 1;
    this.elements = new Float32Array(9);
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m21;
    e[4] = m22;
    e[5] = m23;
    e[6] = m31;
    e[7] = m32;
    e[8] = m33;
  }
  var _proto = Matrix3x32.prototype;
  _proto.set = function set(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m21;
    e[4] = m22;
    e[5] = m23;
    e[6] = m31;
    e[7] = m32;
    e[8] = m33;
    return this;
  };
  _proto.add = function add2(right) {
    Matrix3x32.add(this, right, this);
    return this;
  };
  _proto.subtract = function subtract(right) {
    Matrix3x32.subtract(this, right, this);
    return this;
  };
  _proto.multiply = function multiply(right) {
    Matrix3x32.multiply(this, right, this);
    return this;
  };
  _proto.determinant = function determinant() {
    var e = this.elements;
    var a11 = e[0], a12 = e[1], a13 = e[2];
    var a21 = e[3], a22 = e[4], a23 = e[5];
    var a31 = e[6], a32 = e[7], a33 = e[8];
    var b12 = a33 * a22 - a23 * a32;
    var b22 = -a33 * a21 + a23 * a31;
    var b32 = a32 * a21 - a22 * a31;
    return a11 * b12 + a12 * b22 + a13 * b32;
  };
  _proto.identity = function identity() {
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 1;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
    return this;
  };
  _proto.invert = function invert() {
    Matrix3x32.invert(this, this);
    return this;
  };
  _proto.rotate = function rotate(r) {
    Matrix3x32.rotate(this, r, this);
    return this;
  };
  _proto.scale = function scale(s) {
    Matrix3x32.scale(this, s, this);
    return this;
  };
  _proto.translate = function translate(translation) {
    Matrix3x32.translate(this, translation, this);
    return this;
  };
  _proto.transpose = function transpose() {
    Matrix3x32.transpose(this, this);
    return this;
  };
  _proto.clone = function clone() {
    var e = this.elements;
    var ret = new Matrix3x32(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
    return ret;
  };
  _proto.copyFrom = function copyFrom(source) {
    var e = this.elements;
    var se2 = source.elements;
    e[0] = se2[0];
    e[1] = se2[1];
    e[2] = se2[2];
    e[3] = se2[3];
    e[4] = se2[4];
    e[5] = se2[5];
    e[6] = se2[6];
    e[7] = se2[7];
    e[8] = se2[8];
    return this;
  };
  _proto.copyFromArray = function copyFromArray(array, offset) {
    if (offset === void 0)
      offset = 0;
    var srce = this.elements;
    for (var i = 0; i < 12; i++) {
      srce[i] = array[i + offset];
    }
    return this;
  };
  _proto.copyToArray = function copyToArray(out, outOffset) {
    if (outOffset === void 0)
      outOffset = 0;
    var e = this.elements;
    out[outOffset] = e[0];
    out[outOffset + 1] = e[1];
    out[outOffset + 2] = e[2];
    out[outOffset + 3] = e[3];
    out[outOffset + 4] = e[4];
    out[outOffset + 5] = e[5];
    out[outOffset + 6] = e[6];
    out[outOffset + 7] = e[7];
    out[outOffset + 8] = e[8];
  };
  _proto.copyFromMatrix = function copyFromMatrix(source) {
    var ae2 = source.elements;
    var e = this.elements;
    e[0] = ae2[0];
    e[1] = ae2[1];
    e[2] = ae2[2];
    e[3] = ae2[4];
    e[4] = ae2[5];
    e[5] = ae2[6];
    e[6] = ae2[8];
    e[7] = ae2[9];
    e[8] = ae2[10];
    return this;
  };
  Matrix3x32.add = function add2(left, right, out) {
    var le2 = left.elements;
    var re2 = right.elements;
    var oe2 = out.elements;
    oe2[0] = le2[0] + re2[0];
    oe2[1] = le2[1] + re2[1];
    oe2[2] = le2[2] + re2[2];
    oe2[3] = le2[3] + re2[3];
    oe2[4] = le2[4] + re2[4];
    oe2[5] = le2[5] + re2[5];
    oe2[6] = le2[6] + re2[6];
    oe2[7] = le2[7] + re2[7];
    oe2[8] = le2[8] + re2[8];
  };
  Matrix3x32.subtract = function subtract(left, right, out) {
    var le2 = left.elements;
    var re2 = right.elements;
    var oe2 = out.elements;
    oe2[0] = le2[0] - re2[0];
    oe2[1] = le2[1] - re2[1];
    oe2[2] = le2[2] - re2[2];
    oe2[3] = le2[3] - re2[3];
    oe2[4] = le2[4] - re2[4];
    oe2[5] = le2[5] - re2[5];
    oe2[6] = le2[6] - re2[6];
    oe2[7] = le2[7] - re2[7];
    oe2[8] = le2[8] - re2[8];
  };
  Matrix3x32.multiply = function multiply(left, right, out) {
    var le2 = left.elements;
    var re2 = right.elements;
    var oe2 = out.elements;
    var l11 = le2[0], l12 = le2[1], l13 = le2[2];
    var l21 = le2[3], l22 = le2[4], l23 = le2[5];
    var l31 = le2[6], l32 = le2[7], l33 = le2[8];
    var r11 = re2[0], r12 = re2[1], r13 = re2[2];
    var r21 = re2[3], r22 = re2[4], r23 = re2[5];
    var r31 = re2[6], r32 = re2[7], r33 = re2[8];
    oe2[0] = l11 * r11 + l21 * r12 + l31 * r13;
    oe2[1] = l12 * r11 + l22 * r12 + l32 * r13;
    oe2[2] = l13 * r11 + l23 * r12 + l33 * r13;
    oe2[3] = l11 * r21 + l21 * r22 + l31 * r23;
    oe2[4] = l12 * r21 + l22 * r22 + l32 * r23;
    oe2[5] = l13 * r21 + l23 * r22 + l33 * r23;
    oe2[6] = l11 * r31 + l21 * r32 + l31 * r33;
    oe2[7] = l12 * r31 + l22 * r32 + l32 * r33;
    oe2[8] = l13 * r31 + l23 * r32 + l33 * r33;
  };
  Matrix3x32.equals = function equals(left, right) {
    var le2 = left.elements;
    var re2 = right.elements;
    return MathUtil$1.equals(le2[0], re2[0]) && MathUtil$1.equals(le2[1], re2[1]) && MathUtil$1.equals(le2[2], re2[2]) && MathUtil$1.equals(le2[3], re2[3]) && MathUtil$1.equals(le2[4], re2[4]) && MathUtil$1.equals(le2[5], re2[5]) && MathUtil$1.equals(le2[6], re2[6]) && MathUtil$1.equals(le2[7], re2[7]) && MathUtil$1.equals(le2[8], re2[8]);
  };
  Matrix3x32.lerp = function lerp(start, end, t, out) {
    var se2 = start.elements;
    var ee2 = end.elements;
    var oe2 = out.elements;
    var inv = 1 - t;
    oe2[0] = se2[0] * inv + ee2[0] * t;
    oe2[1] = se2[1] * inv + ee2[1] * t;
    oe2[2] = se2[2] * inv + ee2[2] * t;
    oe2[3] = se2[3] * inv + ee2[3] * t;
    oe2[4] = se2[4] * inv + ee2[4] * t;
    oe2[5] = se2[5] * inv + ee2[5] * t;
    oe2[6] = se2[6] * inv + ee2[6] * t;
    oe2[7] = se2[7] * inv + ee2[7] * t;
    oe2[8] = se2[8] * inv + ee2[8] * t;
  };
  Matrix3x32.rotationQuaternion = function rotationQuaternion(quaternion, out) {
    var oe2 = out.elements;
    var x = quaternion._x, y = quaternion._y, z2 = quaternion._z, w = quaternion._w;
    var x2 = x + x;
    var y2 = y + y;
    var z22 = z2 + z2;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z2 * x2;
    var zy = z2 * y2;
    var zz = z2 * z22;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z22;
    oe2[0] = 1 - yy - zz;
    oe2[3] = yx - wz;
    oe2[6] = zx + wy;
    oe2[1] = yx + wz;
    oe2[4] = 1 - xx - zz;
    oe2[7] = zy - wx;
    oe2[2] = zx - wy;
    oe2[5] = zy + wx;
    oe2[8] = 1 - xx - yy;
  };
  Matrix3x32.scaling = function scaling(s, out) {
    var oe2 = out.elements;
    oe2[0] = s._x;
    oe2[1] = 0;
    oe2[2] = 0;
    oe2[3] = 0;
    oe2[4] = s._y;
    oe2[5] = 0;
    oe2[6] = 0;
    oe2[7] = 0;
    oe2[8] = 1;
  };
  Matrix3x32.translation = function translation(translation, out) {
    var oe2 = out.elements;
    oe2[0] = 1;
    oe2[1] = 0;
    oe2[2] = 0;
    oe2[3] = 0;
    oe2[4] = 1;
    oe2[5] = 0;
    oe2[6] = translation._x;
    oe2[7] = translation._y;
    oe2[8] = 1;
  };
  Matrix3x32.invert = function invert(a, out) {
    var ae2 = a.elements;
    var oe2 = out.elements;
    var a11 = ae2[0], a12 = ae2[1], a13 = ae2[2];
    var a21 = ae2[3], a22 = ae2[4], a23 = ae2[5];
    var a31 = ae2[6], a32 = ae2[7], a33 = ae2[8];
    var b12 = a33 * a22 - a23 * a32;
    var b22 = -a33 * a21 + a23 * a31;
    var b32 = a32 * a21 - a22 * a31;
    var det = a11 * b12 + a12 * b22 + a13 * b32;
    if (!det) {
      return;
    }
    det = 1 / det;
    oe2[0] = b12 * det;
    oe2[1] = (-a33 * a12 + a13 * a32) * det;
    oe2[2] = (a23 * a12 - a13 * a22) * det;
    oe2[3] = b22 * det;
    oe2[4] = (a33 * a11 - a13 * a31) * det;
    oe2[5] = (-a23 * a11 + a13 * a21) * det;
    oe2[6] = b32 * det;
    oe2[7] = (-a32 * a11 + a12 * a31) * det;
    oe2[8] = (a22 * a11 - a12 * a21) * det;
  };
  Matrix3x32.normalMatrix = function normalMatrix(mat4, out) {
    var ae2 = mat4.elements;
    var oe2 = out.elements;
    var a11 = ae2[0], a12 = ae2[1], a13 = ae2[2], a14 = ae2[3];
    var a21 = ae2[4], a22 = ae2[5], a23 = ae2[6], a24 = ae2[7];
    var a31 = ae2[8], a32 = ae2[9], a33 = ae2[10], a34 = ae2[11];
    var a41 = ae2[12], a42 = ae2[13], a43 = ae2[14], a44 = ae2[15];
    var b00 = a11 * a22 - a12 * a21;
    var b01 = a11 * a23 - a13 * a21;
    var b02 = a11 * a24 - a14 * a21;
    var b03 = a12 * a23 - a13 * a22;
    var b04 = a12 * a24 - a14 * a22;
    var b05 = a13 * a24 - a14 * a23;
    var b06 = a31 * a42 - a32 * a41;
    var b07 = a31 * a43 - a33 * a41;
    var b08 = a31 * a44 - a34 * a41;
    var b09 = a32 * a43 - a33 * a42;
    var b10 = a32 * a44 - a34 * a42;
    var b11 = a33 * a44 - a34 * a43;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    oe2[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
    oe2[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
    oe2[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
    oe2[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
    oe2[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
    oe2[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
    oe2[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
    oe2[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
    oe2[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
  };
  Matrix3x32.rotate = function rotate(a, r, out) {
    var ae2 = a.elements;
    var oe2 = out.elements;
    var s = Math.sin(r);
    var c = Math.cos(r);
    var a11 = ae2[0], a12 = ae2[1], a13 = ae2[2];
    var a21 = ae2[3], a22 = ae2[4], a23 = ae2[5];
    var a31 = ae2[6], a32 = ae2[7], a33 = ae2[8];
    oe2[0] = c * a11 + s * a21;
    oe2[1] = c * a12 + s * a22;
    oe2[2] = c * a13 + s * a23;
    oe2[3] = c * a21 - s * a11;
    oe2[4] = c * a22 - s * a12;
    oe2[5] = c * a23 - s * a13;
    oe2[6] = a31;
    oe2[7] = a32;
    oe2[8] = a33;
  };
  Matrix3x32.scale = function scale(m, s, out) {
    var x = s._x, y = s._y;
    var ae2 = m.elements;
    var oe2 = out.elements;
    oe2[0] = x * ae2[0];
    oe2[1] = x * ae2[1];
    oe2[2] = x * ae2[2];
    oe2[3] = y * ae2[3];
    oe2[4] = y * ae2[4];
    oe2[5] = y * ae2[5];
    oe2[6] = ae2[6];
    oe2[7] = ae2[7];
    oe2[8] = ae2[8];
  };
  Matrix3x32.translate = function translate(m, translation, out) {
    var x = translation._x, y = translation._y;
    var ae2 = m.elements;
    var oe2 = out.elements;
    var a11 = ae2[0], a12 = ae2[1], a13 = ae2[2];
    var a21 = ae2[3], a22 = ae2[4], a23 = ae2[5];
    var a31 = ae2[6], a32 = ae2[7], a33 = ae2[8];
    oe2[0] = a11;
    oe2[1] = a12;
    oe2[2] = a13;
    oe2[3] = a21;
    oe2[4] = a22;
    oe2[5] = a23;
    oe2[6] = x * a11 + y * a21 + a31;
    oe2[7] = x * a12 + y * a22 + a32;
    oe2[8] = x * a13 + y * a23 + a33;
  };
  Matrix3x32.transpose = function transpose(a, out) {
    var ae2 = a.elements;
    var oe2 = out.elements;
    if (out === a) {
      var a12 = ae2[1];
      var a13 = ae2[2];
      var a23 = ae2[5];
      oe2[1] = ae2[3];
      oe2[2] = ae2[6];
      oe2[3] = a12;
      oe2[5] = ae2[7];
      oe2[6] = a13;
      oe2[7] = a23;
    } else {
      oe2[0] = ae2[0];
      oe2[1] = ae2[3];
      oe2[2] = ae2[6];
      oe2[3] = ae2[1];
      oe2[4] = ae2[4];
      oe2[5] = ae2[7];
      oe2[6] = ae2[2];
      oe2[7] = ae2[5];
      oe2[8] = ae2[8];
    }
  };
  return Matrix3x32;
}();
var Quaternion = /* @__PURE__ */ function() {
  function Quaternion2(x, y, z2, w) {
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    if (z2 === void 0)
      z2 = 0;
    if (w === void 0)
      w = 1;
    this._onValueChanged = null;
    this._x = x;
    this._y = y;
    this._z = z2;
    this._w = w;
  }
  var _proto = Quaternion2.prototype;
  _proto.set = function set(x, y, z2, w) {
    this._x = x;
    this._y = y;
    this._z = z2;
    this._w = w;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.conjugate = function conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.getAxisAngle = function getAxisAngle(out) {
    var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
    var length2 = _x * _x + _y * _y + _z * _z;
    if (length2 < MathUtil$1.zeroTolerance) {
      out._x = 1;
      out._y = 0;
      out._z = 0;
      return 0;
    } else {
      var inv = 1 / length2;
      out._x = this._x * inv;
      out._y = this._y * inv;
      out._z = this._z * inv;
      return Math.acos(this._w) * 2;
    }
  };
  _proto.identity = function identity() {
    this._x = 0;
    this._y = 0;
    this._z = 0;
    this._w = 1;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.length = function length2() {
    var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
    return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
  };
  _proto.lengthSquared = function lengthSquared() {
    var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
    return _x * _x + _y * _y + _z * _z + _w * _w;
  };
  _proto.normalize = function normalize() {
    Quaternion2.normalize(this, this);
    return this;
  };
  _proto.toEuler = function toEuler(out) {
    this._toYawPitchRoll(out);
    var t = out._x;
    out._x = out._y;
    out._y = t;
    out._onValueChanged && out._onValueChanged();
    return out;
  };
  _proto.toYawPitchRoll = function toYawPitchRoll(out) {
    this._toYawPitchRoll(out);
    out._onValueChanged && out._onValueChanged();
    return out;
  };
  _proto.rotateX = function rotateX(rad) {
    Quaternion2.rotateX(this, rad, this);
    return this;
  };
  _proto.rotateY = function rotateY(rad) {
    Quaternion2.rotateY(this, rad, this);
    return this;
  };
  _proto.rotateZ = function rotateZ(rad) {
    Quaternion2.rotateZ(this, rad, this);
    return this;
  };
  _proto.rotationAxisAngle = function rotationAxisAngle(axis, rad) {
    Quaternion2.rotationAxisAngle(axis, rad, this);
    return this;
  };
  _proto.multiply = function multiply(quat) {
    Quaternion2.multiply(this, quat, this);
    return this;
  };
  _proto.invert = function invert() {
    Quaternion2.invert(this, this);
    return this;
  };
  _proto.dot = function dot(quat) {
    return Quaternion2.dot(this, quat);
  };
  _proto.lerp = function lerp(quat, t) {
    Quaternion2.lerp(this, quat, t, this);
    return this;
  };
  _proto.rotateAxisAngle = function rotateAxisAngle(axis, rad) {
    Quaternion2._tempQuat1.rotationAxisAngle(axis, rad);
    this.multiply(Quaternion2._tempQuat1);
    return this;
  };
  _proto.clone = function clone() {
    return new Quaternion2(this._x, this._y, this._z, this._w);
  };
  _proto.copyFrom = function copyFrom(source) {
    this._x = source.x;
    this._y = source.y;
    this._z = source.z;
    this._w = source.w;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.copyFromArray = function copyFromArray(array, offset) {
    if (offset === void 0)
      offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.copyToArray = function copyToArray(out, outOffset) {
    if (outOffset === void 0)
      outOffset = 0;
    out[outOffset] = this._x;
    out[outOffset + 1] = this._y;
    out[outOffset + 2] = this._z;
    out[outOffset + 3] = this._w;
  };
  _proto.toJSON = function toJSON() {
    return {
      x: this._x,
      y: this._y,
      z: this._z,
      w: this._w
    };
  };
  _proto._toYawPitchRoll = function _toYawPitchRoll(out) {
    var _this = this, x = _this._x, y = _this._y, z2 = _this._z, w = _this._w;
    var xx = x * x;
    var sinP = 2 * (x * w - y * z2);
    out._y = Math.abs(sinP) >= 1 ? Math.sign(sinP) * (Math.PI / 2) : Math.asin(sinP);
    out._x = Math.atan2(2 * (z2 * x + y * w), 1 - 2 * (y * y + xx));
    out._z = Math.atan2(2 * (x * y + z2 * w), 1 - 2 * (z2 * z2 + xx));
  };
  Quaternion2.add = function add2(left, right, out) {
    out._x = left._x + right._x;
    out._y = left._y + right._y;
    out._z = left._z + right._z;
    out._w = left._w + right._w;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.multiply = function multiply(left, right, out) {
    var ax = left._x, ay = left._y, az = left._z, aw = left._w;
    var bx = right._x, by = right._y, bz = right._z, bw = right._w;
    out._x = ax * bw + aw * bx + ay * bz - az * by;
    out._y = ay * bw + aw * by + az * bx - ax * bz;
    out._z = az * bw + aw * bz + ax * by - ay * bx;
    out._w = aw * bw - ax * bx - ay * by - az * bz;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.conjugate = function conjugate(a, out) {
    out._x = -a._x;
    out._y = -a._y;
    out._z = -a._z;
    out._w = a._w;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.dot = function dot(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
  };
  Quaternion2.equals = function equals(left, right) {
    return MathUtil$1.equals(left._x, right._x) && MathUtil$1.equals(left._y, right._y) && MathUtil$1.equals(left._z, right._z) && MathUtil$1.equals(left._w, right._w);
  };
  Quaternion2.rotationAxisAngle = function rotationAxisAngle(axis, rad, out) {
    var normalAxis = Quaternion2._tempVector3;
    Vector3.normalize(axis, normalAxis);
    rad *= 0.5;
    var s = Math.sin(rad);
    out._x = normalAxis._x * s;
    out._y = normalAxis._y * s;
    out._z = normalAxis._z * s;
    out._w = Math.cos(rad);
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.rotationEuler = function rotationEuler(x, y, z2, out) {
    Quaternion2.rotationYawPitchRoll(y, x, z2, out);
  };
  Quaternion2.rotationYawPitchRoll = function rotationYawPitchRoll(yaw, pitch, roll, out) {
    var halfRoll = roll * 0.5;
    var halfPitch = pitch * 0.5;
    var halfYaw = yaw * 0.5;
    var sinRoll = Math.sin(halfRoll);
    var cosRoll = Math.cos(halfRoll);
    var sinPitch = Math.sin(halfPitch);
    var cosPitch = Math.cos(halfPitch);
    var sinYaw = Math.sin(halfYaw);
    var cosYaw = Math.cos(halfYaw);
    var cosYawPitch = cosYaw * cosPitch;
    var sinYawPitch = sinYaw * sinPitch;
    out._x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
    out._y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
    out._z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
    out._w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.rotationMatrix3x3 = function rotationMatrix3x3(m, out) {
    var me = m.elements;
    var m11 = me[0], m12 = me[1], m13 = me[2];
    var m21 = me[3], m22 = me[4], m23 = me[5];
    var m31 = me[6], m32 = me[7], m33 = me[8];
    var scale = m11 + m22 + m33;
    var sqrt, half;
    if (scale > 0) {
      sqrt = Math.sqrt(scale + 1);
      out._w = sqrt * 0.5;
      sqrt = 0.5 / sqrt;
      out._x = (m23 - m32) * sqrt;
      out._y = (m31 - m13) * sqrt;
      out._z = (m12 - m21) * sqrt;
    } else if (m11 >= m22 && m11 >= m33) {
      sqrt = Math.sqrt(1 + m11 - m22 - m33);
      half = 0.5 / sqrt;
      out._x = 0.5 * sqrt;
      out._y = (m12 + m21) * half;
      out._z = (m13 + m31) * half;
      out._w = (m23 - m32) * half;
    } else if (m22 > m33) {
      sqrt = Math.sqrt(1 + m22 - m11 - m33);
      half = 0.5 / sqrt;
      out._x = (m21 + m12) * half;
      out._y = 0.5 * sqrt;
      out._z = (m32 + m23) * half;
      out._w = (m31 - m13) * half;
    } else {
      sqrt = Math.sqrt(1 + m33 - m11 - m22);
      half = 0.5 / sqrt;
      out._x = (m13 + m31) * half;
      out._y = (m23 + m32) * half;
      out._z = 0.5 * sqrt;
      out._w = (m12 - m21) * half;
    }
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.invert = function invert(a, out) {
    var x = a._x, y = a._y, z2 = a._z, w = a._w;
    var dot = x * x + y * y + z2 * z2 + w * w;
    if (dot > MathUtil$1.zeroTolerance) {
      var invDot = 1 / dot;
      out._x = -x * invDot;
      out._y = -y * invDot;
      out._z = -z2 * invDot;
      out._w = w * invDot;
      out._onValueChanged && out._onValueChanged();
    }
  };
  Quaternion2.lerp = function lerp(start, end, t, out) {
    var inv = 1 - t;
    if (Quaternion2.dot(start, end) >= 0) {
      out._x = start._x * inv + end._x * t;
      out._y = start._y * inv + end._y * t;
      out._z = start._z * inv + end._z * t;
      out._w = start._w * inv + end._w * t;
    } else {
      out._x = start._x * inv - end._x * t;
      out._y = start._y * inv - end._y * t;
      out._z = start._z * inv - end._z * t;
      out._w = start._w * inv - end._w * t;
    }
    out.normalize();
  };
  Quaternion2.slerp = function slerp(start, end, amount, out) {
    var opposite;
    var inverse;
    var dot = Quaternion2.dot(start, end);
    if (Math.abs(dot) > 1 - MathUtil$1.zeroTolerance) {
      inverse = 1 - amount;
      opposite = amount * Math.sign(dot);
    } else {
      var acos = Math.acos(Math.abs(dot));
      var invSin = 1 / Math.sin(acos);
      inverse = Math.sin((1 - amount) * acos) * invSin;
      opposite = Math.sin(amount * acos) * invSin * Math.sign(dot);
    }
    out.x = inverse * start.x + opposite * end.x;
    out.y = inverse * start.y + opposite * end.y;
    out.z = inverse * start.z + opposite * end.z;
    out.w = inverse * start.w + opposite * end.w;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.normalize = function normalize(a, out) {
    var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
    var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    if (len > MathUtil$1.zeroTolerance) {
      len = 1 / len;
      out._x = _x * len;
      out._y = _y * len;
      out._z = _z * len;
      out._w = _w * len;
      out._onValueChanged && out._onValueChanged();
    }
  };
  Quaternion2.rotationX = function rotationX(rad, out) {
    rad *= 0.5;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out._x = s;
    out._y = 0;
    out._z = 0;
    out._w = c;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.rotationY = function rotationY(rad, out) {
    rad *= 0.5;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out._x = 0;
    out._y = s;
    out._z = 0;
    out._w = c;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.rotationZ = function rotationZ(rad, out) {
    rad *= 0.5;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out._x = 0;
    out._y = 0;
    out._z = s;
    out._w = c;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.rotateX = function rotateX(quaternion, rad, out) {
    var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
    rad *= 0.5;
    var bx = Math.sin(rad);
    var bw = Math.cos(rad);
    out._x = _x * bw + _w * bx;
    out._y = _y * bw + _z * bx;
    out._z = _z * bw - _y * bx;
    out._w = _w * bw - _x * bx;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.rotateY = function rotateY(quaternion, rad, out) {
    var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
    rad *= 0.5;
    var by = Math.sin(rad);
    var bw = Math.cos(rad);
    out._x = _x * bw - _z * by;
    out._y = _y * bw + _w * by;
    out._z = _z * bw + _x * by;
    out._w = _w * bw - _y * by;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.rotateZ = function rotateZ(quaternion, rad, out) {
    var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
    rad *= 0.5;
    var bz = Math.sin(rad);
    var bw = Math.cos(rad);
    out._x = _x * bw + _y * bz;
    out._y = _y * bw - _x * bz;
    out._z = _z * bw + _w * bz;
    out._w = _w * bw - _z * bz;
    out._onValueChanged && out._onValueChanged();
  };
  Quaternion2.scale = function scale(a, s, out) {
    out._x = a._x * s;
    out._y = a._y * s;
    out._z = a._z * s;
    out._w = a._w * s;
    out._onValueChanged && out._onValueChanged();
  };
  _create_class$5(Quaternion2, [
    {
      key: "x",
      get: function get3() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "y",
      get: function get3() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "z",
      get: function get3() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "normalized",
      get: function get3() {
        return Math.abs(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w - 1) < MathUtil$1.zeroTolerance;
      }
    },
    {
      key: "w",
      get: function get3() {
        return this._w;
      },
      set: function set(value) {
        this._w = value;
        this._onValueChanged && this._onValueChanged();
      }
    }
  ]);
  return Quaternion2;
}();
(function() {
  Quaternion._tempVector3 = new Vector3();
})();
(function() {
  Quaternion._tempQuat1 = new Quaternion();
})();
var Matrix = /* @__PURE__ */ function() {
  function Matrix2(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
    if (m11 === void 0)
      m11 = 1;
    if (m12 === void 0)
      m12 = 0;
    if (m13 === void 0)
      m13 = 0;
    if (m14 === void 0)
      m14 = 0;
    if (m21 === void 0)
      m21 = 0;
    if (m22 === void 0)
      m22 = 1;
    if (m23 === void 0)
      m23 = 0;
    if (m24 === void 0)
      m24 = 0;
    if (m31 === void 0)
      m31 = 0;
    if (m32 === void 0)
      m32 = 0;
    if (m33 === void 0)
      m33 = 1;
    if (m34 === void 0)
      m34 = 0;
    if (m41 === void 0)
      m41 = 0;
    if (m42 === void 0)
      m42 = 0;
    if (m43 === void 0)
      m43 = 0;
    if (m44 === void 0)
      m44 = 1;
    this.elements = new Float32Array(16);
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m14;
    e[4] = m21;
    e[5] = m22;
    e[6] = m23;
    e[7] = m24;
    e[8] = m31;
    e[9] = m32;
    e[10] = m33;
    e[11] = m34;
    e[12] = m41;
    e[13] = m42;
    e[14] = m43;
    e[15] = m44;
  }
  var _proto = Matrix2.prototype;
  _proto.set = function set(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m14;
    e[4] = m21;
    e[5] = m22;
    e[6] = m23;
    e[7] = m24;
    e[8] = m31;
    e[9] = m32;
    e[10] = m33;
    e[11] = m34;
    e[12] = m41;
    e[13] = m42;
    e[14] = m43;
    e[15] = m44;
    return this;
  };
  _proto.multiply = function multiply(right) {
    Matrix2.multiply(this, right, this);
    return this;
  };
  _proto.determinant = function determinant() {
    var e = this.elements;
    var a11 = e[0], a12 = e[1], a13 = e[2], a14 = e[3];
    var a21 = e[4], a22 = e[5], a23 = e[6], a24 = e[7];
    var a31 = e[8], a32 = e[9], a33 = e[10], a34 = e[11];
    var a41 = e[12], a42 = e[13], a43 = e[14], a44 = e[15];
    var b00 = a11 * a22 - a12 * a21;
    var b01 = a11 * a23 - a13 * a21;
    var b02 = a11 * a24 - a14 * a21;
    var b03 = a12 * a23 - a13 * a22;
    var b04 = a12 * a24 - a14 * a22;
    var b05 = a13 * a24 - a14 * a23;
    var b06 = a31 * a42 - a32 * a41;
    var b07 = a31 * a43 - a33 * a41;
    var b08 = a31 * a44 - a34 * a41;
    var b09 = a32 * a43 - a33 * a42;
    var b10 = a32 * a44 - a34 * a42;
    var b11 = a33 * a44 - a34 * a43;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  };
  _proto.decompose = function decompose(translation, rotation, scale) {
    var rm = Matrix2._tempMat30;
    var e = this.elements;
    var rme = rm.elements;
    var m11 = e[0];
    var m12 = e[1];
    var m13 = e[2];
    var m14 = e[3];
    var m21 = e[4];
    var m22 = e[5];
    var m23 = e[6];
    var m24 = e[7];
    var m31 = e[8];
    var m32 = e[9];
    var m33 = e[10];
    var m34 = e[11];
    translation.set(e[12], e[13], e[14]);
    var xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
    var ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
    var zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
    var sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    var sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    var sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    scale.set(sx, sy, sz);
    if (Math.abs(sx) < MathUtil$1.zeroTolerance || Math.abs(sy) < MathUtil$1.zeroTolerance || Math.abs(sz) < MathUtil$1.zeroTolerance) {
      rotation.identity();
      return false;
    } else {
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      rme[0] = m11 * invSX;
      rme[1] = m12 * invSX;
      rme[2] = m13 * invSX;
      rme[3] = m21 * invSY;
      rme[4] = m22 * invSY;
      rme[5] = m23 * invSY;
      rme[6] = m31 * invSZ;
      rme[7] = m32 * invSZ;
      rme[8] = m33 * invSZ;
      Quaternion.rotationMatrix3x3(rm, rotation);
      return true;
    }
  };
  _proto.getRotation = function getRotation(out) {
    var e = this.elements;
    var trace = e[0] + e[5] + e[10];
    if (trace > MathUtil$1.zeroTolerance) {
      var s = Math.sqrt(trace + 1) * 2;
      out._w = 0.25 * s;
      out._x = (e[6] - e[9]) / s;
      out._y = (e[8] - e[2]) / s;
      out._z = (e[1] - e[4]) / s;
    } else if (e[0] > e[5] && e[0] > e[10]) {
      var s1 = Math.sqrt(1 + e[0] - e[5] - e[10]) * 2;
      out._w = (e[6] - e[9]) / s1;
      out._x = 0.25 * s1;
      out._y = (e[1] + e[4]) / s1;
      out._z = (e[8] + e[2]) / s1;
    } else if (e[5] > e[10]) {
      var s2 = Math.sqrt(1 + e[5] - e[0] - e[10]) * 2;
      out._w = (e[8] - e[2]) / s2;
      out._x = (e[1] + e[4]) / s2;
      out._y = 0.25 * s2;
      out._z = (e[6] + e[9]) / s2;
    } else {
      var s3 = Math.sqrt(1 + e[10] - e[0] - e[5]) * 2;
      out._w = (e[1] - e[4]) / s3;
      out._x = (e[8] + e[2]) / s3;
      out._y = (e[6] + e[9]) / s3;
      out._z = 0.25 * s3;
    }
    out._onValueChanged && out._onValueChanged();
    return out;
  };
  _proto.getScaling = function getScaling(out) {
    var e = this.elements;
    var m11 = e[0], m12 = e[1], m13 = e[2];
    var m21 = e[4], m22 = e[5], m23 = e[6];
    var m31 = e[8], m32 = e[9], m33 = e[10];
    out.set(Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13), Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23), Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33));
    return out;
  };
  _proto.getTranslation = function getTranslation(out) {
    var e = this.elements;
    out.set(e[12], e[13], e[14]);
    return out;
  };
  _proto.identity = function identity() {
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 1;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
    e[9] = 0;
    e[10] = 1;
    e[11] = 0;
    e[12] = 0;
    e[13] = 0;
    e[14] = 0;
    e[15] = 1;
    return this;
  };
  _proto.invert = function invert() {
    Matrix2.invert(this, this);
    return this;
  };
  _proto.rotateAxisAngle = function rotateAxisAngle(axis, r) {
    Matrix2.rotateAxisAngle(this, axis, r, this);
    return this;
  };
  _proto.scale = function scale(s) {
    Matrix2.scale(this, s, this);
    return this;
  };
  _proto.translate = function translate(v) {
    Matrix2.translate(this, v, this);
    return this;
  };
  _proto.transpose = function transpose() {
    Matrix2.transpose(this, this);
    return this;
  };
  _proto.clone = function clone() {
    var e = this.elements;
    var ret = new Matrix2(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
    return ret;
  };
  _proto.copyFrom = function copyFrom(source) {
    var e = this.elements;
    var se2 = source.elements;
    e[0] = se2[0];
    e[1] = se2[1];
    e[2] = se2[2];
    e[3] = se2[3];
    e[4] = se2[4];
    e[5] = se2[5];
    e[6] = se2[6];
    e[7] = se2[7];
    e[8] = se2[8];
    e[9] = se2[9];
    e[10] = se2[10];
    e[11] = se2[11];
    e[12] = se2[12];
    e[13] = se2[13];
    e[14] = se2[14];
    e[15] = se2[15];
    return this;
  };
  _proto.copyFromArray = function copyFromArray(array, offset) {
    if (offset === void 0)
      offset = 0;
    var srce = this.elements;
    for (var i = 0; i < 16; i++) {
      srce[i] = array[i + offset];
    }
    return this;
  };
  _proto.copyToArray = function copyToArray(out, outOffset) {
    if (outOffset === void 0)
      outOffset = 0;
    var e = this.elements;
    out[outOffset] = e[0];
    out[outOffset + 1] = e[1];
    out[outOffset + 2] = e[2];
    out[outOffset + 3] = e[3];
    out[outOffset + 4] = e[4];
    out[outOffset + 5] = e[5];
    out[outOffset + 6] = e[6];
    out[outOffset + 7] = e[7];
    out[outOffset + 8] = e[8];
    out[outOffset + 9] = e[9];
    out[outOffset + 10] = e[10];
    out[outOffset + 11] = e[11];
    out[outOffset + 12] = e[12];
    out[outOffset + 13] = e[13];
    out[outOffset + 14] = e[14];
    out[outOffset + 15] = e[15];
  };
  Matrix2.multiply = function multiply(left, right, out) {
    var le2 = left.elements;
    var re2 = right.elements;
    var oe2 = out.elements;
    var l11 = le2[0], l12 = le2[1], l13 = le2[2], l14 = le2[3], l21 = le2[4], l22 = le2[5], l23 = le2[6], l24 = le2[7], l31 = le2[8], l32 = le2[9], l33 = le2[10], l34 = le2[11], l41 = le2[12], l42 = le2[13], l43 = le2[14], l44 = le2[15];
    var r11 = re2[0], r12 = re2[1], r13 = re2[2], r14 = re2[3], r21 = re2[4], r22 = re2[5], r23 = re2[6], r24 = re2[7], r31 = re2[8], r32 = re2[9], r33 = re2[10], r34 = re2[11], r41 = re2[12], r42 = re2[13], r43 = re2[14], r44 = re2[15];
    oe2[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
    oe2[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
    oe2[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
    oe2[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
    oe2[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
    oe2[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
    oe2[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
    oe2[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
    oe2[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
    oe2[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
    oe2[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
    oe2[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
    oe2[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
    oe2[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
    oe2[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
    oe2[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
  };
  Matrix2.equals = function equals(left, right) {
    var le2 = left.elements;
    var re2 = right.elements;
    return MathUtil$1.equals(le2[0], re2[0]) && MathUtil$1.equals(le2[1], re2[1]) && MathUtil$1.equals(le2[2], re2[2]) && MathUtil$1.equals(le2[3], re2[3]) && MathUtil$1.equals(le2[4], re2[4]) && MathUtil$1.equals(le2[5], re2[5]) && MathUtil$1.equals(le2[6], re2[6]) && MathUtil$1.equals(le2[7], re2[7]) && MathUtil$1.equals(le2[8], re2[8]) && MathUtil$1.equals(le2[9], re2[9]) && MathUtil$1.equals(le2[10], re2[10]) && MathUtil$1.equals(le2[11], re2[11]) && MathUtil$1.equals(le2[12], re2[12]) && MathUtil$1.equals(le2[13], re2[13]) && MathUtil$1.equals(le2[14], re2[14]) && MathUtil$1.equals(le2[15], re2[15]);
  };
  Matrix2.lerp = function lerp(start, end, t, out) {
    var se2 = start.elements;
    var ee2 = end.elements;
    var oe2 = out.elements;
    var inv = 1 - t;
    oe2[0] = se2[0] * inv + ee2[0] * t;
    oe2[1] = se2[1] * inv + ee2[1] * t;
    oe2[2] = se2[2] * inv + ee2[2] * t;
    oe2[3] = se2[3] * inv + ee2[3] * t;
    oe2[4] = se2[4] * inv + ee2[4] * t;
    oe2[5] = se2[5] * inv + ee2[5] * t;
    oe2[6] = se2[6] * inv + ee2[6] * t;
    oe2[7] = se2[7] * inv + ee2[7] * t;
    oe2[8] = se2[8] * inv + ee2[8] * t;
    oe2[9] = se2[9] * inv + ee2[9] * t;
    oe2[10] = se2[10] * inv + ee2[10] * t;
    oe2[11] = se2[11] * inv + ee2[11] * t;
    oe2[12] = se2[12] * inv + ee2[12] * t;
    oe2[13] = se2[13] * inv + ee2[13] * t;
    oe2[14] = se2[14] * inv + ee2[14] * t;
    oe2[15] = se2[15] * inv + ee2[15] * t;
  };
  Matrix2.add = function add2(left, right, out) {
    var le2 = left.elements;
    var re2 = right.elements;
    var oe2 = out.elements;
    oe2[0] = le2[0] + re2[0];
    oe2[1] = le2[1] + re2[1];
    oe2[2] = le2[2] + re2[2];
    oe2[3] = le2[3] + re2[3];
    oe2[4] = le2[4] + re2[4];
    oe2[5] = le2[5] + re2[5];
    oe2[6] = le2[6] + re2[6];
    oe2[7] = le2[7] + re2[7];
    oe2[8] = le2[8] + re2[8];
    oe2[9] = le2[9] + re2[9];
    oe2[10] = le2[10] + re2[10];
    oe2[11] = le2[11] + re2[11];
    oe2[12] = le2[12] + re2[12];
    oe2[13] = le2[13] + re2[13];
    oe2[14] = le2[14] + re2[14];
    oe2[15] = le2[15] + re2[15];
  };
  Matrix2.multiplyScalar = function multiplyScalar(source, scalar, out) {
    var se2 = source.elements;
    var oe2 = out.elements;
    oe2[0] = se2[0] * scalar;
    oe2[1] = se2[1] * scalar;
    oe2[2] = se2[2] * scalar;
    oe2[3] = se2[3] * scalar;
    oe2[4] = se2[4] * scalar;
    oe2[5] = se2[5] * scalar;
    oe2[6] = se2[6] * scalar;
    oe2[7] = se2[7] * scalar;
    oe2[8] = se2[8] * scalar;
    oe2[9] = se2[9] * scalar;
    oe2[10] = se2[10] * scalar;
    oe2[11] = se2[11] * scalar;
    oe2[12] = se2[12] * scalar;
    oe2[13] = se2[13] * scalar;
    oe2[14] = se2[14] * scalar;
    oe2[15] = se2[15] * scalar;
  };
  Matrix2.rotationQuaternion = function rotationQuaternion(quaternion, out) {
    var oe2 = out.elements;
    var x = quaternion._x, y = quaternion._y, z2 = quaternion._z, w = quaternion._w;
    var x2 = x + x;
    var y2 = y + y;
    var z22 = z2 + z2;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z2 * x2;
    var zy = z2 * y2;
    var zz = z2 * z22;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z22;
    oe2[0] = 1 - yy - zz;
    oe2[1] = yx + wz;
    oe2[2] = zx - wy;
    oe2[3] = 0;
    oe2[4] = yx - wz;
    oe2[5] = 1 - xx - zz;
    oe2[6] = zy + wx;
    oe2[7] = 0;
    oe2[8] = zx + wy;
    oe2[9] = zy - wx;
    oe2[10] = 1 - xx - yy;
    oe2[11] = 0;
    oe2[12] = 0;
    oe2[13] = 0;
    oe2[14] = 0;
    oe2[15] = 1;
  };
  Matrix2.rotationAxisAngle = function rotationAxisAngle(axis, r, out) {
    var oe2 = out.elements;
    var x = axis._x, y = axis._y, z2 = axis._z;
    var len = Math.sqrt(x * x + y * y + z2 * z2);
    var s, c, t;
    if (Math.abs(len) < MathUtil$1.zeroTolerance) {
      return;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z2 *= len;
    s = Math.sin(r);
    c = Math.cos(r);
    t = 1 - c;
    oe2[0] = x * x * t + c;
    oe2[1] = y * x * t + z2 * s;
    oe2[2] = z2 * x * t - y * s;
    oe2[3] = 0;
    oe2[4] = x * y * t - z2 * s;
    oe2[5] = y * y * t + c;
    oe2[6] = z2 * y * t + x * s;
    oe2[7] = 0;
    oe2[8] = x * z2 * t + y * s;
    oe2[9] = y * z2 * t - x * s;
    oe2[10] = z2 * z2 * t + c;
    oe2[11] = 0;
    oe2[12] = 0;
    oe2[13] = 0;
    oe2[14] = 0;
    oe2[15] = 1;
  };
  Matrix2.rotationTranslation = function rotationTranslation(quaternion, translation, out) {
    Matrix2.rotationQuaternion(quaternion, out);
    var oe2 = out.elements;
    oe2[12] = translation._x;
    oe2[13] = translation._y;
    oe2[14] = translation._z;
  };
  Matrix2.affineTransformation = function affineTransformation(scale, rotation, translation, out) {
    var oe2 = out.elements;
    var x = rotation._x, y = rotation._y, z2 = rotation._z, w = rotation._w;
    var x2 = x + x;
    var y2 = y + y;
    var z22 = z2 + z2;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z22;
    var yy = y * y2;
    var yz = y * z22;
    var zz = z2 * z22;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z22;
    var sx = scale._x;
    var sy = scale._y;
    var sz = scale._z;
    oe2[0] = (1 - (yy + zz)) * sx;
    oe2[1] = (xy + wz) * sx;
    oe2[2] = (xz - wy) * sx;
    oe2[3] = 0;
    oe2[4] = (xy - wz) * sy;
    oe2[5] = (1 - (xx + zz)) * sy;
    oe2[6] = (yz + wx) * sy;
    oe2[7] = 0;
    oe2[8] = (xz + wy) * sz;
    oe2[9] = (yz - wx) * sz;
    oe2[10] = (1 - (xx + yy)) * sz;
    oe2[11] = 0;
    oe2[12] = translation._x;
    oe2[13] = translation._y;
    oe2[14] = translation._z;
    oe2[15] = 1;
  };
  Matrix2.scaling = function scaling(s, out) {
    var oe2 = out.elements;
    oe2[0] = s._x;
    oe2[1] = 0;
    oe2[2] = 0;
    oe2[3] = 0;
    oe2[4] = 0;
    oe2[5] = s._y;
    oe2[6] = 0;
    oe2[7] = 0;
    oe2[8] = 0;
    oe2[9] = 0;
    oe2[10] = s._z;
    oe2[11] = 0;
    oe2[12] = 0;
    oe2[13] = 0;
    oe2[14] = 0;
    oe2[15] = 1;
  };
  Matrix2.translation = function translation(translation, out) {
    var oe2 = out.elements;
    oe2[0] = 1;
    oe2[1] = 0;
    oe2[2] = 0;
    oe2[3] = 0;
    oe2[4] = 0;
    oe2[5] = 1;
    oe2[6] = 0;
    oe2[7] = 0;
    oe2[8] = 0;
    oe2[9] = 0;
    oe2[10] = 1;
    oe2[11] = 0;
    oe2[12] = translation._x;
    oe2[13] = translation._y;
    oe2[14] = translation._z;
    oe2[15] = 1;
  };
  Matrix2.invert = function invert(a, out) {
    var ae2 = a.elements;
    var oe2 = out.elements;
    var a11 = ae2[0], a12 = ae2[1], a13 = ae2[2], a14 = ae2[3];
    var a21 = ae2[4], a22 = ae2[5], a23 = ae2[6], a24 = ae2[7];
    var a31 = ae2[8], a32 = ae2[9], a33 = ae2[10], a34 = ae2[11];
    var a41 = ae2[12], a42 = ae2[13], a43 = ae2[14], a44 = ae2[15];
    var b00 = a11 * a22 - a12 * a21;
    var b01 = a11 * a23 - a13 * a21;
    var b02 = a11 * a24 - a14 * a21;
    var b03 = a12 * a23 - a13 * a22;
    var b04 = a12 * a24 - a14 * a22;
    var b05 = a13 * a24 - a14 * a23;
    var b06 = a31 * a42 - a32 * a41;
    var b07 = a31 * a43 - a33 * a41;
    var b08 = a31 * a44 - a34 * a41;
    var b09 = a32 * a43 - a33 * a42;
    var b10 = a32 * a44 - a34 * a42;
    var b11 = a33 * a44 - a34 * a43;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    oe2[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
    oe2[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
    oe2[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
    oe2[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
    oe2[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
    oe2[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
    oe2[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
    oe2[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
    oe2[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
    oe2[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
    oe2[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    oe2[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
    oe2[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
    oe2[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
    oe2[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
    oe2[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
  };
  Matrix2.lookAt = function lookAt(eye, target, up, out) {
    var oe2 = out.elements;
    var xAxis = Matrix2._tempVec30;
    var yAxis = Matrix2._tempVec31;
    var zAxis = Matrix2._tempVec32;
    Vector3.subtract(eye, target, zAxis);
    zAxis.normalize();
    Vector3.cross(up, zAxis, xAxis);
    xAxis.normalize();
    Vector3.cross(zAxis, xAxis, yAxis);
    oe2[0] = xAxis._x;
    oe2[1] = yAxis._x;
    oe2[2] = zAxis._x;
    oe2[3] = 0;
    oe2[4] = xAxis._y;
    oe2[5] = yAxis._y;
    oe2[6] = zAxis._y;
    oe2[7] = 0;
    oe2[8] = xAxis._z;
    oe2[9] = yAxis._z;
    oe2[10] = zAxis._z;
    oe2[11] = 0;
    oe2[12] = -Vector3.dot(xAxis, eye);
    oe2[13] = -Vector3.dot(yAxis, eye);
    oe2[14] = -Vector3.dot(zAxis, eye);
    oe2[15] = 1;
  };
  Matrix2.ortho = function ortho(left, right, bottom, top, near, far, out) {
    var oe2 = out.elements;
    var lr = 1 / (left - right);
    var bt2 = 1 / (bottom - top);
    var nf = 1 / (near - far);
    oe2[0] = -2 * lr;
    oe2[1] = 0;
    oe2[2] = 0;
    oe2[3] = 0;
    oe2[4] = 0;
    oe2[5] = -2 * bt2;
    oe2[6] = 0;
    oe2[7] = 0;
    oe2[8] = 0;
    oe2[9] = 0;
    oe2[10] = 2 * nf;
    oe2[11] = 0;
    oe2[12] = (left + right) * lr;
    oe2[13] = (top + bottom) * bt2;
    oe2[14] = (far + near) * nf;
    oe2[15] = 1;
  };
  Matrix2.perspective = function perspective(fovY, aspect, near, far, out) {
    var oe2 = out.elements;
    var f = 1 / Math.tan(fovY / 2);
    var nf = 1 / (near - far);
    oe2[0] = f / aspect;
    oe2[1] = 0;
    oe2[2] = 0;
    oe2[3] = 0;
    oe2[4] = 0;
    oe2[5] = f;
    oe2[6] = 0;
    oe2[7] = 0;
    oe2[8] = 0;
    oe2[9] = 0;
    oe2[10] = (far + near) * nf;
    oe2[11] = -1;
    oe2[12] = 0;
    oe2[13] = 0;
    oe2[14] = 2 * far * near * nf;
    oe2[15] = 0;
  };
  Matrix2.rotateAxisAngle = function rotateAxisAngle(m, axis, r, out) {
    var x = axis._x, y = axis._y, z2 = axis._z;
    var len = Math.sqrt(x * x + y * y + z2 * z2);
    if (Math.abs(len) < MathUtil$1.zeroTolerance) {
      return;
    }
    var me = m.elements;
    var oe2 = out.elements;
    var s, c, t;
    len = 1 / len;
    x *= len;
    y *= len;
    z2 *= len;
    s = Math.sin(r);
    c = Math.cos(r);
    t = 1 - c;
    var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
    var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
    var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
    var b11 = x * x * t + c;
    var b12 = y * x * t + z2 * s;
    var b13 = z2 * x * t - y * s;
    var b21 = x * y * t - z2 * s;
    var b22 = y * y * t + c;
    var b23 = z2 * y * t + x * s;
    var b31 = x * z2 * t + y * s;
    var b32 = y * z2 * t - x * s;
    var b33 = z2 * z2 * t + c;
    oe2[0] = a11 * b11 + a21 * b12 + a31 * b13;
    oe2[1] = a12 * b11 + a22 * b12 + a32 * b13;
    oe2[2] = a13 * b11 + a23 * b12 + a33 * b13;
    oe2[3] = a14 * b11 + a24 * b12 + a34 * b13;
    oe2[4] = a11 * b21 + a21 * b22 + a31 * b23;
    oe2[5] = a12 * b21 + a22 * b22 + a32 * b23;
    oe2[6] = a13 * b21 + a23 * b22 + a33 * b23;
    oe2[7] = a14 * b21 + a24 * b22 + a34 * b23;
    oe2[8] = a11 * b31 + a21 * b32 + a31 * b33;
    oe2[9] = a12 * b31 + a22 * b32 + a32 * b33;
    oe2[10] = a13 * b31 + a23 * b32 + a33 * b33;
    oe2[11] = a14 * b31 + a24 * b32 + a34 * b33;
    if (m !== out) {
      oe2[12] = me[12];
      oe2[13] = me[13];
      oe2[14] = me[14];
      oe2[15] = me[15];
    }
  };
  Matrix2.scale = function scale(m, s, out) {
    var me = m.elements;
    var oe2 = out.elements;
    var x = s._x, y = s._y, z2 = s._z;
    oe2[0] = me[0] * x;
    oe2[1] = me[1] * x;
    oe2[2] = me[2] * x;
    oe2[3] = me[3] * x;
    oe2[4] = me[4] * y;
    oe2[5] = me[5] * y;
    oe2[6] = me[6] * y;
    oe2[7] = me[7] * y;
    oe2[8] = me[8] * z2;
    oe2[9] = me[9] * z2;
    oe2[10] = me[10] * z2;
    oe2[11] = me[11] * z2;
    oe2[12] = me[12];
    oe2[13] = me[13];
    oe2[14] = me[14];
    oe2[15] = me[15];
  };
  Matrix2.translate = function translate(m, v, out) {
    var me = m.elements;
    var oe2 = out.elements;
    var x = v._x, y = v._y, z2 = v._z;
    if (m === out) {
      oe2[12] = me[0] * x + me[4] * y + me[8] * z2 + me[12];
      oe2[13] = me[1] * x + me[5] * y + me[9] * z2 + me[13];
      oe2[14] = me[2] * x + me[6] * y + me[10] * z2 + me[14];
      oe2[15] = me[3] * x + me[7] * y + me[11] * z2 + me[15];
    } else {
      var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
      var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
      var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
      oe2[0] = a11, oe2[1] = a12, oe2[2] = a13, oe2[3] = a14;
      oe2[4] = a21, oe2[5] = a22, oe2[6] = a23, oe2[7] = a24;
      oe2[8] = a31, oe2[9] = a32, oe2[10] = a33, oe2[11] = a34;
      oe2[12] = a11 * x + a21 * y + a31 * z2 + me[12];
      oe2[13] = a12 * x + a22 * y + a32 * z2 + me[13];
      oe2[14] = a13 * x + a23 * y + a33 * z2 + me[14];
      oe2[15] = a14 * x + a24 * y + a34 * z2 + me[15];
    }
  };
  Matrix2.transpose = function transpose(a, out) {
    var ae2 = a.elements;
    var oe2 = out.elements;
    if (out === a) {
      var a12 = ae2[1];
      var a13 = ae2[2];
      var a14 = ae2[3];
      var a23 = ae2[6];
      var a24 = ae2[7];
      var a34 = ae2[11];
      oe2[1] = ae2[4];
      oe2[2] = ae2[8];
      oe2[3] = ae2[12];
      oe2[4] = a12;
      oe2[6] = ae2[9];
      oe2[7] = ae2[13];
      oe2[8] = a13;
      oe2[9] = a23;
      oe2[11] = ae2[14];
      oe2[12] = a14;
      oe2[13] = a24;
      oe2[14] = a34;
    } else {
      oe2[0] = ae2[0];
      oe2[1] = ae2[4];
      oe2[2] = ae2[8];
      oe2[3] = ae2[12];
      oe2[4] = ae2[1];
      oe2[5] = ae2[5];
      oe2[6] = ae2[9];
      oe2[7] = ae2[13];
      oe2[8] = ae2[2];
      oe2[9] = ae2[6];
      oe2[10] = ae2[10];
      oe2[11] = ae2[14];
      oe2[12] = ae2[3];
      oe2[13] = ae2[7];
      oe2[14] = ae2[11];
      oe2[15] = ae2[15];
    }
  };
  return Matrix2;
}();
(function() {
  Matrix._tempVec30 = new Vector3();
})();
(function() {
  Matrix._tempVec31 = new Vector3();
})();
(function() {
  Matrix._tempVec32 = new Vector3();
})();
(function() {
  Matrix._tempMat30 = new Matrix3x3();
})();
(function() {
  Matrix._identity = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
})();
var Ray = /* @__PURE__ */ function() {
  function Ray2(origin, direction) {
    if (origin === void 0)
      origin = null;
    if (direction === void 0)
      direction = null;
    this.origin = new Vector3();
    this.direction = new Vector3();
    origin && this.origin.copyFrom(origin);
    direction && this.direction.copyFrom(direction);
  }
  var _proto = Ray2.prototype;
  _proto.intersectPlane = function intersectPlane(plane) {
    return CollisionUtil.intersectsRayAndPlane(this, plane);
  };
  _proto.intersectSphere = function intersectSphere(sphere) {
    return CollisionUtil.intersectsRayAndSphere(this, sphere);
  };
  _proto.intersectBox = function intersectBox(box) {
    return CollisionUtil.intersectsRayAndBox(this, box);
  };
  _proto.getPoint = function getPoint(distance, out) {
    Vector3.scale(this.direction, distance, out);
    return out.add(this.origin);
  };
  return Ray2;
}();
var Vector2 = /* @__PURE__ */ function() {
  function Vector22(x, y) {
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    this._onValueChanged = null;
    this._x = x;
    this._y = y;
  }
  var _proto = Vector22.prototype;
  _proto.set = function set(x, y) {
    this._x = x;
    this._y = y;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.add = function add2(right) {
    this._x += right._x;
    this._y += right._y;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.subtract = function subtract(right) {
    this._x -= right._x;
    this._y -= right._y;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.multiply = function multiply(right) {
    this._x *= right._x;
    this._y *= right._y;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.divide = function divide(right) {
    this._x /= right._x;
    this._y /= right._y;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.length = function length2() {
    var _this = this, _x = _this._x, _y = _this._y;
    return Math.sqrt(_x * _x + _y * _y);
  };
  _proto.lengthSquared = function lengthSquared() {
    var _this = this, _x = _this._x, _y = _this._y;
    return _x * _x + _y * _y;
  };
  _proto.negate = function negate() {
    this._x = -this._x;
    this._y = -this._y;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.normalize = function normalize() {
    Vector22.normalize(this, this);
    return this;
  };
  _proto.scale = function scale(s) {
    this._x *= s;
    this._y *= s;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.clone = function clone() {
    return new Vector22(this._x, this._y);
  };
  _proto.copyFrom = function copyFrom(source) {
    this._x = source.x;
    this._y = source.y;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.copyFromArray = function copyFromArray(array, offset) {
    if (offset === void 0)
      offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.copyToArray = function copyToArray(out, outOffset) {
    if (outOffset === void 0)
      outOffset = 0;
    out[outOffset] = this._x;
    out[outOffset + 1] = this._y;
  };
  _proto.toJSON = function toJSON() {
    return {
      x: this._x,
      y: this._y
    };
  };
  Vector22.add = function add2(left, right, out) {
    out._x = left._x + right._x;
    out._y = left._y + right._y;
    out._onValueChanged && out._onValueChanged();
  };
  Vector22.subtract = function subtract(left, right, out) {
    out._x = left._x - right._x;
    out._y = left._y - right._y;
    out._onValueChanged && out._onValueChanged();
  };
  Vector22.multiply = function multiply(left, right, out) {
    out._x = left._x * right._x;
    out._y = left._y * right._y;
    out._onValueChanged && out._onValueChanged();
  };
  Vector22.divide = function divide(left, right, out) {
    out._x = left._x / right._x;
    out._y = left._y / right._y;
    out._onValueChanged && out._onValueChanged();
  };
  Vector22.dot = function dot(left, right) {
    return left._x * right._x + left._y * right._y;
  };
  Vector22.distance = function distance(left, right) {
    var x = right._x - left._x;
    var y = right._y - left._y;
    return Math.sqrt(x * x + y * y);
  };
  Vector22.distanceSquared = function distanceSquared(left, right) {
    var x = right._x - left._x;
    var y = right._y - left._y;
    return x * x + y * y;
  };
  Vector22.equals = function equals(left, right) {
    return MathUtil$1.equals(left._x, right._x) && MathUtil$1.equals(left._y, right._y);
  };
  Vector22.lerp = function lerp(left, right, t, out) {
    var _x = left._x, _y = left._y;
    out._x = _x + (right._x - _x) * t;
    out._y = _y + (right._y - _y) * t;
    out._onValueChanged && out._onValueChanged();
  };
  Vector22.max = function max(left, right, out) {
    out._x = Math.max(left._x, right._x);
    out._y = Math.max(left._y, right._y);
    out._onValueChanged && out._onValueChanged();
  };
  Vector22.min = function min(left, right, out) {
    out._x = Math.min(left._x, right._x);
    out._y = Math.min(left._y, right._y);
    out._onValueChanged && out._onValueChanged();
  };
  Vector22.negate = function negate(left, out) {
    out._x = -left._x;
    out._y = -left._y;
    out._onValueChanged && out._onValueChanged();
  };
  Vector22.normalize = function normalize(left, out) {
    var _x = left._x, _y = left._y;
    var len = Math.sqrt(_x * _x + _y * _y);
    if (len > MathUtil$1.zeroTolerance) {
      len = 1 / len;
      out._x = _x * len;
      out._y = _y * len;
      out._onValueChanged && out._onValueChanged();
    }
  };
  Vector22.scale = function scale(left, s, out) {
    out._x = left._x * s;
    out._y = left._y * s;
    out._onValueChanged && out._onValueChanged();
  };
  _create_class$5(Vector22, [
    {
      key: "x",
      get: function get3() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "y",
      get: function get3() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onValueChanged && this._onValueChanged();
      }
    }
  ]);
  return Vector22;
}();
(function() {
  Vector2._zero = new Vector2(0, 0);
})();
(function() {
  Vector2._one = new Vector2(1, 1);
})();
var Vector4 = /* @__PURE__ */ function() {
  function Vector42(x, y, z2, w) {
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    if (z2 === void 0)
      z2 = 0;
    if (w === void 0)
      w = 0;
    this._onValueChanged = null;
    this._x = x;
    this._y = y;
    this._z = z2;
    this._w = w;
  }
  var _proto = Vector42.prototype;
  _proto.set = function set(x, y, z2, w) {
    this._x = x;
    this._y = y;
    this._z = z2;
    this._w = w;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.add = function add2(right) {
    this._x += right._x;
    this._y += right._y;
    this._z += right._z;
    this._w += right._w;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.subtract = function subtract(right) {
    this._x -= right._x;
    this._y -= right._y;
    this._z -= right._z;
    this._w -= right._w;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.multiply = function multiply(right) {
    this._x *= right._x;
    this._y *= right._y;
    this._z *= right._z;
    this._w *= right._w;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.divide = function divide(right) {
    this._x /= right._x;
    this._y /= right._y;
    this._z /= right._z;
    this._w /= right._w;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.length = function length2() {
    var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
    return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
  };
  _proto.lengthSquared = function lengthSquared() {
    var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
    return _x * _x + _y * _y + _z * _z + _w * _w;
  };
  _proto.negate = function negate() {
    this._x = -this._x;
    this._y = -this._y;
    this._z = -this._z;
    this._w = -this._w;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.normalize = function normalize() {
    Vector42.normalize(this, this);
    return this;
  };
  _proto.scale = function scale(s) {
    this._x *= s;
    this._y *= s;
    this._z *= s;
    this._w *= s;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.clone = function clone() {
    var ret = new Vector42(this._x, this._y, this._z, this._w);
    return ret;
  };
  _proto.copyFrom = function copyFrom(source) {
    this._x = source.x;
    this._y = source.y;
    this._z = source.z;
    this._w = source.w;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.copyFromArray = function copyFromArray(array, offset) {
    if (offset === void 0)
      offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.copyToArray = function copyToArray(out, outOffset) {
    if (outOffset === void 0)
      outOffset = 0;
    out[outOffset] = this._x;
    out[outOffset + 1] = this._y;
    out[outOffset + 2] = this._z;
    out[outOffset + 3] = this._w;
  };
  _proto.toJSON = function toJSON() {
    return {
      x: this._x,
      y: this._y,
      z: this._z,
      w: this._w
    };
  };
  Vector42.add = function add2(left, right, out) {
    out._x = left._x + right._x;
    out._y = left._y + right._y;
    out._z = left._z + right._z;
    out._w = left._w + right._w;
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.subtract = function subtract(left, right, out) {
    out._x = left._x - right._x;
    out._y = left._y - right._y;
    out._z = left._z - right._z;
    out._w = left._w - right._w;
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.multiply = function multiply(left, right, out) {
    out._x = left._x * right._x;
    out._y = left._y * right._y;
    out._z = left._z * right._z;
    out._w = left._w * right._w;
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.divide = function divide(left, right, out) {
    out._x = left._x / right._x;
    out._y = left._y / right._y;
    out._z = left._z / right._z;
    out._w = left._w / right._w;
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.dot = function dot(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
  };
  Vector42.distance = function distance(a, b) {
    var x = b._x - a._x;
    var y = b._y - a._y;
    var z2 = b._z - a._z;
    var w = b._w - a._w;
    return Math.sqrt(x * x + y * y + z2 * z2 + w * w);
  };
  Vector42.distanceSquared = function distanceSquared(a, b) {
    var x = b._x - a._x;
    var y = b._y - a._y;
    var z2 = b._z - a._z;
    var w = b._w - a._w;
    return x * x + y * y + z2 * z2 + w * w;
  };
  Vector42.equals = function equals(left, right) {
    return MathUtil$1.equals(left._x, right._x) && MathUtil$1.equals(left._y, right._y) && MathUtil$1.equals(left._z, right._z) && MathUtil$1.equals(left._w, right._w);
  };
  Vector42.lerp = function lerp(start, end, t, out) {
    var _x = start._x, _y = start._y, _z = start._z, _w = start._w;
    out._x = _x + (end._x - _x) * t;
    out._y = _y + (end._y - _y) * t;
    out._z = _z + (end._z - _z) * t;
    out._w = _w + (end._w - _w) * t;
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.max = function max(left, right, out) {
    out._x = Math.max(left._x, right._x);
    out._y = Math.max(left._y, right._y);
    out._z = Math.max(left._z, right._z);
    out._w = Math.max(left._w, right._w);
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.min = function min(left, right, out) {
    out._x = Math.min(left._x, right._x);
    out._y = Math.min(left._y, right._y);
    out._z = Math.min(left._z, right._z);
    out._w = Math.min(left._w, right._w);
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.negate = function negate(a, out) {
    out._x = -a._x;
    out._y = -a._y;
    out._z = -a._z;
    out._w = -a._w;
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.normalize = function normalize(a, out) {
    var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
    var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    if (len > MathUtil$1.zeroTolerance) {
      len = 1 / len;
      out._x = _x * len;
      out._y = _y * len;
      out._z = _z * len;
      out._w = _w * len;
      out._onValueChanged && out._onValueChanged();
    }
  };
  Vector42.scale = function scale(a, s, out) {
    out._x = a._x * s;
    out._y = a._y * s;
    out._z = a._z * s;
    out._w = a._w * s;
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.transform = function transform(v, m, out) {
    var _x = v._x, _y = v._y, _z = v._z, _w = v._w;
    var e = m.elements;
    out._x = _x * e[0] + _y * e[4] + _z * e[8] + _w * e[12];
    out._y = _x * e[1] + _y * e[5] + _z * e[9] + _w * e[13];
    out._z = _x * e[2] + _y * e[6] + _z * e[10] + _w * e[14];
    out._w = _x * e[3] + _y * e[7] + _z * e[11] + _w * e[15];
    out._onValueChanged && out._onValueChanged();
  };
  Vector42.transformByQuat = function transformByQuat(v, q2, out) {
    var x = v._x, y = v._y, z2 = v._z, w = v._w;
    var qx = q2._x;
    var qy = q2._y;
    var qz = q2._z;
    var qw = q2._w;
    var ix = qw * x + qy * z2 - qz * y;
    var iy = qw * y + qz * x - qx * z2;
    var iz = qw * z2 + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z2;
    out._x = ix * qw - iw * qx - iy * qz + iz * qy;
    out._y = iy * qw - iw * qy - iz * qx + ix * qz;
    out._z = iz * qw - iw * qz - ix * qy + iy * qx;
    out._w = w;
    out._onValueChanged && out._onValueChanged();
  };
  _create_class$5(Vector42, [
    {
      key: "x",
      get: function get3() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "y",
      get: function get3() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "z",
      get: function get3() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "w",
      get: function get3() {
        return this._w;
      },
      set: function set(value) {
        this._w = value;
        this._onValueChanged && this._onValueChanged();
      }
    }
  ]);
  return Vector42;
}();
(function() {
  Vector4._zero = new Vector4(0, 0, 0, 0);
})();
(function() {
  Vector4._one = new Vector4(1, 1, 1, 1);
})();
var Color$1 = /* @__PURE__ */ function() {
  function Color2(r, g, b, a) {
    if (r === void 0)
      r = 1;
    if (g === void 0)
      g = 1;
    if (b === void 0)
      b = 1;
    if (a === void 0)
      a = 1;
    this._onValueChanged = null;
    this._r = r;
    this._g = g;
    this._b = b;
    this._a = a;
  }
  var _proto = Color2.prototype;
  _proto.set = function set(r, g, b, a) {
    this._r = r;
    this._g = g;
    this._b = b;
    this._a = a;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.add = function add2(color) {
    this._r += color._r;
    this._g += color._g;
    this._b += color._b;
    this._a += color._a;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.scale = function scale(s) {
    this._r *= s;
    this._g *= s;
    this._b *= s;
    this._a *= s;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.clone = function clone() {
    var ret = new Color2(this._r, this._g, this._b, this._a);
    return ret;
  };
  _proto.copyFrom = function copyFrom(source) {
    this._r = source.r;
    this._g = source.g;
    this._b = source.b;
    this._a = source.a;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.toLinear = function toLinear(out) {
    out._r = Color2.gammaToLinearSpace(this._r);
    out._g = Color2.gammaToLinearSpace(this._g);
    out._b = Color2.gammaToLinearSpace(this._b);
    this._onValueChanged && this._onValueChanged();
    return out;
  };
  _proto.toGamma = function toGamma(out) {
    out._r = Color2.linearToGammaSpace(this._r);
    out._g = Color2.linearToGammaSpace(this._g);
    out._b = Color2.linearToGammaSpace(this._b);
    this._onValueChanged && this._onValueChanged();
    return out;
  };
  _proto.getBrightness = function getBrightness() {
    var r = this.r;
    var g = this.g;
    var b = this.b;
    var max = r;
    var min = r;
    if (g > max)
      max = g;
    if (b > max)
      max = b;
    if (g < min)
      min = g;
    if (b < min)
      min = b;
    return (max + min) / 2;
  };
  _proto.toJSON = function toJSON() {
    return {
      r: this._r,
      g: this._g,
      b: this._b,
      a: this._a
    };
  };
  Color2.gammaToLinearSpace = function gammaToLinearSpace(value) {
    if (value <= 0)
      return 0;
    else if (value <= 0.04045)
      return value / 12.92;
    else if (value < 1)
      return Math.pow((value + 0.055) / 1.055, 2.4);
    else
      return Math.pow(value, 2.4);
  };
  Color2.linearToGammaSpace = function linearToGammaSpace(value) {
    if (value <= 0)
      return 0;
    else if (value < 31308e-7)
      return 12.92 * value;
    else if (value < 1)
      return 1.055 * Math.pow(value, 0.41666) - 0.055;
    else
      return Math.pow(value, 0.41666);
  };
  Color2.equals = function equals(left, right) {
    return MathUtil$1.equals(left._r, right._r) && MathUtil$1.equals(left._g, right._g) && MathUtil$1.equals(left._b, right._b) && MathUtil$1.equals(left._a, right._a);
  };
  Color2.add = function add2(left, right, out) {
    out._r = left._r + right._r;
    out._g = left._g + right._g;
    out._b = left._b + right._b;
    out._a = left._a + right._a;
    out._onValueChanged && out._onValueChanged();
    return out;
  };
  Color2.subtract = function subtract(left, right, out) {
    out._r = left._r - right._r;
    out._g = left._g - right._g;
    out._b = left._b - right._b;
    out._a = left._a - right._a;
    out._onValueChanged && out._onValueChanged();
  };
  Color2.scale = function scale(left, s, out) {
    out._r = left._r * s;
    out._g = left._g * s;
    out._b = left._b * s;
    out._a = left._a * s;
    out._onValueChanged && out._onValueChanged();
    return out;
  };
  Color2.lerp = function lerp(start, end, t, out) {
    var _r = start._r, _g = start._g, _b = start._b, _a = start._a;
    out._r = _r + (end._r - _r) * t;
    out._g = _g + (end._g - _g) * t;
    out._b = _b + (end._b - _b) * t;
    out._a = _a + (end._a - _a) * t;
    out._onValueChanged && out._onValueChanged();
    return out;
  };
  _create_class$5(Color2, [
    {
      key: "r",
      get: function get3() {
        return this._r;
      },
      set: function set(value) {
        this._r = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "g",
      get: function get3() {
        return this._g;
      },
      set: function set(value) {
        this._g = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "b",
      get: function get3() {
        return this._b;
      },
      set: function set(value) {
        this._b = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "a",
      get: function get3() {
        return this._a;
      },
      set: function set(value) {
        this._a = value;
        this._onValueChanged && this._onValueChanged();
      }
    }
  ]);
  return Color2;
}();
var Rect = /* @__PURE__ */ function() {
  function Rect2(x, y, width, height) {
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    if (width === void 0)
      width = 0;
    if (height === void 0)
      height = 0;
    this._onValueChanged = null;
    this._x = x;
    this._y = y;
    this._width = width;
    this._height = height;
  }
  var _proto = Rect2.prototype;
  _proto.set = function set(x, y, width, height) {
    this._x = x;
    this._y = y;
    this._width = width;
    this._height = height;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.clone = function clone() {
    return new Rect2(this.x, this.y, this.width, this.height);
  };
  _proto.copyFrom = function copyFrom(source) {
    this._x = source.x;
    this._y = source.y;
    this._width = source.width;
    this._height = source.height;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _create_class$5(Rect2, [
    {
      key: "x",
      get: function get3() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "y",
      get: function get3() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "width",
      get: function get3() {
        return this._width;
      },
      set: function set(value) {
        this._width = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "height",
      get: function get3() {
        return this._height;
      },
      set: function set(value) {
        this._height = value;
        this._onValueChanged && this._onValueChanged();
      }
    }
  ]);
  return Rect2;
}();
var SphericalHarmonics3 = /* @__PURE__ */ function() {
  function SphericalHarmonics32() {
    this.coefficients = new Float32Array(27);
  }
  var _proto = SphericalHarmonics32.prototype;
  _proto.addLight = function addLight(direction, color, deltaSolidAngle) {
    color.scale(deltaSolidAngle);
    var coe = this.coefficients;
    var x = direction._x, y = direction._y, z2 = direction._z;
    var r = color.r, g = color.g, b = color.b;
    var bv0 = 0.282095;
    var bv1 = -0.488603 * y;
    var bv2 = 0.488603 * z2;
    var bv3 = -0.488603 * x;
    var bv4 = 1.092548 * (x * y);
    var bv5 = -1.092548 * (y * z2);
    var bv6 = 0.315392 * (3 * z2 * z2 - 1);
    var bv7 = -1.092548 * (x * z2);
    var bv8 = 0.546274 * (x * x - y * y);
    coe[0] += r * bv0, coe[1] += g * bv0, coe[2] += b * bv0;
    coe[3] += r * bv1, coe[4] += g * bv1, coe[5] += b * bv1;
    coe[6] += r * bv2, coe[7] += g * bv2, coe[8] += b * bv2;
    coe[9] += r * bv3, coe[10] += g * bv3, coe[11] += b * bv3;
    coe[12] += r * bv4, coe[13] += g * bv4, coe[14] += b * bv4;
    coe[15] += r * bv5, coe[16] += g * bv5, coe[17] += b * bv5;
    coe[18] += r * bv6, coe[19] += g * bv6, coe[20] += b * bv6;
    coe[21] += r * bv7, coe[22] += g * bv7, coe[23] += b * bv7;
    coe[24] += r * bv8, coe[25] += g * bv8, coe[26] += b * bv8;
  };
  _proto.evaluate = function evaluate(direction, out) {
    var coe = this.coefficients;
    var x = direction._x, y = direction._y, z2 = direction._z;
    var bv0 = 0.886227;
    var bv1 = -1.023327 * y;
    var bv2 = 1.023327 * z2;
    var bv3 = -1.023327 * x;
    var bv4 = 0.858086 * y * x;
    var bv5 = -0.858086 * y * z2;
    var bv6 = 0.247708 * (3 * z2 * z2 - 1);
    var bv7 = -0.858086 * z2 * x;
    var bv8 = 0.429042 * (x * x - y * y);
    var r = coe[0] * bv0;
    var g = coe[1] * bv0;
    var b = coe[2] * bv0;
    r += coe[3] * bv1 + coe[6] * bv2 + coe[9] * bv3;
    g += coe[4] * bv1 + coe[7] * bv2 + coe[10] * bv3;
    b += coe[5] * bv1 + coe[8] * bv2 + coe[11] * bv3;
    r += coe[12] * bv4 + coe[15] * bv5 + coe[18] * bv6 + coe[21] * bv7 + coe[24] * bv8;
    g += coe[13] * bv4 + coe[16] * bv5 + coe[19] * bv6 + coe[22] * bv7 + coe[25] * bv8;
    b += coe[14] * bv4 + coe[17] * bv5 + coe[20] * bv6 + coe[23] * bv7 + coe[26] * bv8;
    out.set(r, g, b, 1);
    return out;
  };
  _proto.scale = function scale(s) {
    var src = this.coefficients;
    src[0] *= s, src[1] *= s, src[2] *= s;
    src[3] *= s, src[4] *= s, src[5] *= s;
    src[6] *= s, src[7] *= s, src[8] *= s;
    src[9] *= s, src[10] *= s, src[11] *= s;
    src[12] *= s, src[13] *= s, src[14] *= s;
    src[15] *= s, src[16] *= s, src[17] *= s;
    src[18] *= s, src[19] *= s, src[20] *= s;
    src[21] *= s, src[22] *= s, src[23] *= s;
    src[24] *= s, src[25] *= s, src[26] *= s;
  };
  _proto.clone = function clone() {
    var sh = new SphericalHarmonics32();
    sh.copyFrom(this);
    return sh;
  };
  _proto.copyFrom = function copyFrom(source) {
    source.copyToArray(this.coefficients);
    return this;
  };
  _proto.copyFromArray = function copyFromArray(array, offset) {
    if (offset === void 0)
      offset = 0;
    var s = this.coefficients;
    s[0] = array[offset], s[1] = array[1 + offset], s[2] = array[2 + offset];
    s[3] = array[3 + offset], s[4] = array[4 + offset], s[5] = array[5 + offset];
    s[6] = array[6 + offset], s[7] = array[7 + offset], s[8] = array[8 + offset];
    s[9] = array[9 + offset], s[10] = array[10 + offset], s[11] = array[11 + offset];
    s[12] = array[12 + offset], s[13] = array[13 + offset], s[14] = array[14 + offset];
    s[15] = array[15 + offset], s[16] = array[16 + offset], s[17] = array[17 + offset];
    s[18] = array[18 + offset], s[19] = array[19 + offset], s[20] = array[20 + offset];
    s[21] = array[21 + offset], s[22] = array[22 + offset], s[23] = array[23 + offset];
    s[24] = array[24 + offset], s[25] = array[25 + offset], s[26] = array[26 + offset];
  };
  _proto.copyToArray = function copyToArray(out, outOffset) {
    if (outOffset === void 0)
      outOffset = 0;
    var s = this.coefficients;
    out[0 + outOffset] = s[0], out[1 + outOffset] = s[1], out[2 + outOffset] = s[2];
    out[3 + outOffset] = s[3], out[4 + outOffset] = s[4], out[5 + outOffset] = s[5];
    out[6 + outOffset] = s[6], out[7 + outOffset] = s[7], out[8 + outOffset] = s[8];
    out[9 + outOffset] = s[9], out[10 + outOffset] = s[10], out[11 + outOffset] = s[11];
    out[12 + outOffset] = s[12], out[13 + outOffset] = s[13], out[14 + outOffset] = s[14];
    out[15 + outOffset] = s[15], out[16 + outOffset] = s[16], out[17 + outOffset] = s[17];
    out[18 + outOffset] = s[18], out[19 + outOffset] = s[19], out[20 + outOffset] = s[20];
    out[21 + outOffset] = s[21], out[22 + outOffset] = s[22], out[23 + outOffset] = s[23];
    out[24 + outOffset] = s[24], out[25 + outOffset] = s[25], out[26 + outOffset] = s[26];
  };
  return SphericalHarmonics32;
}();
var Platform;
(function(Platform2) {
  Platform2[Platform2["Android"] = 0] = "Android";
  Platform2[Platform2["IPhone"] = 1] = "IPhone";
  Platform2[Platform2["IPad"] = 2] = "IPad";
  Platform2[Platform2["Mac"] = 3] = "Mac";
  Platform2[Platform2["Unknown"] = 4] = "Unknown";
})(Platform || (Platform = {}));
function _assert_this_initialized(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
function _set_prototype_of$2(o, p) {
  _set_prototype_of$2 = Object.setPrototypeOf || function setPrototypeOf(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _set_prototype_of$2(o, p);
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _set_prototype_of$2(subClass, superClass);
}
var MathUtil = /* @__PURE__ */ function() {
  function MathUtil2() {
  }
  MathUtil2.clamp = function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  };
  MathUtil2.equals = function equals(a, b) {
    return Math.abs(a - b) <= MathUtil2.zeroTolerance;
  };
  MathUtil2.isPowerOf2 = function isPowerOf2(v) {
    return (v & v - 1) === 0;
  };
  MathUtil2.radianToDegree = function radianToDegree(r) {
    return r * MathUtil2.radToDegreeFactor;
  };
  MathUtil2.degreeToRadian = function degreeToRadian(d) {
    return d * MathUtil2.degreeToRadFactor;
  };
  return MathUtil2;
}();
(function() {
  MathUtil.zeroTolerance = 1e-6;
})();
(function() {
  MathUtil.radToDegreeFactor = 180 / Math.PI;
})();
(function() {
  MathUtil.degreeToRadFactor = Math.PI / 180;
})();
var Color = /* @__PURE__ */ function() {
  function Color2(r, g, b, a) {
    if (r === void 0)
      r = 1;
    if (g === void 0)
      g = 1;
    if (b === void 0)
      b = 1;
    if (a === void 0)
      a = 1;
    this._onValueChanged = null;
    this._r = r;
    this._g = g;
    this._b = b;
    this._a = a;
  }
  var _proto = Color2.prototype;
  _proto.set = function set(r, g, b, a) {
    this._r = r;
    this._g = g;
    this._b = b;
    this._a = a;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.add = function add2(color) {
    this._r += color._r;
    this._g += color._g;
    this._b += color._b;
    this._a += color._a;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.scale = function scale(s) {
    this._r *= s;
    this._g *= s;
    this._b *= s;
    this._a *= s;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.clone = function clone() {
    var ret = new Color2(this._r, this._g, this._b, this._a);
    return ret;
  };
  _proto.copyFrom = function copyFrom(source) {
    this._r = source.r;
    this._g = source.g;
    this._b = source.b;
    this._a = source.a;
    this._onValueChanged && this._onValueChanged();
    return this;
  };
  _proto.toLinear = function toLinear(out) {
    out._r = Color2.gammaToLinearSpace(this._r);
    out._g = Color2.gammaToLinearSpace(this._g);
    out._b = Color2.gammaToLinearSpace(this._b);
    this._onValueChanged && this._onValueChanged();
    return out;
  };
  _proto.toGamma = function toGamma(out) {
    out._r = Color2.linearToGammaSpace(this._r);
    out._g = Color2.linearToGammaSpace(this._g);
    out._b = Color2.linearToGammaSpace(this._b);
    this._onValueChanged && this._onValueChanged();
    return out;
  };
  _proto.getBrightness = function getBrightness() {
    var r = this.r;
    var g = this.g;
    var b = this.b;
    var max = r;
    var min = r;
    if (g > max)
      max = g;
    if (b > max)
      max = b;
    if (g < min)
      min = g;
    if (b < min)
      min = b;
    return (max + min) / 2;
  };
  _proto.toJSON = function toJSON() {
    return {
      r: this._r,
      g: this._g,
      b: this._b,
      a: this._a
    };
  };
  Color2.gammaToLinearSpace = function gammaToLinearSpace(value) {
    if (value <= 0)
      return 0;
    else if (value <= 0.04045)
      return value / 12.92;
    else if (value < 1)
      return Math.pow((value + 0.055) / 1.055, 2.4);
    else
      return Math.pow(value, 2.4);
  };
  Color2.linearToGammaSpace = function linearToGammaSpace(value) {
    if (value <= 0)
      return 0;
    else if (value < 31308e-7)
      return 12.92 * value;
    else if (value < 1)
      return 1.055 * Math.pow(value, 0.41666) - 0.055;
    else
      return Math.pow(value, 0.41666);
  };
  Color2.equals = function equals(left, right) {
    return MathUtil.equals(left._r, right._r) && MathUtil.equals(left._g, right._g) && MathUtil.equals(left._b, right._b) && MathUtil.equals(left._a, right._a);
  };
  Color2.add = function add2(left, right, out) {
    out._r = left._r + right._r;
    out._g = left._g + right._g;
    out._b = left._b + right._b;
    out._a = left._a + right._a;
    out._onValueChanged && out._onValueChanged();
    return out;
  };
  Color2.subtract = function subtract(left, right, out) {
    out._r = left._r - right._r;
    out._g = left._g - right._g;
    out._b = left._b - right._b;
    out._a = left._a - right._a;
    out._onValueChanged && out._onValueChanged();
  };
  Color2.scale = function scale(left, s, out) {
    out._r = left._r * s;
    out._g = left._g * s;
    out._b = left._b * s;
    out._a = left._a * s;
    out._onValueChanged && out._onValueChanged();
    return out;
  };
  Color2.lerp = function lerp(start, end, t, out) {
    var _r = start._r, _g = start._g, _b = start._b, _a = start._a;
    out._r = _r + (end._r - _r) * t;
    out._g = _g + (end._g - _g) * t;
    out._b = _b + (end._b - _b) * t;
    out._a = _a + (end._a - _a) * t;
    out._onValueChanged && out._onValueChanged();
    return out;
  };
  _create_class$4(Color2, [
    {
      key: "r",
      get: function get3() {
        return this._r;
      },
      set: function set(value) {
        this._r = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "g",
      get: function get3() {
        return this._g;
      },
      set: function set(value) {
        this._g = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "b",
      get: function get3() {
        return this._b;
      },
      set: function set(value) {
        this._b = value;
        this._onValueChanged && this._onValueChanged();
      }
    },
    {
      key: "a",
      get: function get3() {
        return this._a;
      },
      set: function set(value) {
        this._a = value;
        this._onValueChanged && this._onValueChanged();
      }
    }
  ]);
  return Color2;
}();
function __decorate$2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function _instanceof$2(left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return !!right[Symbol.hasInstance](left);
  } else
    return left instanceof right;
}
var CloneMode;
(function(CloneMode2) {
  CloneMode2[CloneMode2["Ignore"] = 0] = "Ignore";
  CloneMode2[CloneMode2["Assignment"] = 1] = "Assignment";
  CloneMode2[CloneMode2["Shallow"] = 2] = "Shallow";
  CloneMode2[CloneMode2["Deep"] = 3] = "Deep";
})(CloneMode || (CloneMode = {}));
function ignoreClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
}
function assignmentClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Assignment);
}
function shallowClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
}
function deepClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
}
var CloneManager = /* @__PURE__ */ function() {
  function CloneManager2() {
  }
  CloneManager2.registerCloneMode = function registerCloneMode(target, propertyKey, mode) {
    var targetMap = CloneManager2._subCloneModeMap.get(target.constructor);
    if (!targetMap) {
      targetMap = /* @__PURE__ */ Object.create(null);
      CloneManager2._subCloneModeMap.set(target.constructor, targetMap);
    }
    targetMap[propertyKey] = mode;
  };
  CloneManager2.getCloneMode = function getCloneMode(type) {
    var cloneModes = CloneManager2._cloneModeMap.get(type);
    if (!cloneModes) {
      cloneModes = /* @__PURE__ */ Object.create(null);
      CloneManager2._cloneModeMap.set(type, cloneModes);
      var objectType = CloneManager2._objectType;
      var cloneModeMap = CloneManager2._subCloneModeMap;
      while (type !== objectType) {
        var subCloneModes = cloneModeMap.get(type);
        if (subCloneModes) {
          Object.assign(cloneModes, subCloneModes);
        }
        type = Object.getPrototypeOf(type);
      }
    }
    return cloneModes;
  };
  CloneManager2.deepCloneObject = function deepCloneObject(source, target) {
    var type = source.constructor;
    switch (type) {
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case Float32Array:
      case Float64Array:
        target.set(source);
        break;
      case Array:
        for (var i = 0, n = source.length; i < n; i++) {
          CloneManager2._deepCloneObjectItem(source, target, i);
        }
        break;
      default:
        var customSource = source;
        if (customSource.clone && customSource.cloneTo) {
          customSource.cloneTo(target);
        } else {
          var keys = Object.keys(source);
          for (var i1 = 0, n1 = keys.length; i1 < n1; i1++) {
            CloneManager2._deepCloneObjectItem(source, target, keys[i1]);
          }
        }
    }
  };
  CloneManager2._deepCloneObjectItem = function _deepCloneObjectItem(source, target, k2) {
    var sourceItem = source[k2];
    if (_instanceof$2(sourceItem, Object)) {
      var itemType = sourceItem.constructor;
      switch (itemType) {
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case Float32Array:
        case Float64Array:
          var sourceTypeArrayItem = sourceItem;
          var targetTypeArrayItem = target[k2];
          if (targetTypeArrayItem == null) {
            target[k2] = sourceTypeArrayItem.slice();
          } else {
            targetTypeArrayItem.set(sourceTypeArrayItem);
          }
          break;
        case Array:
          var sourceArrayItem = sourceItem;
          var targetArrayItem = target[k2];
          if (targetArrayItem == null) {
            target[k2] = new Array(sourceArrayItem.length);
          } else {
            targetArrayItem.length = sourceArrayItem.length;
          }
          CloneManager2.deepCloneObject(sourceArrayItem, targetArrayItem);
          break;
        default:
          if (sourceItem.clone && sourceItem.cloneTo) {
            var sourceCustomItem = sourceItem;
            var targetCustomItem = target[k2];
            if (targetCustomItem) {
              sourceCustomItem.cloneTo(targetCustomItem);
            } else {
              target[k2] = sourceCustomItem.clone();
            }
          } else {
            var targetItem = target[k2];
            targetItem == null && (target[k2] = targetItem = new sourceItem.constructor());
            CloneManager2.deepCloneObject(sourceItem, targetItem);
            break;
          }
      }
    } else {
      target[k2] = sourceItem;
    }
  };
  return CloneManager2;
}();
(function() {
  CloneManager._subCloneModeMap = /* @__PURE__ */ new Map();
})();
(function() {
  CloneManager._cloneModeMap = /* @__PURE__ */ new Map();
})();
(function() {
  CloneManager._objectType = Object.getPrototypeOf(Object);
})();
var EngineObject = /* @__PURE__ */ function() {
  function EngineObject2(engine) {
    this.instanceId = ++EngineObject2._instanceIdCounter;
    this._destroyed = false;
    this._engine = engine;
  }
  var _proto = EngineObject2.prototype;
  _proto.destroy = function destroy2() {
    if (this._destroyed)
      return;
    this._onDestroy();
    this._destroyed = true;
  };
  _proto._onDestroy = function _onDestroy() {
    var resourceManager = this._engine.resourceManager;
    resourceManager._deleteAsset(this);
    resourceManager._deleteContentRestorer(this);
  };
  _create_class$4(EngineObject2, [
    {
      key: "engine",
      get: function get3() {
        return this._engine;
      }
    },
    {
      key: "destroyed",
      get: function get3() {
        return this._destroyed;
      }
    }
  ]);
  return EngineObject2;
}();
(function() {
  EngineObject._instanceIdCounter = 0;
})();
__decorate$2([
  ignoreClone
], EngineObject.prototype, "instanceId", void 0);
__decorate$2([
  ignoreClone
], EngineObject.prototype, "_engine", void 0);
var ReferResource = /* @__PURE__ */ function(EngineObject2) {
  _inherits$2(ReferResource2, EngineObject2);
  function ReferResource2(engine) {
    var _this;
    _this = EngineObject2.call(this, engine) || this;
    _this.isGCIgnored = false;
    _this._refCount = 0;
    engine.resourceManager._addReferResource(_assert_this_initialized(_this));
    return _this;
  }
  var _proto = ReferResource2.prototype;
  _proto.destroy = function destroy2(force) {
    if (force === void 0)
      force = false;
    if (!force && this._refCount !== 0) {
      return false;
    }
    EngineObject2.prototype.destroy.call(this);
    return true;
  };
  _proto._getReferCount = function _getReferCount() {
    return this._refCount;
  };
  _proto._addReferCount = function _addReferCount(value) {
    this._refCount += value;
  };
  _proto._addToResourceManager = function _addToResourceManager(path) {
    this._engine.resourceManager._addAsset(path, this);
  };
  _proto._onDestroy = function _onDestroy() {
    EngineObject2.prototype._onDestroy.call(this);
    this._engine.resourceManager._deleteReferResource(this);
    var refCount = this._getReferCount();
    if (refCount > 0) {
      this._addReferCount(-refCount);
    }
  };
  _create_class$4(ReferResource2, [
    {
      key: "refCount",
      get: function get3() {
        return this._refCount;
      }
    }
  ]);
  return ReferResource2;
}(EngineObject);
var ContentRestorer = function ContentRestorer2(resource) {
  this.resource = resource;
};
var RenderBufferDepthFormat;
(function(RenderBufferDepthFormat2) {
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth"] = 0] = "Depth";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["DepthStencil"] = 1] = "DepthStencil";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Stencil"] = 2] = "Stencil";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth16"] = 3] = "Depth16";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24"] = 4] = "Depth24";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32"] = 5] = "Depth32";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24Stencil8"] = 6] = "Depth24Stencil8";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32Stencil8"] = 7] = "Depth32Stencil8";
})(RenderBufferDepthFormat || (RenderBufferDepthFormat = {}));
var TextureCubeFace;
(function(TextureCubeFace2) {
  TextureCubeFace2[TextureCubeFace2["PositiveX"] = 0] = "PositiveX";
  TextureCubeFace2[TextureCubeFace2["NegativeX"] = 1] = "NegativeX";
  TextureCubeFace2[TextureCubeFace2["PositiveY"] = 2] = "PositiveY";
  TextureCubeFace2[TextureCubeFace2["NegativeY"] = 3] = "NegativeY";
  TextureCubeFace2[TextureCubeFace2["PositiveZ"] = 4] = "PositiveZ";
  TextureCubeFace2[TextureCubeFace2["NegativeZ"] = 5] = "NegativeZ";
})(TextureCubeFace || (TextureCubeFace = {}));
var TextureDepthCompareFunction;
(function(TextureDepthCompareFunction2) {
  TextureDepthCompareFunction2[TextureDepthCompareFunction2["Never"] = 0] = "Never";
  TextureDepthCompareFunction2[TextureDepthCompareFunction2["Less"] = 1] = "Less";
  TextureDepthCompareFunction2[TextureDepthCompareFunction2["Equal"] = 2] = "Equal";
  TextureDepthCompareFunction2[TextureDepthCompareFunction2["LessEqual"] = 3] = "LessEqual";
  TextureDepthCompareFunction2[TextureDepthCompareFunction2["Greater"] = 4] = "Greater";
  TextureDepthCompareFunction2[TextureDepthCompareFunction2["NotEqual"] = 5] = "NotEqual";
  TextureDepthCompareFunction2[TextureDepthCompareFunction2["GreaterEqual"] = 6] = "GreaterEqual";
  TextureDepthCompareFunction2[TextureDepthCompareFunction2["Always"] = 7] = "Always";
})(TextureDepthCompareFunction || (TextureDepthCompareFunction = {}));
var TextureFilterMode;
(function(TextureFilterMode2) {
  TextureFilterMode2[TextureFilterMode2["Point"] = 0] = "Point";
  TextureFilterMode2[TextureFilterMode2["Bilinear"] = 1] = "Bilinear";
  TextureFilterMode2[TextureFilterMode2["Trilinear"] = 2] = "Trilinear";
})(TextureFilterMode || (TextureFilterMode = {}));
var TextureFormat;
(function(TextureFormat2) {
  TextureFormat2[TextureFormat2["R8G8B8"] = 0] = "R8G8B8";
  TextureFormat2[TextureFormat2["R8G8B8A8"] = 1] = "R8G8B8A8";
  TextureFormat2[TextureFormat2["R4G4B4A4"] = 2] = "R4G4B4A4";
  TextureFormat2[TextureFormat2["R5G5B5A1"] = 3] = "R5G5B5A1";
  TextureFormat2[TextureFormat2["R5G6B5"] = 4] = "R5G6B5";
  TextureFormat2[TextureFormat2["Alpha8"] = 5] = "Alpha8";
  TextureFormat2[TextureFormat2["LuminanceAlpha"] = 6] = "LuminanceAlpha";
  TextureFormat2[TextureFormat2["R16G16B16A16"] = 7] = "R16G16B16A16";
  TextureFormat2[TextureFormat2["R32G32B32A32"] = 8] = "R32G32B32A32";
  TextureFormat2[TextureFormat2["DXT1"] = 9] = "DXT1";
  TextureFormat2[TextureFormat2["DXT5"] = 10] = "DXT5";
  TextureFormat2[TextureFormat2["ETC1_RGB"] = 11] = "ETC1_RGB";
  TextureFormat2[TextureFormat2["ETC2_RGB"] = 12] = "ETC2_RGB";
  TextureFormat2[TextureFormat2["ETC2_RGBA5"] = 13] = "ETC2_RGBA5";
  TextureFormat2[TextureFormat2["ETC2_RGBA8"] = 14] = "ETC2_RGBA8";
  TextureFormat2[TextureFormat2["PVRTC_RGB2"] = 15] = "PVRTC_RGB2";
  TextureFormat2[TextureFormat2["PVRTC_RGBA2"] = 16] = "PVRTC_RGBA2";
  TextureFormat2[TextureFormat2["PVRTC_RGB4"] = 17] = "PVRTC_RGB4";
  TextureFormat2[TextureFormat2["PVRTC_RGBA4"] = 18] = "PVRTC_RGBA4";
  TextureFormat2[TextureFormat2["ASTC_4x4"] = 19] = "ASTC_4x4";
  TextureFormat2[TextureFormat2["ASTC_5x5"] = 20] = "ASTC_5x5";
  TextureFormat2[TextureFormat2["ASTC_6x6"] = 21] = "ASTC_6x6";
  TextureFormat2[TextureFormat2["ASTC_8x8"] = 22] = "ASTC_8x8";
  TextureFormat2[TextureFormat2["ASTC_10x10"] = 23] = "ASTC_10x10";
  TextureFormat2[TextureFormat2["ASTC_12x12"] = 24] = "ASTC_12x12";
  TextureFormat2[TextureFormat2["Depth"] = 25] = "Depth";
  TextureFormat2[TextureFormat2["DepthStencil"] = 26] = "DepthStencil";
  TextureFormat2[TextureFormat2["Depth16"] = 27] = "Depth16";
  TextureFormat2[TextureFormat2["Depth24"] = 28] = "Depth24";
  TextureFormat2[TextureFormat2["Depth32"] = 29] = "Depth32";
  TextureFormat2[TextureFormat2["Depth24Stencil8"] = 30] = "Depth24Stencil8";
  TextureFormat2[TextureFormat2["Depth32Stencil8"] = 31] = "Depth32Stencil8";
})(TextureFormat || (TextureFormat = {}));
var TextureUsage;
(function(TextureUsage2) {
  TextureUsage2[TextureUsage2["Static"] = 0] = "Static";
  TextureUsage2[TextureUsage2["Dynamic"] = 1] = "Dynamic";
})(TextureUsage || (TextureUsage = {}));
var TextureWrapMode$1;
(function(TextureWrapMode2) {
  TextureWrapMode2[TextureWrapMode2["Clamp"] = 0] = "Clamp";
  TextureWrapMode2[TextureWrapMode2["Repeat"] = 1] = "Repeat";
  TextureWrapMode2[TextureWrapMode2["Mirror"] = 2] = "Mirror";
})(TextureWrapMode$1 || (TextureWrapMode$1 = {}));
var GraphicsResource = /* @__PURE__ */ function(ReferResource2) {
  _inherits$2(GraphicsResource2, ReferResource2);
  function GraphicsResource2(engine) {
    var _this;
    _this = ReferResource2.call(this, engine) || this;
    engine.resourceManager._addGraphicResource(_assert_this_initialized(_this));
    return _this;
  }
  var _proto = GraphicsResource2.prototype;
  _proto._onDestroy = function _onDestroy() {
    ReferResource2.prototype._onDestroy.call(this);
    this.engine.resourceManager._deleteGraphicResource(this);
  };
  return GraphicsResource2;
}(ReferResource);
var noop = function(message) {
  for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    optionalParams[_key - 1] = arguments[_key];
  }
};
var debug = console.log.bind(console);
var info = console.info.bind(console);
var warn = console.warn.bind(console);
var error = console.error.bind(console);
var Logger = {
  debug: noop,
  info: noop,
  warn: noop,
  error: noop,
  isEnabled: false,
  enable: function enable() {
    this.debug = debug;
    this.info = info;
    this.warn = warn;
    this.error = error;
    this.isEnabled = true;
  },
  disable: function disable() {
    this.debug = noop;
    this.info = noop;
    this.warn = noop;
    this.error = noop;
    this.isEnabled = false;
  }
};
var Texture = /* @__PURE__ */ function(GraphicsResource2) {
  _inherits$2(Texture2, GraphicsResource2);
  function Texture2() {
    var _this;
    _this = GraphicsResource2.apply(this, arguments) || this;
    _this._isDepthTexture = false;
    _this._anisoLevel = 1;
    _this._useDepthCompareMode = false;
    return _this;
  }
  var _proto = Texture2.prototype;
  _proto.generateMipmaps = function generateMipmaps() {
    if (!this._mipmap)
      return;
    this._platformTexture.generateMipmaps();
  };
  _proto._setUseDepthCompareMode = function _setUseDepthCompareMode(value) {
    if (this._useDepthCompareMode !== value) {
      this._platformTexture.setUseDepthCompareMode(value);
      this._useDepthCompareMode = value;
    }
  };
  _proto._rebuild = function _rebuild() {
    var platformTexture = this._platformTexture;
    platformTexture.wrapModeU = this._wrapModeU;
    platformTexture.wrapModeV = this._wrapModeV;
    platformTexture.filterMode = this._filterMode;
    platformTexture.anisoLevel = this._anisoLevel;
    platformTexture.depthCompareFunction = this._depthCompareFunction;
    platformTexture.setUseDepthCompareMode(this._useDepthCompareMode);
  };
  _proto._onDestroy = function _onDestroy() {
    GraphicsResource2.prototype._onDestroy.call(this);
    this._platformTexture.destroy();
    this._platformTexture = null;
  };
  _proto._getMaxMiplevel = function _getMaxMiplevel(size) {
    return Math.floor(Math.log2(size));
  };
  _proto._getMipmapCount = function _getMipmapCount() {
    return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
  };
  _create_class$4(Texture2, [
    {
      key: "format",
      get: function get3() {
        return this._format;
      }
    },
    {
      key: "width",
      get: function get3() {
        return this._width;
      }
    },
    {
      key: "height",
      get: function get3() {
        return this._height;
      }
    },
    {
      key: "usage",
      get: function get3() {
        return this._usage;
      }
    },
    {
      key: "wrapModeU",
      get: function get3() {
        return this._wrapModeU;
      },
      set: function set(value) {
        if (value === this._wrapModeU)
          return;
        this._wrapModeU = value;
        this._platformTexture.wrapModeU = value;
      }
    },
    {
      key: "wrapModeV",
      get: function get3() {
        return this._wrapModeV;
      },
      set: function set(value) {
        if (value === this._wrapModeV)
          return;
        this._wrapModeV = value;
        this._platformTexture.wrapModeV = value;
      }
    },
    {
      key: "mipmapCount",
      get: function get3() {
        return this._mipmapCount;
      }
    },
    {
      key: "filterMode",
      get: function get3() {
        return this._filterMode;
      },
      set: function set(value) {
        if (value === this._filterMode)
          return;
        this._filterMode = value;
        this._platformTexture.filterMode = value;
      }
    },
    {
      key: "anisoLevel",
      get: function get3() {
        return this._anisoLevel;
      },
      set: function set(value) {
        var max = this._engine._hardwareRenderer.capability.maxAnisoLevel;
        if (value > max) {
          Logger.warn("anisoLevel:" + value + ", exceeds the limit and is automatically downgraded to:" + max);
          value = max;
        }
        if (value < 1) {
          Logger.warn("anisoLevel:" + value + ", must be greater than 0, and is automatically downgraded to 1");
          value = 1;
        }
        if (value === this._anisoLevel)
          return;
        this._anisoLevel = value;
        this._platformTexture.anisoLevel = value;
      }
    },
    {
      key: "depthCompareFunction",
      get: function get3() {
        return this._depthCompareFunction;
      },
      set: function set(value) {
        if (!this._engine._hardwareRenderer._isWebGL2) {
          console.warn("depthCompareFunction only support WebGL2");
          return;
        }
        if (value !== this._depthCompareFunction) {
          this._depthCompareFunction = value;
          this._platformTexture.depthCompareFunction = value;
        }
      }
    }
  ]);
  return Texture2;
}(GraphicsResource);
var RenderTarget = /* @__PURE__ */ function(GraphicsResource2) {
  _inherits$2(RenderTarget2, GraphicsResource2);
  function RenderTarget2(engine, width, height, renderTexture, depth, antiAliasing) {
    if (depth === void 0)
      depth = RenderBufferDepthFormat.Depth;
    if (antiAliasing === void 0)
      antiAliasing = 1;
    var _this;
    _this = GraphicsResource2.call(this, engine) || this;
    _this._autoGenerateMipmaps = true;
    _this._width = width;
    _this._height = height;
    _this._antiAliasing = antiAliasing;
    _this._depth = depth;
    if (renderTexture) {
      var colorTextures = _instanceof$2(renderTexture, Array) ? renderTexture.slice() : [
        renderTexture
      ];
      for (var i = 0, n = colorTextures.length; i < n; i++) {
        var colorTexture = colorTextures[i];
        if (colorTexture._isDepthTexture) {
          throw "Render texture can't use depth format.";
        }
        colorTexture._addReferCount(1);
      }
      _this._colorTextures = colorTextures;
    } else {
      _this._colorTextures = [];
    }
    if (_instanceof$2(depth, Texture)) {
      if (!depth._isDepthTexture) {
        throw "Depth texture must use depth format.";
      }
      _this._depthTexture = depth;
      _this._depthTexture._addReferCount(1);
    }
    _this._platformRenderTarget = engine._hardwareRenderer.createPlatformRenderTarget(_assert_this_initialized(_this));
    return _this;
  }
  var _proto = RenderTarget2.prototype;
  _proto.getColorTexture = function getColorTexture(index) {
    if (index === void 0)
      index = 0;
    return this._colorTextures[index];
  };
  _proto.generateMipmaps = function generateMipmaps() {
    if (this._autoGenerateMipmaps) {
      var colorTextures = this._colorTextures;
      for (var i = 0, n = colorTextures.length; i < n; i++) {
        var colorTexture = colorTextures[i];
        colorTexture.generateMipmaps();
      }
      this._depthTexture && this._depthTexture.generateMipmaps();
    }
  };
  _proto._onDestroy = function _onDestroy() {
    var _this__depthTexture;
    GraphicsResource2.prototype._onDestroy.call(this);
    this._platformRenderTarget.destroy();
    var _this = this, colorTextures = _this._colorTextures;
    for (var i = 0, n = colorTextures.length; i < n; i++) {
      colorTextures[i]._addReferCount(-1);
    }
    colorTextures.length = 0;
    (_this__depthTexture = this._depthTexture) == null ? void 0 : _this__depthTexture._addReferCount(-1);
    this._depthTexture = null;
    this._depth = null;
  };
  _proto._setRenderTargetInfo = function _setRenderTargetInfo(faceIndex, mipLevel) {
    this._platformRenderTarget.setRenderTargetInfo(faceIndex, mipLevel);
  };
  _proto._blitRenderTarget = function _blitRenderTarget() {
    this._platformRenderTarget.blitRenderTarget();
  };
  _proto._rebuild = function _rebuild() {
    this._platformRenderTarget = this._engine._hardwareRenderer.createPlatformRenderTarget(this);
  };
  _create_class$4(RenderTarget2, [
    {
      key: "autoGenerateMipmaps",
      get: function get3() {
        return this._autoGenerateMipmaps;
      },
      set: function set(value) {
        this._autoGenerateMipmaps = value;
      }
    },
    {
      key: "width",
      get: function get3() {
        return this._width;
      }
    },
    {
      key: "height",
      get: function get3() {
        return this._height;
      }
    },
    {
      key: "colorTextureCount",
      get: function get3() {
        return this._colorTextures.length;
      }
    },
    {
      key: "depthTexture",
      get: function get3() {
        return this._depthTexture;
      }
    },
    {
      key: "antiAliasing",
      get: function get3() {
        return this._antiAliasing;
      }
    }
  ]);
  return RenderTarget2;
}(GraphicsResource);
var Texture2D = /* @__PURE__ */ function(Texture2) {
  _inherits$2(Texture2D2, Texture2);
  function Texture2D2(engine, width, height, format, mipmap, usage) {
    if (format === void 0)
      format = TextureFormat.R8G8B8A8;
    if (mipmap === void 0)
      mipmap = true;
    if (usage === void 0)
      usage = TextureUsage.Static;
    var _this;
    _this = Texture2.call(this, engine) || this;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._usage = usage;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._isDepthTexture = format == TextureFormat.Depth || format == TextureFormat.DepthStencil || format == TextureFormat.Depth16 || format == TextureFormat.Depth24 || format == TextureFormat.Depth32 || format == TextureFormat.Depth24Stencil8 || format == TextureFormat.Depth32Stencil8;
    _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2D(_assert_this_initialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode$1.Repeat;
    return _this;
  }
  var _proto = Texture2D2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0)
      mipLevel = 0;
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    this._platformTexture.setPixelBuffer(colorBuffer, mipLevel, x, y, width, height);
  };
  _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0)
      mipLevel = 0;
    if (flipY === void 0)
      flipY = false;
    if (premultiplyAlpha === void 0)
      premultiplyAlpha = false;
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    this._platformTexture.setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  };
  _proto.getPixelBuffer = function getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
    var argsLength = arguments.length;
    if (argsLength === 1) {
      this._platformTexture.getPixelBuffer(0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
    } else if (argsLength === 2) {
      this._platformTexture.getPixelBuffer(0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
    } else if (argsLength === 5) {
      this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
    } else if (argsLength === 6) {
      this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
    }
  };
  _proto._rebuild = function _rebuild() {
    this._platformTexture = this._engine._hardwareRenderer.createPlatformTexture2D(this);
    Texture2.prototype._rebuild.call(this);
  };
  return Texture2D2;
}(Texture);
var Texture2DArray = /* @__PURE__ */ function(Texture2) {
  _inherits$2(Texture2DArray2, Texture2);
  function Texture2DArray2(engine, width, height, length2, format, mipmap) {
    if (format === void 0)
      format = TextureFormat.R8G8B8A8;
    if (mipmap === void 0)
      mipmap = true;
    var _this;
    _this = Texture2.call(this, engine) || this;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._length = length2;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2DArray(_assert_this_initialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode$1.Repeat;
    return _this;
  }
  var _proto = Texture2DArray2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length2) {
    if (mipLevel === void 0)
      mipLevel = 0;
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    this._platformTexture.setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length2);
  };
  _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0)
      mipLevel = 0;
    if (flipY === void 0)
      flipY = false;
    if (premultiplyAlpha === void 0)
      premultiplyAlpha = false;
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    this._platformTexture.setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  };
  _proto.getPixelBuffer = function getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
    var argsLength = arguments.length;
    if (argsLength === 1) {
      this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
    } else if (argsLength === 2) {
      this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
    } else if (argsLength === 5) {
      this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
    } else if (argsLength === 6) {
      this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
    }
  };
  _proto._rebuild = function _rebuild() {
    this._platformTexture = this._engine._hardwareRenderer.createPlatformTexture2DArray(this);
    Texture2.prototype._rebuild.call(this);
  };
  _create_class$4(Texture2DArray2, [
    {
      key: "length",
      get: function get3() {
        return this._length;
      }
    }
  ]);
  return Texture2DArray2;
}(Texture);
var TextureCube = /* @__PURE__ */ function(Texture2) {
  _inherits$2(TextureCube2, Texture2);
  function TextureCube2(engine, size, format, mipmap) {
    if (format === void 0)
      format = TextureFormat.R8G8B8A8;
    if (mipmap === void 0)
      mipmap = true;
    var _this;
    _this = Texture2.call(this, engine) || this;
    _this._mipmap = mipmap;
    _this._width = size;
    _this._height = size;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._platformTexture = engine._hardwareRenderer.createPlatformTextureCube(_assert_this_initialized(_this));
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode$1.Clamp;
    return _this;
  }
  var _proto = TextureCube2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0)
      mipLevel = 0;
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    this._platformTexture.setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height);
  };
  _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0)
      mipLevel = 0;
    if (flipY === void 0)
      flipY = false;
    if (premultiplyAlpha === void 0)
      premultiplyAlpha = false;
    if (x === void 0)
      x = 0;
    if (y === void 0)
      y = 0;
    this._platformTexture.setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
  };
  _proto.getPixelBuffer = function getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
    var argsLength = arguments.length;
    if (argsLength === 2) {
      this._platformTexture.getPixelBuffer(face, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
    } else if (argsLength === 3) {
      this._platformTexture.getPixelBuffer(face, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
    } else if (argsLength === 6) {
      this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
    } else if (argsLength === 7) {
      this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
    }
  };
  _proto._rebuild = function _rebuild() {
    this._platformTexture = this._engine._hardwareRenderer.createPlatformTextureCube(this);
    Texture2.prototype._rebuild.call(this);
  };
  return TextureCube2;
}(Texture);
var FontAtlas = /* @__PURE__ */ function(ReferResource2) {
  _inherits$2(FontAtlas2, ReferResource2);
  function FontAtlas2(engine) {
    var _this;
    _this = ReferResource2.call(this, engine) || this;
    _this._charInfoMap = {};
    _this._space = 1;
    _this._curX = 1;
    _this._curY = 1;
    _this._nextY = 1;
    return _this;
  }
  var _proto = FontAtlas2.prototype;
  _proto.uploadCharTexture = function uploadCharTexture(charInfo) {
    var width = charInfo.w, height = charInfo.h, data = charInfo.data;
    var _this = this, space = _this._space, texture = _this.texture;
    var textureSize = texture.width;
    var offsetWidth = width + space;
    var offsetHeight = height + space;
    if (1 + offsetWidth >= textureSize || 1 + offsetHeight >= textureSize) {
      throw Error("The char fontSize is too large.");
    }
    var endX = this._curX + offsetWidth;
    if (endX >= textureSize) {
      this._curX = space;
      this._curY = this._nextY + space;
    }
    var endY = this._curY + offsetHeight;
    if (endY > this._nextY) {
      this._nextY = endY;
    }
    if (endY >= textureSize) {
      return false;
    }
    if (width > 0 && height > 0 && data) {
      charInfo.bufferOffset = new Vector2(this._curX, this._curY);
      texture.setPixelBuffer(data, 0, this._curX, this._curY, width, height);
      texture.generateMipmaps();
    }
    var textureSizeReciprocal = 1 / textureSize;
    var x = this._curX;
    var y = this._curY;
    var w = width;
    var h = height;
    var u0 = x * textureSizeReciprocal;
    var u1 = (x + w) * textureSizeReciprocal;
    var v0 = y * textureSizeReciprocal;
    var v1 = (y + h) * textureSizeReciprocal;
    charInfo.x = x;
    charInfo.y = y;
    var uvs = charInfo.uvs;
    uvs[0].set(u0, v0);
    uvs[1].set(u1, v0);
    uvs[2].set(u1, v1);
    uvs[3].set(u0, v1);
    this._curX += offsetWidth + space;
    return true;
  };
  _proto.addCharInfo = function addCharInfo(char, charInfo) {
    this._charInfoMap[char.charCodeAt(0)] = charInfo;
  };
  _proto.getCharInfo = function getCharInfo(char) {
    return this._charInfoMap[char.charCodeAt(0)];
  };
  _proto._onDestroy = function _onDestroy() {
    ReferResource2.prototype._onDestroy.call(this);
    this.texture.destroy();
    this.texture = null;
    this._charInfoMap = {};
  };
  return FontAtlas2;
}(ReferResource);
var FontStyle;
(function(FontStyle2) {
  FontStyle2[FontStyle2["None"] = 0] = "None";
  FontStyle2[FontStyle2["Bold"] = 1] = "Bold";
  FontStyle2[FontStyle2["Italic"] = 2] = "Italic";
})(FontStyle || (FontStyle = {}));
var OverflowMode;
(function(OverflowMode2) {
  OverflowMode2[OverflowMode2["Overflow"] = 0] = "Overflow";
  OverflowMode2[OverflowMode2["Truncate"] = 1] = "Truncate";
})(OverflowMode || (OverflowMode = {}));
var TextUtils = /* @__PURE__ */ function() {
  function TextUtils2() {
  }
  TextUtils2.textContext = function textContext() {
    var textContext2 = TextUtils2._textContext;
    if (!textContext2) {
      var canvas;
      try {
        canvas = new OffscreenCanvas(0, 0);
      } catch (e) {
        canvas = document.createElement("canvas");
      }
      var context = canvas.getContext("2d", {
        willReadFrequently: true
      });
      textContext2 = {
        canvas,
        context
      };
      TextUtils2._textContext = textContext2;
    }
    return textContext2;
  };
  TextUtils2.measureFont = function measureFont(fontString) {
    var fontSizeInfoCache = TextUtils2._fontSizeInfoCache;
    var info2 = fontSizeInfoCache[fontString];
    if (info2) {
      return info2;
    }
    info2 = TextUtils2._measureFontOrChar(fontString);
    fontSizeInfoCache[fontString] = info2;
    return info2;
  };
  TextUtils2.getNativeFontString = function getNativeFontString(fontName, fontSize, style) {
    var str = style & FontStyle.Bold ? "bold " : "";
    style & FontStyle.Italic && (str += "italic ");
    if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils2._genericFontFamilies.indexOf(fontName) == -1) {
      fontName = '"' + fontName + '"';
    }
    str += fontSize + "px " + fontName;
    return str;
  };
  TextUtils2.measureChar = function measureChar(char, fontString) {
    return TextUtils2._measureFontOrChar(fontString, char);
  };
  TextUtils2.measureTextWithWrap = function measureTextWithWrap(renderer) {
    var subFont = renderer._subFont;
    var fontString = subFont.nativeFontString;
    var fontSizeInfo = TextUtils2.measureFont(fontString);
    var subTexts = renderer.text.split(/(?:\r\n|\r|\n)/);
    var lines = new Array();
    var lineWidths = new Array();
    var lineMaxSizes = new Array();
    var pixelsPerUnit = Engine._pixelsPerUnit;
    var lineHeight = fontSizeInfo.size + renderer.lineSpacing * pixelsPerUnit;
    var wrapWidth = renderer.width * pixelsPerUnit;
    var textWidth = 0;
    subFont.nativeFontString = fontString;
    for (var i = 0, n = subTexts.length; i < n; i++) {
      var subText = subTexts[i];
      if (subText.length === 0) {
        this._pushLine(lines, lineWidths, lineMaxSizes, "", 0, 0, 0);
        continue;
      }
      var word = "";
      var wordWidth = 0;
      var wordMaxAscent = 0;
      var wordMaxDescent = 0;
      var line = "";
      var lineWidth = 0;
      var lineMaxAscent = 0;
      var lineMaxDescent = 0;
      var notFirstLine = false;
      for (var j2 = 0, m = subText.length; j2 < m; ++j2) {
        var char = subText[j2];
        var charInfo = TextUtils2._getCharInfo(char, fontString, subFont);
        var charCode = char.charCodeAt(0);
        var isSpace = charCode === 32;
        if (isSpace && notFirstLine && line.length === 0 && word.length === 0) {
          continue;
        }
        var unableFromWord = isSpace || charCode >= 19968 && charCode <= 40959;
        var w = charInfo.w, offsetY = charInfo.offsetY;
        var halfH = charInfo.h * 0.5;
        var ascent = halfH + offsetY;
        var descent = halfH - offsetY;
        if (unableFromWord) {
          if (word.length > 0) {
            if (lineWidth + wordWidth > wrapWidth) {
              if (lineWidth > 0) {
                this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
              }
              textWidth = Math.max(textWidth, lineWidth);
              notFirstLine = true;
              line = word;
              lineWidth = wordWidth;
              lineMaxAscent = wordMaxAscent;
              lineMaxDescent = wordMaxDescent;
            } else {
              line += word;
              lineWidth += wordWidth;
              lineMaxAscent = Math.max(lineMaxAscent, wordMaxAscent);
              lineMaxDescent = Math.max(lineMaxDescent, wordMaxDescent);
            }
            word = "";
            wordWidth = wordMaxAscent = wordMaxDescent = 0;
          }
          if (lineWidth + w > wrapWidth && lineWidth > 0) {
            this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
            textWidth = Math.max(textWidth, lineWidth);
            notFirstLine = true;
            if (isSpace) {
              line = "";
              lineWidth = lineMaxAscent = lineMaxDescent = 0;
            } else {
              line = char;
              lineWidth = charInfo.xAdvance;
              lineMaxAscent = ascent;
              lineMaxDescent = descent;
            }
          } else {
            line += char;
            lineWidth += charInfo.xAdvance;
            lineMaxAscent = Math.max(lineMaxAscent, ascent);
            lineMaxDescent = Math.max(lineMaxDescent, descent);
          }
        } else {
          if (wordWidth + charInfo.w > wrapWidth) {
            if (lineWidth > 0) {
              this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
              textWidth = Math.max(textWidth, lineWidth);
              line = "";
              lineWidth = lineMaxAscent = lineMaxDescent = 0;
            }
            if (wordWidth > 0) {
              this._pushLine(lines, lineWidths, lineMaxSizes, word, wordWidth, wordMaxAscent, wordMaxDescent);
            }
            textWidth = Math.max(textWidth, wordWidth);
            notFirstLine = true;
            word = char;
            wordWidth = charInfo.xAdvance;
            wordMaxAscent = ascent;
            wordMaxDescent = descent;
          } else {
            word += char;
            wordWidth += charInfo.xAdvance;
            wordMaxAscent = lineMaxAscent = Math.max(wordMaxAscent, ascent);
            wordMaxDescent = lineMaxDescent = Math.max(wordMaxDescent, descent);
          }
        }
      }
      if (wordWidth > 0) {
        if (lineWidth + wordWidth > wrapWidth) {
          if (lineWidth > 0) {
            this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
          }
          textWidth = Math.max(textWidth, lineWidth);
          lineWidth = 0;
          if (wordWidth > 0) {
            this._pushLine(lines, lineWidths, lineMaxSizes, word, wordWidth, wordMaxAscent, wordMaxDescent);
          }
          textWidth = Math.max(textWidth, wordWidth);
        } else {
          line += word;
          lineWidth += wordWidth;
          lineMaxAscent = Math.max(lineMaxAscent, wordMaxAscent);
          lineMaxDescent = Math.max(lineMaxDescent, wordMaxDescent);
        }
      }
      if (lineWidth > 0) {
        this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
        textWidth = Math.max(textWidth, lineWidth);
      }
    }
    var height = renderer.height * pixelsPerUnit;
    if (renderer.overflowMode === OverflowMode.Overflow) {
      height = lineHeight * lines.length;
    }
    return {
      width: textWidth,
      height,
      lines,
      lineWidths,
      lineHeight,
      lineMaxSizes
    };
  };
  TextUtils2.measureTextWithoutWrap = function measureTextWithoutWrap(renderer) {
    var subFont = renderer._subFont;
    var fontString = subFont.nativeFontString;
    var fontSizeInfo = TextUtils2.measureFont(fontString);
    var subTexts = renderer.text.split(/(?:\r\n|\r|\n)/);
    var textCount = subTexts.length;
    var lines = new Array();
    var lineWidths = new Array();
    var lineMaxSizes = new Array();
    var _pixelsPerUnit = Engine._pixelsPerUnit;
    var lineHeight = fontSizeInfo.size + renderer.lineSpacing * _pixelsPerUnit;
    var width = 0;
    subFont.nativeFontString = fontString;
    for (var i = 0; i < textCount; ++i) {
      var line = subTexts[i];
      var curWidth = 0;
      var maxAscent = 0;
      var maxDescent = 0;
      for (var j2 = 0, m = line.length; j2 < m; ++j2) {
        var charInfo = TextUtils2._getCharInfo(line[j2], fontString, subFont);
        curWidth += charInfo.xAdvance;
        var offsetY = charInfo.offsetY;
        var halfH = charInfo.h * 0.5;
        var ascent = halfH + offsetY;
        var descent = halfH - offsetY;
        maxAscent < ascent && (maxAscent = ascent);
        maxDescent < descent && (maxDescent = descent);
      }
      if (curWidth > 0) {
        this._pushLine(lines, lineWidths, lineMaxSizes, line, curWidth, maxAscent, maxDescent);
        width = Math.max(width, curWidth);
      }
    }
    var height = renderer.height * _pixelsPerUnit;
    if (renderer.overflowMode === OverflowMode.Overflow) {
      height = lineHeight * lines.length;
    }
    return {
      width,
      height,
      lines,
      lineWidths,
      lineHeight,
      lineMaxSizes
    };
  };
  TextUtils2.getNativeFontHash = function getNativeFontHash(fontName, fontSize, style) {
    var str = style & FontStyle.Bold ? "bold" : "";
    style & FontStyle.Italic && (str += "italic");
    if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils2._genericFontFamilies.indexOf(fontName) == -1) {
      fontName = "" + fontName;
    }
    str += fontSize + "px" + fontName;
    return str;
  };
  TextUtils2._measureFontOrChar = function _measureFontOrChar(fontString, char) {
    if (char === void 0)
      char = "";
    var _TextUtils_textContext = TextUtils2.textContext(), canvas = _TextUtils_textContext.canvas, context = _TextUtils_textContext.context;
    context.font = fontString;
    var measureString = char || TextUtils2._measureString;
    var width = Math.max(1, Math.round(context.measureText(measureString).width));
    var baseline = Math.ceil(context.measureText(TextUtils2._measureBaseline).width);
    var height = baseline * TextUtils2._heightMultiplier;
    baseline = TextUtils2._baselineMultiplier * baseline | 0;
    canvas.width = width;
    canvas.height = height;
    context.font = fontString;
    context.fillStyle = "#000";
    context.clearRect(0, 0, width, height);
    context.textBaseline = "middle";
    context.fillStyle = "#fff";
    context.fillText(measureString, 0, baseline);
    var colorData = context.getImageData(0, 0, width, height).data;
    var len = colorData.length;
    var top = -1;
    var bottom = -1;
    var y;
    var ascent = 0;
    var descent = 0;
    var size = 0;
    var integerW = canvas.width;
    var integerWReciprocal = 1 / integerW;
    for (var i = 0; i < len; i += 4) {
      if (colorData[i + 3] !== 0) {
        var idx = i * 0.25;
        y = ~~(idx * integerWReciprocal);
        if (top === -1) {
          top = y;
        }
        if (y > bottom) {
          bottom = y;
        }
      } else {
        colorData[i] = colorData[i + 1] = colorData[i + 2] = 255;
      }
    }
    if (top !== -1 && bottom !== -1) {
      ascent = baseline - top;
      descent = bottom - baseline + 1;
      size = ascent + descent;
    }
    var sizeInfo = {
      ascent,
      descent,
      size
    };
    if (char) {
      var data = null;
      if (size > 0) {
        var lineIntegerW = integerW * 4;
        data = new Uint8Array(colorData.buffer, top * lineIntegerW, size * lineIntegerW);
      }
      return {
        char,
        x: 0,
        y: 0,
        w: width,
        h: size,
        offsetX: 0,
        offsetY: (ascent - descent) * 0.5,
        xAdvance: width,
        uvs: [
          new Vector2(),
          new Vector2(),
          new Vector2(),
          new Vector2()
        ],
        ascent,
        descent,
        index: 0,
        data
      };
    } else {
      return sizeInfo;
    }
  };
  TextUtils2._getCharInfo = function _getCharInfo(char, fontString, font) {
    var charInfo = font._getCharInfo(char);
    if (!charInfo) {
      charInfo = TextUtils2.measureChar(char, fontString);
      font._uploadCharTexture(charInfo);
      font._addCharInfo(char, charInfo);
    }
    return charInfo;
  };
  TextUtils2._pushLine = function _pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, ascent, descent) {
    lines.push(line);
    lineWidths.push(lineWidth);
    lineMaxSizes.push({
      ascent,
      descent,
      size: ascent + descent
    });
  };
  return TextUtils2;
}();
(function() {
  TextUtils._genericFontFamilies = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "math",
    "emoji",
    "fangsong"
  ];
})();
(function() {
  TextUtils._measureString = "|\xC9q\xC5";
})();
(function() {
  TextUtils._measureBaseline = "M";
})();
(function() {
  TextUtils._heightMultiplier = 2;
})();
(function() {
  TextUtils._baselineMultiplier = 1.4;
})();
(function() {
  TextUtils._fontSizeInfoCache = {};
})();
(function() {
  TextUtils._textContext = null;
})();
var SubFont = /* @__PURE__ */ function() {
  function SubFont2(engine) {
    this._fontAtlases = [];
    this._lastIndex = -1;
    this._engine = engine;
  }
  var _proto = SubFont2.prototype;
  _proto.destroy = function destroy2() {
    var fontAtlases = this._fontAtlases;
    for (var i = 0, n = fontAtlases.length; i < n; ++i) {
      fontAtlases[i].destroy(true);
    }
    fontAtlases.length = 0;
  };
  _proto._uploadCharTexture = function _uploadCharTexture(charInfo) {
    var fontAtlases = this._fontAtlases;
    var lastIndex = this._lastIndex;
    if (lastIndex === -1) {
      this._createFontAtlas();
      lastIndex++;
    }
    var fontAtlas = fontAtlases[lastIndex];
    if (!fontAtlas.uploadCharTexture(charInfo)) {
      fontAtlas = this._createFontAtlas();
      fontAtlas.uploadCharTexture(charInfo);
      lastIndex++;
    }
    this._lastIndex = lastIndex;
    charInfo.data = null;
  };
  _proto._addCharInfo = function _addCharInfo(char, charInfo) {
    var lastIndex = this._lastIndex;
    charInfo.index = lastIndex;
    this._fontAtlases[lastIndex].addCharInfo(char, charInfo);
  };
  _proto._getCharInfo = function _getCharInfo(char) {
    var fontAtlases = this._fontAtlases;
    for (var i = 0, n = fontAtlases.length; i < n; ++i) {
      var fontAtlas = fontAtlases[i];
      var charInfo = fontAtlas.getCharInfo(char);
      if (charInfo) {
        return charInfo;
      }
    }
    return null;
  };
  _proto._getTextureByIndex = function _getTextureByIndex(index) {
    var fontAtlas = this._fontAtlases[index];
    if (fontAtlas) {
      return fontAtlas.texture;
    }
    return null;
  };
  _proto._getLastIndex = function _getLastIndex() {
    return this._lastIndex;
  };
  _proto._createFontAtlas = function _createFontAtlas() {
    var _this = this, engine = _this._engine;
    var fontAtlas = new FontAtlas(engine);
    var texture = new Texture2D(engine, 256, 256);
    fontAtlas.texture = texture;
    fontAtlas.isGCIgnored = texture.isGCIgnored = true;
    this._fontAtlases.push(fontAtlas);
    var nativeFontString = this.nativeFontString;
    engine.resourceManager.addContentRestorer(new (function(ContentRestorer3) {
      _inherits$2(_class, ContentRestorer3);
      function _class() {
        return ContentRestorer3.call(this, fontAtlas);
      }
      var _proto2 = _class.prototype;
      _proto2.restoreContent = function restoreContent() {
        var resource = this.resource;
        var charInfoMap = resource._charInfoMap;
        var texture2 = resource.texture;
        for (var k2 in charInfoMap) {
          var charInfo = charInfoMap[k2];
          var data = TextUtils.measureChar(charInfo.char, nativeFontString).data;
          if (charInfo.w > 0 && charInfo.h > 0 && data) {
            var bufferOffset = charInfo.bufferOffset;
            texture2.setPixelBuffer(data, 0, bufferOffset.x, bufferOffset.y, charInfo.w, charInfo.h);
          }
        }
        texture2.generateMipmaps();
      };
      return _class;
    }(ContentRestorer))());
    return fontAtlas;
  };
  return SubFont2;
}();
var Font = /* @__PURE__ */ function(ReferResource2) {
  _inherits$2(Font2, ReferResource2);
  function Font2(engine, name2) {
    if (name2 === void 0)
      name2 = "";
    var _this;
    _this = ReferResource2.call(this, engine) || this;
    _this._name = "";
    _this._subFontMap = {};
    _this._name = name2;
    return _this;
  }
  var _proto = Font2.prototype;
  _proto._getSubFont = function _getSubFont(fontSize, fontStyle) {
    var key = fontSize + "-" + fontStyle;
    var subFontMap = this._subFontMap;
    var subFont = subFontMap[key];
    if (subFont) {
      return subFont;
    }
    subFont = new SubFont(this.engine);
    subFontMap[key] = subFont;
    return subFont;
  };
  _proto._onDestroy = function _onDestroy() {
    ReferResource2.prototype._onDestroy.call(this);
    var subFontMap = this._subFontMap;
    for (var k2 in subFontMap) {
      subFontMap[k2].destroy();
    }
    this._subFontMap = null;
    delete this.engine._fontMap[this._name];
  };
  Font2.createFromOS = function createFromOS(engine, name2) {
    if (name2) {
      var fontMap = engine._fontMap;
      var font = fontMap[name2];
      if (font) {
        return font;
      }
      font = new Font2(engine, name2);
      fontMap[name2] = font;
      return font;
    }
    return null;
  };
  _create_class$4(Font2, [
    {
      key: "name",
      get: function get3() {
        return this._name;
      }
    }
  ]);
  return Font2;
}(ReferResource);
var DisorderedArray = /* @__PURE__ */ function() {
  function DisorderedArray2(count) {
    if (count === void 0)
      count = 0;
    this.length = 0;
    this._elements = new Array(count);
  }
  var _proto = DisorderedArray2.prototype;
  _proto.add = function add2(element) {
    if (this.length === this._elements.length) {
      this._elements.push(element);
    } else {
      this._elements[this.length] = element;
    }
    this.length++;
  };
  _proto.delete = function _delete(element) {
    var index = this._elements.indexOf(element);
    this.deleteByIndex(index);
  };
  _proto.set = function set(index, element) {
    if (index >= this.length) {
      throw "Index is out of range.";
    }
    this._elements[index] = element;
  };
  _proto.get = function get3(index) {
    if (index >= this.length) {
      throw "Index is out of range.";
    }
    return this._elements[index];
  };
  _proto.deleteByIndex = function deleteByIndex(index) {
    var elements = this._elements;
    var end = null;
    var lastIndex = this.length - 1;
    if (index !== lastIndex) {
      end = elements[lastIndex];
      elements[index] = end;
    }
    this.length--;
    return end;
  };
  _proto.garbageCollection = function garbageCollection() {
    this._elements.length = this.length;
  };
  return DisorderedArray2;
}();
var ComponentsManager = /* @__PURE__ */ function() {
  function ComponentsManager2() {
    this._renderers = new DisorderedArray();
    this._onStartScripts = new DisorderedArray();
    this._onUpdateScripts = new DisorderedArray();
    this._onLateUpdateScripts = new DisorderedArray();
    this._onPhysicsUpdateScripts = new DisorderedArray();
    this._disableScripts = [];
    this._pendingDestroyScripts = [];
    this._disposeDestroyScripts = [];
    this._onUpdateAnimations = new DisorderedArray();
    this._onUpdateRenderers = new DisorderedArray();
    this._componentsContainerPool = [];
  }
  var _proto = ComponentsManager2.prototype;
  _proto.addRenderer = function addRenderer(renderer) {
    renderer._rendererIndex = this._renderers.length;
    this._renderers.add(renderer);
  };
  _proto.removeRenderer = function removeRenderer(renderer) {
    var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);
    replaced && (replaced._rendererIndex = renderer._rendererIndex);
    renderer._rendererIndex = -1;
  };
  _proto.addOnStartScript = function addOnStartScript(script) {
    script._onStartIndex = this._onStartScripts.length;
    this._onStartScripts.add(script);
  };
  _proto.removeOnStartScript = function removeOnStartScript(script) {
    var replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);
    replaced && (replaced._onStartIndex = script._onStartIndex);
    script._onStartIndex = -1;
  };
  _proto.addOnUpdateScript = function addOnUpdateScript(script) {
    script._onUpdateIndex = this._onUpdateScripts.length;
    this._onUpdateScripts.add(script);
  };
  _proto.removeOnUpdateScript = function removeOnUpdateScript(script) {
    var replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = script._onUpdateIndex);
    script._onUpdateIndex = -1;
  };
  _proto.addOnLateUpdateScript = function addOnLateUpdateScript(script) {
    script._onLateUpdateIndex = this._onLateUpdateScripts.length;
    this._onLateUpdateScripts.add(script);
  };
  _proto.removeOnLateUpdateScript = function removeOnLateUpdateScript(script) {
    var replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);
    replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);
    script._onLateUpdateIndex = -1;
  };
  _proto.addOnPhysicsUpdateScript = function addOnPhysicsUpdateScript(script) {
    script._onPhysicsUpdateIndex = this._onPhysicsUpdateScripts.length;
    this._onPhysicsUpdateScripts.add(script);
  };
  _proto.removeOnPhysicsUpdateScript = function removeOnPhysicsUpdateScript(script) {
    var replaced = this._onPhysicsUpdateScripts.deleteByIndex(script._onPhysicsUpdateIndex);
    replaced && (replaced._onPhysicsUpdateIndex = script._onPhysicsUpdateIndex);
    script._onPhysicsUpdateIndex = -1;
  };
  _proto.addOnUpdateAnimations = function addOnUpdateAnimations(animation) {
    animation._onUpdateIndex = this._onUpdateAnimations.length;
    this._onUpdateAnimations.add(animation);
  };
  _proto.removeOnUpdateAnimations = function removeOnUpdateAnimations(animation) {
    var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);
    animation._onUpdateIndex = -1;
  };
  _proto.addOnUpdateRenderers = function addOnUpdateRenderers(renderer) {
    renderer._onUpdateIndex = this._onUpdateRenderers.length;
    this._onUpdateRenderers.add(renderer);
  };
  _proto.removeOnUpdateRenderers = function removeOnUpdateRenderers(renderer) {
    var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
    renderer._onUpdateIndex = -1;
  };
  _proto.addDisableScript = function addDisableScript(component) {
    this._disableScripts.push(component);
  };
  _proto.addPendingDestroyScript = function addPendingDestroyScript(component) {
    this._pendingDestroyScripts.push(component);
  };
  _proto.callScriptOnStart = function callScriptOnStart() {
    var onStartScripts = this._onStartScripts;
    if (onStartScripts.length > 0) {
      var elements = onStartScripts._elements;
      for (var i = 0; i < onStartScripts.length; i++) {
        var script = elements[i];
        if (!script._waitHandlingInValid) {
          script._started = true;
          script._onStartIndex = -1;
          script.onStart();
        }
      }
      onStartScripts.length = 0;
    }
  };
  _proto.callScriptOnUpdate = function callScriptOnUpdate(deltaTime) {
    var elements = this._onUpdateScripts._elements;
    for (var i = this._onUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (!element._waitHandlingInValid && element._started) {
        element.onUpdate(deltaTime);
      }
    }
  };
  _proto.callScriptOnLateUpdate = function callScriptOnLateUpdate(deltaTime) {
    var elements = this._onLateUpdateScripts._elements;
    for (var i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (!element._waitHandlingInValid && element._started) {
        element.onLateUpdate(deltaTime);
      }
    }
  };
  _proto.callScriptOnPhysicsUpdate = function callScriptOnPhysicsUpdate() {
    var elements = this._onPhysicsUpdateScripts._elements;
    for (var i = this._onPhysicsUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (!element._waitHandlingInValid && element._started) {
        element.onPhysicsUpdate();
      }
    }
  };
  _proto.callAnimationUpdate = function callAnimationUpdate(deltaTime) {
    var elements = this._onUpdateAnimations._elements;
    for (var i = this._onUpdateAnimations.length - 1; i >= 0; --i) {
      var animator = elements[i];
      animator.engine.time.frameCount > animator._playFrameCount && animator.update(deltaTime);
    }
  };
  _proto.callRendererOnUpdate = function callRendererOnUpdate(deltaTime) {
    var elements = this._onUpdateRenderers._elements;
    for (var i = this._onUpdateRenderers.length - 1; i >= 0; --i) {
      elements[i].update(deltaTime);
    }
  };
  _proto.handlingInvalidScripts = function handlingInvalidScripts() {
    var _this = this, disableScripts = _this._disableScripts;
    var length2 = disableScripts.length;
    if (length2 > 0) {
      for (var i = length2 - 1; i >= 0; i--) {
        var disableScript = disableScripts[i];
        disableScript._waitHandlingInValid && disableScript._handlingInValid();
      }
      disableScripts.length = 0;
    }
    var _this1 = this, pendingDestroyScripts = _this1._disposeDestroyScripts, disposeDestroyScripts = _this1._pendingDestroyScripts;
    this._disposeDestroyScripts = disposeDestroyScripts;
    this._pendingDestroyScripts = pendingDestroyScripts;
    length2 = disposeDestroyScripts.length;
    if (length2 > 0) {
      for (var i1 = length2 - 1; i1 >= 0; i1--) {
        disposeDestroyScripts[i1].onDestroy();
      }
      disposeDestroyScripts.length = 0;
    }
  };
  _proto.callCameraOnBeginRender = function callCameraOnBeginRender(camera) {
    var scripts = camera.entity._scripts;
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = scripts.get(i);
      script._waitHandlingInValid || script.onBeginRender(camera);
    }
  };
  _proto.callCameraOnEndRender = function callCameraOnEndRender(camera) {
    var scripts = camera.entity._scripts;
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = scripts.get(i);
      script._waitHandlingInValid || script.onEndRender(camera);
    }
  };
  _proto.getActiveChangedTempList = function getActiveChangedTempList() {
    return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
  };
  _proto.putActiveChangedTempList = function putActiveChangedTempList(componentContainer) {
    componentContainer.length = 0;
    this._componentsContainerPool.push(componentContainer);
  };
  _proto._gc = function _gc() {
    this._renderers.garbageCollection();
    this._onStartScripts.garbageCollection();
    this._onUpdateScripts.garbageCollection();
    this._onLateUpdateScripts.garbageCollection();
    this._onPhysicsUpdateScripts.garbageCollection();
    this._onUpdateAnimations.garbageCollection();
    this._onUpdateRenderers.garbageCollection();
  };
  return ComponentsManager2;
}();
var EventDispatcher = /* @__PURE__ */ function() {
  function EventDispatcher2() {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventCount = 0;
  }
  var _proto = EventDispatcher2.prototype;
  _proto.hasEvent = function hasEvent(event) {
    return this._events[event] != null;
  };
  _proto.eventNames = function eventNames() {
    if (this._eventCount === 0)
      return [];
    return Object.keys(this._events);
  };
  _proto.listenerCount = function listenerCount(event) {
    var listeners = this._events[event];
    if (!listeners)
      return 0;
    if (Array.isArray(listeners))
      return listeners.length;
    return 1;
  };
  _proto.dispatch = function dispatch(event, data) {
    if (!this._events[event]) {
      return false;
    }
    var listeners = this._events[event];
    if (Array.isArray(listeners)) {
      var count = listeners.length;
      var pool = EventDispatcher2._dispatchingListenersPool;
      var dispatchingListeners = pool.length > 0 ? pool.pop() : [];
      dispatchingListeners.length = count;
      for (var i = 0; i < count; i++) {
        dispatchingListeners[i] = listeners[i];
      }
      for (var i1 = 0; i1 < count; i1++) {
        var listener = dispatchingListeners[i1];
        if (!listener.destroyed) {
          if (listener.once)
            this.off(event, listener.fn);
          listener.fn(data);
        }
      }
      dispatchingListeners.length = 0;
      pool.push(dispatchingListeners);
    } else {
      if (listeners.once)
        this.off(event, listeners.fn);
      listeners.fn(data);
    }
    return true;
  };
  _proto.on = function on(event, fn) {
    return this._addEventListener(event, fn);
  };
  _proto.once = function once(event, fn) {
    return this._addEventListener(event, fn, true);
  };
  _proto.off = function off(event, fn) {
    if (!this._events[event])
      return this;
    if (!fn) {
      this._clearEvent(event);
      return this;
    }
    var listeners = this._events[event];
    var isArray = Array.isArray(listeners);
    if (!isArray && listeners.fn === fn) {
      this._clearEvent(event);
    } else if (isArray) {
      for (var i = listeners.length - 1; i >= 0; i--) {
        if (listeners[i].fn === fn) {
          listeners[i].destroyed = true;
          listeners.splice(i, 1);
        }
      }
      if (listeners.length === 0) {
        this._clearEvent(event);
      } else if (listeners.length === 1) {
        this._events[event] = listeners[0];
      }
    }
    return this;
  };
  _proto.removeEventListener = function removeEventListener(event, fn) {
    return this.off(event, fn);
  };
  _proto.removeAllEventListeners = function removeAllEventListeners(event) {
    if (event) {
      if (this._events[event])
        this._clearEvent(event);
    } else {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventCount = 0;
    }
  };
  _proto._addEventListener = function _addEventListener(event, fn, once) {
    var listener = {
      fn,
      once
    };
    var events = this._events;
    var element = events[event];
    if (!element) {
      events[event] = listener;
      this._eventCount++;
    } else if (Array.isArray(element)) {
      element.push(listener);
    } else {
      events[event] = [
        element,
        listener
      ];
    }
    return this;
  };
  _proto._clearEvent = function _clearEvent(event) {
    if (--this._eventCount === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
    } else {
      delete this._events[event];
    }
  };
  return EventDispatcher2;
}();
(function() {
  EventDispatcher._dispatchingListenersPool = [];
})();
var ShaderProperty = /* @__PURE__ */ function() {
  function ShaderProperty2(name2) {
    this.name = name2;
    this._uniqueId = ShaderProperty2._propertyNameCounter++;
  }
  ShaderProperty2.getByName = function getByName(name2) {
    var propertyNameMap = ShaderProperty2._propertyNameMap;
    if (propertyNameMap[name2] != null) {
      return propertyNameMap[name2];
    } else {
      var property = new ShaderProperty2(name2);
      propertyNameMap[name2] = property;
      ShaderProperty2._propertyIdMap[property._uniqueId] = property;
      return property;
    }
  };
  ShaderProperty2._getShaderPropertyGroup = function _getShaderPropertyGroup(propertyName) {
    var shaderProperty = ShaderProperty2._propertyNameMap[propertyName];
    return shaderProperty == null ? void 0 : shaderProperty._group;
  };
  _create_class$4(ShaderProperty2, [
    {
      key: "type",
      get: function get3() {
        return this._type;
      }
    }
  ]);
  return ShaderProperty2;
}();
(function() {
  ShaderProperty._propertyIdMap = /* @__PURE__ */ Object.create(null);
})();
(function() {
  ShaderProperty._propertyNameCounter = 0;
})();
(function() {
  ShaderProperty._propertyNameMap = /* @__PURE__ */ Object.create(null);
})();
var Time = /* @__PURE__ */ function() {
  function Time2() {
    this._frameCount = 0;
    this._deltaTime = 0;
    this._actualDeltaTime = 0;
    this._elapsedTime = 0;
    this._actualElapsedTime = 0;
    this._elapsedTimeValue = new Vector4();
    this._deltaTimeValue = new Vector4();
    this.maximumDeltaTime = 0.333333;
    this.timeScale = 1;
    this._lastSystemTime = performance.now() / 1e3;
  }
  var _proto = Time2.prototype;
  _proto._reset = function _reset() {
    this._lastSystemTime = performance.now() / 1e3;
  };
  _proto._update = function _update() {
    var currentSystemTime = performance.now() / 1e3;
    var actualDeltaTime = currentSystemTime - this._lastSystemTime;
    this._actualDeltaTime = actualDeltaTime;
    this._actualElapsedTime += actualDeltaTime;
    var deltaTime = Math.min(actualDeltaTime, this.maximumDeltaTime) * this.timeScale;
    this._deltaTime = deltaTime;
    this._elapsedTime += deltaTime;
    this._frameCount++;
    this._lastSystemTime = currentSystemTime;
  };
  _proto._updateSceneShaderData = function _updateSceneShaderData(shaderData) {
    var _this = this, elapsedTimeValue = _this._elapsedTimeValue, deltaTimeValue = _this._deltaTimeValue;
    var time = this._elapsedTime;
    elapsedTimeValue.set(time, Math.sin(time), Math.cos(time), 0);
    shaderData.setVector4(Time2._elapsedTimeProperty, elapsedTimeValue);
    deltaTimeValue.set(this._deltaTime, 0, 0, 0);
    shaderData.setVector4(Time2._deltaTimeProperty, deltaTimeValue);
  };
  _create_class$4(Time2, [
    {
      key: "frameCount",
      get: function get3() {
        return this._frameCount;
      }
    },
    {
      key: "deltaTime",
      get: function get3() {
        return this._deltaTime;
      }
    },
    {
      key: "elapsedTime",
      get: function get3() {
        return this._elapsedTime;
      }
    },
    {
      key: "actualDeltaTime",
      get: function get3() {
        return this._actualDeltaTime;
      }
    },
    {
      key: "actualElapsedTime",
      get: function get3() {
        return this._actualElapsedTime;
      }
    }
  ]);
  return Time2;
}();
(function() {
  Time._elapsedTimeProperty = ShaderProperty.getByName("scene_ElapsedTime");
})();
(function() {
  Time._deltaTimeProperty = ShaderProperty.getByName("scene_DeltaTime");
})();
var DataType;
(function(DataType2) {
  DataType2[DataType2["FLOAT"] = 5126] = "FLOAT";
  DataType2[DataType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  DataType2[DataType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  DataType2[DataType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  DataType2[DataType2["INT"] = 5124] = "INT";
  DataType2[DataType2["INT_VEC2"] = 35667] = "INT_VEC2";
  DataType2[DataType2["INT_VEC3"] = 35668] = "INT_VEC3";
  DataType2[DataType2["INT_VEC4"] = 35669] = "INT_VEC4";
  DataType2[DataType2["BOOL"] = 35670] = "BOOL";
  DataType2[DataType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  DataType2[DataType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  DataType2[DataType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  DataType2[DataType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  DataType2[DataType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  DataType2[DataType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  DataType2[DataType2["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
  DataType2[DataType2["FLOAT_VEC2_ARRAY"] = 1e5] = "FLOAT_VEC2_ARRAY";
  DataType2[DataType2["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
  DataType2[DataType2["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
  DataType2[DataType2["INT_ARRAY"] = 100003] = "INT_ARRAY";
  DataType2[DataType2["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
  DataType2[DataType2["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
  DataType2[DataType2["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
  DataType2[DataType2["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
  DataType2[DataType2["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
  DataType2[DataType2["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
  DataType2[DataType2["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
  DataType2[DataType2["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
  DataType2[DataType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  DataType2[DataType2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  DataType2[DataType2["BYTE"] = 5120] = "BYTE";
  DataType2[DataType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  DataType2[DataType2["SHORT"] = 5122] = "SHORT";
  DataType2[DataType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  DataType2[DataType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
})(DataType || (DataType = {}));
var GLCapabilityType;
(function(GLCapabilityType2) {
  GLCapabilityType2["shaderVertexID"] = "shaderVertexID";
  GLCapabilityType2["standardDerivatives"] = "OES_standard_derivatives";
  GLCapabilityType2["shaderTextureLod"] = "EXT_shader_texture_lod";
  GLCapabilityType2["elementIndexUint"] = "OES_element_index_uint";
  GLCapabilityType2["depthTexture"] = "WEBGL_depth_texture";
  GLCapabilityType2["drawBuffers"] = "WEBGL_draw_buffers";
  GLCapabilityType2["vertexArrayObject"] = "OES_vertex_array_object";
  GLCapabilityType2["instancedArrays"] = "ANGLE_instanced_arrays";
  GLCapabilityType2["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
  GLCapabilityType2["textureFloat"] = "OES_texture_float";
  GLCapabilityType2["textureFloatLinear"] = "OES_texture_float_linear";
  GLCapabilityType2["textureHalfFloat"] = "OES_texture_half_float";
  GLCapabilityType2["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
  GLCapabilityType2["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
  GLCapabilityType2["colorBufferFloat"] = "EXT_color_buffer_float";
  GLCapabilityType2["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
  GLCapabilityType2["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
  GLCapabilityType2["blendMinMax"] = "EXT_blend_minmax";
  GLCapabilityType2["astc"] = "WEBGL_compressed_texture_astc";
  GLCapabilityType2["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
  GLCapabilityType2["etc"] = "WEBGL_compressed_texture_etc";
  GLCapabilityType2["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
  GLCapabilityType2["etc1"] = "WEBGL_compressed_texture_etc1";
  GLCapabilityType2["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
  GLCapabilityType2["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
  GLCapabilityType2["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
  GLCapabilityType2["s3tc"] = "WEBGL_compressed_texture_s3tc";
  GLCapabilityType2["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
  GLCapabilityType2["WEBGL_lose_context"] = "WEBGL_lose_context";
})(GLCapabilityType || (GLCapabilityType = {}));
var Component = /* @__PURE__ */ function(EngineObject2) {
  _inherits$2(Component2, EngineObject2);
  function Component2(entity) {
    var _this;
    _this = EngineObject2.call(this, entity.engine) || this;
    _this._awoken = false;
    _this._phasedActive = false;
    _this._enabled = true;
    _this._entity = entity;
    return _this;
  }
  var _proto = Component2.prototype;
  _proto._onAwake = function _onAwake() {
  };
  _proto._onEnable = function _onEnable() {
  };
  _proto._onDisable = function _onDisable() {
  };
  _proto._setActive = function _setActive(value) {
    var entity = this._entity;
    if (value) {
      if (!this._awoken && entity._isActiveInHierarchy) {
        this._awoken = true;
        this._onAwake();
      }
      if (!this._phasedActive && entity._isActiveInHierarchy && this._enabled) {
        this._phasedActive = true;
        this._onEnable();
      }
    } else {
      if (this._phasedActive && !(entity._isActiveInHierarchy && this._enabled)) {
        this._phasedActive = false;
        this._onDisable();
      }
    }
  };
  _proto._onDestroy = function _onDestroy() {
    EngineObject2.prototype._onDestroy.call(this);
    this._entity._removeComponent(this);
    if (this._entity.isActiveInHierarchy) {
      this._enabled && this._onDisable();
    }
  };
  _create_class$4(Component2, [
    {
      key: "enabled",
      get: function get3() {
        return this._enabled;
      },
      set: function set(value) {
        if (value !== this._enabled) {
          this._enabled = value;
          if (this._entity.isActiveInHierarchy) {
            if (value) {
              this._phasedActive = true;
              this._onEnable();
            } else {
              this._phasedActive = false;
              this._onDisable();
            }
          }
        }
      }
    },
    {
      key: "entity",
      get: function get3() {
        return this._entity;
      }
    },
    {
      key: "scene",
      get: function get3() {
        return this._entity.scene;
      }
    }
  ]);
  return Component2;
}(EngineObject);
__decorate$2([
  ignoreClone
], Component.prototype, "_entity", void 0);
__decorate$2([
  ignoreClone
], Component.prototype, "_awoken", void 0);
__decorate$2([
  ignoreClone
], Component.prototype, "_phasedActive", void 0);
__decorate$2([
  assignmentClone
], Component.prototype, "_enabled", void 0);
var ComponentsDependencies = /* @__PURE__ */ function() {
  function ComponentsDependencies2() {
  }
  ComponentsDependencies2._addCheck = function _addCheck(entity, type) {
    while (type !== Component) {
      var dependentInfo = ComponentsDependencies2._dependenciesMap.get(type);
      if (dependentInfo) {
        var components = dependentInfo.components, mode = dependentInfo.mode;
        for (var i = 0, n = components.length; i < n; i++) {
          var dependentComponent = components[i];
          if (!entity.getComponent(dependentComponent)) {
            if (mode === 1) {
              entity.addComponent(dependentComponent);
            } else {
              throw "Should add " + dependentComponent.name + " before adding " + type.name;
            }
          }
        }
      }
      type = Object.getPrototypeOf(type);
    }
  };
  ComponentsDependencies2._removeCheck = function _removeCheck(entity, type) {
    while (type !== Component) {
      var invDependencies = ComponentsDependencies2._invDependenciesMap.get(type);
      if (invDependencies) {
        for (var i = 0, len = invDependencies.length; i < len; i++) {
          if (entity.getComponent(invDependencies[i])) {
            throw "Should remove " + invDependencies[i].name + " before adding " + type.name;
          }
        }
      }
      type = Object.getPrototypeOf(type);
    }
  };
  ComponentsDependencies2._addDependency = function _addDependency(targetInfo, dependentComponent, map2) {
    var components = map2.get(targetInfo);
    if (!components) {
      map2.set(targetInfo, [
        dependentComponent
      ]);
    } else {
      components.includes(dependentComponent) || components.push(dependentComponent);
    }
  };
  ComponentsDependencies2._addInvDependency = function _addInvDependency(currentComponent, dependentComponent) {
    var map2 = this._invDependenciesMap;
    var components = map2.get(currentComponent);
    if (!components) {
      map2.set(currentComponent, [
        dependentComponent
      ]);
    } else {
      components.includes(dependentComponent) || components.push(dependentComponent);
    }
  };
  return ComponentsDependencies2;
}();
(function() {
  ComponentsDependencies._invDependenciesMap = /* @__PURE__ */ new Map();
})();
(function() {
  ComponentsDependencies._dependenciesMap = /* @__PURE__ */ new Map();
})();
function dependentComponents(componentOrComponents, dependentMode) {
  if (dependentMode === void 0)
    dependentMode = 0;
  var components = Array.isArray(componentOrComponents) ? componentOrComponents : [
    componentOrComponents
  ];
  return function(target) {
    ComponentsDependencies._dependenciesMap.set(target, {
      mode: dependentMode,
      components
    });
    components.forEach(function(component) {
      return ComponentsDependencies._addInvDependency(component, target);
    });
  };
}
var DependentMode;
(function(DependentMode2) {
  DependentMode2[DependentMode2["CheckOnly"] = 0] = "CheckOnly";
  DependentMode2[DependentMode2["AutoAdd"] = 1] = "AutoAdd";
})(DependentMode || (DependentMode = {}));
var Layer;
(function(Layer2) {
  Layer2[Layer2["Layer0"] = 1] = "Layer0";
  Layer2[Layer2["Layer1"] = 2] = "Layer1";
  Layer2[Layer2["Layer2"] = 4] = "Layer2";
  Layer2[Layer2["Layer3"] = 8] = "Layer3";
  Layer2[Layer2["Layer4"] = 16] = "Layer4";
  Layer2[Layer2["Layer5"] = 32] = "Layer5";
  Layer2[Layer2["Layer6"] = 64] = "Layer6";
  Layer2[Layer2["Layer7"] = 128] = "Layer7";
  Layer2[Layer2["Layer8"] = 256] = "Layer8";
  Layer2[Layer2["Layer9"] = 512] = "Layer9";
  Layer2[Layer2["Layer10"] = 1024] = "Layer10";
  Layer2[Layer2["Layer11"] = 2048] = "Layer11";
  Layer2[Layer2["Layer12"] = 4096] = "Layer12";
  Layer2[Layer2["Layer13"] = 8192] = "Layer13";
  Layer2[Layer2["Layer14"] = 16384] = "Layer14";
  Layer2[Layer2["Layer15"] = 32768] = "Layer15";
  Layer2[Layer2["Layer16"] = 65536] = "Layer16";
  Layer2[Layer2["Layer17"] = 131072] = "Layer17";
  Layer2[Layer2["Layer18"] = 262144] = "Layer18";
  Layer2[Layer2["Layer19"] = 524288] = "Layer19";
  Layer2[Layer2["Layer20"] = 1048576] = "Layer20";
  Layer2[Layer2["Layer21"] = 2097152] = "Layer21";
  Layer2[Layer2["Layer22"] = 4194304] = "Layer22";
  Layer2[Layer2["Layer23"] = 8388608] = "Layer23";
  Layer2[Layer2["Layer24"] = 16777216] = "Layer24";
  Layer2[Layer2["Layer25"] = 33554432] = "Layer25";
  Layer2[Layer2["Layer26"] = 67108864] = "Layer26";
  Layer2[Layer2["Layer27"] = 134217728] = "Layer27";
  Layer2[Layer2["Layer28"] = 268435456] = "Layer28";
  Layer2[Layer2["Layer29"] = 536870912] = "Layer29";
  Layer2[Layer2["Layer30"] = 1073741824] = "Layer30";
  Layer2[Layer2["Layer31"] = 2147483648] = "Layer31";
  Layer2[Layer2["Everything"] = 4294967295] = "Everything";
  Layer2[Layer2["Nothing"] = 0] = "Nothing";
})(Layer || (Layer = {}));
var Utils = /* @__PURE__ */ function() {
  function Utils2() {
  }
  Utils2._floatMatrixMultiply = function _floatMatrixMultiply(left, re2, rOffset, oe2, offset) {
    var le2 = left.elements;
    var l11 = le2[0], l12 = le2[1], l13 = le2[2], l14 = le2[3], l21 = le2[4], l22 = le2[5], l23 = le2[6], l24 = le2[7], l31 = le2[8], l32 = le2[9], l33 = le2[10], l34 = le2[11], l41 = le2[12], l42 = le2[13], l43 = le2[14], l44 = le2[15];
    var r11 = re2[rOffset], r12 = re2[rOffset + 1], r13 = re2[rOffset + 2], r14 = re2[rOffset + 3], r21 = re2[rOffset + 4], r22 = re2[rOffset + 5], r23 = re2[rOffset + 6], r24 = re2[rOffset + 7], r31 = re2[rOffset + 8], r32 = re2[rOffset + 9], r33 = re2[rOffset + 10], r34 = re2[rOffset + 11], r41 = re2[rOffset + 12], r42 = re2[rOffset + 13], r43 = re2[rOffset + 14], r44 = re2[rOffset + 15];
    oe2[offset] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
    oe2[offset + 1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
    oe2[offset + 2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
    oe2[offset + 3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
    oe2[offset + 4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
    oe2[offset + 5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
    oe2[offset + 6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
    oe2[offset + 7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
    oe2[offset + 8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
    oe2[offset + 9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
    oe2[offset + 10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
    oe2[offset + 11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
    oe2[offset + 12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
    oe2[offset + 13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
    oe2[offset + 14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
    oe2[offset + 15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
  };
  Utils2._reflectGet = function _reflectGet(target, path) {
    var pathArr = this._stringToPath(path);
    var object = target;
    var index = 0;
    var length2 = pathArr.length;
    while (object != null && index < length2) {
      object = object[pathArr[index++]];
    }
    return index && index == length2 ? object : void 0;
  };
  Utils2.removeFromArray = function removeFromArray(array, item) {
    var index = array.indexOf(item);
    if (index < 0) {
      return false;
    }
    var last = array.length - 1;
    if (index !== last) {
      var end = array[last];
      array[index] = end;
    }
    array.length--;
    return true;
  };
  Utils2.decodeText = function decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    var s = "";
    for (var i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    return decodeURIComponent(encodeURIComponent(s));
  };
  Utils2.isAbsoluteUrl = function isAbsoluteUrl(url) {
    return /^(?:http|blob|data:|\/)/.test(url);
  };
  Utils2.objectValues = function objectValues(obj) {
    return Object.keys(obj).map(function(key) {
      return obj[key];
    });
  };
  Utils2.resolveAbsoluteUrl = function resolveAbsoluteUrl(baseUrl, relativeUrl) {
    if (Utils2.isAbsoluteUrl(relativeUrl)) {
      return relativeUrl;
    }
    var char0 = relativeUrl.charAt(0);
    if (char0 === ".") {
      return Utils2._formatRelativePath(relativeUrl + relativeUrl);
    }
    return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
  };
  Utils2._stringToPath = function _stringToPath(string) {
    var result2 = [];
    if (string.charCodeAt(0) === charCodeOfDot$1) {
      result2.push("");
    }
    string.replace(rePropName$1, function(match, expression, quote, subString) {
      var key = match;
      if (quote) {
        key = subString.replace(reEscapeChar$1, "$1");
      } else if (expression) {
        key = expression.trim();
      }
      result2.push(key);
    });
    return result2;
  };
  Utils2._formatRelativePath = function _formatRelativePath(value) {
    var parts = value.split("/");
    for (var i = 0, n = parts.length; i < n; i++) {
      if (parts[i] == "..") {
        parts.splice(i - 1, 2);
        i -= 2;
      }
    }
    return parts.join("/");
  };
  return Utils2;
}();
var charCodeOfDot$1 = ".".charCodeAt(0);
var reEscapeChar$1 = /\\(\\)?/g;
var rePropName$1 = RegExp(
  `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
  "g"
);
var UpdateFlag = /* @__PURE__ */ function() {
  function UpdateFlag2() {
    this._flagManagers = [];
  }
  var _proto = UpdateFlag2.prototype;
  _proto.clearFromManagers = function clearFromManagers() {
    this._removeFromManagers();
    this._flagManagers.length = 0;
  };
  _proto.destroy = function destroy2() {
    this._removeFromManagers();
    this._flagManagers = null;
  };
  _proto._removeFromManagers = function _removeFromManagers() {
    var flagManagers = this._flagManagers;
    for (var i = 0, n = flagManagers.length; i < n; i++) {
      Utils.removeFromArray(flagManagers[i]._updateFlags, this);
    }
  };
  return UpdateFlag2;
}();
var BoolUpdateFlag = /* @__PURE__ */ function(UpdateFlag2) {
  _inherits$2(BoolUpdateFlag2, UpdateFlag2);
  function BoolUpdateFlag2() {
    var _this;
    _this = UpdateFlag2.apply(this, arguments) || this;
    _this.flag = true;
    return _this;
  }
  var _proto = BoolUpdateFlag2.prototype;
  _proto.dispatch = function dispatch() {
    this.flag = true;
  };
  return BoolUpdateFlag2;
}(UpdateFlag);
var UpdateFlagManager = /* @__PURE__ */ function() {
  function UpdateFlagManager2() {
    this._updateFlags = [];
    this._listeners = [];
  }
  var _proto = UpdateFlagManager2.prototype;
  _proto.createFlag = function createFlag(type) {
    var flag = new type();
    this.addFlag(flag);
    return flag;
  };
  _proto.addFlag = function addFlag(flag) {
    this._updateFlags.push(flag);
    flag._flagManagers.push(this);
  };
  _proto.removeFlag = function removeFlag(flag) {
    var success = Utils.removeFromArray(this._updateFlags, flag);
    if (success) {
      Utils.removeFromArray(flag._flagManagers, this);
    }
  };
  _proto.addListener = function addListener(listener) {
    this._listeners.push(listener);
  };
  _proto.removeListener = function removeListener(listener) {
    Utils.removeFromArray(this._listeners, listener);
  };
  _proto.dispatch = function dispatch(type, param) {
    var updateFlags = this._updateFlags;
    for (var i = updateFlags.length - 1; i >= 0; i--) {
      updateFlags[i].dispatch(type, param);
    }
    var listeners = this._listeners;
    for (var i1 = listeners.length - 1; i1 >= 0; i1--) {
      listeners[i1](type, param);
    }
  };
  return UpdateFlagManager2;
}();
var Transform = /* @__PURE__ */ function(Component2) {
  _inherits$2(Transform2, Component2);
  function Transform2(entity) {
    var _this;
    _this = Component2.call(this, entity) || this;
    _this._position = new Vector3();
    _this._rotation = new Vector3();
    _this._rotationQuaternion = new Quaternion();
    _this._scale = new Vector3(1, 1, 1);
    _this._worldPosition = new Vector3();
    _this._worldRotation = new Vector3();
    _this._worldRotationQuaternion = new Quaternion();
    _this._lossyWorldScale = new Vector3(1, 1, 1);
    _this._localMatrix = new Matrix();
    _this._worldMatrix = new Matrix();
    _this._worldForward = null;
    _this._worldRight = null;
    _this._worldUp = null;
    _this._isParentDirty = true;
    _this._parentTransformCache = null;
    _this._dirtyFlag = 188;
    _this._updateFlagManager = new UpdateFlagManager();
    _this._onPositionChanged = _this._onPositionChanged.bind(_assert_this_initialized(_this));
    _this._onWorldPositionChanged = _this._onWorldPositionChanged.bind(_assert_this_initialized(_this));
    _this._onRotationChanged = _this._onRotationChanged.bind(_assert_this_initialized(_this));
    _this._onWorldRotationChanged = _this._onWorldRotationChanged.bind(_assert_this_initialized(_this));
    _this._onRotationQuaternionChanged = _this._onRotationQuaternionChanged.bind(_assert_this_initialized(_this));
    _this._onWorldRotationQuaternionChanged = _this._onWorldRotationQuaternionChanged.bind(_assert_this_initialized(_this));
    _this._onScaleChanged = _this._onScaleChanged.bind(_assert_this_initialized(_this));
    _this._position._onValueChanged = _this._onPositionChanged;
    _this._worldPosition._onValueChanged = _this._onWorldPositionChanged;
    _this._rotation._onValueChanged = _this._onRotationChanged;
    _this._worldRotation._onValueChanged = _this._onWorldRotationChanged;
    _this._rotationQuaternion._onValueChanged = _this._onRotationQuaternionChanged;
    _this._worldRotationQuaternion._onValueChanged = _this._onWorldRotationQuaternionChanged;
    _this._scale._onValueChanged = _this._onScaleChanged;
    return _this;
  }
  var _proto = Transform2.prototype;
  _proto.setPosition = function setPosition(x, y, z2) {
    this._position.set(x, y, z2);
  };
  _proto.setRotation = function setRotation(x, y, z2) {
    this._rotation.set(x, y, z2);
  };
  _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z2, w) {
    this._rotationQuaternion.set(x, y, z2, w);
  };
  _proto.setScale = function setScale(x, y, z2) {
    this._scale.set(x, y, z2);
  };
  _proto.setWorldPosition = function setWorldPosition(x, y, z2) {
    this._worldPosition.set(x, y, z2);
  };
  _proto.setWorldRotation = function setWorldRotation(x, y, z2) {
    this._worldRotation.set(x, y, z2);
  };
  _proto.setWorldRotationQuaternion = function setWorldRotationQuaternion(x, y, z2, w) {
    this._worldRotationQuaternion.set(x, y, z2, w);
  };
  _proto.translate = function translate(translationOrX, relativeToLocalOrY, z2, relativeToLocal) {
    if (typeof translationOrX === "number") {
      var translate2 = Transform2._tempVec30;
      translate2.set(translationOrX, relativeToLocalOrY, z2);
      this._translate(translate2, relativeToLocal);
    } else {
      this._translate(translationOrX, relativeToLocalOrY);
    }
  };
  _proto.rotate = function rotate(rotationOrX, relativeToLocalOrY, z2, relativeToLocal) {
    if (typeof rotationOrX === "number") {
      this._rotateXYZ(rotationOrX, relativeToLocalOrY, z2, relativeToLocal);
    } else {
      this._rotateXYZ(rotationOrX.x, rotationOrX.y, rotationOrX.z, relativeToLocalOrY);
    }
  };
  _proto.rotateByAxis = function rotateByAxis(axis, angle, relativeToLocal) {
    if (relativeToLocal === void 0)
      relativeToLocal = true;
    var rad = angle * MathUtil$1.degreeToRadFactor;
    Quaternion.rotationAxisAngle(axis, rad, Transform2._tempQuat0);
    this._rotateByQuat(Transform2._tempQuat0, relativeToLocal);
  };
  _proto.lookAt = function lookAt(targetPosition, worldUp) {
    var zAxis = Transform2._tempVec30;
    Vector3.subtract(this.worldPosition, targetPosition, zAxis);
    var axisLen = zAxis.length();
    if (axisLen <= MathUtil$1.zeroTolerance) {
      return;
    }
    zAxis.scale(1 / axisLen);
    var xAxis = Transform2._tempVec31;
    if (worldUp) {
      Vector3.cross(worldUp, zAxis, xAxis);
    } else {
      xAxis.set(zAxis.z, 0, -zAxis.x);
    }
    axisLen = xAxis.length();
    if (axisLen <= MathUtil$1.zeroTolerance) {
      return;
    }
    xAxis.scale(1 / axisLen);
    var yAxis = Transform2._tempVec32;
    Vector3.cross(zAxis, xAxis, yAxis);
    var rotMat = Transform2._tempMat41;
    var e = rotMat.elements;
    e[0] = xAxis.x, e[1] = xAxis.y, e[2] = xAxis.z;
    e[4] = yAxis.x, e[5] = yAxis.y, e[6] = yAxis.z;
    e[8] = zAxis.x, e[9] = zAxis.y, e[10] = zAxis.z;
    rotMat.getRotation(this._worldRotationQuaternion);
  };
  _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
    return this._updateFlagManager.createFlag(BoolUpdateFlag);
  };
  _proto._parentChange = function _parentChange() {
    this._isParentDirty = true;
    this._updateAllWorldFlag();
  };
  _proto._isFrontFaceInvert = function _isFrontFaceInvert() {
    var scale = this.lossyWorldScale;
    var isInvert = scale.x < 0;
    scale.y < 0 && (isInvert = !isInvert);
    scale.z < 0 && (isInvert = !isInvert);
    return isInvert;
  };
  _proto._onDestroy = function _onDestroy() {
    Component2.prototype._onDestroy.call(this);
    this._worldPosition._onValueChanged = null;
    this._rotation._onValueChanged = null;
    this._worldRotation._onValueChanged = null;
    this._rotationQuaternion._onValueChanged = null;
    this._worldRotationQuaternion._onValueChanged = null;
    this._position._onValueChanged = null;
    this._scale._onValueChanged = null;
  };
  _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
    if (!this._isContainDirtyFlags(132)) {
      this._worldAssociatedChange(132);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren_i_transform;
        (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionFlag();
      }
    }
  };
  _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
    if (!this._isContainDirtyFlags(152)) {
      this._worldAssociatedChange(152);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren_i_transform;
        (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionAndRotationFlag();
      }
    }
  };
  _proto._updateWorldPositionAndRotationFlag = function _updateWorldPositionAndRotationFlag() {
    if (!this._isContainDirtyFlags(156)) {
      this._worldAssociatedChange(156);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren_i_transform;
        (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionAndRotationFlag();
      }
    }
  };
  _proto._updateWorldScaleFlag = function _updateWorldScaleFlag() {
    if (!this._isContainDirtyFlags(160)) {
      this._worldAssociatedChange(160);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren_i_transform;
        (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionAndScaleFlag();
      }
    }
  };
  _proto._updateWorldPositionAndScaleFlag = function _updateWorldPositionAndScaleFlag() {
    if (!this._isContainDirtyFlags(164)) {
      this._worldAssociatedChange(164);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren_i_transform;
        (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionAndScaleFlag();
      }
    }
  };
  _proto._updateAllWorldFlag = function _updateAllWorldFlag() {
    if (!this._isContainDirtyFlags(188)) {
      this._worldAssociatedChange(188);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren_i_transform;
        (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateAllWorldFlag();
      }
    }
  };
  _proto._getParentTransform = function _getParentTransform() {
    if (!this._isParentDirty) {
      return this._parentTransformCache;
    }
    var parentCache = null;
    var parent = this._entity.parent;
    while (parent) {
      var transform = parent.transform;
      if (transform) {
        parentCache = transform;
        break;
      } else {
        parent = parent.parent;
      }
    }
    this._parentTransformCache = parentCache;
    this._isParentDirty = false;
    return parentCache;
  };
  _proto._getScaleMatrix = function _getScaleMatrix() {
    var invRotation = Transform2._tempQuat0;
    var invRotationMat = Transform2._tempMat30;
    var worldRotScaMat = Transform2._tempMat31;
    var scaMat = Transform2._tempMat32;
    worldRotScaMat.copyFromMatrix(this.worldMatrix);
    Quaternion.invert(this.worldRotationQuaternion, invRotation);
    Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
    Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
    return scaMat;
  };
  _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
    return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
  };
  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };
  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };
  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  };
  _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
    this._dirtyFlag |= type;
    this._updateFlagManager.dispatch(128);
  };
  _proto._rotateByQuat = function _rotateByQuat(rotateQuat, relativeToLocal) {
    if (relativeToLocal) {
      Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
    } else {
      Quaternion.multiply(rotateQuat, this.worldRotationQuaternion, this._worldRotationQuaternion);
    }
  };
  _proto._translate = function _translate(translation, relativeToLocal) {
    if (relativeToLocal === void 0)
      relativeToLocal = true;
    if (relativeToLocal) {
      var _tempVec30 = Transform2._tempVec30;
      Vector3.transformByQuat(translation, this.worldRotationQuaternion, _tempVec30);
      this._worldPosition.add(_tempVec30);
    } else {
      this._worldPosition.add(translation);
    }
  };
  _proto._rotateXYZ = function _rotateXYZ(x, y, z2, relativeToLocal) {
    if (relativeToLocal === void 0)
      relativeToLocal = true;
    var radFactor = MathUtil$1.degreeToRadFactor;
    var rotQuat = Transform2._tempQuat0;
    Quaternion.rotationEuler(x * radFactor, y * radFactor, z2 * radFactor, rotQuat);
    this._rotateByQuat(rotQuat, relativeToLocal);
  };
  _proto._onPositionChanged = function _onPositionChanged() {
    this._setDirtyFlagTrue(64);
    this._updateWorldPositionFlag();
  };
  _proto._onWorldPositionChanged = function _onWorldPositionChanged() {
    var worldPosition = this._worldPosition;
    var parent = this._getParentTransform();
    if (parent) {
      Matrix.invert(parent.worldMatrix, Transform2._tempMat41);
      Vector3.transformCoordinate(worldPosition, Transform2._tempMat41, this._position);
    } else {
      this._position.copyFrom(worldPosition);
    }
    this._setDirtyFlagFalse(4);
  };
  _proto._onRotationChanged = function _onRotationChanged() {
    this._setDirtyFlagTrue(64 | 2);
    this._setDirtyFlagFalse(1);
    this._updateWorldRotationFlag();
  };
  _proto._onWorldRotationChanged = function _onWorldRotationChanged() {
    var worldRotation = this._worldRotation;
    Quaternion.rotationEuler(MathUtil$1.degreeToRadian(worldRotation.x), MathUtil$1.degreeToRadian(worldRotation.y), MathUtil$1.degreeToRadian(worldRotation.z), this._worldRotationQuaternion);
    this._setDirtyFlagFalse(8);
  };
  _proto._onRotationQuaternionChanged = function _onRotationQuaternionChanged() {
    this._setDirtyFlagTrue(64 | 1);
    this._setDirtyFlagFalse(2);
    this._updateWorldRotationFlag();
  };
  _proto._onWorldRotationQuaternionChanged = function _onWorldRotationQuaternionChanged() {
    var worldRotationQuaternion = this._worldRotationQuaternion;
    var parent = this._getParentTransform();
    if (parent) {
      var invParentQuaternion = Transform2._tempQuat0;
      Quaternion.invert(parent.worldRotationQuaternion, invParentQuaternion);
      Quaternion.multiply(invParentQuaternion, worldRotationQuaternion, this._rotationQuaternion);
    } else {
      this._rotationQuaternion.copyFrom(worldRotationQuaternion);
    }
    this._setDirtyFlagFalse(16);
  };
  _proto._onScaleChanged = function _onScaleChanged() {
    this._setDirtyFlagTrue(64);
    this._updateWorldScaleFlag();
  };
  _create_class$4(Transform2, [
    {
      key: "position",
      get: function get3() {
        return this._position;
      },
      set: function set(value) {
        if (this._position !== value) {
          this._position.copyFrom(value);
        }
      }
    },
    {
      key: "worldPosition",
      get: function get3() {
        var worldPosition = this._worldPosition;
        if (this._isContainDirtyFlag(4)) {
          worldPosition._onValueChanged = null;
          if (this._getParentTransform()) {
            this.worldMatrix.getTranslation(worldPosition);
          } else {
            worldPosition.copyFrom(this._position);
          }
          worldPosition._onValueChanged = this._onWorldPositionChanged;
          this._setDirtyFlagFalse(4);
        }
        return worldPosition;
      },
      set: function set(value) {
        if (this._worldPosition !== value) {
          this._worldPosition.copyFrom(value);
        }
      }
    },
    {
      key: "rotation",
      get: function get3() {
        var rotation = this._rotation;
        if (this._isContainDirtyFlag(1)) {
          rotation._onValueChanged = null;
          this._rotationQuaternion.toEuler(rotation);
          rotation.scale(MathUtil$1.radToDegreeFactor);
          rotation._onValueChanged = this._onRotationChanged;
          this._setDirtyFlagFalse(1);
        }
        return rotation;
      },
      set: function set(value) {
        if (this._rotation !== value) {
          this._rotation.copyFrom(value);
        }
      }
    },
    {
      key: "worldRotation",
      get: function get3() {
        var worldRotation = this._worldRotation;
        if (this._isContainDirtyFlag(8)) {
          worldRotation._onValueChanged = null;
          this.worldRotationQuaternion.toEuler(worldRotation);
          worldRotation.scale(MathUtil$1.radToDegreeFactor);
          worldRotation._onValueChanged = this._onWorldRotationChanged;
          this._setDirtyFlagFalse(8);
        }
        return worldRotation;
      },
      set: function set(value) {
        if (this._worldRotation !== value) {
          this._worldRotation.copyFrom(value);
        }
      }
    },
    {
      key: "rotationQuaternion",
      get: function get3() {
        var rotationQuaternion = this._rotationQuaternion;
        if (this._isContainDirtyFlag(2)) {
          rotationQuaternion._onValueChanged = null;
          Quaternion.rotationEuler(MathUtil$1.degreeToRadian(this._rotation.x), MathUtil$1.degreeToRadian(this._rotation.y), MathUtil$1.degreeToRadian(this._rotation.z), rotationQuaternion);
          rotationQuaternion._onValueChanged = this._onRotationQuaternionChanged;
          this._setDirtyFlagFalse(2);
        }
        return rotationQuaternion;
      },
      set: function set(value) {
        if (this._rotationQuaternion !== value) {
          if (value.normalized) {
            this._rotationQuaternion.copyFrom(value);
          } else {
            Quaternion.normalize(value, this._rotationQuaternion);
          }
        } else {
          value.normalized || value.normalize();
        }
      }
    },
    {
      key: "worldRotationQuaternion",
      get: function get3() {
        var worldRotationQuaternion = this._worldRotationQuaternion;
        if (this._isContainDirtyFlag(16)) {
          worldRotationQuaternion._onValueChanged = null;
          var parent = this._getParentTransform();
          if (parent != null) {
            Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, worldRotationQuaternion);
          } else {
            worldRotationQuaternion.copyFrom(this.rotationQuaternion);
          }
          worldRotationQuaternion._onValueChanged = this._onWorldRotationQuaternionChanged;
          this._setDirtyFlagFalse(16);
        }
        return worldRotationQuaternion;
      },
      set: function set(value) {
        if (this._worldRotationQuaternion !== value) {
          if (value.normalized) {
            this._worldRotationQuaternion.copyFrom(value);
          } else {
            Quaternion.normalize(value, this._worldRotationQuaternion);
          }
        }
        value.normalized || value.normalize();
      }
    },
    {
      key: "scale",
      get: function get3() {
        return this._scale;
      },
      set: function set(value) {
        if (this._scale !== value) {
          this._scale.copyFrom(value);
        }
      }
    },
    {
      key: "lossyWorldScale",
      get: function get3() {
        if (this._isContainDirtyFlag(32)) {
          if (this._getParentTransform()) {
            var scaleMat = this._getScaleMatrix();
            var e = scaleMat.elements;
            this._lossyWorldScale.set(e[0], e[4], e[8]);
          } else {
            this._lossyWorldScale.copyFrom(this._scale);
          }
          this._setDirtyFlagFalse(32);
        }
        return this._lossyWorldScale;
      }
    },
    {
      key: "localMatrix",
      get: function get3() {
        if (this._isContainDirtyFlag(64)) {
          Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
          this._setDirtyFlagFalse(64);
        }
        return this._localMatrix;
      },
      set: function set(value) {
        if (this._localMatrix !== value) {
          this._localMatrix.copyFrom(value);
        }
        this._position._onValueChanged = this._rotationQuaternion._onValueChanged = this._scale._onValueChanged = null;
        this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);
        this._position._onValueChanged = this._onPositionChanged;
        this._rotationQuaternion._onValueChanged = this._onRotationQuaternionChanged;
        this._scale._onValueChanged = this._onScaleChanged;
        this._setDirtyFlagTrue(1);
        this._setDirtyFlagFalse(64 | 2);
        this._updateAllWorldFlag();
      }
    },
    {
      key: "worldMatrix",
      get: function get3() {
        if (this._isContainDirtyFlag(128)) {
          var parent = this._getParentTransform();
          if (parent) {
            Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
          } else {
            this._worldMatrix.copyFrom(this.localMatrix);
          }
          this._setDirtyFlagFalse(128);
        }
        return this._worldMatrix;
      },
      set: function set(value) {
        if (this._worldMatrix !== value) {
          this._worldMatrix.copyFrom(value);
        }
        var parent = this._getParentTransform();
        if (parent) {
          Matrix.invert(parent.worldMatrix, Transform2._tempMat42);
          Matrix.multiply(Transform2._tempMat42, value, this._localMatrix);
        } else {
          this._localMatrix.copyFrom(value);
        }
        this.localMatrix = this._localMatrix;
        this._setDirtyFlagFalse(128);
      }
    },
    {
      key: "worldForward",
      get: function get3() {
        var worldForward = this._worldForward || (this._worldForward = new Vector3());
        var e = this.worldMatrix.elements;
        worldForward.set(-e[8], -e[9], -e[10]);
        return worldForward.normalize();
      }
    },
    {
      key: "worldRight",
      get: function get3() {
        var worldRight = this._worldRight || (this._worldRight = new Vector3());
        var e = this.worldMatrix.elements;
        worldRight.set(e[0], e[1], e[2]);
        return worldRight.normalize();
      }
    },
    {
      key: "worldUp",
      get: function get3() {
        var worldUp = this._worldUp || (this._worldUp = new Vector3());
        var e = this.worldMatrix.elements;
        worldUp.set(e[4], e[5], e[6]);
        return worldUp.normalize();
      }
    }
  ]);
  return Transform2;
}(Component);
(function() {
  Transform._tempQuat0 = new Quaternion();
})();
(function() {
  Transform._tempVec30 = new Vector3();
})();
(function() {
  Transform._tempVec31 = new Vector3();
})();
(function() {
  Transform._tempVec32 = new Vector3();
})();
(function() {
  Transform._tempMat30 = new Matrix3x3();
})();
(function() {
  Transform._tempMat31 = new Matrix3x3();
})();
(function() {
  Transform._tempMat32 = new Matrix3x3();
})();
(function() {
  Transform._tempMat41 = new Matrix();
})();
(function() {
  Transform._tempMat42 = new Matrix();
})();
__decorate$2([
  deepClone
], Transform.prototype, "_position", void 0);
__decorate$2([
  deepClone
], Transform.prototype, "_rotation", void 0);
__decorate$2([
  deepClone
], Transform.prototype, "_rotationQuaternion", void 0);
__decorate$2([
  deepClone
], Transform.prototype, "_scale", void 0);
__decorate$2([
  deepClone
], Transform.prototype, "_worldPosition", void 0);
__decorate$2([
  deepClone
], Transform.prototype, "_worldRotation", void 0);
__decorate$2([
  deepClone
], Transform.prototype, "_worldRotationQuaternion", void 0);
__decorate$2([
  deepClone
], Transform.prototype, "_lossyWorldScale", void 0);
__decorate$2([
  deepClone
], Transform.prototype, "_localMatrix", void 0);
__decorate$2([
  deepClone
], Transform.prototype, "_worldMatrix", void 0);
__decorate$2([
  ignoreClone
], Transform.prototype, "_worldForward", void 0);
__decorate$2([
  ignoreClone
], Transform.prototype, "_worldRight", void 0);
__decorate$2([
  ignoreClone
], Transform.prototype, "_worldUp", void 0);
__decorate$2([
  ignoreClone
], Transform.prototype, "_isParentDirty", void 0);
__decorate$2([
  ignoreClone
], Transform.prototype, "_parentTransformCache", void 0);
__decorate$2([
  ignoreClone
], Transform.prototype, "_updateFlagManager", void 0);
__decorate$2([
  ignoreClone
], Transform.prototype, "_onPositionChanged", null);
__decorate$2([
  ignoreClone
], Transform.prototype, "_onWorldPositionChanged", null);
__decorate$2([
  ignoreClone
], Transform.prototype, "_onRotationChanged", null);
__decorate$2([
  ignoreClone
], Transform.prototype, "_onWorldRotationChanged", null);
__decorate$2([
  ignoreClone
], Transform.prototype, "_onRotationQuaternionChanged", null);
__decorate$2([
  ignoreClone
], Transform.prototype, "_onWorldRotationQuaternionChanged", null);
__decorate$2([
  ignoreClone
], Transform.prototype, "_onScaleChanged", null);
var TransformModifyFlags;
(function(TransformModifyFlags2) {
  TransformModifyFlags2[TransformModifyFlags2["LocalEuler"] = 1] = "LocalEuler";
  TransformModifyFlags2[TransformModifyFlags2["LocalQuat"] = 2] = "LocalQuat";
  TransformModifyFlags2[TransformModifyFlags2["WorldPosition"] = 4] = "WorldPosition";
  TransformModifyFlags2[TransformModifyFlags2["WorldEuler"] = 8] = "WorldEuler";
  TransformModifyFlags2[TransformModifyFlags2["WorldQuat"] = 16] = "WorldQuat";
  TransformModifyFlags2[TransformModifyFlags2["WorldScale"] = 32] = "WorldScale";
  TransformModifyFlags2[TransformModifyFlags2["LocalMatrix"] = 64] = "LocalMatrix";
  TransformModifyFlags2[TransformModifyFlags2["WorldMatrix"] = 128] = "WorldMatrix";
  TransformModifyFlags2[TransformModifyFlags2["WmWp"] = 132] = "WmWp";
  TransformModifyFlags2[TransformModifyFlags2["WmWeWq"] = 152] = "WmWeWq";
  TransformModifyFlags2[TransformModifyFlags2["WmWpWeWq"] = 156] = "WmWpWeWq";
  TransformModifyFlags2[TransformModifyFlags2["WmWs"] = 160] = "WmWs";
  TransformModifyFlags2[TransformModifyFlags2["WmWpWs"] = 164] = "WmWpWs";
  TransformModifyFlags2[TransformModifyFlags2["WmWpWeWqWs"] = 188] = "WmWpWeWqWs";
})(TransformModifyFlags || (TransformModifyFlags = {}));
var ComponentCloner = /* @__PURE__ */ function() {
  function ComponentCloner2() {
  }
  ComponentCloner2.cloneComponent = function cloneComponent(source, target) {
    var cloneModes = CloneManager.getCloneMode(source.constructor);
    var keys = Object.keys(source);
    for (var i = 0, n = keys.length; i < n; i++) {
      var k2 = keys[i];
      var cloneMode = cloneModes[k2];
      switch (cloneMode) {
        case void 0:
        case CloneMode.Assignment:
          target[k2] = source[k2];
          break;
        case CloneMode.Shallow:
          var sourcePropS = source[k2];
          if (_instanceof$2(sourcePropS, Object)) {
            var tarProp = target[k2];
            tarProp == null && (tarProp = target[k2] = sourcePropS.constructor());
            Object.assign(tarProp, sourcePropS);
          } else {
            target[k2] = sourcePropS;
          }
          break;
        case CloneMode.Deep:
          var sourcePropD = source[k2];
          if (_instanceof$2(sourcePropD, Object)) {
            var tarProp1 = target[k2];
            tarProp1 == null && (tarProp1 = target[k2] = sourcePropD.constructor());
            CloneManager.deepCloneObject(sourcePropD, tarProp1);
          } else {
            target[k2] = sourcePropD;
          }
          break;
      }
    }
    if (source._cloneTo) {
      source._cloneTo(target);
    }
  };
  return ComponentCloner2;
}();
var Entity = /* @__PURE__ */ function(EngineObject2) {
  _inherits$2(Entity2, EngineObject2);
  function Entity2(engine, name2) {
    var _this;
    _this = EngineObject2.call(this, engine) || this;
    _this.layer = Layer.Layer0;
    _this._isActiveInHierarchy = false;
    _this._components = [];
    _this._scripts = new DisorderedArray();
    _this._children = [];
    _this._isRoot = false;
    _this._isActive = true;
    _this._siblingIndex = -1;
    _this._parent = null;
    _this._invModelMatrix = new Matrix();
    _this.name = name2;
    _this.transform = _this.addComponent(Transform);
    _this._inverseWorldMatFlag = _this.transform.registerWorldChangeFlag();
    return _this;
  }
  var _proto = Entity2.prototype;
  _proto.addComponent = function addComponent(type) {
    ComponentsDependencies._addCheck(this, type);
    var component = new type(this);
    this._components.push(component);
    component._setActive(true);
    return component;
  };
  _proto.getComponent = function getComponent(type) {
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      var component = components[i];
      if (_instanceof$2(component, type)) {
        return component;
      }
    }
    return null;
  };
  _proto.getComponents = function getComponents(type, results) {
    results.length = 0;
    var components = this._components;
    for (var i = 0, n = components.length; i < n; i++) {
      var component = components[i];
      if (_instanceof$2(component, type)) {
        results.push(component);
      }
    }
    return results;
  };
  _proto.getComponentsIncludeChildren = function getComponentsIncludeChildren(type, results) {
    results.length = 0;
    this._getComponentsInChildren(type, results);
    return results;
  };
  _proto.addChild = function addChild(indexOrChild, child) {
    var index;
    if (typeof indexOrChild === "number") {
      index = indexOrChild;
    } else {
      index = void 0;
      child = indexOrChild;
    }
    if (child._isRoot) {
      child._scene._removeFromEntityList(child);
      child._isRoot = false;
      this._addToChildrenList(index, child);
      child._parent = this;
      var newScene = this._scene;
      if (child._scene !== newScene) {
        Entity2._traverseSetOwnerScene(child, newScene);
      }
      if (this._isActiveInHierarchy) {
        !child._isActiveInHierarchy && child._isActive && child._processActive();
      } else {
        child._isActiveInHierarchy && child._processInActive();
      }
      child._setTransformDirty();
    } else {
      child._setParent(this, index);
    }
  };
  _proto.removeChild = function removeChild(child) {
    child._setParent(null);
  };
  _proto.getChild = function getChild(index) {
    return this._children[index];
  };
  _proto.findByName = function findByName(name2) {
    if (name2 === this.name) {
      return this;
    }
    var children = this._children;
    for (var i = 0, n = children.length; i < n; i++) {
      var target = children[i].findByName(name2);
      if (target) {
        return target;
      }
    }
    return null;
  };
  _proto.findByPath = function findByPath(path) {
    var splits = path.split("/");
    var entity = this;
    for (var i = 0, length2 = splits.length; i < length2; ++i) {
      var split = splits[i];
      if (split) {
        entity = Entity2._findChildByName(entity, split);
        if (!entity) {
          return null;
        }
      }
    }
    return entity;
  };
  _proto.createChild = function createChild(name2) {
    var child = new Entity2(this.engine, name2);
    child.layer = this.layer;
    child.parent = this;
    return child;
  };
  _proto.clearChildren = function clearChildren() {
    var children = this._children;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      child._parent = null;
      child._isActiveInHierarchy && child._processInActive();
      Entity2._traverseSetOwnerScene(child, null);
    }
    children.length = 0;
  };
  _proto.clone = function clone() {
    var cloneEntity = new Entity2(this._engine, this.name);
    var _this = this, hookResource = _this._hookResource;
    if (hookResource) {
      cloneEntity._hookResource = hookResource;
      hookResource._addReferCount(1);
    }
    cloneEntity.layer = this.layer;
    cloneEntity._isActive = this._isActive;
    cloneEntity.transform.localMatrix = this.transform.localMatrix;
    var children = this._children;
    for (var i = 0, len = this._children.length; i < len; i++) {
      var child = children[i];
      cloneEntity.addChild(child.clone());
    }
    var components = this._components;
    for (var i1 = 0, n = components.length; i1 < n; i1++) {
      var sourceComp = components[i1];
      if (!_instanceof$2(sourceComp, Transform)) {
        var targetComp = cloneEntity.addComponent(sourceComp.constructor);
        ComponentCloner.cloneComponent(sourceComp, targetComp);
      }
    }
    return cloneEntity;
  };
  _proto.destroy = function destroy2() {
    if (this._destroyed) {
      return;
    }
    EngineObject2.prototype.destroy.call(this);
    if (this._hookResource) {
      this._hookResource._addReferCount(-1);
      this._hookResource = null;
    }
    this.isActive = false;
    if (this._isRoot) {
      this._scene.removeRootEntity(this);
    } else {
      this._setParent(null);
    }
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      components[i].destroy();
    }
    this._components.length = 0;
    var children = this._children;
    while (children.length > 0) {
      children[0].destroy();
    }
  };
  _proto._removeComponent = function _removeComponent(component) {
    ComponentsDependencies._removeCheck(this, component.constructor);
    var components = this._components;
    components.splice(components.indexOf(component), 1);
  };
  _proto._addScript = function _addScript(script) {
    script._entityScriptsIndex = this._scripts.length;
    this._scripts.add(script);
  };
  _proto._removeScript = function _removeScript(script) {
    var replaced = this._scripts.deleteByIndex(script._entityScriptsIndex);
    replaced && (replaced._entityScriptsIndex = script._entityScriptsIndex);
    script._entityScriptsIndex = -1;
  };
  _proto._removeFromParent = function _removeFromParent() {
    var oldParent = this._parent;
    if (oldParent != null) {
      var oldSibling = oldParent._children;
      var index = this._siblingIndex;
      oldSibling.splice(index, 1);
      for (var n = oldSibling.length; index < n; index++) {
        oldSibling[index]._siblingIndex--;
      }
      this._parent = null;
      this._siblingIndex = -1;
    }
  };
  _proto._processActive = function _processActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(true);
  };
  _proto._processInActive = function _processInActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setInActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(false);
  };
  _proto._addToChildrenList = function _addToChildrenList(index, child) {
    var children = this._children;
    var childCount = children.length;
    if (index === void 0) {
      child._siblingIndex = childCount;
      children.push(child);
    } else {
      if (index < 0 || index > childCount) {
        throw "The index " + index + " is out of child list bounds " + childCount;
      }
      child._siblingIndex = index;
      children.splice(index, 0, child);
      for (var i = index + 1, n = childCount + 1; i < n; i++) {
        children[i]._siblingIndex++;
      }
    }
  };
  _proto._setParent = function _setParent(parent, siblingIndex) {
    var oldParent = this._parent;
    if (parent !== oldParent) {
      this._removeFromParent();
      this._parent = parent;
      if (parent) {
        parent._addToChildrenList(siblingIndex, this);
        var parentScene = parent._scene;
        if (this._scene !== parentScene) {
          Entity2._traverseSetOwnerScene(this, parentScene);
        }
        if (parent._isActiveInHierarchy) {
          !this._isActiveInHierarchy && this._isActive && this._processActive();
        } else {
          this._isActiveInHierarchy && this._processInActive();
        }
      } else {
        this._isActiveInHierarchy && this._processInActive();
        if (oldParent) {
          Entity2._traverseSetOwnerScene(this, null);
        }
      }
      this._setTransformDirty();
    }
  };
  _proto._getComponentsInChildren = function _getComponentsInChildren(type, results) {
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (_instanceof$2(component, type)) {
        results.push(component);
      }
    }
    for (var i1 = this._children.length - 1; i1 >= 0; i1--) {
      this._children[i1]._getComponentsInChildren(type, results);
    }
  };
  _proto._setActiveComponents = function _setActiveComponents(isActive2) {
    var activeChangedComponents = this._activeChangedComponents;
    for (var i = 0, length2 = activeChangedComponents.length; i < length2; ++i) {
      activeChangedComponents[i]._setActive(isActive2);
    }
    this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);
    this._activeChangedComponents = null;
  };
  _proto._setActiveInHierarchy = function _setActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = true;
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      var component = components[i];
      (component.enabled || !component._awoken) && activeChangedComponents.push(component);
    }
    var children = this._children;
    for (var i1 = children.length - 1; i1 >= 0; i1--) {
      var child = children[i1];
      child.isActive && child._setActiveInHierarchy(activeChangedComponents);
    }
  };
  _proto._setInActiveInHierarchy = function _setInActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = false;
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      var component = components[i];
      component.enabled && activeChangedComponents.push(component);
    }
    var children = this._children;
    for (var i1 = children.length - 1; i1 >= 0; i1--) {
      var child = children[i1];
      child.isActive && child._setInActiveInHierarchy(activeChangedComponents);
    }
  };
  _proto._setTransformDirty = function _setTransformDirty() {
    if (this.transform) {
      this.transform._parentChange();
    } else {
      for (var i = 0, len = this._children.length; i < len; i++) {
        this._children[i]._setTransformDirty();
      }
    }
  };
  _proto._setSiblingIndex = function _setSiblingIndex(sibling, target) {
    target = Math.min(target, sibling.length - 1);
    if (target < 0) {
      throw "Sibling index " + target + " should large than 0";
    }
    if (this._siblingIndex !== target) {
      var oldIndex = this._siblingIndex;
      if (target < oldIndex) {
        for (var i = oldIndex; i >= target; i--) {
          var child = i == target ? this : sibling[i - 1];
          sibling[i] = child;
          child._siblingIndex = i;
        }
      } else {
        for (var i1 = oldIndex; i1 <= target; i1++) {
          var child1 = i1 == target ? this : sibling[i1 + 1];
          sibling[i1] = child1;
          child1._siblingIndex = i1;
        }
      }
    }
  };
  _proto.getInvModelMatrix = function getInvModelMatrix() {
    if (this._inverseWorldMatFlag.flag) {
      Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
      this._inverseWorldMatFlag.flag = false;
    }
    return this._invModelMatrix;
  };
  Entity2._findChildByName = function _findChildByName(root, name2) {
    var children = root._children;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if (child.name === name2) {
        return child;
      }
    }
    return null;
  };
  Entity2._traverseSetOwnerScene = function _traverseSetOwnerScene(entity, scene) {
    entity._scene = scene;
    var children = entity._children;
    for (var i = entity.childCount - 1; i >= 0; i--) {
      this._traverseSetOwnerScene(children[i], scene);
    }
  };
  _create_class$4(Entity2, [
    {
      key: "isActive",
      get: function get3() {
        return this._isActive;
      },
      set: function set(value) {
        if (value !== this._isActive) {
          this._isActive = value;
          if (value) {
            var parent = this._parent;
            if ((parent == null ? void 0 : parent._isActiveInHierarchy) || this._isRoot && this._scene._isActiveInEngine) {
              this._processActive();
            }
          } else {
            if (this._isActiveInHierarchy) {
              this._processInActive();
            }
          }
        }
      }
    },
    {
      key: "isActiveInHierarchy",
      get: function get3() {
        return this._isActiveInHierarchy;
      }
    },
    {
      key: "parent",
      get: function get3() {
        return this._parent;
      },
      set: function set(value) {
        this._setParent(value);
      }
    },
    {
      key: "children",
      get: function get3() {
        return this._children;
      }
    },
    {
      key: "childCount",
      get: function get3() {
        return this._children.length;
      }
    },
    {
      key: "scene",
      get: function get3() {
        return this._scene;
      }
    },
    {
      key: "siblingIndex",
      get: function get3() {
        return this._siblingIndex;
      },
      set: function set(value) {
        if (this._siblingIndex === -1) {
          throw "The entity " + this.name + " is not in the hierarchy";
        }
        this._setSiblingIndex(this._isRoot ? this._scene._rootEntities : this._parent._children, value);
      }
    }
  ]);
  return Entity2;
}(EngineObject);
var ClassPool = /* @__PURE__ */ function() {
  function ClassPool2(type) {
    this._elementPoolIndex = 0;
    this._elementPool = [];
    this._type = type;
  }
  var _proto = ClassPool2.prototype;
  _proto.getFromPool = function getFromPool() {
    var _this = this, index = _this._elementPoolIndex, pool = _this._elementPool;
    this._elementPoolIndex++;
    if (pool.length === index) {
      var element = new this._type();
      pool.push(element);
      return element;
    } else {
      return pool[index];
    }
  };
  _proto.resetPool = function resetPool() {
    this._elementPoolIndex = 0;
  };
  _proto.garbageCollection = function garbageCollection() {
    var _this = this, pool = _this._elementPool;
    for (var i = pool.length - 1; i >= 0; i--) {
      pool[i].dispose && pool[i].dispose();
    }
  };
  return ClassPool2;
}();
var RenderData = function RenderData2() {
};
var MeshRenderData = /* @__PURE__ */ function(RenderData3) {
  _inherits$2(MeshRenderData2, RenderData3);
  function MeshRenderData2() {
    return RenderData3.apply(this, arguments);
  }
  var _proto = MeshRenderData2.prototype;
  _proto.set = function set(component, material, mesh, subMesh) {
    this.component = component;
    this.material = material;
    this.mesh = mesh;
    this.subMesh = subMesh;
  };
  _proto.dispose = function dispose() {
    this.component = this.material = this.mesh = this.subMesh = null;
  };
  return MeshRenderData2;
}(RenderData);
var BlendFactor;
(function(BlendFactor2) {
  BlendFactor2[BlendFactor2["Zero"] = 0] = "Zero";
  BlendFactor2[BlendFactor2["One"] = 1] = "One";
  BlendFactor2[BlendFactor2["SourceColor"] = 2] = "SourceColor";
  BlendFactor2[BlendFactor2["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
  BlendFactor2[BlendFactor2["DestinationColor"] = 4] = "DestinationColor";
  BlendFactor2[BlendFactor2["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
  BlendFactor2[BlendFactor2["SourceAlpha"] = 6] = "SourceAlpha";
  BlendFactor2[BlendFactor2["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
  BlendFactor2[BlendFactor2["DestinationAlpha"] = 8] = "DestinationAlpha";
  BlendFactor2[BlendFactor2["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
  BlendFactor2[BlendFactor2["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
  BlendFactor2[BlendFactor2["BlendColor"] = 11] = "BlendColor";
  BlendFactor2[BlendFactor2["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
})(BlendFactor || (BlendFactor = {}));
var BlendOperation;
(function(BlendOperation2) {
  BlendOperation2[BlendOperation2["Add"] = 0] = "Add";
  BlendOperation2[BlendOperation2["Subtract"] = 1] = "Subtract";
  BlendOperation2[BlendOperation2["ReverseSubtract"] = 2] = "ReverseSubtract";
  BlendOperation2[BlendOperation2["Min"] = 3] = "Min";
  BlendOperation2[BlendOperation2["Max"] = 4] = "Max";
})(BlendOperation || (BlendOperation = {}));
var ColorWriteMask;
(function(ColorWriteMask2) {
  ColorWriteMask2[ColorWriteMask2["None"] = 0] = "None";
  ColorWriteMask2[ColorWriteMask2["Red"] = 1] = "Red";
  ColorWriteMask2[ColorWriteMask2["Green"] = 2] = "Green";
  ColorWriteMask2[ColorWriteMask2["Blue"] = 4] = "Blue";
  ColorWriteMask2[ColorWriteMask2["Alpha"] = 8] = "Alpha";
  ColorWriteMask2[ColorWriteMask2["All"] = 15] = "All";
})(ColorWriteMask || (ColorWriteMask = {}));
var CompareFunction;
(function(CompareFunction2) {
  CompareFunction2[CompareFunction2["Never"] = 0] = "Never";
  CompareFunction2[CompareFunction2["Less"] = 1] = "Less";
  CompareFunction2[CompareFunction2["Equal"] = 2] = "Equal";
  CompareFunction2[CompareFunction2["LessEqual"] = 3] = "LessEqual";
  CompareFunction2[CompareFunction2["Greater"] = 4] = "Greater";
  CompareFunction2[CompareFunction2["NotEqual"] = 5] = "NotEqual";
  CompareFunction2[CompareFunction2["GreaterEqual"] = 6] = "GreaterEqual";
  CompareFunction2[CompareFunction2["Always"] = 7] = "Always";
})(CompareFunction || (CompareFunction = {}));
var CullMode;
(function(CullMode2) {
  CullMode2[CullMode2["Off"] = 0] = "Off";
  CullMode2[CullMode2["Front"] = 1] = "Front";
  CullMode2[CullMode2["Back"] = 2] = "Back";
})(CullMode || (CullMode = {}));
var RenderQueueType;
(function(RenderQueueType2) {
  RenderQueueType2[RenderQueueType2["Opaque"] = 0] = "Opaque";
  RenderQueueType2[RenderQueueType2["AlphaTest"] = 1] = "AlphaTest";
  RenderQueueType2[RenderQueueType2["Transparent"] = 2] = "Transparent";
})(RenderQueueType || (RenderQueueType = {}));
var ShaderPropertyType;
(function(ShaderPropertyType2) {
  ShaderPropertyType2[ShaderPropertyType2["Float"] = 0] = "Float";
  ShaderPropertyType2[ShaderPropertyType2["Int"] = 1] = "Int";
  ShaderPropertyType2[ShaderPropertyType2["Vector2"] = 2] = "Vector2";
  ShaderPropertyType2[ShaderPropertyType2["Vector3"] = 3] = "Vector3";
  ShaderPropertyType2[ShaderPropertyType2["Vector4"] = 4] = "Vector4";
  ShaderPropertyType2[ShaderPropertyType2["Matrix"] = 5] = "Matrix";
  ShaderPropertyType2[ShaderPropertyType2["Color"] = 6] = "Color";
  ShaderPropertyType2[ShaderPropertyType2["Texture"] = 7] = "Texture";
  ShaderPropertyType2[ShaderPropertyType2["FloatArray"] = 8] = "FloatArray";
  ShaderPropertyType2[ShaderPropertyType2["IntArray"] = 9] = "IntArray";
  ShaderPropertyType2[ShaderPropertyType2["TextureArray"] = 10] = "TextureArray";
})(ShaderPropertyType || (ShaderPropertyType = {}));
var StencilOperation;
(function(StencilOperation2) {
  StencilOperation2[StencilOperation2["Keep"] = 0] = "Keep";
  StencilOperation2[StencilOperation2["Zero"] = 1] = "Zero";
  StencilOperation2[StencilOperation2["Replace"] = 2] = "Replace";
  StencilOperation2[StencilOperation2["IncrementSaturate"] = 3] = "IncrementSaturate";
  StencilOperation2[StencilOperation2["DecrementSaturate"] = 4] = "DecrementSaturate";
  StencilOperation2[StencilOperation2["Invert"] = 5] = "Invert";
  StencilOperation2[StencilOperation2["IncrementWrap"] = 6] = "IncrementWrap";
  StencilOperation2[StencilOperation2["DecrementWrap"] = 7] = "DecrementWrap";
})(StencilOperation || (StencilOperation = {}));
var ShaderMacro = /* @__PURE__ */ function() {
  function ShaderMacro2(name2, value, maskIndex, maskValue) {
    this.name = name2;
    this._maskIndex = maskIndex;
    this._maskValue = maskValue;
    this.value = value;
    var macroNameIDMap = ShaderMacro2._macroNameIdMap;
    var nameID = macroNameIDMap[name2];
    if (macroNameIDMap[name2] === void 0) {
      macroNameIDMap[name2] = nameID = ShaderMacro2._macroNameCounter++;
    }
    this._nameId = nameID;
  }
  ShaderMacro2.getByName = function getByName(name2, value) {
    var key = value ? name2 + " " + value : name2;
    var macro = ShaderMacro2._macroMap[key];
    if (!macro) {
      var maskMap = ShaderMacro2._macroMaskMap;
      var counter = ShaderMacro2._macroCounter;
      var index = Math.floor(counter / 32);
      var bit = counter % 32;
      macro = new ShaderMacro2(name2, value, index, 1 << bit);
      ShaderMacro2._macroMap[key] = macro;
      if (index == maskMap.length) {
        maskMap.length++;
        maskMap[index] = new Array(32);
      }
      maskMap[index][bit] = key;
      ShaderMacro2._macroCounter++;
    }
    return macro;
  };
  ShaderMacro2._getNamesByMacros = function _getNamesByMacros(macros, out) {
    var maskMap = ShaderMacro2._macroMaskMap;
    var mask = macros._mask;
    out.length = 0;
    for (var i = 0, n = macros._length; i < n; i++) {
      var subMaskMap = maskMap[i];
      var subMask = mask[i];
      var m = subMask < 0 ? 32 : Math.floor(Math.log2(subMask)) + 1;
      for (var j2 = 0; j2 < m; j2++) {
        if (subMask & 1 << j2) {
          out.push(subMaskMap[j2]);
        }
      }
    }
  };
  return ShaderMacro2;
}();
(function() {
  ShaderMacro._macroMaskMap = [];
})();
(function() {
  ShaderMacro._macroNameIdMap = /* @__PURE__ */ Object.create(null);
})();
(function() {
  ShaderMacro._macroNameCounter = 0;
})();
(function() {
  ShaderMacro._macroCounter = 0;
})();
(function() {
  ShaderMacro._macroMap = /* @__PURE__ */ Object.create(null);
})();
var ShaderMacroCollection = /* @__PURE__ */ function() {
  function ShaderMacroCollection2() {
    this._mask = [];
    this._length = 0;
  }
  var _proto = ShaderMacroCollection2.prototype;
  _proto.enable = function enable2(macro) {
    var index = macro._maskIndex;
    var size = index + 1;
    var mask = this._mask;
    var maskStart = this._length;
    if (maskStart < size) {
      mask.length < size && (mask.length = size);
      for (; maskStart < index; maskStart++) {
        mask[maskStart] = 0;
      }
      mask[index] = macro._maskValue;
      this._length = size;
    } else {
      mask[index] |= macro._maskValue;
    }
  };
  _proto.disable = function disable2(macro) {
    var index = macro._maskIndex;
    var mask = this._mask;
    var endIndex = this._length - 1;
    if (index > endIndex) {
      return;
    }
    var newValue = mask[index] & ~macro._maskValue;
    if (index == endIndex && newValue === 0) {
      this._length--;
    } else {
      mask[index] = newValue;
    }
  };
  _proto.unionCollection = function unionCollection(macroCollection) {
    var addMask = macroCollection._mask;
    var addSize = macroCollection._length;
    var mask = this._mask;
    var maskSize = this._length;
    if (maskSize < addSize) {
      mask.length < addSize && (mask.length = addSize);
      var i = 0;
      for (; i < maskSize; i++) {
        mask[i] |= addMask[i];
      }
      for (; i < addSize; i++) {
        mask[i] = addMask[i];
      }
      this._length = addSize;
    } else {
      for (var i1 = 0; i1 < addSize; i1++) {
        mask[i1] |= addMask[i1];
      }
    }
  };
  _proto.complementaryCollection = function complementaryCollection(macroCollection) {
    var removeMask = macroCollection._mask;
    var mask = this._mask;
    var endIndex = this._length - 1;
    var i = Math.min(macroCollection._length - 1, endIndex);
    for (; i >= 0; i--) {
      var newValue = mask[i] & ~removeMask[i];
      if (i == endIndex && newValue === 0) {
        endIndex--;
        this._length--;
      } else {
        mask[i] = newValue;
      }
    }
  };
  _proto.intersectionCollection = function intersectionCollection(macroCollection) {
    var unionMask = macroCollection._mask;
    var mask = this._mask;
    for (var i = this._length - 1; i >= 0; i--) {
      var value = mask[i] & unionMask[i];
      if (value == 0 && i == this._length - 1) {
        this._length--;
      } else {
        mask[i] = value;
      }
    }
  };
  _proto.isEnable = function isEnable(macro) {
    var index = macro._maskIndex;
    if (index >= this._length) {
      return false;
    }
    return (this._mask[index] & macro._maskValue) !== 0;
  };
  _proto.clear = function clear() {
    this._length = 0;
  };
  ShaderMacroCollection2.unionCollection = function unionCollection(left, right, out) {
    var outMask = out._mask;
    var minSize, maxSize;
    var minMask, maxMask;
    if (left._length < right._length) {
      minSize = left._length;
      maxSize = right._length;
      minMask = left._mask;
      maxMask = right._mask;
    } else {
      minSize = right._length;
      maxSize = left._length;
      minMask = right._mask;
      maxMask = left._mask;
    }
    var i = 0;
    outMask.length < maxSize && (outMask.length = maxSize);
    for (; i < minSize; i++) {
      outMask[i] = minMask[i] | maxMask[i];
    }
    for (; i < maxSize; i++) {
      outMask[i] = maxMask[i];
    }
    out._length = maxSize;
  };
  return ShaderMacroCollection2;
}();
var PipelineStage;
(function(PipelineStage2) {
  PipelineStage2["ShadowCaster"] = "ShadowCaster";
  PipelineStage2["Forward"] = "Forward";
})(PipelineStage || (PipelineStage = {}));
function _extends$2() {
  _extends$2 = Object.assign || function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        if (Object.prototype.hasOwnProperty.call(source, key))
          target[key] = source[key];
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var camera_declare = "#define GLSLIFY 1\nuniform vec3 camera_Position;";
var common = "#define GLSLIFY 1\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate( a ) clamp( a, 0.0, 1.0 )\nfloat pow2(float x){return x*x;}vec4 RGBMToLinear(vec4 value,float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 gammaToLinear(vec4 srgbIn){return vec4(pow(srgbIn.rgb,vec3(2.2)),srgbIn.a);}vec4 linearToGamma(vec4 linearIn){return vec4(pow(linearIn.rgb,vec3(1.0/2.2)),linearIn.a);}\n#ifdef GRAPHICS_API_WEBGL2\n#define INVERSE_MAT(mat) inverse(mat)\n#else\nmat2 inverseMat(mat2 m){return mat2(m[1][1],-m[0][1],-m[1][0],m[0][0])/(m[0][0]*m[1][1]-m[0][1]*m[1][0]);}mat3 inverseMat(mat3 m){float a00=m[0][0],a01=m[0][1],a02=m[0][2];float a10=m[1][0],a11=m[1][1],a12=m[1][2];float a20=m[2][0],a21=m[2][1],a22=m[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}mat4 inverseMat(mat4 m){float a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32,det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;return mat4(a11*b11-a12*b10+a13*b09,a02*b10-a01*b11-a03*b09,a31*b05-a32*b04+a33*b03,a22*b04-a21*b05-a23*b03,a12*b08-a10*b11-a13*b07,a00*b11-a02*b08+a03*b07,a32*b02-a30*b05-a33*b01,a20*b05-a22*b02+a23*b01,a10*b10-a11*b08+a13*b06,a01*b08-a00*b10-a03*b06,a30*b04-a31*b02+a33*b00,a21*b02-a20*b04-a23*b00,a11*b07-a10*b09-a12*b06,a00*b09-a01*b07+a02*b06,a31*b01-a30*b03-a32*b00,a20*b03-a21*b01+a22*b00)/det;}\n#define INVERSE_MAT(mat) inverseMat(mat)\n#endif\n";
var common_vert = "#define GLSLIFY 1\nattribute vec3 POSITION;\n#ifdef RENDERER_HAS_UV\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef RENDERER_HAS_UV1\nattribute vec2 TEXCOORD_1;\n#endif\n#ifdef RENDERER_HAS_SKIN\nattribute vec4 JOINTS_0;attribute vec4 WEIGHTS_0;\n#ifdef RENDERER_USE_JOINT_TEXTURE\nuniform sampler2D renderer_JointSampler;uniform float renderer_JointCount;mat4 getJointMatrix(sampler2D smp,float index){float base=index/renderer_JointCount;float hf=0.5/renderer_JointCount;float v=base+hf;vec4 m0=texture2D(smp,vec2(0.125,v));vec4 m1=texture2D(smp,vec2(0.375,v));vec4 m2=texture2D(smp,vec2(0.625,v));vec4 m3=texture2D(smp,vec2(0.875,v));return mat4(m0,m1,m2,m3);}\n#else\nuniform mat4 renderer_JointMatrix[RENDERER_JOINTS_NUM];\n#endif\n#endif\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\nattribute vec4 COLOR_0;\n#endif\n#include <transform_declare>\n#include <camera_declare>\nuniform vec4 material_TilingOffset;\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nattribute vec3 NORMAL;\n#endif\n#ifdef RENDERER_HAS_TANGENT\nattribute vec4 TANGENT;\n#endif\n#endif\n";
var transform_declare = "#define GLSLIFY 1\nuniform mat4 renderer_LocalMat;uniform mat4 renderer_ModelMat;uniform mat4 camera_ViewMat;uniform mat4 camera_ProjMat;uniform mat4 renderer_MVMat;uniform mat4 renderer_MVPMat;uniform mat4 renderer_NormalMat;";
var color_share = "#define GLSLIFY 1\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\nvarying vec4 v_color;\n#endif\n";
var FogFragmentDeclaration = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\nvarying vec3 v_positionVS;uniform vec4 scene_FogColor;uniform vec4 scene_FogParams;float ComputeFogIntensity(float fogDepth){\n#if SCENE_FOG_MODE == 1\nreturn clamp(fogDepth*scene_FogParams.x+scene_FogParams.y,0.0,1.0);\n#elif SCENE_FOG_MODE == 2\nreturn clamp(exp2(-fogDepth*scene_FogParams.z),0.0,1.0);\n#elif SCENE_FOG_MODE == 3\nfloat factor=fogDepth*scene_FogParams.w;return clamp(exp2(-factor*factor),0.0,1.0);\n#endif\n}\n#endif\n";
var FogVertexDeclaration = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\nvarying vec3 v_positionVS;\n#endif\n";
var normal_share = "#define GLSLIFY 1\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nvarying vec3 v_normal;\n#if defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\nvarying mat3 v_TBN;\n#endif\n#endif\n#endif\n";
var uv_share = "#define GLSLIFY 1\nvarying vec2 v_uv;\n#ifdef RENDERER_HAS_UV1\nvarying vec2 v_uv1;\n#endif\n";
var worldpos_share = "#define GLSLIFY 1\n#ifdef MATERIAL_NEED_WORLD_POS\nvarying vec3 v_pos;\n#endif\n";
var begin_normal_vert = "#define GLSLIFY 1\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nvec3 normal=vec3(NORMAL);\n#endif\n#ifdef RENDERER_HAS_TANGENT\nvec4 tangent=vec4(TANGENT);\n#endif\n#endif\n";
var begin_position_vert = "#define GLSLIFY 1\nvec4 position=vec4(POSITION,1.0);";
var blendShape_input = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_BLENDSHAPE\n#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\nuniform mediump sampler2DArray renderer_BlendShapeTexture;uniform ivec3 renderer_BlendShapeTextureInfo;uniform float renderer_BlendShapeWeights[RENDERER_BLENDSHAPE_COUNT];\n#else\nattribute vec3 POSITION_BS0;attribute vec3 POSITION_BS1;\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;uniform float renderer_BlendShapeWeights[2];\n#else\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\nattribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;\n#ifdef RENDERER_BLENDSHAPE_HAS_NORMAL\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 NORMAL_BS2;attribute vec3 NORMAL_BS3;\n#endif\n#ifdef RENDERER_BLENDSHAPE_HAS_TANGENT\nattribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;attribute vec3 TANGENT_BS2;attribute vec3 TANGENT_BS3;\n#endif\nuniform float renderer_BlendShapeWeights[4];\n#else\nattribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;attribute vec3 POSITION_BS4;attribute vec3 POSITION_BS5;attribute vec3 POSITION_BS6;attribute vec3 POSITION_BS7;uniform float renderer_BlendShapeWeights[8];\n#endif\n#endif\n#endif\n#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\nvec3 getBlendShapeVertexElement(int blendShapeIndex,int vertexElementIndex){int y=vertexElementIndex/renderer_BlendShapeTextureInfo.y;int x=vertexElementIndex-y*renderer_BlendShapeTextureInfo.y;ivec3 uv=ivec3(x,y,blendShapeIndex);return texelFetch(renderer_BlendShapeTexture,uv,0).xyz;}\n#endif\n#endif\n";
var blendShape_vert = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_BLENDSHAPE\n#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\nint vertexOffset=gl_VertexID*renderer_BlendShapeTextureInfo.x;for(int i=0;i<RENDERER_BLENDSHAPE_COUNT;i++){int vertexElementOffset=vertexOffset;float weight=renderer_BlendShapeWeights[i];position.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#ifndef MATERIAL_OMIT_NORMAL\n#if defined( RENDERER_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_NORMAL )\nvertexElementOffset+=1;normal+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#if defined( RENDERER_HAS_TANGENT ) && defined(RENDERER_BLENDSHAPE_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\nvertexElementOffset+=1;tangent.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#endif\n}\n#else\nposition.xyz+=POSITION_BS0*renderer_BlendShapeWeights[0];position.xyz+=POSITION_BS1*renderer_BlendShapeWeights[1];\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nnormal+=NORMAL_BS0*renderer_BlendShapeWeights[0];normal+=NORMAL_BS1*renderer_BlendShapeWeights[1];\n#endif\n#if defined( RENDERER_HAS_TANGENT ) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\ntangent.xyz+=TANGENT_BS0*renderer_BlendShapeWeights[0];tangent.xyz+=TANGENT_BS1*renderer_BlendShapeWeights[1];\n#endif\n#endif\n#else\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n#ifndef MATERIAL_OMIT_NORMAL\nposition.xyz+=POSITION_BS2*renderer_BlendShapeWeights[2];position.xyz+=POSITION_BS3*renderer_BlendShapeWeights[3];\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_HAS_NORMAL )\nnormal+=NORMAL_BS0*renderer_BlendShapeWeights[0];normal+=NORMAL_BS1*renderer_BlendShapeWeights[1];normal+=NORMAL_BS2*renderer_BlendShapeWeights[2];normal+=NORMAL_BS3*renderer_BlendShapeWeights[3];\n#endif\n#if defined(RENDERER_BLENDSHAPE_HAS_TANGENT) && defined( RENDERER_HAS_TANGENT ) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\ntangent.xyz+=TANGENT_BS0*renderer_BlendShapeWeights[0];tangent.xyz+=TANGENT_BS1*renderer_BlendShapeWeights[1];tangent.xyz+=TANGENT_BS2*renderer_BlendShapeWeights[2];tangent.xyz+=TANGENT_BS3*renderer_BlendShapeWeights[3];\n#endif\n#endif\n#else\nposition.xyz+=POSITION_BS2*renderer_BlendShapeWeights[2];position.xyz+=POSITION_BS3*renderer_BlendShapeWeights[3];position.xyz+=POSITION_BS4*renderer_BlendShapeWeights[4];position.xyz+=POSITION_BS5*renderer_BlendShapeWeights[5];position.xyz+=POSITION_BS6*renderer_BlendShapeWeights[6];position.xyz+=POSITION_BS7*renderer_BlendShapeWeights[7];\n#endif\n#endif\n#endif\n#endif\n";
var color_vert = "#define GLSLIFY 1\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\nv_color=COLOR_0;\n#endif\n";
var FogVertex = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\nvec4 positionVS=renderer_MVMat*position;v_positionVS=positionVS.xyz/positionVS.w;\n#endif\n";
var normal_vert = "#define GLSLIFY 1\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nv_normal=normalize(mat3(renderer_NormalMat)*normal);\n#if defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\nvec3 normalW=normalize(mat3(renderer_NormalMat)*normal.xyz);vec3 tangentW=normalize(mat3(renderer_NormalMat)*tangent.xyz);vec3 bitangentW=cross(normalW,tangentW)*tangent.w;v_TBN=mat3(tangentW,bitangentW,normalW);\n#endif\n#endif\n#endif\n";
var position_vert = "#define GLSLIFY 1\ngl_Position=renderer_MVPMat*position;";
var skinning_vert = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_SKIN\n#ifdef RENDERER_USE_JOINT_TEXTURE\nmat4 skinMatrix=WEIGHTS_0.x*getJointMatrix(renderer_JointSampler,JOINTS_0.x)+WEIGHTS_0.y*getJointMatrix(renderer_JointSampler,JOINTS_0.y)+WEIGHTS_0.z*getJointMatrix(renderer_JointSampler,JOINTS_0.z)+WEIGHTS_0.w*getJointMatrix(renderer_JointSampler,JOINTS_0.w);\n#else\nmat4 skinMatrix=WEIGHTS_0.x*renderer_JointMatrix[int(JOINTS_0.x)]+WEIGHTS_0.y*renderer_JointMatrix[int(JOINTS_0.y)]+WEIGHTS_0.z*renderer_JointMatrix[int(JOINTS_0.z)]+WEIGHTS_0.w*renderer_JointMatrix[int(JOINTS_0.w)];\n#endif\nposition=skinMatrix*position;\n#if defined(RENDERER_HAS_NORMAL) && !defined(MATERIAL_OMIT_NORMAL)\nmat3 skinNormalMatrix=INVERSE_MAT(mat3(skinMatrix));normal=normal*skinNormalMatrix;\n#if defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\ntangent.xyz=tangent.xyz*skinNormalMatrix;\n#endif\n#endif\n#endif\n";
var uv_vert = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_UV\nv_uv=TEXCOORD_0;\n#else\nv_uv=vec2(0.,0.);\n#endif\n#ifdef RENDERER_HAS_UV1\nv_uv1=TEXCOORD_1;\n#endif\n#ifdef MATERIAL_NEED_TILING_OFFSET\nv_uv=v_uv*material_TilingOffset.xy+material_TilingOffset.zw;\n#endif\n";
var worldpos_vert = "#define GLSLIFY 1\n#ifdef MATERIAL_NEED_WORLD_POS\nvec4 temp_pos=renderer_ModelMat*position;v_pos=temp_pos.xyz/temp_pos.w;\n#endif\n";
var FogFragment = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\nfloat fogIntensity=ComputeFogIntensity(length(v_positionVS));gl_FragColor.rgb=mix(scene_FogColor.rgb,gl_FragColor.rgb,fogIntensity);\n#endif\n";
var light_frag_define = "#define GLSLIFY 1\n#ifdef SCENE_DIRECT_LIGHT_COUNT\nstruct DirectLight{vec3 color;vec3 direction;};uniform ivec2 scene_DirectLightCullingMask[SCENE_DIRECT_LIGHT_COUNT];uniform vec3 scene_DirectLightColor[SCENE_DIRECT_LIGHT_COUNT];uniform vec3 scene_DirectLightDirection[SCENE_DIRECT_LIGHT_COUNT];\n#endif\n#ifdef SCENE_POINT_LIGHT_COUNT\nstruct PointLight{vec3 color;vec3 position;float distance;};uniform ivec2 scene_PointLightCullingMask[SCENE_POINT_LIGHT_COUNT];uniform vec3 scene_PointLightColor[SCENE_POINT_LIGHT_COUNT];uniform vec3 scene_PointLightPosition[SCENE_POINT_LIGHT_COUNT];uniform float scene_PointLightDistance[SCENE_POINT_LIGHT_COUNT];\n#endif\n#ifdef SCENE_SPOT_LIGHT_COUNT\nstruct SpotLight{vec3 color;vec3 position;vec3 direction;float distance;float angleCos;float penumbraCos;};uniform ivec2 scene_SpotLightCullingMask[SCENE_SPOT_LIGHT_COUNT];uniform vec3 scene_SpotLightColor[SCENE_SPOT_LIGHT_COUNT];uniform vec3 scene_SpotLightPosition[SCENE_SPOT_LIGHT_COUNT];uniform vec3 scene_SpotLightDirection[SCENE_SPOT_LIGHT_COUNT];uniform float scene_SpotLightDistance[SCENE_SPOT_LIGHT_COUNT];uniform float scene_SpotLightAngleCos[SCENE_SPOT_LIGHT_COUNT];uniform float scene_SpotLightPenumbraCos[SCENE_SPOT_LIGHT_COUNT];\n#endif\nstruct EnvMapLight{vec3 diffuse;float mipMapLevel;float diffuseIntensity;float specularIntensity;};uniform EnvMapLight scene_EnvMapLight;uniform ivec4 renderer_Layer;\n#ifdef SCENE_USE_SH\nuniform vec3 scene_EnvSH[9];\n#endif\n#ifdef SCENE_USE_SPECULAR_ENV\nuniform samplerCube scene_EnvSpecularSampler;\n#endif\n#ifndef GRAPHICS_API_WEBGL2\nbool isBitSet(float value,float mask,float bitIndex){return mod(floor(value/pow(2.0,bitIndex)),2.0)==1.0&&mod(floor(mask/pow(2.0,bitIndex)),2.0)==1.0;}\n#endif\nbool isRendererCulledByLight(ivec2 rendererLayer,ivec2 lightCullingMask){\n#ifdef GRAPHICS_API_WEBGL2\nreturn!((rendererLayer.x&lightCullingMask.x)!=0||(rendererLayer.y&lightCullingMask.y)!=0);\n#else\nfor(int i=0;i<16;i++){if(isBitSet(float(rendererLayer.x),float(lightCullingMask.x),float(i))||isBitSet(float(rendererLayer.y),float(lightCullingMask.y),float(i))){return false;}}return true;\n#endif\n}";
var mobile_material_frag = "#define GLSLIFY 1\nuniform vec4 material_EmissiveColor;uniform vec4 material_BaseColor;uniform vec4 material_SpecularColor;uniform float material_Shininess;uniform float material_NormalIntensity;uniform float material_AlphaCutoff;\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\nuniform sampler2D material_EmissiveTexture;\n#endif\n#ifdef MATERIAL_HAS_BASETEXTURE\nuniform sampler2D material_BaseTexture;\n#endif\n#ifdef MATERIAL_HAS_SPECULAR_TEXTURE\nuniform sampler2D material_SpecularTexture;\n#endif\n#ifdef MATERIAL_HAS_NORMALTEXTURE\nuniform sampler2D material_NormalTexture;\n#endif\n";
var begin_mobile_frag = "#define GLSLIFY 1\nvec4 ambient=vec4(0.0);vec4 emission=material_EmissiveColor;vec4 diffuse=material_BaseColor;vec4 specular=material_SpecularColor;\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\nvec4 emissiveTextureColor=texture2D(material_EmissiveTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nemissiveTextureColor=gammaToLinear(emissiveTextureColor);\n#endif\nemission*=emissiveTextureColor;\n#endif\n#ifdef MATERIAL_HAS_BASETEXTURE\nvec4 diffuseTextureColor=texture2D(material_BaseTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ndiffuseTextureColor=gammaToLinear(diffuseTextureColor);\n#endif\ndiffuse*=diffuseTextureColor;\n#endif\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\ndiffuse*=v_color;\n#endif\n#ifdef MATERIAL_HAS_SPECULAR_TEXTURE\nvec4 specularTextureColor=texture2D(material_SpecularTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nspecularTextureColor=gammaToLinear(specularTextureColor);\n#endif\nspecular*=specularTextureColor;\n#endif\nambient=vec4(scene_EnvMapLight.diffuse*scene_EnvMapLight.diffuseIntensity,1.0)*diffuse;";
var begin_viewdir_frag = "#define GLSLIFY 1\n#ifdef MATERIAL_NEED_WORLD_POS\nvec3 V=normalize(camera_Position-v_pos);\n#endif\n";
var mobile_blinnphong_frag = "#define GLSLIFY 1\n#ifdef MATERIAL_HAS_NORMALTEXTURE\nmat3 tbn=getTBN(gl_FrontFacing);vec3 N=getNormalByNormalTexture(tbn,material_NormalTexture,material_NormalIntensity,v_uv,gl_FrontFacing);\n#else\nvec3 N=getNormal(gl_FrontFacing);\n#endif\nvec3 lightDiffuse=vec3(0.0,0.0,0.0);vec3 lightSpecular=vec3(0.0,0.0,0.0);float shadowAttenuation=1.0;\n#ifdef SCENE_DIRECT_LIGHT_COUNT\nshadowAttenuation=1.0;\n#ifdef SCENE_IS_CALCULATE_SHADOWS\nshadowAttenuation*=sampleShadowMap();\n#endif\nDirectLight directionalLight;for(int i=0;i<SCENE_DIRECT_LIGHT_COUNT;i++){if(!isRendererCulledByLight(renderer_Layer.xy,scene_DirectLightCullingMask[i])){directionalLight.color=scene_DirectLightColor[i];\n#ifdef SCENE_IS_CALCULATE_SHADOWS\nif(i==0){directionalLight.color*=shadowAttenuation;}\n#endif\ndirectionalLight.direction=scene_DirectLightDirection[i];float d=max(dot(N,-directionalLight.direction),0.0);lightDiffuse+=directionalLight.color*d;vec3 halfDir=normalize(V-directionalLight.direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),material_Shininess);lightSpecular+=directionalLight.color*s;}}\n#endif\n#ifdef SCENE_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<SCENE_POINT_LIGHT_COUNT;i++){if(!isRendererCulledByLight(renderer_Layer.xy,scene_PointLightCullingMask[i])){pointLight.color=scene_PointLightColor[i];pointLight.position=scene_PointLightPosition[i];pointLight.distance=scene_PointLightDistance[i];vec3 direction=v_pos-pointLight.position;float dist=length(direction);direction/=dist;float decay=clamp(1.0-pow(dist/pointLight.distance,4.0),0.0,1.0);float d=max(dot(N,-direction),0.0)*decay;lightDiffuse+=pointLight.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),material_Shininess)*decay;lightSpecular+=pointLight.color*s;}}\n#endif\n#ifdef SCENE_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<SCENE_SPOT_LIGHT_COUNT;i++){if(!isRendererCulledByLight(renderer_Layer.xy,scene_SpotLightCullingMask[i])){spotLight.color=scene_SpotLightColor[i];spotLight.position=scene_SpotLightPosition[i];spotLight.direction=scene_SpotLightDirection[i];spotLight.distance=scene_SpotLightDistance[i];spotLight.angleCos=scene_SpotLightAngleCos[i];spotLight.penumbraCos=scene_SpotLightPenumbraCos[i];vec3 direction=spotLight.position-v_pos;float lightDistance=length(direction);direction/=lightDistance;float angleCos=dot(direction,-spotLight.direction);float decay=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayTotal=decay*spotEffect;float d=max(dot(N,direction),0.0)*decayTotal;lightDiffuse+=spotLight.color*d;vec3 halfDir=normalize(V+direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),material_Shininess)*decayTotal;lightSpecular+=spotLight.color*s;}}\n#endif\ndiffuse*=vec4(lightDiffuse,1.0);specular*=vec4(lightSpecular,1.0);\n#ifdef MATERIAL_IS_ALPHA_CUTOFF\nif(diffuse.a<material_AlphaCutoff){discard;}\n#endif\n";
var noise_cellular = "#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n";
var noise_cellular_2D = "#define GLSLIFY 1\nvec2 cellular(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec3 oi=vec3(-1.0,0.0,1.0);vec3 of=vec3(-0.5,0.5,1.5);vec3 px=permute(Pi.x+oi);vec3 p=permute(px.x+Pi.y+oi);vec3 ox=fract(p*K)-Ko;vec3 oy=mod7(floor(p*K))*K-Ko;vec3 dx=Pf.x+0.5+jitter*ox;vec3 dy=Pf.y-of+jitter*oy;vec3 d1=dx*dx+dy*dy;p=permute(px.y+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-0.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d2=dx*dx+dy*dy;p=permute(px.z+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-1.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d3=dx*dx+dy*dy;vec3 d1a=min(d1,d2);d2=max(d1,d2);d2=min(d2,d3);d1=min(d1a,d2);d2=max(d1a,d2);d1.xy=(d1.x<d1.y)? d1.xy : d1.yx;d1.xz=(d1.x<d1.z)? d1.xz : d1.zx;d1.yz=min(d1.yz,d2.yz);d1.y=min(d1.y,d1.z);d1.y=min(d1.y,d2.x);return sqrt(d1.xy);}";
var noise_cellular_2x2 = "#define GLSLIFY 1\nvec2 cellular2x2(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec4 Pfx=Pf.x+vec4(-0.5,-1.5,-0.5,-1.5);vec4 Pfy=Pf.y+vec4(-0.5,-0.5,-1.5,-1.5);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 ox=mod7(p)*K+Kd2;vec4 oy=mod7(floor(p*K))*K+Kd2;vec4 dx=Pfx+jitter1*ox;vec4 dy=Pfy+jitter1*oy;vec4 d=dx*dx+dy*dy;d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.y=min(d.y,d.z);d.y=min(d.y,d.w);return sqrt(d.xy);}";
var noise_cellular_2x2x2 = "#define GLSLIFY 1\nvec2 cellular2x2x2(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P);vec4 Pfx=Pf.x+vec4(0.0,-1.0,0.0,-1.0);vec4 Pfy=Pf.y+vec4(0.0,0.0,-1.0,-1.0);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 p1=permute(p+Pi.z);vec4 p2=permute(p+Pi.z+vec4(1.0));vec4 ox1=fract(p1*K)-Ko;vec4 oy1=mod7(floor(p1*K))*K-Ko;vec4 oz1=floor(p1*K2)*Kz-Kzo;vec4 ox2=fract(p2*K)-Ko;vec4 oy2=mod7(floor(p2*K))*K-Ko;vec4 oz2=floor(p2*K2)*Kz-Kzo;vec4 dx1=Pfx+jitter1*ox1;vec4 dy1=Pfy+jitter1*oy1;vec4 dz1=Pf.z+jitter1*oz1;vec4 dx2=Pfx+jitter1*ox2;vec4 dy2=Pfy+jitter1*oy2;vec4 dz2=Pf.z-1.0+jitter1*oz2;vec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;vec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;vec4 d=min(d1,d2);d2=max(d1,d2);d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.yzw=min(d.yzw,d2.yzw);d.y=min(d.y,d.z);d.y=min(d.y,d.w);d.y=min(d.y,d2.x);return sqrt(d.xy);}";
var noise_cellular_3D = "#define GLSLIFY 1\nvec2 cellular(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P)-0.5;vec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);vec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);vec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);vec3 p=permute(Pi.x+vec3(-1.0,0.0,1.0));vec3 p1=permute(p+Pi.y-1.0);vec3 p2=permute(p+Pi.y);vec3 p3=permute(p+Pi.y+1.0);vec3 p11=permute(p1+Pi.z-1.0);vec3 p12=permute(p1+Pi.z);vec3 p13=permute(p1+Pi.z+1.0);vec3 p21=permute(p2+Pi.z-1.0);vec3 p22=permute(p2+Pi.z);vec3 p23=permute(p2+Pi.z+1.0);vec3 p31=permute(p3+Pi.z-1.0);vec3 p32=permute(p3+Pi.z);vec3 p33=permute(p3+Pi.z+1.0);vec3 ox11=fract(p11*K)-Ko;vec3 oy11=mod7(floor(p11*K))*K-Ko;vec3 oz11=floor(p11*K2)*Kz-Kzo;vec3 ox12=fract(p12*K)-Ko;vec3 oy12=mod7(floor(p12*K))*K-Ko;vec3 oz12=floor(p12*K2)*Kz-Kzo;vec3 ox13=fract(p13*K)-Ko;vec3 oy13=mod7(floor(p13*K))*K-Ko;vec3 oz13=floor(p13*K2)*Kz-Kzo;vec3 ox21=fract(p21*K)-Ko;vec3 oy21=mod7(floor(p21*K))*K-Ko;vec3 oz21=floor(p21*K2)*Kz-Kzo;vec3 ox22=fract(p22*K)-Ko;vec3 oy22=mod7(floor(p22*K))*K-Ko;vec3 oz22=floor(p22*K2)*Kz-Kzo;vec3 ox23=fract(p23*K)-Ko;vec3 oy23=mod7(floor(p23*K))*K-Ko;vec3 oz23=floor(p23*K2)*Kz-Kzo;vec3 ox31=fract(p31*K)-Ko;vec3 oy31=mod7(floor(p31*K))*K-Ko;vec3 oz31=floor(p31*K2)*Kz-Kzo;vec3 ox32=fract(p32*K)-Ko;vec3 oy32=mod7(floor(p32*K))*K-Ko;vec3 oz32=floor(p32*K2)*Kz-Kzo;vec3 ox33=fract(p33*K)-Ko;vec3 oy33=mod7(floor(p33*K))*K-Ko;vec3 oz33=floor(p33*K2)*Kz-Kzo;vec3 dx11=Pfx+jitter*ox11;vec3 dy11=Pfy.x+jitter*oy11;vec3 dz11=Pfz.x+jitter*oz11;vec3 dx12=Pfx+jitter*ox12;vec3 dy12=Pfy.x+jitter*oy12;vec3 dz12=Pfz.y+jitter*oz12;vec3 dx13=Pfx+jitter*ox13;vec3 dy13=Pfy.x+jitter*oy13;vec3 dz13=Pfz.z+jitter*oz13;vec3 dx21=Pfx+jitter*ox21;vec3 dy21=Pfy.y+jitter*oy21;vec3 dz21=Pfz.x+jitter*oz21;vec3 dx22=Pfx+jitter*ox22;vec3 dy22=Pfy.y+jitter*oy22;vec3 dz22=Pfz.y+jitter*oz22;vec3 dx23=Pfx+jitter*ox23;vec3 dy23=Pfy.y+jitter*oy23;vec3 dz23=Pfz.z+jitter*oz23;vec3 dx31=Pfx+jitter*ox31;vec3 dy31=Pfy.z+jitter*oy31;vec3 dz31=Pfz.x+jitter*oz31;vec3 dx32=Pfx+jitter*ox32;vec3 dy32=Pfy.z+jitter*oy32;vec3 dz32=Pfz.y+jitter*oz32;vec3 dx33=Pfx+jitter*ox33;vec3 dy33=Pfy.z+jitter*oy33;vec3 dz33=Pfz.z+jitter*oz33;vec3 d11=dx11*dx11+dy11*dy11+dz11*dz11;vec3 d12=dx12*dx12+dy12*dy12+dz12*dz12;vec3 d13=dx13*dx13+dy13*dy13+dz13*dz13;vec3 d21=dx21*dx21+dy21*dy21+dz21*dz21;vec3 d22=dx22*dx22+dy22*dy22+dz22*dz22;vec3 d23=dx23*dx23+dy23*dy23+dz23*dz23;vec3 d31=dx31*dx31+dy31*dy31+dz31*dz31;vec3 d32=dx32*dx32+dy32*dy32+dz32*dz32;vec3 d33=dx33*dx33+dy33*dy33+dz33*dz33;vec3 d1a=min(d11,d12);d12=max(d11,d12);d11=min(d1a,d13);d13=max(d1a,d13);d12=min(d12,d13);vec3 d2a=min(d21,d22);d22=max(d21,d22);d21=min(d2a,d23);d23=max(d2a,d23);d22=min(d22,d23);vec3 d3a=min(d31,d32);d32=max(d31,d32);d31=min(d3a,d33);d33=max(d3a,d33);d32=min(d32,d33);vec3 da=min(d11,d21);d21=max(d11,d21);d11=min(da,d31);d31=max(da,d31);d11.xy=(d11.x<d11.y)? d11.xy : d11.yx;d11.xz=(d11.x<d11.z)? d11.xz : d11.zx;d12=min(d12,d21);d12=min(d12,d22);d12=min(d12,d31);d12=min(d12,d32);d11.yz=min(d11.yz,d12.xy);d11.y=min(d11.y,d12.z);d11.y=min(d11.y,d11.z);return sqrt(d11.xy);}";
var noise_common = "#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod7(vec4 x){return x-floor(x*(1.0/7.0))*7.0;}vec3 mod7(vec3 x){return x-floor(x*(1.0/7.0))*7.0;}vec4 permute(vec4 x){return mod289((34.0*x+1.0)*x);}vec3 permute(vec3 x){return mod289((34.0*x+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 fade(vec4 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define K2 0.020408163265306\n#define Kd2 0.0714285714285\n#define Kz 0.166666666667\n#define Kzo 0.416666666667\n#define jitter 1.0\n#define jitter1 0.8\n";
var noise_perlin = "#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n";
var noise_perlin_2D = "#define GLSLIFY 1\nfloat perlin(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float perlin(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}";
var noise_perlin_3D = "#define GLSLIFY 1\nfloat perlin(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}float perlin(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}";
var noise_perlin_4D = "#define GLSLIFY 1\nfloat perlin(vec4 P){vec4 Pi0=floor(P);vec4 Pi1=Pi0+1.0;Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}float perlin(vec4 P,vec4 rep){vec4 Pi0=mod(floor(P),rep);vec4 Pi1=mod(Pi0+1.0,rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}";
var noise_psrd_2D = "#define GLSLIFY 1\nvec2 rgrad2(vec2 p,float rot){float u=permute(permute(p.x)+p.y)*0.0243902439+rot;u=fract(u)*6.28318530718;return vec2(cos(u),sin(u));}vec3 psrdnoise(vec2 pos,vec2 per,float rot){pos.y+=0.01;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 psdnoise(vec2 pos,vec2 per){return psrdnoise(pos,per,0.0);}float psrnoise(vec2 pos,vec2 per,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float psnoise(vec2 pos,vec2 per){return psrnoise(pos,per,0.0);}vec3 srdnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 sdnoise(vec2 pos){return srdnoise(pos,0.0);}float srnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float snoise(vec2 pos){return srnoise(pos,0.0);}";
var noise_simplex = "#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n";
var noise_simplex_2D = "#define GLSLIFY 1\nfloat simplex(vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}";
var noise_simplex_3D = "#define GLSLIFY 1\nfloat simplex(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}";
var noise_simplex_3D_grad = "#define GLSLIFY 1\nfloat simplex(vec3 v,out vec3 gradient){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);vec4 m2=m*m;vec4 m4=m2*m2;vec4 pdotx=vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3));vec4 temp=m2*m*pdotx;gradient=-8.0*(temp.x*x0+temp.y*x1+temp.z*x2+temp.w*x3);gradient+=m4.x*p0+m4.y*p1+m4.z*p2+m4.w*p3;gradient*=42.0;return 42.0*dot(m4,pdotx);}";
var noise_simplex_4D = "#define GLSLIFY 1\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nfloat simplex(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}";
var pbr_frag_define = "#define GLSLIFY 1\nuniform float material_AlphaCutoff;uniform vec4 material_BaseColor;uniform float material_Metal;uniform float material_Roughness;uniform float material_IOR;uniform vec3 material_PBRSpecularColor;uniform float material_Glossiness;uniform vec3 material_EmissiveColor;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nuniform float material_ClearCoat;uniform float material_ClearCoatRoughness;\n#endif\nuniform float material_NormalIntensity;uniform float material_OcclusionIntensity;uniform float material_OcclusionTextureCoord;\n#ifdef MATERIAL_HAS_BASETEXTURE\nuniform sampler2D material_BaseTexture;\n#endif\n#ifdef MATERIAL_HAS_NORMALTEXTURE\nuniform sampler2D material_NormalTexture;\n#endif\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\nuniform sampler2D material_EmissiveTexture;\n#endif\n#ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\nuniform sampler2D material_RoughnessMetallicTexture;\n#endif\n#ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\nuniform sampler2D material_SpecularGlossinessTexture;\n#endif\n#ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\nuniform sampler2D material_OcclusionTexture;\n#endif\n#ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\nuniform sampler2D material_ClearCoatTexture;\n#endif\n#ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\nuniform sampler2D material_ClearCoatRoughnessTexture;\n#endif\n#ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\nuniform sampler2D material_ClearCoatNormalTexture;\n#endif\nstruct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct Geometry{vec3 position;vec3 normal;vec3 viewDir;float dotNV;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nvec3 clearCoatNormal;float clearCoatDotNV;\n#endif\n};struct Material{vec3 diffuseColor;float roughness;vec3 specularColor;float opacity;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nfloat clearCoat;float clearCoatRoughness;\n#endif\n};";
var pbr_helper = "#define GLSLIFY 1\n#include <normal_get>\nfloat computeSpecularOcclusion(float ambientOcclusion,float roughness,float dotNV){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}float getAARoughnessFactor(vec3 normal){\n#ifdef HAS_DERIVATIVES\nvec3 dxy=max(abs(dFdx(normal)),abs(dFdy(normal)));return 0.04+max(max(dxy.x,dxy.y),dxy.z);\n#else\nreturn 0.04;\n#endif\n}void initGeometry(out Geometry geometry,bool isFrontFacing){geometry.position=v_pos;geometry.viewDir=normalize(camera_Position-v_pos);\n#if defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE)\nmat3 tbn=getTBN(isFrontFacing);\n#endif\n#ifdef MATERIAL_HAS_NORMALTEXTURE\ngeometry.normal=getNormalByNormalTexture(tbn,material_NormalTexture,material_NormalIntensity,v_uv,isFrontFacing);\n#else\ngeometry.normal=getNormal(isFrontFacing);\n#endif\ngeometry.dotNV=saturate(dot(geometry.normal,geometry.viewDir));\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\n#ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\ngeometry.clearCoatNormal=getNormalByNormalTexture(tbn,material_ClearCoatNormalTexture,material_NormalIntensity,v_uv,isFrontFacing);\n#else\ngeometry.clearCoatNormal=getNormal(isFrontFacing);\n#endif\ngeometry.clearCoatDotNV=saturate(dot(geometry.clearCoatNormal,geometry.viewDir));\n#endif\n}void initMaterial(out Material material,const in Geometry geometry){vec4 baseColor=material_BaseColor;float metal=material_Metal;float roughness=material_Roughness;vec3 specularColor=material_PBRSpecularColor;float glossiness=material_Glossiness;float alphaCutoff=material_AlphaCutoff;float F0=pow2((material_IOR-1.0)/(material_IOR+1.0));\n#ifdef MATERIAL_HAS_BASETEXTURE\nvec4 baseTextureColor=texture2D(material_BaseTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nbaseTextureColor=gammaToLinear(baseTextureColor);\n#endif\nbaseColor*=baseTextureColor;\n#endif\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\nbaseColor*=v_color;\n#endif\n#ifdef MATERIAL_IS_ALPHA_CUTOFF\nif(baseColor.a<alphaCutoff){discard;}\n#endif\n#ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\nvec4 metalRoughMapColor=texture2D(material_RoughnessMetallicTexture,v_uv);roughness*=metalRoughMapColor.g;metal*=metalRoughMapColor.b;\n#endif\n#ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\nvec4 specularGlossinessColor=texture2D(material_SpecularGlossinessTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nspecularGlossinessColor=gammaToLinear(specularGlossinessColor);\n#endif\nspecularColor*=specularGlossinessColor.rgb;glossiness*=specularGlossinessColor.a;\n#endif\n#ifdef IS_METALLIC_WORKFLOW\nmaterial.diffuseColor=baseColor.rgb*(1.0-metal);material.specularColor=mix(vec3(F0),baseColor.rgb,metal);material.roughness=roughness;\n#else\nfloat specularStrength=max(max(specularColor.r,specularColor.g),specularColor.b);material.diffuseColor=baseColor.rgb*(1.0-specularStrength);material.specularColor=specularColor;material.roughness=1.0-glossiness;\n#endif\nmaterial.roughness=max(material.roughness,getAARoughnessFactor(geometry.normal));\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nmaterial.clearCoat=material_ClearCoat;material.clearCoatRoughness=material_ClearCoatRoughness;\n#ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\nmaterial.clearCoat*=texture2D(material_ClearCoatTexture,v_uv).r;\n#endif\n#ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\nmaterial.clearCoatRoughness*=texture2D(material_ClearCoatRoughnessTexture,v_uv).g;\n#endif\nmaterial.clearCoat=saturate(material.clearCoat);material.clearCoatRoughness=max(material.clearCoatRoughness,getAARoughnessFactor(geometry.clearCoatNormal));\n#endif\n#ifdef MATERIAL_IS_TRANSPARENT\nmaterial.opacity=baseColor.a;\n#else\nmaterial.opacity=1.0;\n#endif\n}\n#include <brdf>\n#include <direct_irradiance_frag_define>\n#include <ibl_frag_define>\n";
var brdf = "#define GLSLIFY 1\nfloat F_Schlick(float dotLH){return 0.04+0.96*(pow(1.0-dotLH,5.0));}vec3 F_Schlick(vec3 specularColor,float dotLH){float fresnel=exp2((-5.55473*dotLH-6.98316)*dotLH);return(1.0-specularColor)*fresnel+specularColor;}float G_GGX_SmithCorrelated(float alpha,float dotNL,float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(float alpha,float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_Specular_GGX(vec3 incidentDirection,vec3 viewDir,vec3 normal,vec3 specularColor,float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(incidentDirection+viewDir);float dotNL=saturate(dot(normal,incidentDirection));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotLH=saturate(dot(incidentDirection,halfDir));vec3 F=F_Schlick(specularColor,dotLH);float G=G_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(G*D);}vec3 BRDF_Diffuse_Lambert(vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}";
var direct_irradiance_frag_define = "#define GLSLIFY 1\n#include <ShadowFragmentDeclaration>\nvoid addDirectRadiance(vec3 incidentDirection,vec3 color,Geometry geometry,Material material,inout ReflectedLight reflectedLight){float attenuation=1.0;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nfloat clearCoatDotNL=saturate(dot(geometry.clearCoatNormal,incidentDirection));vec3 clearCoatIrradiance=clearCoatDotNL*color;reflectedLight.directSpecular+=material.clearCoat*clearCoatIrradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.clearCoatNormal,vec3(0.04),material.clearCoatRoughness);attenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nfloat dotNL=saturate(dot(geometry.normal,incidentDirection));vec3 irradiance=dotNL*color*PI;reflectedLight.directSpecular+=attenuation*irradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.normal,material.specularColor,material.roughness);reflectedLight.directDiffuse+=attenuation*irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef SCENE_DIRECT_LIGHT_COUNT\nvoid addDirectionalDirectLightRadiance(DirectLight directionalLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 color=directionalLight.color;vec3 direction=-directionalLight.direction;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef SCENE_POINT_LIGHT_COUNT\nvoid addPointDirectLightRadiance(PointLight pointLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=pointLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);vec3 color=pointLight.color;color*=clamp(1.0-pow(lightDistance/pointLight.distance,4.0),0.0,1.0);addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef SCENE_SPOT_LIGHT_COUNT\nvoid addSpotDirectLightRadiance(SpotLight spotLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=spotLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);float angleCos=dot(direction,-spotLight.direction);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayEffect=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);vec3 color=spotLight.color;color*=spotEffect*decayEffect;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\nvoid addTotalDirectRadiance(Geometry geometry,Material material,inout ReflectedLight reflectedLight){float shadowAttenuation=1.0;\n#ifdef SCENE_DIRECT_LIGHT_COUNT\nshadowAttenuation=1.0;\n#ifdef SCENE_IS_CALCULATE_SHADOWS\nshadowAttenuation*=sampleShadowMap();\n#endif\nDirectLight directionalLight;for(int i=0;i<SCENE_DIRECT_LIGHT_COUNT;i++){if(!isRendererCulledByLight(renderer_Layer.xy,scene_DirectLightCullingMask[i])){directionalLight.color=scene_DirectLightColor[i];\n#ifdef SCENE_IS_CALCULATE_SHADOWS\nif(i==0){directionalLight.color*=shadowAttenuation;}\n#endif\ndirectionalLight.direction=scene_DirectLightDirection[i];addDirectionalDirectLightRadiance(directionalLight,geometry,material,reflectedLight);}}\n#endif\n#ifdef SCENE_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<SCENE_POINT_LIGHT_COUNT;i++){if(!isRendererCulledByLight(renderer_Layer.xy,scene_PointLightCullingMask[i])){pointLight.color=scene_PointLightColor[i];pointLight.position=scene_PointLightPosition[i];pointLight.distance=scene_PointLightDistance[i];addPointDirectLightRadiance(pointLight,geometry,material,reflectedLight);}}\n#endif\n#ifdef SCENE_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<SCENE_SPOT_LIGHT_COUNT;i++){if(!isRendererCulledByLight(renderer_Layer.xy,scene_SpotLightCullingMask[i])){spotLight.color=scene_SpotLightColor[i];spotLight.position=scene_SpotLightPosition[i];spotLight.direction=scene_SpotLightDirection[i];spotLight.distance=scene_SpotLightDistance[i];spotLight.angleCos=scene_SpotLightAngleCos[i];spotLight.penumbraCos=scene_SpotLightPenumbraCos[i];addSpotDirectLightRadiance(spotLight,geometry,material,reflectedLight);}}\n#endif\n}";
var ibl_frag_define = "#define GLSLIFY 1\nvec3 getLightProbeIrradiance(vec3 sh[9],vec3 normal){normal.x=-normal.x;vec3 result=sh[0]+sh[1]*(normal.y)+sh[2]*(normal.z)+sh[3]*(normal.x)+sh[4]*(normal.y*normal.x)+sh[5]*(normal.y*normal.z)+sh[6]*(3.0*normal.z*normal.z-1.0)+sh[7]*(normal.z*normal.x)+sh[8]*(normal.x*normal.x-normal.y*normal.y);return max(result,vec3(0.0));}vec3 envBRDFApprox(vec3 specularColor,float roughness,float dotNV){const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}float getSpecularMIPLevel(float roughness,int maxMIPLevel){return roughness*float(maxMIPLevel);}vec3 getLightProbeRadiance(vec3 viewDir,vec3 normal,float roughness,int maxMIPLevel,float specularIntensity){\n#ifndef SCENE_USE_SPECULAR_ENV\nreturn vec3(0);\n#else\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec.x=-reflectVec.x;float specularMIPLevel=getSpecularMIPLevel(roughness,maxMIPLevel);\n#ifdef HAS_TEX_LOD\nvec4 envMapColor=textureCubeLodEXT(scene_EnvSpecularSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCube(scene_EnvSpecularSampler,reflectVec,specularMIPLevel);\n#endif\n#ifdef SCENE_IS_DECODE_ENV_RGBM\nenvMapColor.rgb=RGBMToLinear(envMapColor,5.0).rgb;\n#ifdef ENGINE_IS_COLORSPACE_GAMMA\nenvMapColor=linearToGamma(envMapColor);\n#endif\n#else\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nenvMapColor=gammaToLinear(envMapColor);\n#endif\n#endif\nreturn envMapColor.rgb*specularIntensity;\n#endif\n}";
var pbr_frag = "#define GLSLIFY 1\nGeometry geometry;Material material;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));initGeometry(geometry,gl_FrontFacing);initMaterial(material,geometry);addTotalDirectRadiance(geometry,material,reflectedLight);\n#ifdef SCENE_USE_SH\nvec3 irradiance=getLightProbeIrradiance(scene_EnvSH,geometry.normal);\n#ifdef ENGINE_IS_COLORSPACE_GAMMA\nirradiance=linearToGamma(vec4(irradiance,1.0)).rgb;\n#endif\nirradiance*=scene_EnvMapLight.diffuseIntensity;\n#else\nvec3 irradiance=scene_EnvMapLight.diffuse*scene_EnvMapLight.diffuseIntensity;irradiance*=PI;\n#endif\nreflectedLight.indirectDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);vec3 radiance=getLightProbeRadiance(geometry.viewDir,geometry.normal,material.roughness,int(scene_EnvMapLight.mipMapLevel),scene_EnvMapLight.specularIntensity);float radianceAttenuation=1.0;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nvec3 clearCoatRadiance=getLightProbeRadiance(geometry.viewDir,geometry.clearCoatNormal,material.clearCoatRoughness,int(scene_EnvMapLight.mipMapLevel),scene_EnvMapLight.specularIntensity);reflectedLight.indirectSpecular+=clearCoatRadiance*material.clearCoat*envBRDFApprox(vec3(0.04),material.clearCoatRoughness,geometry.clearCoatDotNV);radianceAttenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nreflectedLight.indirectSpecular+=radianceAttenuation*radiance*envBRDFApprox(material.specularColor,material.roughness,geometry.dotNV);\n#ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\nvec2 aoUV=v_uv;\n#ifdef RENDERER_HAS_UV1\nif(material_OcclusionTextureCoord==1.0){aoUV=v_uv1;}\n#endif\nfloat ambientOcclusion=(texture2D(material_OcclusionTexture,aoUV).r-1.0)*material_OcclusionIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#ifdef SCENE_USE_SPECULAR_ENV\nreflectedLight.indirectSpecular*=computeSpecularOcclusion(ambientOcclusion,material.roughness,geometry.dotNV);\n#endif\n#endif\nvec3 emissiveRadiance=material_EmissiveColor;\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\nvec4 emissiveColor=texture2D(material_EmissiveTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nemissiveColor=gammaToLinear(emissiveColor);\n#endif\nemissiveRadiance*=emissiveColor.rgb;\n#endif\nvec3 totalRadiance=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+emissiveRadiance;vec4 targetColor=vec4(totalRadiance,material.opacity);gl_FragColor=targetColor;";
var PBRShaderLib = {
  pbr_frag_define,
  pbr_helper,
  brdf,
  direct_irradiance_frag_define,
  ibl_frag_define,
  pbr_frag
};
var ShadowCoord = "#define GLSLIFY 1\nuniform mat4 scene_ShadowMatrices[SCENE_SHADOW_CASCADED_COUNT+1];uniform vec4 scene_ShadowSplitSpheres[4];mediump int computeCascadeIndex(vec3 positionWS){vec3 fromCenter0=positionWS-scene_ShadowSplitSpheres[0].xyz;vec3 fromCenter1=positionWS-scene_ShadowSplitSpheres[1].xyz;vec3 fromCenter2=positionWS-scene_ShadowSplitSpheres[2].xyz;vec3 fromCenter3=positionWS-scene_ShadowSplitSpheres[3].xyz;mediump vec4 comparison=vec4(dot(fromCenter0,fromCenter0)<scene_ShadowSplitSpheres[0].w,dot(fromCenter1,fromCenter1)<scene_ShadowSplitSpheres[1].w,dot(fromCenter2,fromCenter2)<scene_ShadowSplitSpheres[2].w,dot(fromCenter3,fromCenter3)<scene_ShadowSplitSpheres[3].w);comparison.yzw=clamp(comparison.yzw-comparison.xyz,0.0,1.0);mediump vec4 indexCoefficient=vec4(4.0,3.0,2.0,1.0);mediump int index=4-int(dot(comparison,indexCoefficient));return index;}vec3 getShadowCoord(){\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nmediump int cascadeIndex=0;\n#else\nmediump int cascadeIndex=computeCascadeIndex(v_pos);\n#endif\n#ifdef GRAPHICS_API_WEBGL2\nmat4 shadowMatrix=scene_ShadowMatrices[cascadeIndex];\n#else\nmat4 shadowMatrix;\n#if SCENE_SHADOW_CASCADED_COUNT == 4\nif(cascadeIndex==0){shadowMatrix=scene_ShadowMatrices[0];}else if(cascadeIndex==1){shadowMatrix=scene_ShadowMatrices[1];}else if(cascadeIndex==2){shadowMatrix=scene_ShadowMatrices[2];}else if(cascadeIndex==3){shadowMatrix=scene_ShadowMatrices[3];}else{shadowMatrix=scene_ShadowMatrices[4];}\n#endif\n#if SCENE_SHADOW_CASCADED_COUNT == 2\nif(cascadeIndex==0){shadowMatrix=scene_ShadowMatrices[0];}else if(cascadeIndex==1){shadowMatrix=scene_ShadowMatrices[1];}else{shadowMatrix=scene_ShadowMatrices[2];}\n#endif\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nif(cascadeIndex==0){shadowMatrix=scene_ShadowMatrices[0];}else{shadowMatrix=scene_ShadowMatrices[1];}\n#endif\n#endif\nvec4 shadowCoord=shadowMatrix*vec4(v_pos,1.0);return shadowCoord.xyz;}";
var ShadowFragmentDeclaration = "#define GLSLIFY 1\n#if defined(SCENE_SHADOW_TYPE) && defined(RENDERER_IS_RECEIVE_SHADOWS)\n#define SCENE_IS_CALCULATE_SHADOWS\n#endif\n#ifdef SCENE_IS_CALCULATE_SHADOWS\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nvarying vec3 v_shadowCoord;\n#else\n#include <ShadowCoord>\n#endif\nuniform vec3 scene_ShadowInfo;uniform vec4 scene_ShadowMapSize;\n#ifdef GRAPHICS_API_WEBGL2\nuniform mediump sampler2DShadow scene_ShadowMap;\n#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName, coord3 , 0.0)\n#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\n#else\nuniform sampler2D scene_ShadowMap;\n#ifdef ENGINE_NO_DEPTH_TEXTURE\nconst vec4 bitShift=vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0));float unpack(const in vec4 rgbaDepth){return dot(rgbaDepth,bitShift);}\n#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (unpack(texture2D(textureName, coord3.xy)) < coord3.z ? 0.0 : 1.0)\n#else\n#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (texture2D(textureName, coord3.xy).r < coord3.z ? 0.0 : 1.0)\n#endif\n#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\n#endif\n#if SCENE_SHADOW_TYPE == 2\nfloat sampleShadowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowMapSize){float attenuation;vec4 attenuation4;vec2 offset=shadowMapSize.xy/2.0;vec3 shadowCoord0=shadowCoord+vec3(-offset,0.0);vec3 shadowCoord1=shadowCoord+vec3(offset.x,-offset.y,0.0);vec3 shadowCoord2=shadowCoord+vec3(-offset.x,offset.y,0.0);vec3 shadowCoord3=shadowCoord+vec3(offset,0.0);attenuation4.x=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord0);attenuation4.y=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord1);attenuation4.z=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord2);attenuation4.w=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord3);attenuation=dot(attenuation4,vec4(0.25));return attenuation;}\n#endif\n#if SCENE_SHADOW_TYPE == 3\n#include <shadow_sample_tent>\nfloat sampleShadowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowmapSize){float attenuation;float fetchesWeights[9];vec2 fetchesUV[9];sampleShadowComputeSamplesTent5x5(shadowmapSize,shadowCoord.xy,fetchesWeights,fetchesUV);attenuation=fetchesWeights[0]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[0].xy,shadowCoord.z));attenuation+=fetchesWeights[1]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[1].xy,shadowCoord.z));attenuation+=fetchesWeights[2]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[2].xy,shadowCoord.z));attenuation+=fetchesWeights[3]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[3].xy,shadowCoord.z));attenuation+=fetchesWeights[4]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[4].xy,shadowCoord.z));attenuation+=fetchesWeights[5]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[5].xy,shadowCoord.z));attenuation+=fetchesWeights[6]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[6].xy,shadowCoord.z));attenuation+=fetchesWeights[7]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[7].xy,shadowCoord.z));attenuation+=fetchesWeights[8]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[8].xy,shadowCoord.z));return attenuation;}\n#endif\nfloat sampleShadowMap(){\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nvec3 shadowCoord=v_shadowCoord;\n#else\nvec3 shadowCoord=getShadowCoord();\n#endif\nfloat attenuation=1.0;if(shadowCoord.z>0.0&&shadowCoord.z<1.0){\n#if SCENE_SHADOW_TYPE == 1\nattenuation=SAMPLE_TEXTURE2D_SHADOW(scene_ShadowMap,shadowCoord);\n#endif\n#if SCENE_SHADOW_TYPE == 2\nattenuation=sampleShadowMapFiltered4(scene_ShadowMap,shadowCoord,scene_ShadowMapSize);\n#endif\n#if SCENE_SHADOW_TYPE == 3\nattenuation=sampleShadowMapFiltered9(scene_ShadowMap,shadowCoord,scene_ShadowMapSize);\n#endif\nattenuation=mix(1.0,attenuation,scene_ShadowInfo.x);}return attenuation;}\n#endif\n";
var shadow_sample_tent = "#define GLSLIFY 1\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight){return triangleHeight-0.5;}void sampleShadowGetTexelAreasTent3x3(float offset,out vec4 computedArea,out vec4 computedAreaUncut){float a=offset+0.5;float offsetSquaredHalved=a*a*0.5;computedAreaUncut.x=computedArea.x=offsetSquaredHalved-offset;computedAreaUncut.w=computedArea.w=offsetSquaredHalved;computedAreaUncut.y=sampleShadowGetIRTriangleTexelArea(1.5-offset);float clampedOffsetLeft=min(offset,0.0);float areaOfSmallLeftTriangle=clampedOffsetLeft*clampedOffsetLeft;computedArea.y=computedAreaUncut.y-areaOfSmallLeftTriangle;computedAreaUncut.z=sampleShadowGetIRTriangleTexelArea(1.5+offset);float clampedOffsetRight=max(offset,0.0);float areaOfSmallRightTriangle=clampedOffsetRight*clampedOffsetRight;computedArea.z=computedAreaUncut.z-areaOfSmallRightTriangle;}void sampleShadowGetTexelWeightsTent5x5(float offset,out vec3 texelsWeightsA,out vec3 texelsWeightsB){vec4 areaFrom3texelTriangle;vec4 areaUncutFrom3texelTriangle;sampleShadowGetTexelAreasTent3x3(offset,areaFrom3texelTriangle,areaUncutFrom3texelTriangle);texelsWeightsA.x=0.16*(areaFrom3texelTriangle.x);texelsWeightsA.y=0.16*(areaUncutFrom3texelTriangle.y);texelsWeightsA.z=0.16*(areaFrom3texelTriangle.y+1.0);texelsWeightsB.x=0.16*(areaFrom3texelTriangle.z+1.0);texelsWeightsB.y=0.16*(areaUncutFrom3texelTriangle.z);texelsWeightsB.z=0.16*(areaFrom3texelTriangle.w);}void sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize,vec2 coord,out float fetchesWeights[9],out vec2 fetchesUV[9]){vec2 tentCenterInTexelSpace=coord.xy*shadowMapTextureTexelSize.zw;vec2 centerOfFetchesInTexelSpace=floor(tentCenterInTexelSpace+0.5);vec2 offsetFromTentCenterToCenterOfFetches=tentCenterInTexelSpace-centerOfFetchesInTexelSpace;vec3 texelsWeightsUA,texelsWeightsUB;vec3 texelsWeightsVA,texelsWeightsVB;sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x,texelsWeightsUA,texelsWeightsUB);sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y,texelsWeightsVA,texelsWeightsVB);vec3 fetchesWeightsU=vec3(texelsWeightsUA.xz,texelsWeightsUB.y)+vec3(texelsWeightsUA.y,texelsWeightsUB.xz);vec3 fetchesWeightsV=vec3(texelsWeightsVA.xz,texelsWeightsVB.y)+vec3(texelsWeightsVA.y,texelsWeightsVB.xz);vec3 fetchesOffsetsU=vec3(texelsWeightsUA.y,texelsWeightsUB.xz)/fetchesWeightsU.xyz+vec3(-2.5,-0.5,1.5);vec3 fetchesOffsetsV=vec3(texelsWeightsVA.y,texelsWeightsVB.xz)/fetchesWeightsV.xyz+vec3(-2.5,-0.5,1.5);fetchesOffsetsU*=shadowMapTextureTexelSize.xxx;fetchesOffsetsV*=shadowMapTextureTexelSize.yyy;vec2 bilinearFetchOrigin=centerOfFetchesInTexelSpace*shadowMapTextureTexelSize.xy;fetchesUV[0]=bilinearFetchOrigin+vec2(fetchesOffsetsU.x,fetchesOffsetsV.x);fetchesUV[1]=bilinearFetchOrigin+vec2(fetchesOffsetsU.y,fetchesOffsetsV.x);fetchesUV[2]=bilinearFetchOrigin+vec2(fetchesOffsetsU.z,fetchesOffsetsV.x);fetchesUV[3]=bilinearFetchOrigin+vec2(fetchesOffsetsU.x,fetchesOffsetsV.y);fetchesUV[4]=bilinearFetchOrigin+vec2(fetchesOffsetsU.y,fetchesOffsetsV.y);fetchesUV[5]=bilinearFetchOrigin+vec2(fetchesOffsetsU.z,fetchesOffsetsV.y);fetchesUV[6]=bilinearFetchOrigin+vec2(fetchesOffsetsU.x,fetchesOffsetsV.z);fetchesUV[7]=bilinearFetchOrigin+vec2(fetchesOffsetsU.y,fetchesOffsetsV.z);fetchesUV[8]=bilinearFetchOrigin+vec2(fetchesOffsetsU.z,fetchesOffsetsV.z);fetchesWeights[0]=fetchesWeightsU.x*fetchesWeightsV.x;fetchesWeights[1]=fetchesWeightsU.y*fetchesWeightsV.x;fetchesWeights[2]=fetchesWeightsU.z*fetchesWeightsV.x;fetchesWeights[3]=fetchesWeightsU.x*fetchesWeightsV.y;fetchesWeights[4]=fetchesWeightsU.y*fetchesWeightsV.y;fetchesWeights[5]=fetchesWeightsU.z*fetchesWeightsV.y;fetchesWeights[6]=fetchesWeightsU.x*fetchesWeightsV.z;fetchesWeights[7]=fetchesWeightsU.y*fetchesWeightsV.z;fetchesWeights[8]=fetchesWeightsU.z*fetchesWeightsV.z;}";
var ShadowVertexDeclaration = "#define GLSLIFY 1\n#if defined(SCENE_SHADOW_TYPE) && defined(RENDERER_IS_RECEIVE_SHADOWS)\n#define SCENE_IS_CALCULATE_SHADOWS\n#endif\n#ifdef SCENE_IS_CALCULATE_SHADOWS\n#if SCENE_SHADOW_CASCADED_COUNT==1\n#include <ShadowCoord>\nvarying vec3 v_shadowCoord;\n#endif\n#endif\n";
var ShadowVertex = "#define GLSLIFY 1\n#ifdef SCENE_IS_CALCULATE_SHADOWS\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nv_shadowCoord=getShadowCoord();\n#endif\n#endif\n";
var ShadowLib = {
  ShadowCoord,
  ShadowFragmentDeclaration,
  shadow_sample_tent,
  ShadowVertexDeclaration,
  ShadowVertex
};
var normal_get = "#define GLSLIFY 1\nvec3 getNormal(bool isFrontFacing){\n#ifdef RENDERER_HAS_NORMAL\nvec3 normal=normalize(v_normal);\n#elif defined(HAS_DERIVATIVES)\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 normal=normalize(cross(pos_dx,pos_dy));\n#else\nvec3 normal=vec3(0,0,1);\n#endif\nnormal*=float(isFrontFacing)*2.0-1.0;return normal;}vec3 getNormalByNormalTexture(mat3 tbn,sampler2D normalTexture,float normalIntensity,vec2 uv,bool isFrontFacing){vec3 normal=texture2D(normalTexture,uv).rgb;normal=normalize(tbn*((2.0*normal-1.0)*vec3(normalIntensity,normalIntensity,1.0)));normal*=float(isFrontFacing)*2.0-1.0;return normal;}mat3 getTBN(bool isFrontFacing){\n#if defined(RENDERER_HAS_NORMAL) && defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\nmat3 tbn=v_TBN;\n#else\nvec3 normal=getNormal(isFrontFacing);vec3 position=v_pos;vec2 uv=isFrontFacing? v_uv:-v_uv;\n#ifdef HAS_DERIVATIVES\nvec3 dp1=dFdx(position);vec3 dp2=dFdy(position);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));mat3 tbn=mat3(tangent*invmax,binormal*invmax,normal);\n#else\nmat3 tbn=mat3(vec3(0.0),vec3(0.0),normal);\n#endif\n#endif\nreturn tbn;}";
var ShaderLib = _extends$2({
  common,
  common_vert,
  transform_declare,
  camera_declare,
  color_share,
  normal_share,
  uv_share,
  worldpos_share,
  FogVertexDeclaration,
  FogFragmentDeclaration,
  begin_normal_vert,
  begin_position_vert,
  position_vert,
  color_vert,
  normal_vert,
  skinning_vert,
  blendShape_input,
  blendShape_vert,
  uv_vert,
  worldpos_vert,
  FogVertex,
  light_frag_define,
  mobile_material_frag,
  FogFragment,
  begin_mobile_frag,
  begin_viewdir_frag,
  mobile_blinnphong_frag,
  noise_common,
  noise_cellular_2D,
  noise_cellular_2x2,
  noise_cellular_2x2x2,
  noise_cellular_3D,
  noise_cellular,
  noise_perlin_2D,
  noise_perlin_3D,
  noise_perlin_4D,
  noise_perlin,
  noise_psrd_2D,
  noise_simplex_2D,
  noise_simplex_3D_grad,
  noise_simplex_3D,
  noise_simplex_4D,
  noise_simplex
}, ShadowLib, PBRShaderLib, {
  normal_get
});
var ShaderFactory = /* @__PURE__ */ function() {
  function ShaderFactory2() {
  }
  ShaderFactory2.parseCustomMacros = function parseCustomMacros(macros) {
    return macros.map(function(m) {
      return "#define " + m + "\n";
    }).join("");
  };
  ShaderFactory2.parseIncludes = function parseIncludes(src) {
    var replace = function replace2(match, slice) {
      var replace3 = ShaderLib[slice];
      if (replace3 === void 0) {
        Logger.error('Shader slice "' + match.trim() + '" not founded.');
        return "";
      }
      return ShaderFactory2.parseIncludes(replace3);
    };
    var regex = /^[ \t]*#include +<([\w\d.]+)>/gm;
    return src.replace(regex, replace);
  };
  ShaderFactory2.parseExtension = function parseExtension(extensions) {
    return extensions.map(function(e) {
      return "#extension " + e + " : enable\n";
    }).join("");
  };
  ShaderFactory2.convertTo300 = function convertTo300(shader, isFrag) {
    shader = shader.replace(/\battribute\b/g, "in");
    shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
    shader = shader.replace(/\btexture(2D|Cube)\b/g, "texture");
    shader = shader.replace(/\btexture(2D|Cube)LodEXT\b/g, "textureLod");
    if (isFrag) {
      var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);
      if (isMRT) {
        shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
        var result2 = shader.match(/\bgl_FragData\[.+?\]/g);
        shader = this._replaceMRTShader(shader, result2);
      } else {
        shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
        shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
      }
    }
    return shader;
  };
  ShaderFactory2._replaceMRTShader = function _replaceMRTShader(shader, result2) {
    var declaration = "";
    var mrtIndexSet = /* @__PURE__ */ new Set();
    for (var i = 0; i < result2.length; i++) {
      var res = result2[i].match(/\bgl_FragData\[(.+?)\]/);
      mrtIndexSet.add(res[1]);
    }
    mrtIndexSet.forEach(function(index) {
      declaration += "layout(location=" + index + ") out vec4 fragOutColor" + index + ";\n";
    });
    declaration += "void main(";
    shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
    shader = shader.replace(/void\s+?main\s*\(/g, declaration);
    return shader;
  };
  return ShaderFactory2;
}();
var ShaderTagKey = /* @__PURE__ */ function() {
  function ShaderTagKey2(name2) {
    this.name = name2;
    this._uniqueId = ShaderTagKey2._nameCounter++;
  }
  ShaderTagKey2.getByName = function getByName(name2) {
    var _nameMap, _name;
    var nameMap = ShaderTagKey2._nameMap;
    return (_nameMap = nameMap)[_name = name2] || (_nameMap[_name] = new ShaderTagKey2(name2));
  };
  return ShaderTagKey2;
}();
(function() {
  ShaderTagKey._nameCounter = 0;
})();
(function() {
  ShaderTagKey._nameMap = /* @__PURE__ */ Object.create(null);
})();
var ShaderPart = /* @__PURE__ */ function() {
  function ShaderPart2() {
    this._tagsMap = /* @__PURE__ */ Object.create(null);
  }
  var _proto = ShaderPart2.prototype;
  _proto.setTag = function setTag(keyOrKeyName, value) {
    var key = typeof keyOrKeyName === "string" ? ShaderTagKey.getByName(keyOrKeyName) : keyOrKeyName;
    var tags = this._tagsMap;
    if (tags[key._uniqueId] !== void 0) {
      Logger.warn('The value of tag named "' + key.name + '" is being replaced.');
    }
    tags[key._uniqueId] = value;
  };
  _proto.deleteTag = function deleteTag(keyOrKeyName) {
    delete this._tagsMap[(typeof keyOrKeyName == "string" ? ShaderTagKey.getByName(keyOrKeyName) : keyOrKeyName)._uniqueId];
  };
  _proto.getTagValue = function getTagValue(keyOrKeyName) {
    return this._tagsMap[typeof keyOrKeyName == "string" ? ShaderTagKey.getByName(keyOrKeyName)._uniqueId : keyOrKeyName._uniqueId];
  };
  return ShaderPart2;
}();
var ShaderDataGroup;
(function(ShaderDataGroup2) {
  ShaderDataGroup2[ShaderDataGroup2["Scene"] = 0] = "Scene";
  ShaderDataGroup2[ShaderDataGroup2["Camera"] = 1] = "Camera";
  ShaderDataGroup2[ShaderDataGroup2["Renderer"] = 2] = "Renderer";
  ShaderDataGroup2[ShaderDataGroup2["Material"] = 3] = "Material";
})(ShaderDataGroup || (ShaderDataGroup = {}));
var ColorSpace;
(function(ColorSpace2) {
  ColorSpace2[ColorSpace2["Linear"] = 0] = "Linear";
  ColorSpace2[ColorSpace2["Gamma"] = 1] = "Gamma";
})(ColorSpace || (ColorSpace = {}));
var ShaderUniform = /* @__PURE__ */ function() {
  function ShaderUniform2(engine) {
    this.textureUseCompareMode = false;
    var rhi = engine._hardwareRenderer;
    this._rhi = rhi;
    this._gl = rhi.gl;
    this._colorSpace = engine.settings.colorSpace;
  }
  var _proto = ShaderUniform2.prototype;
  _proto.upload1f = function upload1f(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1f(shaderUniform.location, value);
      this.cacheValue = value;
    }
  };
  _proto.upload1fv = function upload1fv(shaderUniform, value) {
    this._gl.uniform1fv(shaderUniform.location, value);
  };
  _proto.upload2f = function upload2f(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
        if (this._colorSpace === ColorSpace.Linear) {
          this._gl.uniform2f(shaderUniform.location, Color$1.gammaToLinearSpace(value.r), Color$1.gammaToLinearSpace(value.g));
        } else {
          this._gl.uniform2f(shaderUniform.location, value.r, value.g);
        }
        cacheValue.x = value.r;
        cacheValue.y = value.g;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
        this._gl.uniform2f(shaderUniform.location, value.x, value.y);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
      }
    }
  };
  _proto.upload2fv = function upload2fv(shaderUniform, value) {
    this._gl.uniform2fv(shaderUniform.location, value);
  };
  _proto.upload3f = function upload3f(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
        if (this._colorSpace === ColorSpace.Linear) {
          this._gl.uniform3f(shaderUniform.location, Color$1.gammaToLinearSpace(value.r), Color$1.gammaToLinearSpace(value.g), Color$1.gammaToLinearSpace(value.b));
        } else {
          this._gl.uniform3f(shaderUniform.location, value.r, value.g, value.b);
        }
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
        this._gl.uniform3f(shaderUniform.location, value.x, value.y, value.z);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
      }
    }
  };
  _proto.upload3fv = function upload3fv(shaderUniform, value) {
    this._gl.uniform3fv(shaderUniform.location, value);
  };
  _proto.upload4f = function upload4f(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
        if (this._colorSpace === ColorSpace.Linear) {
          this._gl.uniform4f(shaderUniform.location, Color$1.gammaToLinearSpace(value.r), Color$1.gammaToLinearSpace(value.g), Color$1.gammaToLinearSpace(value.b), value.a);
        } else {
          this._gl.uniform4f(shaderUniform.location, value.r, value.g, value.b, value.a);
        }
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
        cacheValue.w = value.a;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
        this._gl.uniform4f(shaderUniform.location, value.x, value.y, value.z, value.w);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
        cacheValue.w = value.w;
      }
    }
  };
  _proto.upload4fv = function upload4fv(shaderUniform, value) {
    this._gl.uniform4fv(shaderUniform.location, value);
  };
  _proto.upload1i = function upload1i(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1i(shaderUniform.location, value);
      this.cacheValue = value;
    }
  };
  _proto.upload1iv = function upload1iv(shaderUniform, value) {
    this._gl.uniform1iv(shaderUniform.location, value);
  };
  _proto.upload2i = function upload2i(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
        this._gl.uniform2i(shaderUniform.location, value.r, value.g);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
        this._gl.uniform2i(shaderUniform.location, value.x, value.y);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
      }
    }
  };
  _proto.upload2iv = function upload2iv(shaderUniform, value) {
    this._gl.uniform2iv(shaderUniform.location, value);
  };
  _proto.upload3i = function upload3i(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
        this._gl.uniform3i(shaderUniform.location, value.r, value.g, value.b);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
        this._gl.uniform3i(shaderUniform.location, value.x, value.y, value.z);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
      }
    }
  };
  _proto.upload3iv = function upload3iv(shaderUniform, value) {
    this._gl.uniform3iv(shaderUniform.location, value);
  };
  _proto.upload4i = function upload4i(shaderUniform, value) {
    var cacheValue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
        this._gl.uniform4i(shaderUniform.location, value.r, value.g, value.b, value.a);
        cacheValue.x = value.r;
        cacheValue.y = value.g;
        cacheValue.z = value.b;
        cacheValue.w = value.a;
      }
    } else {
      if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
        this._gl.uniform4i(shaderUniform.location, value.x, value.y, value.z, value.w);
        cacheValue.x = value.x;
        cacheValue.y = value.y;
        cacheValue.z = value.z;
        cacheValue.w = value.w;
      }
    }
  };
  _proto.upload4iv = function upload4iv(shaderUniform, value) {
    this._gl.uniform4iv(shaderUniform.location, value);
  };
  _proto.uploadMat4 = function uploadMat4(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value.elements);
  };
  _proto.uploadMat4v = function uploadMat4v(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value);
  };
  _proto.uploadTexture = function uploadTexture(shaderUniform, value) {
    var rhi = this._rhi;
    rhi.activeTexture(shaderUniform.textureIndex);
    rhi.bindTexture(value._platformTexture);
    value._setUseDepthCompareMode(shaderUniform.textureUseCompareMode);
  };
  _proto.uploadTextureArray = function uploadTextureArray(shaderUniform, value) {
    var rhi = this._rhi;
    var textureIndices = shaderUniform.textureIndex;
    for (var i = 0; i < value.length; i++) {
      var texture = value[i];
      rhi.activeTexture(textureIndices[i]);
      rhi.bindTexture(texture._platformTexture);
      texture._setUseDepthCompareMode(shaderUniform.textureUseCompareMode);
    }
  };
  return ShaderUniform2;
}();
var ShaderUniformBlock = function ShaderUniformBlock2() {
  this.constUniforms = [];
  this.textureUniforms = [];
};
var ShaderProgram = /* @__PURE__ */ function() {
  function ShaderProgram2(engine, vertexSource, fragmentSource) {
    this.sceneUniformBlock = new ShaderUniformBlock();
    this.cameraUniformBlock = new ShaderUniformBlock();
    this.rendererUniformBlock = new ShaderUniformBlock();
    this.materialUniformBlock = new ShaderUniformBlock();
    this.otherUniformBlock = new ShaderUniformBlock();
    this._uploadRenderCount = -1;
    this.attributeLocation = /* @__PURE__ */ Object.create(null);
    this._activeTextureUint = 0;
    this._engine = engine;
    this._gl = engine._hardwareRenderer.gl;
    this._glProgram = this._createProgram(vertexSource, fragmentSource);
    if (this._glProgram) {
      this._isValid = true;
      this._recordLocation();
    } else {
      this._isValid = false;
    }
    this.id = ShaderProgram2._counter++;
  }
  var _proto = ShaderProgram2.prototype;
  _proto.uploadAll = function uploadAll(uniformBlock, shaderData) {
    this.uploadUniforms(uniformBlock, shaderData);
    this.uploadTextures(uniformBlock, shaderData);
  };
  _proto.uploadUniforms = function uploadUniforms(uniformBlock, shaderData) {
    var propertyValueMap = shaderData._propertyValueMap;
    var constUniforms = uniformBlock.constUniforms;
    for (var i = 0, n = constUniforms.length; i < n; i++) {
      var uniform = constUniforms[i];
      var data = propertyValueMap[uniform.propertyId];
      data != null && uniform.applyFunc(uniform, data);
    }
  };
  _proto.uploadTextures = function uploadTextures(uniformBlock, shaderData) {
    var propertyValueMap = shaderData._propertyValueMap;
    var textureUniforms = uniformBlock.textureUniforms;
    if (textureUniforms) {
      for (var i = 0, n = textureUniforms.length; i < n; i++) {
        var uniform = textureUniforms[i];
        var texture = propertyValueMap[uniform.propertyId];
        if (texture && !texture.destroyed) {
          uniform.applyFunc(uniform, texture);
        } else {
          uniform.applyFunc(uniform, uniform.textureDefault);
        }
      }
    }
  };
  _proto.uploadUnGroupTextures = function uploadUnGroupTextures() {
    var textureUniforms = this.otherUniformBlock.textureUniforms;
    if (textureUniforms) {
      for (var i = 0, n = textureUniforms.length; i < n; i++) {
        var uniform = textureUniforms[i];
        uniform.applyFunc(uniform, uniform.textureDefault);
      }
    }
  };
  _proto.groupingOtherUniformBlock = function groupingOtherUniformBlock() {
    var _this_otherUniformBlock = this.otherUniformBlock, constUniforms = _this_otherUniformBlock.constUniforms, textureUniforms = _this_otherUniformBlock.textureUniforms;
    constUniforms.length > 0 && this._groupingSubOtherUniforms(constUniforms, false);
    textureUniforms.length > 0 && this._groupingSubOtherUniforms(textureUniforms, true);
  };
  _proto.bind = function bind2() {
    var rhi = this._engine._hardwareRenderer;
    if (rhi._currentBindShaderProgram !== this) {
      this._gl.useProgram(this._glProgram);
      rhi._currentBindShaderProgram = this;
      return true;
    } else {
      return false;
    }
  };
  _proto.destroy = function destroy2() {
    var gl = this._gl;
    this._glProgram && gl.deleteProgram(this._glProgram);
  };
  _proto._groupingSubOtherUniforms = function _groupingSubOtherUniforms(uniforms, isTexture) {
    for (var i = uniforms.length - 1; i >= 0; i--) {
      var uniform = uniforms[i];
      var group = ShaderProperty._getShaderPropertyGroup(uniform.name);
      if (group !== void 0) {
        uniforms.splice(uniforms.indexOf(uniform), 1);
        this._groupingUniform(uniform, group, isTexture);
      }
    }
  };
  _proto._groupingUniform = function _groupingUniform(uniform, group, isTexture) {
    switch (group) {
      case ShaderDataGroup.Scene:
        if (isTexture) {
          this.sceneUniformBlock.textureUniforms.push(uniform);
        } else {
          this.sceneUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Camera:
        if (isTexture) {
          this.cameraUniformBlock.textureUniforms.push(uniform);
        } else {
          this.cameraUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Renderer:
        if (isTexture) {
          this.rendererUniformBlock.textureUniforms.push(uniform);
        } else {
          this.rendererUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Material:
        if (isTexture) {
          this.materialUniformBlock.textureUniforms.push(uniform);
        } else {
          this.materialUniformBlock.constUniforms.push(uniform);
        }
        break;
      default:
        if (isTexture) {
          this.otherUniformBlock.textureUniforms.push(uniform);
        } else {
          this.otherUniformBlock.constUniforms.push(uniform);
        }
    }
  };
  _proto._createProgram = function _createProgram(vertexSource, fragmentSource) {
    var gl = this._gl;
    var vertexShader = this._createShader(gl.VERTEX_SHADER, vertexSource);
    if (!vertexShader) {
      return null;
    }
    var fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentSource);
    if (!fragmentShader) {
      return null;
    }
    var program = gl.createProgram();
    if (!program) {
      console.warn("Context lost while create program.");
      return null;
    }
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    if (Logger.isEnabled && !gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {
      Logger.error("Could not link WebGL program\n\n" + ("Shader error: " + gl.getError() + "\n\n") + ("Validate status: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\n") + ("Program information log: " + gl.getProgramInfoLog(program)));
      gl.deleteProgram(program);
      return null;
    }
    return program;
  };
  _proto._createShader = function _createShader(shaderType, shaderSource) {
    var gl = this._gl;
    var shader = gl.createShader(shaderType);
    if (!shader) {
      console.warn("Context lost while create shader.");
      return null;
    }
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (Logger.isEnabled && !gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
      console.warn("Could not compile WebGL shader\n\n" + ("Shader type: " + (shaderType == gl.VERTEX_SHADER ? "vertex" : "fragment") + "\n\n") + ("Shader information log:\n" + gl.getShaderInfoLog(shader) + "\n") + ("Shader source:\n" + ShaderProgram2._addLineNum(shaderSource)));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  };
  _proto._recordLocation = function _recordLocation() {
    var _this = this;
    var gl = this._gl;
    var program = this._glProgram;
    var uniformInfos = this._getUniformInfos();
    var attributeInfos = this._getAttributeInfos();
    uniformInfos.forEach(function(param) {
      var name2 = param.name, size = param.size, type = param.type;
      var shaderUniform = new ShaderUniform(_this._engine);
      var isArray = false;
      var isTexture = false;
      if (name2.indexOf("[0]") > 0) {
        name2 = name2.substr(0, name2.length - 3);
        isArray = true;
      }
      var location = gl.getUniformLocation(program, name2);
      shaderUniform.name = name2;
      shaderUniform.propertyId = ShaderProperty.getByName(name2)._uniqueId;
      shaderUniform.location = location;
      switch (type) {
        case gl.FLOAT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1f;
            shaderUniform.cacheValue = 0;
          }
          break;
        case gl.FLOAT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2f;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }
          break;
        case gl.FLOAT_VEC3:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload3fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload3f;
            shaderUniform.cacheValue = new Vector3(0, 0, 0);
          }
          break;
        case gl.FLOAT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4f;
            shaderUniform.cacheValue = new Vector4(0, 0, 0, 0);
          }
          break;
        case gl.BOOL:
        case gl.INT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1i;
            shaderUniform.cacheValue = 0;
          }
          break;
        case gl.BOOL_VEC2:
        case gl.INT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2i;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }
          break;
        case gl.BOOL_VEC3:
        case gl.INT_VEC3:
          shaderUniform.applyFunc = isArray ? shaderUniform.upload3iv : shaderUniform.upload3i;
          shaderUniform.cacheValue = new Vector3(0, 0, 0);
          break;
        case gl.BOOL_VEC4:
        case gl.INT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4i;
            shaderUniform.cacheValue = new Vector4(0, 0, 0);
          }
          break;
        case gl.FLOAT_MAT4:
          shaderUniform.applyFunc = isArray ? shaderUniform.uploadMat4v : shaderUniform.uploadMat4;
          break;
        case gl.SAMPLER_2D:
        case gl.SAMPLER_CUBE:
        case gl.SAMPLER_2D_ARRAY:
        case gl.SAMPLER_2D_SHADOW:
          var defaultTexture;
          switch (type) {
            case gl.SAMPLER_2D:
              defaultTexture = _this._engine._magentaTexture2D;
              break;
            case gl.SAMPLER_CUBE:
              defaultTexture = _this._engine._magentaTextureCube;
              break;
            case gl.SAMPLER_2D_ARRAY:
              defaultTexture = _this._engine._magentaTexture2DArray;
              break;
            case gl.SAMPLER_2D_SHADOW:
              defaultTexture = _this._engine._depthTexture2D;
              shaderUniform.textureUseCompareMode = true;
              break;
          }
          isTexture = true;
          if (isArray) {
            var defaultTextures = new Array(size);
            var textureIndices = new Int32Array(size);
            var glTextureIndices = new Array(size);
            for (var i = 0; i < size; i++) {
              defaultTextures[i] = defaultTexture;
              textureIndices[i] = _this._activeTextureUint;
              glTextureIndices[i] = gl.TEXTURE0 + _this._activeTextureUint++;
            }
            shaderUniform.textureDefault = defaultTextures;
            shaderUniform.textureIndex = glTextureIndices;
            shaderUniform.applyFunc = shaderUniform.uploadTextureArray;
            _this.bind();
            gl.uniform1iv(location, textureIndices);
          } else {
            var glTextureIndex = gl.TEXTURE0 + _this._activeTextureUint;
            shaderUniform.textureDefault = defaultTexture;
            shaderUniform.textureIndex = glTextureIndex;
            shaderUniform.applyFunc = shaderUniform.uploadTexture;
            _this.bind();
            gl.uniform1i(location, _this._activeTextureUint++);
          }
          break;
        default:
          throw new Error("Unsupported uniform type");
      }
      var group = ShaderProperty._getShaderPropertyGroup(name2);
      _this._groupingUniform(shaderUniform, group, isTexture);
    });
    attributeInfos.forEach(function(param) {
      var name2 = param.name;
      _this.attributeLocation[name2] = gl.getAttribLocation(program, name2);
    });
  };
  _proto._getUniformInfos = function _getUniformInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    var uniformInfos = new Array(uniformCount);
    for (var i = 0; i < uniformCount; ++i) {
      var info2 = gl.getActiveUniform(program, i);
      uniformInfos[i] = info2;
    }
    return uniformInfos;
  };
  _proto._getAttributeInfos = function _getAttributeInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var attributeInfos = new Array();
    var attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < attributeCount; ++i) {
      var info2 = gl.getActiveAttrib(program, i);
      attributeInfos[i] = info2;
    }
    return attributeInfos;
  };
  ShaderProgram2._addLineNum = function _addLineNum(str) {
    var lines = str.split("\n");
    var limitLength = (lines.length + 1).toString().length + 6;
    var prefix;
    return lines.map(function(line, index) {
      prefix = "0:" + (index + 1);
      if (prefix.length >= limitLength)
        return prefix.substring(0, limitLength) + line;
      for (var i = 0; i < limitLength - prefix.length; i++)
        prefix += " ";
      return prefix + line;
    }).join("\n");
  };
  _create_class$4(ShaderProgram2, [
    {
      key: "isValid",
      get: function get3() {
        return this._isValid;
      }
    }
  ]);
  return ShaderProgram2;
}();
(function() {
  ShaderProgram._counter = 0;
})();
var ShaderPass = /* @__PURE__ */ function(ShaderPart2) {
  _inherits$2(ShaderPass2, ShaderPart2);
  function ShaderPass2(vertexSource, fragmentSource, tags) {
    if (tags === void 0)
      tags = {
        pipelineStage: PipelineStage.Forward
      };
    var _this;
    _this = ShaderPart2.call(this) || this;
    _this._shaderPassId = 0;
    _this._shaderPassId = ShaderPass2._shaderPassCounter++;
    _this._vertexSource = vertexSource;
    _this._fragmentSource = fragmentSource;
    for (var key in tags) {
      _this.setTag(key, tags[key]);
    }
    return _this;
  }
  var _proto = ShaderPass2.prototype;
  _proto._getShaderProgram = function _getShaderProgram(engine, macroCollection) {
    var shaderProgramPool = engine._getShaderProgramPool(this);
    var shaderProgram = shaderProgramPool.get(macroCollection);
    if (shaderProgram) {
      return shaderProgram;
    }
    var isWebGL2 = engine._hardwareRenderer.isWebGL2;
    var macroNameList = [];
    ShaderMacro._getNamesByMacros(macroCollection, macroNameList);
    var macroNameStr = ShaderFactory.parseCustomMacros(macroNameList);
    var versionStr = isWebGL2 ? "#version 300 es" : "#version 100";
    var graphicAPI = isWebGL2 ? "#define GRAPHICS_API_WEBGL2" : "#define GRAPHICS_API_WEBGL1";
    var precisionStr = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n    #else\n      precision mediump float;\n      precision mediump int;\n    #endif\n    ";
    if (engine._hardwareRenderer.canIUse(GLCapabilityType.shaderTextureLod)) {
      precisionStr += "#define HAS_TEX_LOD\n";
    }
    if (engine._hardwareRenderer.canIUse(GLCapabilityType.standardDerivatives)) {
      precisionStr += "#define HAS_DERIVATIVES\n";
    }
    var vertexSource = " " + versionStr + "\n        " + graphicAPI + "\n        " + macroNameStr + "\n      " + ShaderFactory.parseIncludes(this._vertexSource);
    var fragmentSource = " " + versionStr + "\n        " + graphicAPI + "\n        " + (isWebGL2 ? "" : ShaderFactory.parseExtension(Shader._shaderExtension)) + "\n        " + precisionStr + "\n        " + macroNameStr + "\n      " + ShaderFactory.parseIncludes(this._fragmentSource);
    if (isWebGL2) {
      vertexSource = ShaderFactory.convertTo300(vertexSource);
      fragmentSource = ShaderFactory.convertTo300(fragmentSource, true);
    }
    shaderProgram = new ShaderProgram(engine, vertexSource, fragmentSource);
    shaderProgramPool.cache(shaderProgram);
    return shaderProgram;
  };
  return ShaderPass2;
}(ShaderPart);
(function() {
  ShaderPass._shaderPassCounter = 0;
})();
var SubShader = /* @__PURE__ */ function(ShaderPart2) {
  _inherits$2(SubShader2, ShaderPart2);
  function SubShader2(name2, passes, tags) {
    var _this;
    _this = ShaderPart2.call(this) || this;
    _this.name = name2;
    var passCount = passes.length;
    if (passCount < 1) {
      throw " count must large than 0.";
    }
    _this._passes = passes.slice();
    for (var key in tags) {
      _this.setTag(key, tags[key]);
    }
    return _this;
  }
  _create_class$4(SubShader2, [
    {
      key: "passes",
      get: function get3() {
        return this._passes;
      }
    }
  ]);
  return SubShader2;
}(ShaderPart);
var Shader = /* @__PURE__ */ function() {
  function Shader2(name2, subShaders) {
    this.name = name2;
    this.name = name2;
    this._subShaders = subShaders;
  }
  var _proto = Shader2.prototype;
  _proto.compileVariant = function compileVariant(engine, macros) {
    var compileMacros = Shader2._compileMacros;
    compileMacros.clear();
    for (var i = 0, n = macros.length; i < n; i++) {
      compileMacros.enable(ShaderMacro.getByName(macros[i]));
    }
    var subShaders = this._subShaders;
    for (var i1 = 0, n1 = subShaders.length; i1 < n1; i1++) {
      var isValid2 = void 0;
      var passes = subShaders[i1].passes;
      for (var j2 = 0, m = passes.length; j2 < m; j2++) {
        if (isValid2 === void 0) {
          isValid2 = passes[j2]._getShaderProgram(engine, compileMacros).isValid;
        } else {
          isValid2 && (isValid2 = passes[j2]._getShaderProgram(engine, compileMacros).isValid);
        }
      }
      if (isValid2)
        return true;
    }
    return false;
  };
  Shader2.create = function create(name2, vertexSourceOrShaderPassesOrSubShaders, fragmentSource) {
    var shaderMap = Shader2._shaderMap;
    if (shaderMap[name2]) {
      throw 'Shader named "' + name2 + '" already exists.';
    }
    var shader;
    if (typeof vertexSourceOrShaderPassesOrSubShaders === "string") {
      var shaderPass = new ShaderPass(vertexSourceOrShaderPassesOrSubShaders, fragmentSource);
      shader = new Shader2(name2, [
        new SubShader("Default", [
          shaderPass
        ])
      ]);
    } else {
      if (vertexSourceOrShaderPassesOrSubShaders.length > 0) {
        if (vertexSourceOrShaderPassesOrSubShaders[0].constructor === ShaderPass) {
          shader = new Shader2(name2, [
            new SubShader("Default", vertexSourceOrShaderPassesOrSubShaders)
          ]);
        } else {
          shader = new Shader2(name2, vertexSourceOrShaderPassesOrSubShaders.slice());
        }
      } else {
        throw "SubShader or ShaderPass count must large than 0.";
      }
    }
    shaderMap[name2] = shader;
    return shader;
  };
  Shader2.find = function find(name2) {
    return Shader2._shaderMap[name2];
  };
  Shader2.getMacroByName = function getMacroByName(name2, value) {
    return ShaderMacro.getByName(name2, value);
  };
  Shader2.getPropertyByName = function getPropertyByName(name2) {
    return ShaderProperty.getByName(name2);
  };
  _create_class$4(Shader2, [
    {
      key: "subShaders",
      get: function get3() {
        return this._subShaders;
      }
    }
  ]);
  return Shader2;
}();
(function() {
  Shader._compileMacros = new ShaderMacroCollection();
})();
(function() {
  Shader._shaderExtension = [
    "GL_EXT_shader_texture_lod",
    "GL_OES_standard_derivatives",
    "GL_EXT_draw_buffers"
  ];
})();
(function() {
  Shader._shaderMap = /* @__PURE__ */ Object.create(null);
})();
var ShaderData = /* @__PURE__ */ function() {
  function ShaderData2(group) {
    this._propertyValueMap = /* @__PURE__ */ Object.create(null);
    this._macroCollection = new ShaderMacroCollection();
    this._macroMap = /* @__PURE__ */ Object.create(null);
    this._refCount = 0;
    this._group = group;
  }
  var _proto = ShaderData2.prototype;
  _proto.getFloat = function getFloat(property) {
    return this.getPropertyValue(property);
  };
  _proto.setFloat = function setFloat(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Float, value);
  };
  _proto.getInt = function getInt(property) {
    return this.getPropertyValue(property);
  };
  _proto.setInt = function setInt(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Int, value);
  };
  _proto.getFloatArray = function getFloatArray(property) {
    return this.getPropertyValue(property);
  };
  _proto.setFloatArray = function setFloatArray(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.FloatArray, value);
  };
  _proto.getIntArray = function getIntArray(property) {
    return this.getPropertyValue(property);
  };
  _proto.setIntArray = function setIntArray(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.IntArray, value);
  };
  _proto.getVector2 = function getVector2(property) {
    return this.getPropertyValue(property);
  };
  _proto.setVector2 = function setVector2(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Vector2, value);
  };
  _proto.getVector3 = function getVector3(property) {
    return this.getPropertyValue(property);
  };
  _proto.setVector3 = function setVector3(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Vector3, value);
  };
  _proto.getVector4 = function getVector4(property) {
    return this.getPropertyValue(property);
  };
  _proto.setVector4 = function setVector4(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Vector4, value);
  };
  _proto.getMatrix = function getMatrix(property) {
    return this.getPropertyValue(property);
  };
  _proto.setMatrix = function setMatrix(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Matrix, value);
  };
  _proto.getColor = function getColor(property) {
    return this.getPropertyValue(property);
  };
  _proto.setColor = function setColor(property, value) {
    this._setPropertyValue(property, ShaderPropertyType.Color, value);
  };
  _proto.getTexture = function getTexture(property) {
    return this.getPropertyValue(property);
  };
  _proto.setTexture = function setTexture(property, value) {
    if (this._getReferCount() > 0) {
      var lastValue = this.getPropertyValue(property);
      lastValue && lastValue._addReferCount(-1);
      value && value._addReferCount(1);
    }
    this._setPropertyValue(property, ShaderPropertyType.Texture, value);
  };
  _proto.getTextureArray = function getTextureArray(property) {
    return this.getPropertyValue(property);
  };
  _proto.setTextureArray = function setTextureArray(property, value) {
    if (this._getReferCount() > 0) {
      var lastValue = this.getPropertyValue(property);
      if (lastValue) {
        for (var i = 0, n = lastValue.length; i < n; i++) {
          lastValue[i]._addReferCount(-1);
        }
      }
      if (value) {
        for (var i1 = 0, n1 = value.length; i1 < n1; i1++) {
          value[i1]._addReferCount(1);
        }
      }
    }
    this._setPropertyValue(property, ShaderPropertyType.TextureArray, value);
  };
  _proto.getPropertyValue = function getPropertyValue(property) {
    if (typeof property === "string") {
      property = ShaderProperty.getByName(property);
    }
    return this._propertyValueMap[property._uniqueId];
  };
  _proto.enableMacro = function enableMacro(macro, value) {
    if (typeof macro === "string") {
      macro = ShaderMacro.getByName(macro, value);
    }
    var nameID = macro._nameId;
    var lastMacro = this._macroMap[nameID];
    if (lastMacro !== macro) {
      var macroCollection = this._macroCollection;
      lastMacro && macroCollection.disable(lastMacro);
      macroCollection.enable(macro);
      this._macroMap[nameID] = macro;
    }
  };
  _proto.disableMacro = function disableMacro(macro) {
    var nameID;
    if (typeof macro === "string") {
      nameID = ShaderMacro._macroNameIdMap[macro];
      if (nameID === void 0) {
        return;
      }
    } else {
      nameID = macro._nameId;
    }
    var currentMacro = this._macroMap[nameID];
    if (currentMacro) {
      this._macroCollection.disable(currentMacro);
      delete this._macroMap[nameID];
    }
  };
  _proto.getMacros = function getMacros(out) {
    if (out) {
      var macroMap = this._macroMap;
      out.length = 0;
      for (var key in macroMap) {
        out.push(macroMap[key]);
      }
    } else {
      return Object.values(this._macroMap);
    }
  };
  _proto.getProperties = function getProperties(out) {
    var properties;
    if (out) {
      out.length = 0;
      properties = out;
    } else {
      properties = [];
    }
    var propertyValueMap = this._propertyValueMap;
    var propertyIdMap = ShaderProperty._propertyIdMap;
    for (var key in propertyValueMap) {
      properties.push(propertyIdMap[key]);
    }
    if (!out) {
      return properties;
    }
  };
  _proto.clone = function clone() {
    var shaderData = new ShaderData2(this._group);
    this.cloneTo(shaderData);
    return shaderData;
  };
  _proto.cloneTo = function cloneTo(target) {
    CloneManager.deepCloneObject(this._macroCollection, target._macroCollection);
    Object.assign(target._macroMap, this._macroMap);
    var referCount = target._getReferCount();
    var propertyValueMap = this._propertyValueMap;
    var targetPropertyValueMap = target._propertyValueMap;
    var keys = Object.keys(propertyValueMap);
    for (var i = 0, n = keys.length; i < n; i++) {
      var k2 = keys[i];
      var property = propertyValueMap[k2];
      if (property != null) {
        if (typeof property === "number") {
          targetPropertyValueMap[k2] = property;
        } else if (_instanceof$2(property, Texture)) {
          targetPropertyValueMap[k2] = property;
          referCount > 0 && property._addReferCount(referCount);
        } else if (_instanceof$2(property, Array) || _instanceof$2(property, Float32Array) || _instanceof$2(property, Int32Array)) {
          targetPropertyValueMap[k2] = property.slice();
        } else {
          var targetProperty = targetPropertyValueMap[k2];
          if (targetProperty) {
            targetProperty.copyFrom(property);
          } else {
            targetPropertyValueMap[k2] = property.clone();
          }
        }
      } else {
        targetPropertyValueMap[k2] = property;
      }
    }
  };
  _proto._setPropertyValue = function _setPropertyValue(property, type, value) {
    if (typeof property === "string") {
      property = ShaderProperty.getByName(property);
    }
    if (property._group !== this._group) {
      if (property._group === void 0) {
        property._group = this._group;
      } else {
        throw "Shader property " + property.name + " has been used as " + ShaderDataGroup[property._group] + " group.";
      }
    }
    if (property._type !== type) {
      if (property._type === void 0) {
        property._type = type;
      } else {
        throw "Shader property " + property.name + " has been used as " + ShaderPropertyType[property._type] + " type.";
      }
    }
    this._propertyValueMap[property._uniqueId] = value;
  };
  _proto._getReferCount = function _getReferCount() {
    return this._refCount;
  };
  _proto._addReferCount = function _addReferCount(value) {
    this._refCount += value;
    var properties = this._propertyValueMap;
    for (var k2 in properties) {
      var property = properties[k2];
      if (property && _instanceof$2(property, Texture)) {
        property._addReferCount(value);
      }
    }
  };
  return ShaderData2;
}();
var RenderTargetBlendState = function RenderTargetBlendState2() {
  this.enabled = false;
  this.colorBlendOperation = BlendOperation.Add;
  this.alphaBlendOperation = BlendOperation.Add;
  this.sourceColorBlendFactor = BlendFactor.One;
  this.sourceAlphaBlendFactor = BlendFactor.One;
  this.destinationColorBlendFactor = BlendFactor.Zero;
  this.destinationAlphaBlendFactor = BlendFactor.Zero;
  this.colorWriteMask = ColorWriteMask.All;
};
var BlendState = /* @__PURE__ */ function() {
  function BlendState2() {
    this.targetBlendState = new RenderTargetBlendState();
    this.blendColor = new Color$1(0, 0, 0, 0);
    this.alphaToCoverage = false;
  }
  var _proto = BlendState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.blendState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var lastTargetBlendState = lastState.targetBlendState;
    var _this_targetBlendState = this.targetBlendState, enabled = _this_targetBlendState.enabled, colorBlendOperation = _this_targetBlendState.colorBlendOperation, alphaBlendOperation = _this_targetBlendState.alphaBlendOperation, sourceColorBlendFactor = _this_targetBlendState.sourceColorBlendFactor, destinationColorBlendFactor = _this_targetBlendState.destinationColorBlendFactor, sourceAlphaBlendFactor = _this_targetBlendState.sourceAlphaBlendFactor, destinationAlphaBlendFactor = _this_targetBlendState.destinationAlphaBlendFactor, colorWriteMask = _this_targetBlendState.colorWriteMask;
    if (enabled !== lastTargetBlendState.enabled) {
      if (enabled) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      lastTargetBlendState.enabled = enabled;
    }
    if (enabled) {
      if (sourceColorBlendFactor !== lastTargetBlendState.sourceColorBlendFactor || destinationColorBlendFactor !== lastTargetBlendState.destinationColorBlendFactor || sourceAlphaBlendFactor !== lastTargetBlendState.sourceAlphaBlendFactor || destinationAlphaBlendFactor !== lastTargetBlendState.destinationAlphaBlendFactor) {
        gl.blendFuncSeparate(BlendState2._getGLBlendFactor(rhi, sourceColorBlendFactor), BlendState2._getGLBlendFactor(rhi, destinationColorBlendFactor), BlendState2._getGLBlendFactor(rhi, sourceAlphaBlendFactor), BlendState2._getGLBlendFactor(rhi, destinationAlphaBlendFactor));
        lastTargetBlendState.sourceColorBlendFactor = sourceColorBlendFactor;
        lastTargetBlendState.destinationColorBlendFactor = destinationColorBlendFactor;
        lastTargetBlendState.sourceAlphaBlendFactor = sourceAlphaBlendFactor;
        lastTargetBlendState.destinationAlphaBlendFactor = destinationAlphaBlendFactor;
      }
      if (colorBlendOperation !== lastTargetBlendState.colorBlendOperation || alphaBlendOperation !== lastTargetBlendState.alphaBlendOperation) {
        gl.blendEquationSeparate(BlendState2._getGLBlendOperation(rhi, colorBlendOperation), BlendState2._getGLBlendOperation(rhi, alphaBlendOperation));
        lastTargetBlendState.colorBlendOperation = colorBlendOperation;
        lastTargetBlendState.alphaBlendOperation = alphaBlendOperation;
      }
      var blendColor = this.blendColor;
      if (!Color$1.equals(lastState.blendColor, blendColor)) {
        gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
        lastState.blendColor.copyFrom(blendColor);
      }
    }
    if (colorWriteMask !== lastTargetBlendState.colorWriteMask) {
      gl.colorMask((colorWriteMask & ColorWriteMask.Red) !== 0, (colorWriteMask & ColorWriteMask.Green) !== 0, (colorWriteMask & ColorWriteMask.Blue) !== 0, (colorWriteMask & ColorWriteMask.Alpha) !== 0);
      lastTargetBlendState.colorWriteMask = colorWriteMask;
    }
    var alphaToCoverage = this.alphaToCoverage;
    if (alphaToCoverage !== lastState.alphaToCoverage) {
      if (alphaToCoverage) {
        gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      } else {
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      }
      lastState.alphaToCoverage = alphaToCoverage;
    }
  };
  BlendState2._getGLBlendFactor = function _getGLBlendFactor(rhi, blendFactor) {
    var gl = rhi.gl;
    switch (blendFactor) {
      case BlendFactor.Zero:
        return gl.ZERO;
      case BlendFactor.One:
        return gl.ONE;
      case BlendFactor.SourceColor:
        return gl.SRC_COLOR;
      case BlendFactor.OneMinusSourceColor:
        return gl.ONE_MINUS_SRC_COLOR;
      case BlendFactor.DestinationColor:
        return gl.DST_COLOR;
      case BlendFactor.OneMinusDestinationColor:
        return gl.ONE_MINUS_DST_COLOR;
      case BlendFactor.SourceAlpha:
        return gl.SRC_ALPHA;
      case BlendFactor.OneMinusSourceAlpha:
        return gl.ONE_MINUS_SRC_ALPHA;
      case BlendFactor.DestinationAlpha:
        return gl.DST_ALPHA;
      case BlendFactor.OneMinusDestinationAlpha:
        return gl.ONE_MINUS_DST_ALPHA;
      case BlendFactor.SourceAlphaSaturate:
        return gl.SRC_ALPHA_SATURATE;
      case BlendFactor.BlendColor:
        return gl.CONSTANT_COLOR;
      case BlendFactor.OneMinusBlendColor:
        return gl.ONE_MINUS_CONSTANT_COLOR;
    }
  };
  BlendState2._getGLBlendOperation = function _getGLBlendOperation(rhi, blendOperation) {
    var gl = rhi.gl;
    switch (blendOperation) {
      case BlendOperation.Add:
        return gl.FUNC_ADD;
      case BlendOperation.Subtract:
        return gl.FUNC_SUBTRACT;
      case BlendOperation.ReverseSubtract:
        return gl.FUNC_REVERSE_SUBTRACT;
      case BlendOperation.Min:
        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
          throw new Error("BlendOperation.Min is not supported in this context");
        }
        return gl.MIN;
      case BlendOperation.Max:
        if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
          throw new Error("BlendOperation.Max is not supported in this context");
        }
        return gl.MAX;
    }
  };
  return BlendState2;
}();
var DepthState = /* @__PURE__ */ function() {
  function DepthState2() {
    this.enabled = true;
    this.writeEnabled = true;
    this.compareFunction = CompareFunction.Less;
  }
  var _proto = DepthState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.depthState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var _this = this, enabled = _this.enabled, compareFunction = _this.compareFunction, writeEnabled = _this.writeEnabled;
    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      lastState.enabled = enabled;
    }
    if (enabled) {
      if (compareFunction != lastState.compareFunction) {
        gl.depthFunc(DepthState2._getGLCompareFunction(rhi, compareFunction));
        lastState.compareFunction = compareFunction;
      }
      if (writeEnabled != lastState.writeEnabled) {
        gl.depthMask(writeEnabled);
        lastState.writeEnabled = writeEnabled;
      }
    }
  };
  DepthState2._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
    var gl = rhi.gl;
    switch (compareFunction) {
      case CompareFunction.Never:
        return gl.NEVER;
      case CompareFunction.Less:
        return gl.LESS;
      case CompareFunction.Equal:
        return gl.EQUAL;
      case CompareFunction.LessEqual:
        return gl.LEQUAL;
      case CompareFunction.Greater:
        return gl.GREATER;
      case CompareFunction.NotEqual:
        return gl.NOTEQUAL;
      case CompareFunction.GreaterEqual:
        return gl.GEQUAL;
      case CompareFunction.Always:
        return gl.ALWAYS;
    }
  };
  return DepthState2;
}();
var RasterState = /* @__PURE__ */ function() {
  function RasterState2() {
    this.cullMode = CullMode.Back;
    this.depthBias = 0;
    this.slopeScaledDepthBias = 0;
    this._cullFaceEnable = true;
    this._frontFaceInvert = false;
  }
  var _proto = RasterState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState, frontFaceInvert) {
    this._platformApply(hardwareRenderer, lastRenderState.rasterState, frontFaceInvert);
  };
  _proto._platformApply = function _platformApply(rhi, lastState, frontFaceInvert) {
    var gl = rhi.gl;
    var _this = this, cullMode = _this.cullMode, depthBias = _this.depthBias, slopeScaledDepthBias = _this.slopeScaledDepthBias;
    var cullFaceEnable = cullMode !== CullMode.Off;
    if (cullFaceEnable !== lastState._cullFaceEnable) {
      if (cullFaceEnable) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }
      lastState._cullFaceEnable = cullFaceEnable;
    }
    if (cullFaceEnable) {
      if (cullMode !== lastState.cullMode) {
        if (cullMode == CullMode.Back) {
          gl.cullFace(gl.BACK);
        } else {
          gl.cullFace(gl.FRONT);
        }
        lastState.cullMode = cullMode;
      }
    }
    if (frontFaceInvert !== lastState._frontFaceInvert) {
      if (frontFaceInvert) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      lastState._frontFaceInvert = frontFaceInvert;
    }
    if (!rhi._enableGlobalDepthBias) {
      if (depthBias !== lastState.depthBias || slopeScaledDepthBias !== lastState.slopeScaledDepthBias) {
        if (depthBias !== 0 || slopeScaledDepthBias !== 0) {
          gl.enable(gl.POLYGON_OFFSET_FILL);
          gl.polygonOffset(slopeScaledDepthBias, depthBias);
        } else {
          gl.disable(gl.POLYGON_OFFSET_FILL);
        }
        lastState.depthBias = depthBias;
        lastState.slopeScaledDepthBias = slopeScaledDepthBias;
      }
    }
  };
  return RasterState2;
}();
var StencilState = /* @__PURE__ */ function() {
  function StencilState2() {
    this.enabled = false;
    this.referenceValue = 0;
    this.mask = 255;
    this.writeMask = 255;
    this.compareFunctionFront = CompareFunction.Always;
    this.compareFunctionBack = CompareFunction.Always;
    this.passOperationFront = StencilOperation.Keep;
    this.passOperationBack = StencilOperation.Keep;
    this.failOperationFront = StencilOperation.Keep;
    this.failOperationBack = StencilOperation.Keep;
    this.zFailOperationFront = StencilOperation.Keep;
    this.zFailOperationBack = StencilOperation.Keep;
  }
  var _proto = StencilState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.stencilState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var _this = this, enabled = _this.enabled, referenceValue = _this.referenceValue, mask = _this.mask, compareFunctionFront = _this.compareFunctionFront, compareFunctionBack = _this.compareFunctionBack, failOperationFront = _this.failOperationFront, zFailOperationFront = _this.zFailOperationFront, passOperationFront = _this.passOperationFront, failOperationBack = _this.failOperationBack, zFailOperationBack = _this.zFailOperationBack, passOperationBack = _this.passOperationBack, writeMask = _this.writeMask;
    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      lastState.enabled = enabled;
    }
    if (enabled) {
      var referenceOrMaskChange = referenceValue !== lastState.referenceValue || mask !== lastState.mask;
      if (referenceOrMaskChange || compareFunctionFront !== lastState.compareFunctionFront) {
        gl.stencilFuncSeparate(gl.FRONT, StencilState2._getGLCompareFunction(rhi, compareFunctionFront), referenceValue, mask);
        lastState.compareFunctionFront = compareFunctionFront;
      }
      if (referenceOrMaskChange || compareFunctionBack !== lastState.compareFunctionBack) {
        gl.stencilFuncSeparate(gl.BACK, StencilState2._getGLCompareFunction(rhi, compareFunctionBack), referenceValue, mask);
        lastState.compareFunctionBack = this.compareFunctionBack;
      }
      if (referenceOrMaskChange) {
        lastState.referenceValue = this.referenceValue;
        lastState.mask = this.mask;
      }
      if (failOperationFront !== lastState.failOperationFront || zFailOperationFront !== lastState.zFailOperationFront || passOperationFront !== lastState.passOperationFront) {
        gl.stencilOpSeparate(gl.FRONT, StencilState2._getGLStencilOperation(rhi, failOperationFront), StencilState2._getGLStencilOperation(rhi, zFailOperationFront), StencilState2._getGLStencilOperation(rhi, passOperationFront));
        lastState.failOperationFront = failOperationFront;
        lastState.zFailOperationFront = zFailOperationFront;
        lastState.passOperationFront = passOperationFront;
      }
      if (failOperationBack !== lastState.failOperationBack || zFailOperationBack !== lastState.zFailOperationBack || passOperationBack !== lastState.passOperationBack) {
        gl.stencilOpSeparate(gl.BACK, StencilState2._getGLStencilOperation(rhi, failOperationBack), StencilState2._getGLStencilOperation(rhi, zFailOperationBack), StencilState2._getGLStencilOperation(rhi, passOperationBack));
        lastState.failOperationBack = failOperationBack;
        lastState.zFailOperationBack = zFailOperationBack;
        lastState.passOperationBack = passOperationBack;
      }
      if (writeMask !== lastState.writeMask) {
        gl.stencilMask(writeMask);
        lastState.writeMask = writeMask;
      }
    }
  };
  StencilState2._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
    var gl = rhi.gl;
    switch (compareFunction) {
      case CompareFunction.Never:
        return gl.NEVER;
      case CompareFunction.Less:
        return gl.LESS;
      case CompareFunction.Equal:
        return gl.EQUAL;
      case CompareFunction.LessEqual:
        return gl.LEQUAL;
      case CompareFunction.Greater:
        return gl.GREATER;
      case CompareFunction.NotEqual:
        return gl.NOTEQUAL;
      case CompareFunction.GreaterEqual:
        return gl.GEQUAL;
      case CompareFunction.Always:
        return gl.ALWAYS;
    }
  };
  StencilState2._getGLStencilOperation = function _getGLStencilOperation(rhi, compareFunction) {
    var gl = rhi.gl;
    switch (compareFunction) {
      case StencilOperation.Keep:
        return gl.KEEP;
      case StencilOperation.Zero:
        return gl.ZERO;
      case StencilOperation.Replace:
        return gl.REPLACE;
      case StencilOperation.IncrementSaturate:
        return gl.INCR;
      case StencilOperation.DecrementSaturate:
        return gl.DECR;
      case StencilOperation.Invert:
        return gl.INVERT;
      case StencilOperation.IncrementWrap:
        return gl.INCR_WRAP;
      case StencilOperation.DecrementWrap:
        return gl.DECR_WRAP;
    }
  };
  return StencilState2;
}();
var RenderState = /* @__PURE__ */ function() {
  function RenderState2() {
    this.blendState = new BlendState();
    this.depthState = new DepthState();
    this.stencilState = new StencilState();
    this.rasterState = new RasterState();
    this.renderQueueType = RenderQueueType.Opaque;
  }
  var _proto = RenderState2.prototype;
  _proto._apply = function _apply(engine, frontFaceInvert) {
    var hardwareRenderer = engine._hardwareRenderer;
    var lastRenderState = engine._lastRenderState;
    this.blendState._apply(hardwareRenderer, lastRenderState);
    this.depthState._apply(hardwareRenderer, lastRenderState);
    this.stencilState._apply(hardwareRenderer, lastRenderState);
    this.rasterState._apply(hardwareRenderer, lastRenderState, frontFaceInvert);
  };
  return RenderState2;
}();
var RenderContext = /* @__PURE__ */ function() {
  function RenderContext2() {
  }
  var _proto = RenderContext2.prototype;
  _proto.applyVirtualCamera = function applyVirtualCamera(virtualCamera) {
    this.virtualCamera = virtualCamera;
    var shaderData = this.camera.shaderData;
    shaderData.setMatrix(RenderContext2._viewMatrixProperty, virtualCamera.viewMatrix);
    shaderData.setMatrix(RenderContext2._projectionMatrixProperty, virtualCamera.projectionMatrix);
    shaderData.setMatrix(RenderContext2.vpMatrixProperty, virtualCamera.viewProjectionMatrix);
  };
  return RenderContext2;
}();
(function() {
  RenderContext.vpMatrixProperty = ShaderProperty.getByName("camera_VPMat");
})();
(function() {
  RenderContext.pipelineStageKey = ShaderTagKey.getByName("pipelineStage");
})();
(function() {
  RenderContext._viewMatrixProperty = ShaderProperty.getByName("camera_ViewMat");
})();
(function() {
  RenderContext._projectionMatrixProperty = ShaderProperty.getByName("camera_ProjMat");
})();
var RenderElement = /* @__PURE__ */ function() {
  function RenderElement2() {
  }
  var _proto = RenderElement2.prototype;
  _proto.set = function set(data, shaderPass, renderState) {
    this.data = data;
    this.shaderPass = shaderPass;
    this.renderState = renderState;
  };
  _proto.dispose = function dispose() {
    this.data = this.shaderPass = this.renderState = null;
  };
  return RenderElement2;
}();
var SpriteMaskInteraction;
(function(SpriteMaskInteraction2) {
  SpriteMaskInteraction2[SpriteMaskInteraction2["None"] = 0] = "None";
  SpriteMaskInteraction2[SpriteMaskInteraction2["VisibleInsideMask"] = 1] = "VisibleInsideMask";
  SpriteMaskInteraction2[SpriteMaskInteraction2["VisibleOutsideMask"] = 2] = "VisibleOutsideMask";
})(SpriteMaskInteraction || (SpriteMaskInteraction = {}));
var _Renderer;
var Renderer = (_Renderer = /* @__PURE__ */ function(Component2) {
  _inherits$2(Renderer1, Component2);
  function Renderer1(entity) {
    var _this;
    _this = Component2.call(this, entity) || this;
    _this._onUpdateIndex = -1;
    _this._rendererIndex = -1;
    _this._globalShaderMacro = new ShaderMacroCollection();
    _this._bounds = new BoundingBox();
    _this._overrideUpdate = false;
    _this._materials = [];
    _this._dirtyUpdateFlag = 0;
    _this._shaderData = new ShaderData(ShaderDataGroup.Renderer);
    _this._mvMatrix = new Matrix();
    _this._mvpMatrix = new Matrix();
    _this._mvInvMatrix = new Matrix();
    _this._normalMatrix = new Matrix();
    _this._materialsInstanced = [];
    _this._priority = 0;
    _this._receiveShadows = true;
    _this._rendererLayer = new Vector4();
    _this.castShadows = true;
    var prototype = Renderer.prototype;
    var shaderData = _this.shaderData;
    _this._overrideUpdate = _this.update !== prototype.update;
    shaderData._addReferCount(1);
    _this._onTransformChanged = _this._onTransformChanged.bind(_assert_this_initialized(_this));
    _this._registerEntityTransformListener();
    shaderData.enableMacro(Renderer._receiveShadowMacro);
    shaderData.setVector4(Renderer._rendererLayerProperty, _this._rendererLayer);
    return _this;
  }
  var _proto = Renderer1.prototype;
  _proto.getInstanceMaterial = function getInstanceMaterial(index) {
    if (index === void 0)
      index = 0;
    var materials = this._materials;
    if (materials.length > index) {
      var material = materials[index];
      if (material) {
        if (this._materialsInstanced[index]) {
          return material;
        } else {
          return this._createInstanceMaterial(material, index);
        }
      }
    }
    return null;
  };
  _proto.getMaterial = function getMaterial(index) {
    if (index === void 0)
      index = 0;
    return this._materials[index] || null;
  };
  _proto.setMaterial = function setMaterial(indexOrMaterial, material) {
    if (material === void 0)
      material = null;
    if (typeof indexOrMaterial === "number") {
      this._setMaterial(indexOrMaterial, material);
    } else {
      this._setMaterial(0, indexOrMaterial);
    }
  };
  _proto.getInstanceMaterials = function getInstanceMaterials() {
    var materials = this._materials;
    var materialsInstance = this._materialsInstanced;
    for (var i = 0, n = materials.length; i < n; i++) {
      if (!materialsInstance[i]) {
        this._createInstanceMaterial(this._materials[i], i);
      }
    }
    return materials;
  };
  _proto.getMaterials = function getMaterials() {
    return this._materials;
  };
  _proto.setMaterials = function setMaterials(materials) {
    var count = materials.length;
    var internalMaterials = this._materials;
    var materialsInstanced = this._materialsInstanced;
    for (var i = count, n = internalMaterials.length; i < n; i++) {
      var internalMaterial = internalMaterials[i];
      internalMaterial && internalMaterial._addReferCount(-1);
    }
    internalMaterials.length !== count && (internalMaterials.length = count);
    materialsInstanced.length !== 0 && (materialsInstanced.length = 0);
    for (var i1 = 0; i1 < count; i1++) {
      var internalMaterial1 = internalMaterials[i1];
      var material = materials[i1];
      if (internalMaterial1 !== material) {
        internalMaterials[i1] = material;
        internalMaterial1 && internalMaterial1._addReferCount(-1);
        material && material._addReferCount(1);
      }
    }
  };
  _proto.update = function update(deltaTime) {
  };
  _proto._onEnable = function _onEnable() {
    var componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.addOnUpdateRenderers(this);
    }
    componentsManager.addRenderer(this);
  };
  _proto._onDisable = function _onDisable() {
    var componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.removeOnUpdateRenderers(this);
    }
    componentsManager.removeRenderer(this);
  };
  _proto._prepareRender = function _prepareRender(context) {
    var virtualCamera = context.virtualCamera;
    var cameraPosition = virtualCamera.position;
    var boundsCenter = this.bounds.getCenter(Renderer._tempVector0);
    if (virtualCamera.isOrthographic) {
      Vector3.subtract(boundsCenter, cameraPosition, boundsCenter);
      this._distanceForSort = Vector3.dot(boundsCenter, virtualCamera.forward);
    } else {
      this._distanceForSort = Vector3.distanceSquared(boundsCenter, cameraPosition);
    }
    this._updateShaderData(context);
    this._render(context);
    ShaderMacroCollection.unionCollection(context.camera._globalShaderMacro, this.shaderData._macroCollection, this._globalShaderMacro);
  };
  _proto._cloneTo = function _cloneTo(target) {
    var materials = this._materials;
    for (var i = 0, n = materials.length; i < n; i++) {
      target._setMaterial(i, materials[i]);
    }
  };
  _proto._onDestroy = function _onDestroy() {
    Component2.prototype._onDestroy.call(this);
    this.entity.transform._updateFlagManager.removeListener(this._onTransformChanged);
    this.shaderData._addReferCount(-1);
    var materials = this._materials;
    for (var i = 0, n = materials.length; i < n; i++) {
      var _materials_i;
      (_materials_i = materials[i]) == null ? void 0 : _materials_i._addReferCount(-1);
    }
    this._entity = null;
    this._globalShaderMacro = null;
    this._bounds = null;
    this._materials = null;
    this._shaderData = null;
    this._mvMatrix = null;
    this._mvpMatrix = null;
    this._mvInvMatrix = null;
    this._normalMatrix = null;
    this._materialsInstanced = null;
    this._rendererLayer = null;
  };
  _proto._updateShaderData = function _updateShaderData(context) {
    var entity = this.entity;
    var worldMatrix = entity.transform.worldMatrix;
    this._updateTransformShaderData(context, worldMatrix);
    var layer = entity.layer;
    this._rendererLayer.set(layer & 65535, layer >>> 16 & 65535, 0, 0);
  };
  _proto._updateTransformShaderData = function _updateTransformShaderData(context, worldMatrix) {
    var shaderData = this.shaderData;
    var virtualCamera = context.virtualCamera;
    var mvMatrix = this._mvMatrix;
    var mvpMatrix = this._mvpMatrix;
    var mvInvMatrix = this._mvInvMatrix;
    var normalMatrix = this._normalMatrix;
    Matrix.multiply(virtualCamera.viewMatrix, worldMatrix, mvMatrix);
    Matrix.multiply(virtualCamera.viewProjectionMatrix, worldMatrix, mvpMatrix);
    Matrix.invert(mvMatrix, mvInvMatrix);
    Matrix.invert(worldMatrix, normalMatrix);
    normalMatrix.transpose();
    shaderData.setMatrix(Renderer._localMatrixProperty, this.entity.transform.localMatrix);
    shaderData.setMatrix(Renderer._worldMatrixProperty, worldMatrix);
    shaderData.setMatrix(Renderer._mvMatrixProperty, mvMatrix);
    shaderData.setMatrix(Renderer._mvpMatrixProperty, mvpMatrix);
    shaderData.setMatrix(Renderer._mvInvMatrixProperty, mvInvMatrix);
    shaderData.setMatrix(Renderer._normalMatrixProperty, normalMatrix);
  };
  _proto._registerEntityTransformListener = function _registerEntityTransformListener() {
    this.entity.transform._updateFlagManager.addListener(this._onTransformChanged);
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
  };
  _proto._render = function _render(context) {
    throw "not implement";
  };
  _proto._createInstanceMaterial = function _createInstanceMaterial(material, index) {
    var insMaterial = material.clone();
    insMaterial.name = insMaterial.name + "(Instance)";
    material._addReferCount(-1);
    insMaterial._addReferCount(1);
    this._materialsInstanced[index] = true;
    this._materials[index] = insMaterial;
    return insMaterial;
  };
  _proto._setMaterial = function _setMaterial(index, material) {
    var materials = this._materials;
    if (index >= materials.length) {
      materials.length = index + 1;
    }
    var internalMaterial = materials[index];
    if (internalMaterial !== material) {
      var materialsInstance = this._materialsInstanced;
      index < materialsInstance.length && (materialsInstance[index] = false);
      internalMaterial && internalMaterial._addReferCount(-1);
      material && material._addReferCount(1);
      materials[index] = material;
    }
  };
  _proto._onTransformChanged = function _onTransformChanged(type) {
    this._dirtyUpdateFlag |= 1;
  };
  _create_class$4(Renderer1, [
    {
      key: "shaderData",
      get: function get3() {
        return this._shaderData;
      }
    },
    {
      key: "isCulled",
      get: function get3() {
        return !(this._renderFrameCount === void 0 || this._renderFrameCount === this._engine.time.frameCount - 1);
      }
    },
    {
      key: "receiveShadows",
      get: function get3() {
        return this._receiveShadows;
      },
      set: function set(value) {
        if (this._receiveShadows !== value) {
          if (value) {
            this.shaderData.enableMacro(Renderer._receiveShadowMacro);
          } else {
            this.shaderData.disableMacro(Renderer._receiveShadowMacro);
          }
          this._receiveShadows = value;
        }
      }
    },
    {
      key: "materialCount",
      get: function get3() {
        return this._materials.length;
      },
      set: function set(value) {
        var materials = this._materials;
        var materialsInstanced = this._materialsInstanced;
        materials.length !== value && (materials.length = value);
        materialsInstanced.length > value && (materialsInstanced.length = value);
      }
    },
    {
      key: "bounds",
      get: function get3() {
        if (this._dirtyUpdateFlag & 1) {
          this._updateBounds(this._bounds);
          this._dirtyUpdateFlag &= ~1;
        }
        return this._bounds;
      }
    },
    {
      key: "priority",
      get: function get3() {
        return this._priority;
      },
      set: function set(value) {
        this._priority = value;
      }
    }
  ]);
  return Renderer1;
}(Component), function() {
  _Renderer._tempVector0 = new Vector3();
}(), function() {
  _Renderer._receiveShadowMacro = ShaderMacro.getByName("RENDERER_IS_RECEIVE_SHADOWS");
}(), function() {
  _Renderer._localMatrixProperty = ShaderProperty.getByName("renderer_LocalMat");
}(), function() {
  _Renderer._worldMatrixProperty = ShaderProperty.getByName("renderer_ModelMat");
}(), function() {
  _Renderer._mvMatrixProperty = ShaderProperty.getByName("renderer_MVMat");
}(), function() {
  _Renderer._mvpMatrixProperty = ShaderProperty.getByName("renderer_MVPMat");
}(), function() {
  _Renderer._mvInvMatrixProperty = ShaderProperty.getByName("renderer_MVInvMat");
}(), function() {
  _Renderer._normalMatrixProperty = ShaderProperty.getByName("renderer_NormalMat");
}(), function() {
  _Renderer._rendererLayerProperty = ShaderProperty.getByName("renderer_Layer");
}(), _Renderer);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_distanceForSort", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_onUpdateIndex", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_rendererIndex", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_globalShaderMacro", void 0);
__decorate$2([
  deepClone
], Renderer.prototype, "_bounds", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_renderFrameCount", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_overrideUpdate", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_materials", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_dirtyUpdateFlag", void 0);
__decorate$2([
  deepClone
], Renderer.prototype, "_shaderData", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_mvMatrix", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_mvpMatrix", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_mvInvMatrix", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_normalMatrix", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_materialsInstanced", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_priority", void 0);
__decorate$2([
  assignmentClone
], Renderer.prototype, "_receiveShadows", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_rendererLayer", void 0);
__decorate$2([
  ignoreClone
], Renderer.prototype, "_onTransformChanged", null);
Renderer = __decorate$2([
  dependentComponents(Transform, DependentMode.CheckOnly)
], Renderer);
var RendererUpdateFlags;
(function(RendererUpdateFlags2) {
  RendererUpdateFlags2[RendererUpdateFlags2["WorldVolume"] = 1] = "WorldVolume";
})(RendererUpdateFlags || (RendererUpdateFlags = {}));
function StaticInterfaceImplement$1() {
  return function(constructor) {
  };
}
var _SimpleSpriteAssembler;
var SimpleSpriteAssembler = (_SimpleSpriteAssembler = /* @__PURE__ */ function() {
  function SimpleSpriteAssembler1() {
  }
  SimpleSpriteAssembler1.resetData = function resetData(renderer) {
    var verticesData = renderer._verticesData;
    var vertexCount = verticesData.vertexCount = 4;
    var positions = verticesData.positions, uvs = verticesData.uvs;
    if (positions.length < vertexCount) {
      for (var i = positions.length; i < vertexCount; i++) {
        positions.push(new Vector3());
        uvs.push(new Vector2());
      }
    }
    verticesData.triangles = SimpleSpriteAssembler._rectangleTriangles;
  };
  SimpleSpriteAssembler1.updatePositions = function updatePositions(renderer) {
    var width = renderer.width, height = renderer.height, sprite = renderer.sprite;
    var _sprite_pivot = sprite.pivot, pivotX = _sprite_pivot.x, pivotY = _sprite_pivot.y;
    var worldMatrix = SimpleSpriteAssembler._worldMatrix;
    var wE = worldMatrix.elements;
    var _renderer_entity_transform_worldMatrix = renderer.entity.transform.worldMatrix, pWE = _renderer_entity_transform_worldMatrix.elements;
    var sx = renderer.flipX ? -width : width;
    var sy = renderer.flipY ? -height : height;
    wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
    wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
    wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
    wE[12] = pWE[12] - pivotX * wE[0] - pivotY * wE[4];
    wE[13] = pWE[13] - pivotX * wE[1] - pivotY * wE[5];
    wE[14] = pWE[14] - pivotX * wE[2] - pivotY * wE[6];
    var spritePositions = sprite._getPositions();
    var positions = renderer._verticesData.positions;
    for (var i = 0; i < 4; i++) {
      var _spritePositions_i = spritePositions[i], x = _spritePositions_i.x, y = _spritePositions_i.y;
      positions[i].set(wE[0] * x + wE[4] * y + wE[12], wE[1] * x + wE[5] * y + wE[13], wE[2] * x + wE[6] * y + wE[14]);
    }
    BoundingBox.transform(sprite._getBounds(), worldMatrix, renderer._bounds);
  };
  SimpleSpriteAssembler1.updateUVs = function updateUVs(renderer) {
    var spriteUVs = renderer.sprite._getUVs();
    var renderUVs = renderer._verticesData.uvs;
    var _spriteUVs_ = spriteUVs[0], left = _spriteUVs_.x, bottom = _spriteUVs_.y;
    var _spriteUVs_1 = spriteUVs[3], right = _spriteUVs_1.x, top = _spriteUVs_1.y;
    renderUVs[0].set(left, bottom);
    renderUVs[1].set(right, bottom);
    renderUVs[2].set(left, top);
    renderUVs[3].set(right, top);
  };
  return SimpleSpriteAssembler1;
}(), function() {
  _SimpleSpriteAssembler._rectangleTriangles = [
    0,
    1,
    2,
    2,
    1,
    3
  ];
}(), function() {
  _SimpleSpriteAssembler._worldMatrix = new Matrix();
}(), _SimpleSpriteAssembler);
SimpleSpriteAssembler = __decorate$2([
  StaticInterfaceImplement$1()
], SimpleSpriteAssembler);
var VertexData2D = function VertexData2D2(vertexCount, positions, uvs, triangles, color) {
  if (triangles === void 0)
    triangles = null;
  if (color === void 0)
    color = null;
  this.vertexCount = vertexCount;
  this.positions = positions;
  this.uvs = uvs;
  this.triangles = triangles;
  this.color = color;
};
var SpriteMaskLayer;
(function(SpriteMaskLayer2) {
  SpriteMaskLayer2[SpriteMaskLayer2["Layer0"] = 1] = "Layer0";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer1"] = 2] = "Layer1";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer2"] = 4] = "Layer2";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer3"] = 8] = "Layer3";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer4"] = 16] = "Layer4";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer5"] = 32] = "Layer5";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer6"] = 64] = "Layer6";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer7"] = 128] = "Layer7";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer8"] = 256] = "Layer8";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer9"] = 512] = "Layer9";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer10"] = 1024] = "Layer10";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer11"] = 2048] = "Layer11";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer12"] = 4096] = "Layer12";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer13"] = 8192] = "Layer13";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer14"] = 16384] = "Layer14";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer15"] = 32768] = "Layer15";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer16"] = 65536] = "Layer16";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer17"] = 131072] = "Layer17";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer18"] = 262144] = "Layer18";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer19"] = 524288] = "Layer19";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer20"] = 1048576] = "Layer20";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer21"] = 2097152] = "Layer21";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer22"] = 4194304] = "Layer22";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer23"] = 8388608] = "Layer23";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer24"] = 16777216] = "Layer24";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer25"] = 33554432] = "Layer25";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer26"] = 67108864] = "Layer26";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer27"] = 134217728] = "Layer27";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer28"] = 268435456] = "Layer28";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer29"] = 536870912] = "Layer29";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer30"] = 1073741824] = "Layer30";
  SpriteMaskLayer2[SpriteMaskLayer2["Layer31"] = 2147483648] = "Layer31";
  SpriteMaskLayer2[SpriteMaskLayer2["Everything"] = 4294967295] = "Everything";
})(SpriteMaskLayer || (SpriteMaskLayer = {}));
var SpriteModifyFlags;
(function(SpriteModifyFlags2) {
  SpriteModifyFlags2[SpriteModifyFlags2["texture"] = 1] = "texture";
  SpriteModifyFlags2[SpriteModifyFlags2["size"] = 2] = "size";
  SpriteModifyFlags2[SpriteModifyFlags2["atlasRotate"] = 4] = "atlasRotate";
  SpriteModifyFlags2[SpriteModifyFlags2["atlasRegion"] = 8] = "atlasRegion";
  SpriteModifyFlags2[SpriteModifyFlags2["atlasRegionOffset"] = 16] = "atlasRegionOffset";
  SpriteModifyFlags2[SpriteModifyFlags2["region"] = 32] = "region";
  SpriteModifyFlags2[SpriteModifyFlags2["pivot"] = 64] = "pivot";
  SpriteModifyFlags2[SpriteModifyFlags2["border"] = 128] = "border";
})(SpriteModifyFlags || (SpriteModifyFlags = {}));
var SpriteMask = /* @__PURE__ */ function(Renderer2) {
  _inherits$2(SpriteMask2, Renderer2);
  function SpriteMask2(entity) {
    var _this;
    _this = Renderer2.call(this, entity) || this;
    _this.influenceLayers = SpriteMaskLayer.Everything;
    _this._sprite = null;
    _this._automaticWidth = 0;
    _this._automaticHeight = 0;
    _this._customWidth = void 0;
    _this._customHeight = void 0;
    _this._flipX = false;
    _this._flipY = false;
    _this._alphaCutoff = 0.5;
    _this._verticesData = new VertexData2D(4, [], []);
    SimpleSpriteAssembler.resetData(_assert_this_initialized(_this));
    _this.setMaterial(_this._engine._spriteMaskDefaultMaterial);
    _this.shaderData.setFloat(SpriteMask2._alphaCutoffProperty, _this._alphaCutoff);
    _this._onSpriteChange = _this._onSpriteChange.bind(_assert_this_initialized(_this));
    return _this;
  }
  var _proto = SpriteMask2.prototype;
  _proto._cloneTo = function _cloneTo(target) {
    Renderer2.prototype._cloneTo.call(this, target);
    target.sprite = this._sprite;
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    if (this.sprite) {
      SimpleSpriteAssembler.updatePositions(this);
    } else {
      worldBounds.min.set(0, 0, 0);
      worldBounds.max.set(0, 0, 0);
    }
  };
  _proto._render = function _render(context) {
    var _this_sprite;
    if (!((_this_sprite = this.sprite) == null ? void 0 : _this_sprite.texture) || !this.width || !this.height) {
      return;
    }
    if (this._dirtyUpdateFlag & RendererUpdateFlags.WorldVolume) {
      SimpleSpriteAssembler.updatePositions(this);
      this._dirtyUpdateFlag &= ~RendererUpdateFlags.WorldVolume;
    }
    if (this._dirtyUpdateFlag & 2) {
      SimpleSpriteAssembler.updateUVs(this);
      this._dirtyUpdateFlag &= ~2;
    }
    context.camera._renderPipeline._allSpriteMasks.add(this);
    var renderData = this._engine._spriteMaskRenderDataPool.getFromPool();
    var material = this.getMaterial();
    renderData.set(this, material, this._verticesData);
    var renderElement = this._engine._renderElementPool.getFromPool();
    renderElement.set(renderData, material.shader.subShaders[0].passes[0], material.renderStates[0]);
    this._maskElement = renderElement;
  };
  _proto._onDestroy = function _onDestroy() {
    Renderer2.prototype._onDestroy.call(this);
    var sprite = this._sprite;
    if (sprite) {
      sprite._addReferCount(-1);
      sprite._updateFlagManager.removeListener(this._onSpriteChange);
    }
    this._entity = null;
    this._sprite = null;
    this._verticesData = null;
  };
  _proto._calDefaultSize = function _calDefaultSize() {
    var sprite = this._sprite;
    if (sprite) {
      this._automaticWidth = sprite.width;
      this._automaticHeight = sprite.height;
    } else {
      this._automaticWidth = this._automaticHeight = 0;
    }
    this._dirtyUpdateFlag &= ~4;
  };
  _proto._onSpriteChange = function _onSpriteChange(type) {
    switch (type) {
      case SpriteModifyFlags.texture:
        this.shaderData.setTexture(SpriteMask2._textureProperty, this.sprite.texture);
        break;
      case SpriteModifyFlags.size:
        this._dirtyUpdateFlag |= 4;
        if (this._customWidth === void 0 || this._customHeight === void 0) {
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        }
        break;
      case SpriteModifyFlags.region:
      case SpriteModifyFlags.atlasRegionOffset:
        this._dirtyUpdateFlag |= 3;
        break;
      case SpriteModifyFlags.atlasRegion:
        this._dirtyUpdateFlag |= 2;
        break;
      case SpriteModifyFlags.pivot:
        this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        break;
    }
  };
  _create_class$4(SpriteMask2, [
    {
      key: "width",
      get: function get3() {
        if (this._customWidth !== void 0) {
          return this._customWidth;
        } else {
          this._dirtyUpdateFlag & 4 && this._calDefaultSize();
          return this._automaticWidth;
        }
      },
      set: function set(value) {
        if (this._customWidth !== value) {
          this._customWidth = value;
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        }
      }
    },
    {
      key: "height",
      get: function get3() {
        if (this._customHeight !== void 0) {
          return this._customHeight;
        } else {
          this._dirtyUpdateFlag & 4 && this._calDefaultSize();
          return this._automaticHeight;
        }
      },
      set: function set(value) {
        if (this._customHeight !== value) {
          this._customHeight = value;
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        }
      }
    },
    {
      key: "flipX",
      get: function get3() {
        return this._flipX;
      },
      set: function set(value) {
        if (this._flipX !== value) {
          this._flipX = value;
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        }
      }
    },
    {
      key: "flipY",
      get: function get3() {
        return this._flipY;
      },
      set: function set(value) {
        if (this._flipY !== value) {
          this._flipY = value;
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        }
      }
    },
    {
      key: "sprite",
      get: function get3() {
        return this._sprite;
      },
      set: function set(value) {
        var lastSprite = this._sprite;
        if (lastSprite !== value) {
          if (lastSprite) {
            lastSprite._addReferCount(-1);
            lastSprite._updateFlagManager.removeListener(this._onSpriteChange);
          }
          this._dirtyUpdateFlag |= 7;
          if (value) {
            value._addReferCount(1);
            value._updateFlagManager.addListener(this._onSpriteChange);
            this.shaderData.setTexture(SpriteMask2._textureProperty, value.texture);
          } else {
            this.shaderData.setTexture(SpriteMask2._textureProperty, null);
          }
          this._sprite = value;
        }
      }
    },
    {
      key: "alphaCutoff",
      get: function get3() {
        return this._alphaCutoff;
      },
      set: function set(value) {
        if (this._alphaCutoff !== value) {
          this._alphaCutoff = value;
          this.shaderData.setFloat(SpriteMask2._alphaCutoffProperty, value);
        }
      }
    }
  ]);
  return SpriteMask2;
}(Renderer);
(function() {
  SpriteMask._textureProperty = ShaderProperty.getByName("renderer_MaskTexture");
})();
(function() {
  SpriteMask._alphaCutoffProperty = ShaderProperty.getByName("renderer_MaskAlphaCutoff");
})();
__decorate$2([
  assignmentClone
], SpriteMask.prototype, "influenceLayers", void 0);
__decorate$2([
  ignoreClone
], SpriteMask.prototype, "_sprite", void 0);
__decorate$2([
  ignoreClone
], SpriteMask.prototype, "_automaticWidth", void 0);
__decorate$2([
  ignoreClone
], SpriteMask.prototype, "_automaticHeight", void 0);
__decorate$2([
  assignmentClone
], SpriteMask.prototype, "_customWidth", void 0);
__decorate$2([
  assignmentClone
], SpriteMask.prototype, "_customHeight", void 0);
__decorate$2([
  assignmentClone
], SpriteMask.prototype, "_flipX", void 0);
__decorate$2([
  assignmentClone
], SpriteMask.prototype, "_flipY", void 0);
__decorate$2([
  assignmentClone
], SpriteMask.prototype, "_alphaCutoff", void 0);
__decorate$2([
  ignoreClone
], SpriteMask.prototype, "_onSpriteChange", null);
var SpriteMaskUpdateFlags;
(function(SpriteMaskUpdateFlags2) {
  SpriteMaskUpdateFlags2[SpriteMaskUpdateFlags2["UV"] = 2] = "UV";
  SpriteMaskUpdateFlags2[SpriteMaskUpdateFlags2["RenderData"] = 3] = "RenderData";
  SpriteMaskUpdateFlags2[SpriteMaskUpdateFlags2["AutomaticSize"] = 4] = "AutomaticSize";
  SpriteMaskUpdateFlags2[SpriteMaskUpdateFlags2["All"] = 7] = "All";
})(SpriteMaskUpdateFlags || (SpriteMaskUpdateFlags = {}));
var VertexElementFormat;
(function(VertexElementFormat2) {
  VertexElementFormat2[VertexElementFormat2["Float"] = 0] = "Float";
  VertexElementFormat2[VertexElementFormat2["Vector2"] = 1] = "Vector2";
  VertexElementFormat2[VertexElementFormat2["Vector3"] = 2] = "Vector3";
  VertexElementFormat2[VertexElementFormat2["Vector4"] = 3] = "Vector4";
  VertexElementFormat2[VertexElementFormat2["Byte4"] = 4] = "Byte4";
  VertexElementFormat2[VertexElementFormat2["UByte4"] = 5] = "UByte4";
  VertexElementFormat2[VertexElementFormat2["NormalizedByte4"] = 6] = "NormalizedByte4";
  VertexElementFormat2[VertexElementFormat2["NormalizedUByte4"] = 7] = "NormalizedUByte4";
  VertexElementFormat2[VertexElementFormat2["Short2"] = 8] = "Short2";
  VertexElementFormat2[VertexElementFormat2["UShort2"] = 9] = "UShort2";
  VertexElementFormat2[VertexElementFormat2["NormalizedShort2"] = 10] = "NormalizedShort2";
  VertexElementFormat2[VertexElementFormat2["NormalizedUShort2"] = 11] = "NormalizedUShort2";
  VertexElementFormat2[VertexElementFormat2["Short4"] = 12] = "Short4";
  VertexElementFormat2[VertexElementFormat2["UShort4"] = 13] = "UShort4";
  VertexElementFormat2[VertexElementFormat2["NormalizedShort4"] = 14] = "NormalizedShort4";
  VertexElementFormat2[VertexElementFormat2["NormalizedUShort4"] = 15] = "NormalizedUShort4";
})(VertexElementFormat || (VertexElementFormat = {}));
var IndexFormat;
(function(IndexFormat2) {
  IndexFormat2[IndexFormat2["UInt8"] = 0] = "UInt8";
  IndexFormat2[IndexFormat2["UInt16"] = 1] = "UInt16";
  IndexFormat2[IndexFormat2["UInt32"] = 2] = "UInt32";
})(IndexFormat || (IndexFormat = {}));
var BufferUtil = /* @__PURE__ */ function() {
  function BufferUtil2() {
  }
  BufferUtil2._getGLIndexType = function _getGLIndexType(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return DataType.UNSIGNED_BYTE;
      case IndexFormat.UInt16:
        return DataType.UNSIGNED_SHORT;
      case IndexFormat.UInt32:
        return DataType.UNSIGNED_INT;
    }
  };
  BufferUtil2._getGLIndexByteCount = function _getGLIndexByteCount(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return 1;
      case IndexFormat.UInt16:
        return 2;
      case IndexFormat.UInt32:
        return 4;
    }
  };
  BufferUtil2._getElementInfo = function _getElementInfo(format) {
    var size;
    var type;
    var normalized = false;
    switch (format) {
      case VertexElementFormat.Float:
        size = 1;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector2:
        size = 2;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector3:
        size = 3;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector4:
        size = 4;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Byte4:
        size = 4;
        type = DataType.BYTE;
        break;
      case VertexElementFormat.UByte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        break;
      case VertexElementFormat.NormalizedByte4:
        size = 4;
        type = DataType.BYTE;
        normalized = true;
        break;
      case VertexElementFormat.NormalizedUByte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        normalized = true;
        break;
      case VertexElementFormat.Short2:
        size = 2;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.UShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        break;
      case VertexElementFormat.NormalizedShort2:
        size = 2;
        type = DataType.SHORT;
        normalized = true;
        break;
      case VertexElementFormat.NormalizedUShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        normalized = true;
        break;
      case VertexElementFormat.Short4:
        size = 4;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.UShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        break;
      case VertexElementFormat.NormalizedShort4:
        size = 4;
        type = DataType.SHORT;
        normalized = true;
        break;
      case VertexElementFormat.NormalizedUShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        normalized = true;
        break;
    }
    return {
      size,
      type,
      normalized
    };
  };
  return BufferUtil2;
}();
var VertexElement = /* @__PURE__ */ function() {
  function VertexElement2(semantic, offset, format, bindingIndex, instanceStepRate) {
    if (instanceStepRate === void 0)
      instanceStepRate = 0;
    this._semantic = semantic;
    this._offset = offset;
    this._format = format;
    this._bindingIndex = bindingIndex;
    this._glElementInfo = BufferUtil._getElementInfo(this.format);
    this._instanceStepRate = Math.floor(instanceStepRate);
  }
  _create_class$4(VertexElement2, [
    {
      key: "semantic",
      get: function get3() {
        return this._semantic;
      }
    },
    {
      key: "offset",
      get: function get3() {
        return this._offset;
      },
      set: function set(value) {
        this._offset = value;
      }
    },
    {
      key: "format",
      get: function get3() {
        return this._format;
      }
    },
    {
      key: "bindingIndex",
      get: function get3() {
        return this._bindingIndex;
      },
      set: function set(value) {
        this._bindingIndex = value;
      }
    },
    {
      key: "instanceStepRate",
      get: function get3() {
        return this._instanceStepRate;
      }
    }
  ]);
  return VertexElement2;
}();
var BufferUsage;
(function(BufferUsage2) {
  BufferUsage2[BufferUsage2["Static"] = 0] = "Static";
  BufferUsage2[BufferUsage2["Dynamic"] = 1] = "Dynamic";
  BufferUsage2[BufferUsage2["Stream"] = 2] = "Stream";
})(BufferUsage || (BufferUsage = {}));
var SetDataOptions;
(function(SetDataOptions2) {
  SetDataOptions2[SetDataOptions2["None"] = 0] = "None";
  SetDataOptions2[SetDataOptions2["Discard"] = 1] = "Discard";
})(SetDataOptions || (SetDataOptions = {}));
var Buffer = /* @__PURE__ */ function(GraphicsResource2) {
  _inherits$2(Buffer2, GraphicsResource2);
  function Buffer2(engine, type, byteLengthOrData, bufferUsage) {
    if (bufferUsage === void 0)
      bufferUsage = BufferUsage.Static;
    var _this;
    _this = GraphicsResource2.call(this, engine) || this;
    _this._engine = engine;
    _this._type = type;
    _this._bufferUsage = bufferUsage;
    if (typeof byteLengthOrData === "number") {
      _this._byteLength = byteLengthOrData;
      _this._platformBuffer = engine._hardwareRenderer.createPlatformBuffer(type, byteLengthOrData, bufferUsage);
    } else {
      var byteLength = byteLengthOrData.byteLength;
      _this._byteLength = byteLength;
      _this._platformBuffer = engine._hardwareRenderer.createPlatformBuffer(type, byteLength, bufferUsage, byteLengthOrData);
    }
    return _this;
  }
  var _proto = Buffer2.prototype;
  _proto.bind = function bind2() {
    this._platformBuffer.bind();
  };
  _proto.setData = function setData(data, bufferByteOffset, dataOffset, dataLength, options) {
    if (bufferByteOffset === void 0)
      bufferByteOffset = 0;
    if (dataOffset === void 0)
      dataOffset = 0;
    if (options === void 0)
      options = SetDataOptions.None;
    this._platformBuffer.setData(this._byteLength, data, bufferByteOffset, dataOffset, dataLength, options);
  };
  _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
    if (bufferByteOffset === void 0)
      bufferByteOffset = 0;
    if (dataOffset === void 0)
      dataOffset = 0;
    this._platformBuffer.getData(data, bufferByteOffset, dataOffset, dataLength);
  };
  _proto._rebuild = function _rebuild() {
    var platformBuffer = this._engine._hardwareRenderer.createPlatformBuffer(this._type, this._byteLength, this._bufferUsage);
    this._platformBuffer = platformBuffer;
  };
  _proto._onDestroy = function _onDestroy() {
    GraphicsResource2.prototype._onDestroy.call(this);
    this._platformBuffer.destroy();
  };
  _proto.resize = function resize(byteLength) {
    this._platformBuffer.resize(byteLength);
    this._byteLength = byteLength;
  };
  _create_class$4(Buffer2, [
    {
      key: "type",
      get: function get3() {
        return this._type;
      }
    },
    {
      key: "byteLength",
      get: function get3() {
        return this._byteLength;
      }
    },
    {
      key: "bufferUsage",
      get: function get3() {
        return this._bufferUsage;
      }
    }
  ]);
  return Buffer2;
}(GraphicsResource);
var BufferBindFlag;
(function(BufferBindFlag2) {
  BufferBindFlag2[BufferBindFlag2["VertexBuffer"] = 0] = "VertexBuffer";
  BufferBindFlag2[BufferBindFlag2["IndexBuffer"] = 1] = "IndexBuffer";
})(BufferBindFlag || (BufferBindFlag = {}));
var MeshTopology;
(function(MeshTopology2) {
  MeshTopology2[MeshTopology2["Points"] = 0] = "Points";
  MeshTopology2[MeshTopology2["Lines"] = 1] = "Lines";
  MeshTopology2[MeshTopology2["LineLoop"] = 2] = "LineLoop";
  MeshTopology2[MeshTopology2["LineStrip"] = 3] = "LineStrip";
  MeshTopology2[MeshTopology2["Triangles"] = 4] = "Triangles";
  MeshTopology2[MeshTopology2["TriangleStrip"] = 5] = "TriangleStrip";
  MeshTopology2[MeshTopology2["TriangleFan"] = 6] = "TriangleFan";
})(MeshTopology || (MeshTopology = {}));
var IndexBufferBinding = /* @__PURE__ */ function() {
  function IndexBufferBinding2(buffer, format) {
    this._buffer = buffer;
    this._format = format;
  }
  _create_class$4(IndexBufferBinding2, [
    {
      key: "buffer",
      get: function get3() {
        return this._buffer;
      }
    },
    {
      key: "format",
      get: function get3() {
        return this._format;
      }
    }
  ]);
  return IndexBufferBinding2;
}();
var SubMesh = /* @__PURE__ */ function() {
  function SubMesh2(start, count, topology) {
    if (start === void 0)
      start = 0;
    if (count === void 0)
      count = 0;
    if (topology === void 0)
      topology = MeshTopology.Triangles;
    this.start = start;
    this.count = count;
    this.topology = topology;
  }
  var _proto = SubMesh2.prototype;
  _proto.dispose = function dispose() {
  };
  return SubMesh2;
}();
var Mesh = /* @__PURE__ */ function(GraphicsResource2) {
  _inherits$2(Mesh2, GraphicsResource2);
  function Mesh2(engine, name2) {
    var _this;
    _this = GraphicsResource2.call(this, engine) || this;
    _this._vertexElementMap = {};
    _this._instanceCount = 0;
    _this._vertexBufferBindings = [];
    _this._indexBufferBinding = null;
    _this._vertexElements = [];
    _this._enableVAO = true;
    _this._updateFlagManager = new UpdateFlagManager();
    _this._bounds = new BoundingBox();
    _this._subMeshes = [];
    _this.name = name2;
    _this._platformPrimitive = _this._engine._hardwareRenderer.createPlatformPrimitive(_assert_this_initialized(_this));
    _this._onBoundsChanged = _this._onBoundsChanged.bind(_assert_this_initialized(_this));
    var bounds = _this._bounds;
    bounds.min._onValueChanged = _this._onBoundsChanged;
    bounds.max._onValueChanged = _this._onBoundsChanged;
    return _this;
  }
  var _proto = Mesh2.prototype;
  _proto.addSubMesh = function addSubMesh(startOrSubMesh, count, topology) {
    if (topology === void 0)
      topology = MeshTopology.Triangles;
    if (typeof startOrSubMesh === "number") {
      startOrSubMesh = new SubMesh(startOrSubMesh, count, topology);
    }
    this._subMeshes.push(startOrSubMesh);
    return startOrSubMesh;
  };
  _proto.removeSubMesh = function removeSubMesh(subMesh) {
    var subMeshes = this._subMeshes;
    var index = subMeshes.indexOf(subMesh);
    if (index !== -1) {
      subMeshes.splice(index, 1);
    }
  };
  _proto.clearSubMesh = function clearSubMesh() {
    this._subMeshes.length = 0;
  };
  _proto._clearVertexElements = function _clearVertexElements() {
    this._vertexElements.length = 0;
    var vertexElementMap = this._vertexElementMap;
    for (var k2 in vertexElementMap) {
      delete vertexElementMap[k2];
    }
  };
  _proto._addVertexElement = function _addVertexElement(element) {
    var semantic = element.semantic;
    this._vertexElementMap[semantic] = element;
    this._vertexElements.push(element);
    this._updateFlagManager.dispatch(2);
    this._bufferStructChanged = true;
  };
  _proto._insertVertexElement = function _insertVertexElement(i, element) {
    var semantic = element.semantic;
    this._vertexElementMap[semantic] = element;
    this._vertexElements.splice(i, 0, element);
    this._updateFlagManager.dispatch(2);
    this._bufferStructChanged = true;
  };
  _proto._setVertexBufferBinding = function _setVertexBufferBinding(index, binding) {
    var referCount = this._getReferCount();
    if (referCount > 0) {
      var _this__vertexBufferBindings_index;
      (_this__vertexBufferBindings_index = this._vertexBufferBindings[index]) == null ? void 0 : _this__vertexBufferBindings_index._buffer._addReferCount(-referCount);
      binding == null ? void 0 : binding._buffer._addReferCount(referCount);
    }
    this._vertexBufferBindings[index] = binding;
    this._bufferStructChanged = true;
  };
  _proto._draw = function _draw(shaderProgram, subMesh) {
    this._platformPrimitive.draw(shaderProgram, subMesh);
    this._bufferStructChanged = false;
  };
  _proto._addReferCount = function _addReferCount(value) {
    var _this__indexBufferBinding;
    GraphicsResource2.prototype._addReferCount.call(this, value);
    var vertexBufferBindings = this._vertexBufferBindings;
    for (var i = 0, n = vertexBufferBindings.length; i < n; i++) {
      vertexBufferBindings[i]._buffer._addReferCount(value);
    }
    (_this__indexBufferBinding = this._indexBufferBinding) == null ? void 0 : _this__indexBufferBinding._buffer._addReferCount(value);
  };
  _proto._rebuild = function _rebuild() {
    this._engine._hardwareRenderer.createPlatformPrimitive(this);
  };
  _proto._onDestroy = function _onDestroy() {
    GraphicsResource2.prototype._onDestroy.call(this);
    this._vertexBufferBindings = null;
    this._indexBufferBinding = null;
    this._vertexElements = null;
    this._vertexElementMap = null;
    this._platformPrimitive.destroy();
  };
  _proto._setVertexElements = function _setVertexElements(elements) {
    this._clearVertexElements();
    for (var i = 0, n = elements.length; i < n; i++) {
      this._addVertexElement(elements[i]);
    }
  };
  _proto._setIndexBufferBinding = function _setIndexBufferBinding(binding) {
    var lastBinding = this._indexBufferBinding;
    var referCount = this._getReferCount();
    if (referCount > 0) {
      lastBinding == null ? void 0 : lastBinding.buffer._addReferCount(-referCount);
      binding == null ? void 0 : binding.buffer._addReferCount(referCount);
    }
    if (binding) {
      this._indexBufferBinding = binding;
      this._glIndexType = BufferUtil._getGLIndexType(binding.format);
      this._glIndexByteCount = BufferUtil._getGLIndexByteCount(binding.format);
      (!lastBinding || lastBinding._buffer !== binding._buffer) && (this._bufferStructChanged = true);
    } else {
      this._indexBufferBinding = null;
      this._glIndexType = void 0;
      lastBinding && (this._bufferStructChanged = true);
    }
  };
  _proto._onBoundsChanged = function _onBoundsChanged() {
    this._updateFlagManager.dispatch(1);
  };
  _create_class$4(Mesh2, [
    {
      key: "bounds",
      get: function get3() {
        return this._bounds;
      },
      set: function set(value) {
        if (this._bounds !== value) {
          this._bounds.copyFrom(value);
        }
      }
    },
    {
      key: "subMesh",
      get: function get3() {
        return this._subMeshes[0] || null;
      }
    },
    {
      key: "subMeshes",
      get: function get3() {
        return this._subMeshes;
      }
    }
  ]);
  return Mesh2;
}(GraphicsResource);
var MeshModifyFlags;
(function(MeshModifyFlags2) {
  MeshModifyFlags2[MeshModifyFlags2["Bounds"] = 1] = "Bounds";
  MeshModifyFlags2[MeshModifyFlags2["VertexElements"] = 2] = "VertexElements";
})(MeshModifyFlags || (MeshModifyFlags = {}));
var VertexBufferBinding = /* @__PURE__ */ function() {
  function VertexBufferBinding2(buffer, stride) {
    this._buffer = buffer;
    this._stride = stride;
  }
  _create_class$4(VertexBufferBinding2, [
    {
      key: "buffer",
      get: function get3() {
        return this._buffer;
      }
    },
    {
      key: "stride",
      get: function get3() {
        return this._stride;
      }
    }
  ]);
  return VertexBufferBinding2;
}();
var BlendShapeManager = /* @__PURE__ */ function() {
  function BlendShapeManager2(engine, modelMesh) {
    this._blendShapeCount = 0;
    this._blendShapes = [];
    this._subDataDirtyFlags = [];
    this._vertexBuffers = [];
    this._uniformOccupiesCount = 0;
    this._useBlendNormal = false;
    this._useBlendTangent = false;
    this._vertexElementCount = 0;
    this._storeInVertexBufferInfo = [];
    this._maxCountSingleVertexBuffer = 0;
    this._lastCreateHostInfo = new Vector3(0, 0, 0);
    this._canUseTextureStoreData = true;
    this._dataTextureInfo = new Vector3();
    this._engine = engine;
    this._modelMesh = modelMesh;
    this._canUseTextureStoreData = this._engine._hardwareRenderer.capability.canUseFloatTextureBlendShape;
    this._updateLayoutChange = this._updateLayoutChange.bind(this);
  }
  var _proto = BlendShapeManager2.prototype;
  _proto._addBlendShape = function _addBlendShape(blendShape) {
    this._blendShapes.push(blendShape);
    this._blendShapeCount++;
    blendShape._layoutChangeManager.addListener(this._updateLayoutChange);
    this._updateLayoutChange(0, blendShape);
    this._subDataDirtyFlags.push(blendShape._dataChangeManager.createFlag(BoolUpdateFlag));
  };
  _proto._clearBlendShapes = function _clearBlendShapes() {
    var blendShapes = this._blendShapes;
    for (var i = 0, n = blendShapes.length; i < n; i++) {
      blendShapes[i]._layoutChangeManager.removeListener(this._updateLayoutChange);
    }
    this._useBlendNormal = false;
    this._useBlendTangent = false;
    this._vertexElementCount = 0;
    this._blendShapes.length = 0;
    this._blendShapeCount = 0;
    var subDataDirtyFlags = this._subDataDirtyFlags;
    for (var i1 = 0, n1 = subDataDirtyFlags.length; i1 < n1; i1++) {
      subDataDirtyFlags[i1].destroy();
    }
    subDataDirtyFlags.length = 0;
  };
  _proto._updateShaderData = function _updateShaderData(shaderData, skinnedMeshRenderer) {
    var blendShapeCount = this._blendShapeCount;
    if (blendShapeCount > 0) {
      shaderData.enableMacro(BlendShapeManager2._blendShapeMacro);
      if (this._useTextureMode()) {
        shaderData.enableMacro(BlendShapeManager2._blendShapeTextureMacro);
        shaderData.setTexture(BlendShapeManager2._blendShapeTextureProperty, this._vertexTexture);
        shaderData.setVector3(BlendShapeManager2._blendShapeTextureInfoProperty, this._dataTextureInfo);
        shaderData.setFloatArray(BlendShapeManager2._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
        shaderData.enableMacro("RENDERER_BLENDSHAPE_COUNT", blendShapeCount.toString());
        this._uniformOccupiesCount = blendShapeCount + 1;
      } else {
        var maxBlendCount = this._getVertexBufferModeSupportCount();
        if (blendShapeCount > maxBlendCount) {
          var condensedBlendShapeWeights = skinnedMeshRenderer._condensedBlendShapeWeights;
          if (!condensedBlendShapeWeights) {
            condensedBlendShapeWeights = new Float32Array(maxBlendCount);
            skinnedMeshRenderer._condensedBlendShapeWeights = condensedBlendShapeWeights;
          }
          this._filterCondensedBlendShapeWeights(skinnedMeshRenderer.blendShapeWeights, condensedBlendShapeWeights);
          shaderData.setFloatArray(BlendShapeManager2._blendShapeWeightsProperty, condensedBlendShapeWeights);
          this._modelMesh._enableVAO = false;
          blendShapeCount = maxBlendCount;
        } else {
          shaderData.setFloatArray(BlendShapeManager2._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
          this._modelMesh._enableVAO = true;
        }
        shaderData.disableMacro(BlendShapeManager2._blendShapeTextureMacro);
        shaderData.disableMacro("RENDERER_BLENDSHAPE_COUNT");
        this._uniformOccupiesCount = blendShapeCount;
      }
      if (this._useBlendNormal) {
        shaderData.enableMacro(BlendShapeManager2._blendShapeNormalMacro);
      } else {
        shaderData.disableMacro(BlendShapeManager2._blendShapeNormalMacro);
      }
      if (this._useBlendTangent) {
        shaderData.enableMacro(BlendShapeManager2._blendShapeTangentMacro);
      } else {
        shaderData.disableMacro(BlendShapeManager2._blendShapeTangentMacro);
      }
    } else {
      shaderData.disableMacro(BlendShapeManager2._blendShapeMacro);
      shaderData.disableMacro("RENDERER_BLENDSHAPE_COUNT");
    }
  };
  _proto._useTextureMode = function _useTextureMode() {
    if (!this._canUseTextureStoreData) {
      return false;
    }
    return this._blendShapeCount > this._getVertexBufferModeSupportCount();
  };
  _proto._layoutOrCountChange = function _layoutOrCountChange() {
    var last = this._lastCreateHostInfo;
    return last.x !== this._blendShapeCount || !!last.y !== this._useBlendNormal || !!last.z !== this._useBlendTangent;
  };
  _proto._vertexElementsNeedUpdate = function _vertexElementsNeedUpdate() {
    var maxSupportCount = this._getVertexBufferModeSupportCount();
    var info2 = this._lastCreateHostInfo;
    return Math.min(info2.x, maxSupportCount) !== Math.min(this._blendShapeCount, maxSupportCount) || !!info2.y !== this._useBlendNormal || !!info2.z !== this._useBlendTangent;
  };
  _proto._needUpdateData = function _needUpdateData() {
    var subDataDirtyFlags = this._subDataDirtyFlags;
    for (var i = 0, n = subDataDirtyFlags.length; i < n; i++) {
      if (subDataDirtyFlags[i].flag) {
        return true;
      }
    }
    return false;
  };
  _proto._setAttributeModeOffsetInfo = function _setAttributeModeOffsetInfo(vertexElementOffset, bufferBindingOffset) {
    this._vertexElementOffset = vertexElementOffset;
    this._bufferBindingOffset = bufferBindingOffset;
  };
  _proto._addVertexElements = function _addVertexElements(modelMesh) {
    var bindingOffset = this._bufferBindingOffset;
    var offset = 0;
    for (var i = 0, n = Math.min(this._blendShapeCount, this._getVertexBufferModeSupportCount()); i < n; i++) {
      modelMesh._addVertexElement(new VertexElement("POSITION_BS" + i, offset, VertexElementFormat.Vector3, bindingOffset));
      offset += 12;
      if (this._useBlendNormal) {
        modelMesh._addVertexElement(new VertexElement("NORMAL_BS" + i, offset, VertexElementFormat.Vector3, bindingOffset));
        offset += 12;
      }
      if (this._useBlendTangent) {
        modelMesh._addVertexElement(new VertexElement("TANGENT_BS" + i, offset, VertexElementFormat.Vector3, bindingOffset));
        offset += 12;
      }
    }
  };
  _proto._update = function _update(vertexCountChange, noLongerReadable) {
    var vertexCount = this._modelMesh.vertexCount;
    var useTexture = this._useTextureMode();
    var createHost = this._layoutOrCountChange() || vertexCountChange;
    if (createHost) {
      if (useTexture) {
        this._createTextureArray(vertexCount);
      } else {
        this._createVertexBuffers(vertexCount, noLongerReadable);
      }
      this._lastCreateHostInfo.set(this._blendShapeCount, +this._useBlendNormal, +this._useBlendTangent);
    }
    if (this._needUpdateData()) {
      if (useTexture) {
        this._updateTextureArray(vertexCount, createHost);
      } else {
        this._updateVertexBuffers(vertexCount, createHost);
      }
    }
  };
  _proto._releaseMemoryCache = function _releaseMemoryCache() {
    var blendShapes = this._blendShapes;
    for (var i = 0, n = blendShapes.length; i < n; i++) {
      blendShapes[i]._releaseData();
    }
    this._vertices = null;
  };
  _proto._createVertexBuffers = function _createVertexBuffers(vertexCount, noLongerAccessible) {
    var _this = this, engine = _this._engine, modelMesh = _this._modelMesh, blendShapeCount = _this._blendShapeCount, vertexBuffers = _this._vertexBuffers;
    var vertexFloatCount = this._vertexElementCount * 3;
    var vertexByteCount = vertexFloatCount * 4;
    var maxCountSingleBuffer = Math.floor(255 / vertexByteCount);
    var bufferCount = Math.ceil(blendShapeCount / maxCountSingleBuffer);
    var floatCount = vertexFloatCount * vertexCount * Math.min(maxCountSingleBuffer, blendShapeCount);
    vertexBuffers.length = bufferCount;
    this._vertices = new Float32Array(floatCount);
    this._maxCountSingleVertexBuffer = maxCountSingleBuffer;
    this._storeInVertexBufferInfo.length = blendShapeCount;
    var bufferBindingOffset = this._bufferBindingOffset;
    for (var i = 0; i < bufferCount; i++) {
      var lastIndex = bufferCount - 1;
      var containCount = i === lastIndex ? blendShapeCount - lastIndex * maxCountSingleBuffer : maxCountSingleBuffer;
      var stride = containCount * vertexByteCount;
      var byteLength = stride * vertexCount;
      var usage = noLongerAccessible ? BufferUsage.Static : BufferUsage.Dynamic;
      var blendShapeBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, byteLength, usage);
      modelMesh._setVertexBufferBinding(bufferBindingOffset + i, new VertexBufferBinding(blendShapeBuffer, stride));
      vertexBuffers[i] = blendShapeBuffer;
    }
  };
  _proto._createTextureArray = function _createTextureArray(vertexCount) {
    var maxTextureSize = this._engine._hardwareRenderer.capability.maxTextureSize;
    var vertexPixelStride = this._vertexElementCount;
    var textureWidth = vertexPixelStride * vertexCount;
    var textureHeight = 1;
    if (textureWidth > maxTextureSize) {
      textureHeight = Math.ceil(textureWidth / maxTextureSize);
      textureWidth = maxTextureSize;
    }
    var blendShapeDataTexture = this._vertexTexture;
    var blendShapeCount = this._blendShapes.length;
    blendShapeDataTexture && blendShapeDataTexture.destroy();
    blendShapeDataTexture = new Texture2DArray(this._engine, textureWidth, textureHeight, blendShapeCount, TextureFormat.R32G32B32A32, false);
    blendShapeDataTexture.filterMode = TextureFilterMode.Point;
    this._vertices = new Float32Array(blendShapeCount * textureWidth * textureHeight * 4);
    this._vertexTexture = blendShapeDataTexture;
    this._dataTextureInfo.set(vertexPixelStride, textureWidth, textureHeight);
  };
  _proto._updateVertexBuffers = function _updateVertexBuffers(vertexCount, force) {
    var _this = this, blendShapes = _this._blendShapes, maxCountSingleBuffer = _this._maxCountSingleVertexBuffer;
    var _this1 = this, vertices = _this1._vertices, vertexBuffers = _this1._vertexBuffers, storeInfos = _this1._storeInVertexBufferInfo;
    var subDataDirtyFlags = this._subDataDirtyFlags;
    var blendShapeFloatStride = this._vertexElementCount * 3;
    var blendShapeByteStride = blendShapeFloatStride * 4;
    var bufferOffset = this._bufferBindingOffset;
    for (var i = 0, n = blendShapes.length; i < n; i++) {
      var dataChangedFlag = subDataDirtyFlags[i];
      if (force || dataChangedFlag.flag) {
        var frames = blendShapes[i].frames;
        var frameCount = frames.length;
        var endFrame = frames[frameCount - 1];
        if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
          throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
        }
        var bufferIndex = Math.floor(i / maxCountSingleBuffer);
        var indexInBuffer = i % maxCountSingleBuffer;
        var buffer = vertexBuffers[bufferIndex];
        var bufferFloatStride = buffer.byteLength / (vertexCount * 4);
        var offset = indexInBuffer * blendShapeFloatStride;
        var storeInfo = storeInfos[i];
        storeInfo || (storeInfos[i] = storeInfo = new Vector2());
        storeInfo.set(bufferOffset + bufferIndex, indexInBuffer * blendShapeByteStride);
        var deltaPositions = endFrame.deltaPositions;
        for (var j2 = 0; j2 < vertexCount; j2++) {
          var start = offset + bufferFloatStride * j2;
          var deltaPosition = deltaPositions[j2];
          if (deltaPosition) {
            vertices[start] = deltaPosition.x;
            vertices[start + 1] = deltaPosition.y;
            vertices[start + 2] = deltaPosition.z;
          }
        }
        offset += 3;
        if (this._useBlendNormal) {
          var deltaNormals = endFrame.deltaNormals;
          if (deltaNormals) {
            for (var j1 = 0; j1 < vertexCount; j1++) {
              var start1 = offset + bufferFloatStride * j1;
              var deltaNormal = deltaNormals[j1];
              if (deltaNormal) {
                vertices[start1] = deltaNormal.x;
                vertices[start1 + 1] = deltaNormal.y;
                vertices[start1 + 2] = deltaNormal.z;
              }
            }
          }
          offset += 3;
        }
        if (this._useBlendTangent) {
          var deltaTangents = endFrame.deltaTangents;
          if (deltaTangents) {
            for (var j22 = 0; j22 < vertexCount; j22++) {
              var start2 = offset + bufferFloatStride * j22;
              var deltaTangent = deltaTangents[j22];
              if (deltaTangent) {
                vertices[start2] = deltaTangent.x;
                vertices[start2 + 1] = deltaTangent.y;
                vertices[start2 + 2] = deltaTangent.z;
              }
            }
          }
          offset += 3;
        }
        if (indexInBuffer === maxCountSingleBuffer - 1 || i === n - 1) {
          buffer.setData(vertices, 0, 0, buffer.byteLength / 4);
        }
        dataChangedFlag.flag = false;
      }
    }
  };
  _proto._updateTextureArray = function _updateTextureArray(vertexCount, force) {
    var _this = this, blendShapes = _this._blendShapes, vertexTexture = _this._vertexTexture, vertices = _this._vertices, subDataDirtyFlags = _this._subDataDirtyFlags;
    for (var i = 0, n = blendShapes.length; i < n; i++) {
      var subDirtyFlag = subDataDirtyFlags[i];
      var subBlendShapeDataStride = vertexTexture.width * vertexTexture.height * 4;
      if (force || subDirtyFlag.flag) {
        var frames = blendShapes[i].frames;
        var frameCount = frames.length;
        var endFrame = frames[frameCount - 1];
        if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
          throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
        }
        var deltaPositions = endFrame.deltaPositions, deltaNormals = endFrame.deltaNormals, deltaTangents = endFrame.deltaTangents;
        var offset = i * subBlendShapeDataStride;
        for (var j2 = 0; j2 < vertexCount; j2++) {
          var position = deltaPositions[j2];
          vertices[offset] = position.x;
          vertices[offset + 1] = position.y;
          vertices[offset + 2] = position.z;
          offset += 4;
          if (deltaNormals) {
            var normal = deltaNormals[j2];
            vertices[offset] = normal.x;
            vertices[offset + 1] = normal.y;
            vertices[offset + 2] = normal.z;
            offset += 4;
          }
          if (deltaTangents) {
            var tangent = deltaTangents[j2];
            vertices[offset] = tangent.x;
            vertices[offset + 1] = tangent.y;
            vertices[offset + 2] = tangent.z;
            offset += 4;
          }
        }
        subDirtyFlag.flag = false;
      }
    }
    vertexTexture.setPixelBuffer(0, vertices);
  };
  _proto._updateLayoutChange = function _updateLayoutChange(type, blendShape) {
    var notFirst = this._blendShapeCount > 1;
    var vertexElementCount = 1;
    var useBlendNormal = blendShape._useBlendShapeNormal;
    var useBlendTangent = blendShape._useBlendShapeTangent;
    if (notFirst) {
      useBlendNormal && (useBlendNormal = this._useBlendNormal);
      useBlendTangent && (useBlendTangent = this._useBlendTangent);
    }
    useBlendNormal && vertexElementCount++;
    useBlendTangent && vertexElementCount++;
    this._useBlendNormal = useBlendNormal;
    this._useBlendTangent = useBlendTangent;
    this._vertexElementCount = vertexElementCount;
  };
  _proto._attributeModeUpdateVertexElement = function _attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, index, condensedIndex) {
    var elementOffset = this._vertexElementOffset + this._vertexElementCount * condensedIndex;
    var _vertexBufferStoreInfo_index = vertexBufferStoreInfo[index], bufferIndex = _vertexBufferStoreInfo_index.x, offset = _vertexBufferStoreInfo_index.y;
    var vertexElement = vertexElements[elementOffset];
    vertexElement.bindingIndex = bufferIndex;
    vertexElement.offset = offset;
    if (this._useBlendNormal) {
      var vertexElement1 = vertexElements[++elementOffset];
      offset += 12;
      vertexElement1.bindingIndex = bufferIndex;
      vertexElement1.offset = offset;
    }
    if (this._useBlendTangent) {
      var vertexElement2 = vertexElements[++elementOffset];
      offset += 12;
      vertexElement2.bindingIndex = bufferIndex;
      vertexElement2.offset = offset;
    }
  };
  _proto._getVertexBufferModeSupportCount = function _getVertexBufferModeSupportCount() {
    if (this._useBlendNormal && this._useBlendTangent) {
      return 2;
    } else {
      return this._useBlendNormal || this._useBlendTangent ? 4 : 8;
    }
  };
  _proto._filterCondensedBlendShapeWeights = function _filterCondensedBlendShapeWeights(blendShapeWeights, condensedBlendShapeWeights) {
    var condensedWeightsCount = condensedBlendShapeWeights.length;
    var vertexElements = this._modelMesh._vertexElements;
    var vertexBufferStoreInfo = this._storeInVertexBufferInfo;
    var thresholdWeight = Number.POSITIVE_INFINITY;
    var thresholdIndex;
    for (var i = 0, n = Math.min(blendShapeWeights.length, this._blendShapeCount); i < n; i++) {
      var weight = blendShapeWeights[i];
      if (i < condensedWeightsCount) {
        this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, i);
        condensedBlendShapeWeights[i] = weight;
        if (weight < thresholdWeight) {
          thresholdWeight = weight;
          thresholdIndex = i;
        }
      } else if (weight > thresholdWeight) {
        this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, thresholdIndex);
        condensedBlendShapeWeights[thresholdIndex] = weight;
        thresholdWeight = Number.POSITIVE_INFINITY;
        for (var j2 = 0; j2 < condensedWeightsCount; j2++) {
          var condensedWeight = condensedBlendShapeWeights[j2];
          if (condensedWeight < thresholdWeight) {
            thresholdWeight = condensedWeight;
            thresholdIndex = j2;
          }
        }
      }
    }
  };
  return BlendShapeManager2;
}();
(function() {
  BlendShapeManager._blendShapeMacro = ShaderMacro.getByName("RENDERER_HAS_BLENDSHAPE");
})();
(function() {
  BlendShapeManager._blendShapeTextureMacro = ShaderMacro.getByName("RENDERER_BLENDSHAPE_USE_TEXTURE");
})();
(function() {
  BlendShapeManager._blendShapeNormalMacro = ShaderMacro.getByName("RENDERER_BLENDSHAPE_HAS_NORMAL");
})();
(function() {
  BlendShapeManager._blendShapeTangentMacro = ShaderMacro.getByName("RENDERER_BLENDSHAPE_HAS_TANGENT");
})();
(function() {
  BlendShapeManager._blendShapeWeightsProperty = ShaderProperty.getByName("renderer_BlendShapeWeights");
})();
(function() {
  BlendShapeManager._blendShapeTextureProperty = ShaderProperty.getByName("renderer_BlendShapeTexture");
})();
(function() {
  BlendShapeManager._blendShapeTextureInfoProperty = ShaderProperty.getByName("renderer_BlendShapeTextureInfo");
})();
var VertexAttribute;
(function(VertexAttribute2) {
  VertexAttribute2["Position"] = "POSITION";
  VertexAttribute2["Normal"] = "NORMAL";
  VertexAttribute2["Color"] = "COLOR_0";
  VertexAttribute2["Tangent"] = "TANGENT";
  VertexAttribute2["BoneWeight"] = "WEIGHTS_0";
  VertexAttribute2["BoneIndex"] = "JOINTS_0";
  VertexAttribute2["UV"] = "TEXCOORD_0";
  VertexAttribute2["UV1"] = "TEXCOORD_1";
  VertexAttribute2["UV2"] = "TEXCOORD_2";
  VertexAttribute2["UV3"] = "TEXCOORD_3";
  VertexAttribute2["UV4"] = "TEXCOORD_4";
  VertexAttribute2["UV5"] = "TEXCOORD_5";
  VertexAttribute2["UV6"] = "TEXCOORD_6";
  VertexAttribute2["UV7"] = "TEXCOORD_7";
})(VertexAttribute || (VertexAttribute = {}));
var ModelMesh = /* @__PURE__ */ function(Mesh2) {
  _inherits$2(ModelMesh2, Mesh2);
  function ModelMesh2(engine, name2) {
    var _this;
    _this = Mesh2.call(this, engine) || this;
    _this._vertexCount = 0;
    _this._readable = true;
    _this._verticesFloat32 = null;
    _this._verticesUint8 = null;
    _this._indices = null;
    _this._indicesFormat = null;
    _this._indicesChangeFlag = false;
    _this._positions = null;
    _this._normals = null;
    _this._colors = null;
    _this._tangents = null;
    _this._uv = null;
    _this._uv1 = null;
    _this._uv2 = null;
    _this._uv3 = null;
    _this._uv4 = null;
    _this._uv5 = null;
    _this._uv6 = null;
    _this._uv7 = null;
    _this._boneWeights = null;
    _this._boneIndices = null;
    _this._bufferStrides = [];
    _this._vertexBufferUpdateFlag = 0;
    _this._vertexDataUpdateFlag = 0;
    _this._vertexElementsUpdate = false;
    _this._customVertexElements = [];
    _this._vertexCountChanged = false;
    _this.name = name2;
    _this._blendShapeManager = new BlendShapeManager(engine, _assert_this_initialized(_this));
    return _this;
  }
  var _proto = ModelMesh2.prototype;
  _proto.setPositions = function setPositions(positions) {
    if (!this._positions && !positions) {
      return;
    }
    var newVertexCount = (positions == null ? void 0 : positions.length) || 0;
    this._vertexCountChanged = this._vertexCount != newVertexCount;
    this._vertexCount = newVertexCount;
    this._vertexElementsUpdate = !!this._positions !== !!positions;
    this._vertexBufferUpdateFlag |= 1;
    this._vertexDataUpdateFlag &= ~1;
    this._positions = positions;
  };
  _proto.getPositions = function getPositions() {
    if (!this._readable) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._positions;
  };
  _proto.setNormals = function setNormals(normals) {
    if (normals) {
      if (normals.length !== this._vertexCount) {
        throw "The array provided needs to be the same size as vertex count.";
      }
    } else if (!this._normals) {
      return;
    }
    this._vertexElementsUpdate = !!this._normals !== !!normals;
    this._vertexBufferUpdateFlag |= 2;
    this._vertexDataUpdateFlag &= ~2;
    this._normals = normals;
  };
  _proto.getNormals = function getNormals() {
    if (!this._readable) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._normals;
  };
  _proto.setColors = function setColors(colors) {
    if (colors) {
      if (colors.length !== this._vertexCount) {
        throw "The array provided needs to be the same size as vertex count.";
      }
    } else if (!this._colors) {
      return;
    }
    this._vertexElementsUpdate = !!this._colors !== !!colors;
    this._vertexBufferUpdateFlag |= 4;
    this._vertexDataUpdateFlag &= ~4;
    this._colors = colors;
  };
  _proto.getColors = function getColors() {
    if (!this._readable) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._colors;
  };
  _proto.setBoneWeights = function setBoneWeights(boneWeights) {
    if (boneWeights) {
      if (boneWeights.length !== this._vertexCount) {
        throw "The array provided needs to be the same size as vertex count.";
      }
    } else if (!this._boneWeights) {
      return;
    }
    this._vertexElementsUpdate = !!this._boneWeights !== !!boneWeights;
    this._vertexBufferUpdateFlag |= 16;
    this._vertexDataUpdateFlag &= ~16;
    this._boneWeights = boneWeights;
  };
  _proto.getBoneWeights = function getBoneWeights() {
    if (!this._readable) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._boneWeights;
  };
  _proto.setBoneIndices = function setBoneIndices(boneIndices) {
    if (boneIndices) {
      if ((boneIndices == null ? void 0 : boneIndices.length) !== this._vertexCount) {
        throw "The array provided needs to be the same size as vertex count.";
      }
    } else if (!this._boneIndices) {
      return;
    }
    this._vertexElementsUpdate = !!this._boneIndices !== !!boneIndices;
    this._vertexBufferUpdateFlag |= 32;
    this._vertexDataUpdateFlag &= ~32;
    this._boneIndices = boneIndices;
  };
  _proto.getBoneIndices = function getBoneIndices() {
    if (!this._readable) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._boneIndices;
  };
  _proto.setTangents = function setTangents(tangents) {
    if (tangents) {
      if (tangents.length !== this._vertexCount) {
        throw "The array provided needs to be the same size as vertex count.";
      }
    } else if (!this._tangents) {
      return;
    }
    this._vertexElementsUpdate = !!this._tangents !== !!tangents;
    this._vertexBufferUpdateFlag |= 8;
    this._vertexDataUpdateFlag &= ~8;
    this._tangents = tangents;
  };
  _proto.getTangents = function getTangents() {
    if (!this._readable) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._tangents;
  };
  _proto.setUVs = function setUVs(uv, channelIndex) {
    if (uv && uv.length !== this._vertexCount) {
      throw "The array provided needs to be the same size as vertex count.";
    }
    channelIndex = channelIndex != null ? channelIndex : 0;
    switch (channelIndex) {
      case 0:
        if (!this._uv && !uv) {
          return;
        }
        this._vertexElementsUpdate = !!this._uv !== !!uv;
        this._vertexBufferUpdateFlag |= 64;
        this._vertexDataUpdateFlag &= ~64;
        this._uv = uv;
        break;
      case 1:
        if (!this._uv1 && !uv) {
          return;
        }
        this._vertexElementsUpdate = !!this._uv1 !== !!uv;
        this._vertexBufferUpdateFlag |= 128;
        this._vertexDataUpdateFlag &= ~128;
        this._uv1 = uv;
        break;
      case 2:
        if (!this._uv2 && !uv) {
          return;
        }
        this._vertexElementsUpdate = !!this._uv2 !== !!uv;
        this._vertexBufferUpdateFlag |= 256;
        this._vertexDataUpdateFlag &= ~256;
        this._uv2 = uv;
        break;
      case 3:
        if (!this._uv3 && !uv) {
          return;
        }
        this._vertexElementsUpdate = !!this._uv3 !== !!uv;
        this._vertexBufferUpdateFlag |= 512;
        this._vertexDataUpdateFlag &= ~512;
        this._uv3 = uv;
        break;
      case 4:
        if (!this._uv4 && !uv) {
          return;
        }
        this._vertexElementsUpdate = !!this._uv4 !== !!uv;
        this._vertexBufferUpdateFlag |= 1024;
        this._vertexDataUpdateFlag &= ~1024;
        this._uv4 = uv;
        break;
      case 5:
        if (!this._uv5 && !uv) {
          return;
        }
        this._vertexElementsUpdate = !!this._uv5 !== !!uv;
        this._vertexBufferUpdateFlag |= 2048;
        this._vertexDataUpdateFlag &= ~2048;
        this._uv5 = uv;
        break;
      case 6:
        if (!this._uv6 && !uv) {
          return;
        }
        this._vertexElementsUpdate = !!this._uv6 !== !!uv;
        this._vertexBufferUpdateFlag |= 4096;
        this._vertexDataUpdateFlag &= ~4096;
        this._uv6 = uv;
        break;
      case 7:
        if (!this._uv7 && !uv) {
          return;
        }
        this._vertexElementsUpdate = !!this._uv7 !== !!uv;
        this._vertexBufferUpdateFlag |= 8192;
        this._vertexDataUpdateFlag &= ~8192;
        this._uv7 = uv;
        break;
      default:
        throw "The index of channel needs to be in range [0 - 7].";
    }
  };
  _proto.getUVs = function getUVs(channelIndex) {
    if (!this._readable) {
      throw "Not allowed to access data while accessible is false.";
    }
    channelIndex = channelIndex != null ? channelIndex : 0;
    switch (channelIndex) {
      case 0:
        return this._uv;
      case 1:
        return this._uv1;
      case 2:
        return this._uv2;
      case 3:
        return this._uv3;
      case 4:
        return this._uv4;
      case 5:
        return this._uv5;
      case 6:
        return this._uv6;
      case 7:
        return this._uv7;
    }
    throw "The index of channel needs to be in range [0 - 7].";
  };
  _proto.setIndices = function setIndices(indices) {
    if (this._indices !== indices) {
      this._indices = indices;
      if (_instanceof$2(indices, Uint8Array)) {
        this._indicesFormat = IndexFormat.UInt8;
      } else if (_instanceof$2(indices, Uint16Array)) {
        this._indicesFormat = IndexFormat.UInt16;
      } else if (_instanceof$2(indices, Uint32Array)) {
        this._indicesFormat = IndexFormat.UInt32;
      }
    }
    this._indicesChangeFlag = true;
  };
  _proto.getIndices = function getIndices() {
    if (!this._readable) {
      throw "Not allowed to access data while accessible is false.";
    }
    return this._indices;
  };
  _proto.setVertexElements = function setVertexElements(elements) {
    var customVertexElements = this._customVertexElements;
    customVertexElements.length = 0;
    var customVertexElementMap = {};
    for (var i = 0, n = elements.length; i < n; i++) {
      var element = elements[i];
      customVertexElements.push(element);
      customVertexElementMap[element.semantic] = element;
    }
    if (customVertexElementMap[VertexAttribute.Position]) {
      var positions = this.getPositions();
      positions && (this._vertexBufferUpdateFlag |= 1);
    } else {
      this.setPositions(null);
    }
    if (customVertexElementMap[VertexAttribute.Normal]) {
      var normals = this.getNormals();
      normals && (this._vertexBufferUpdateFlag |= 2);
    } else {
      this.setNormals(null);
    }
    if (customVertexElementMap[VertexAttribute.Color]) {
      var colors = this.getColors();
      colors && (this._vertexBufferUpdateFlag |= 4);
    } else {
      this.setColors(null);
    }
    if (customVertexElementMap[VertexAttribute.BoneWeight]) {
      var boneWeights = this.getBoneWeights();
      boneWeights && (this._vertexBufferUpdateFlag |= 16);
    } else {
      this.setBoneWeights(null);
    }
    if (customVertexElementMap[VertexAttribute.BoneIndex]) {
      var boneIndices = this.getBoneIndices();
      boneIndices && (this._vertexBufferUpdateFlag |= 32);
    } else {
      this.setBoneIndices(null);
    }
    if (customVertexElementMap[VertexAttribute.Tangent]) {
      var tangents = this.getTangents();
      tangents && (this._vertexBufferUpdateFlag |= 8);
    } else {
      this.setTangents(null);
    }
    if (customVertexElementMap[VertexAttribute.UV]) {
      var uvs = this.getUVs(0);
      uvs && (this._vertexBufferUpdateFlag |= 64);
    } else {
      this.setUVs(null, 0);
    }
    if (customVertexElementMap[VertexAttribute.UV1]) {
      var uv1s = this.getUVs(1);
      uv1s && (this._vertexBufferUpdateFlag |= 128);
    } else {
      this.setUVs(null, 1);
    }
    if (customVertexElementMap[VertexAttribute.UV2]) {
      var uv2s = this.getUVs(2);
      uv2s && (this._vertexBufferUpdateFlag |= 256);
    } else {
      this.setUVs(null, 2);
    }
    if (customVertexElementMap[VertexAttribute.UV3]) {
      var uv3s = this.getUVs(3);
      uv3s && (this._vertexBufferUpdateFlag |= 512);
    } else {
      this.setUVs(null, 3);
    }
    if (customVertexElementMap[VertexAttribute.UV4]) {
      var uv4s = this.getUVs(4);
      uv4s && (this._vertexBufferUpdateFlag |= 1024);
    } else {
      this.setUVs(null, 4);
    }
    if (customVertexElementMap[VertexAttribute.UV5]) {
      var uv5s = this.getUVs(5);
      uv5s && (this._vertexBufferUpdateFlag |= 2048);
    } else {
      this.setUVs(null, 5);
    }
    if (customVertexElementMap[VertexAttribute.UV6]) {
      var uv6s = this.getUVs(6);
      uv6s && (this._vertexBufferUpdateFlag |= 4096);
    } else {
      this.setUVs(null, 6);
    }
    if (customVertexElementMap[VertexAttribute.UV7]) {
      var uv7s = this.getUVs(7);
      uv7s && (this._vertexBufferUpdateFlag |= 8192);
    } else {
      this.setUVs(null, 7);
    }
    this._vertexElementsUpdate = true;
  };
  _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, index) {
    if (strideOrFirstIndex === void 0)
      strideOrFirstIndex = 0;
    if (index === void 0)
      index = 0;
    var binding = bufferOrBinding;
    var isBinding = binding.buffer !== void 0;
    isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
    var bindings = this._vertexBufferBindings;
    bindings.length <= index && (bindings.length = index + 1);
    this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);
    this._vertexDataUpdateFlag |= 1;
  };
  _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
    if (firstIndex === void 0)
      firstIndex = 0;
    var bindings = this._vertexBufferBindings;
    var count = vertexBufferBindings.length;
    var needLength = firstIndex + count;
    bindings.length < needLength && (bindings.length = needLength);
    for (var i = 0; i < count; i++) {
      this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
    }
  };
  _proto.addBlendShape = function addBlendShape(blendShape) {
    this._blendShapeManager._addBlendShape(blendShape);
  };
  _proto.clearBlendShapes = function clearBlendShapes() {
    this._blendShapeManager._clearBlendShapes();
  };
  _proto.getBlendShapeName = function getBlendShapeName(index) {
    var blendShapes = this._blendShapeManager._blendShapes;
    return blendShapes[index].name;
  };
  _proto.uploadData = function uploadData(noLongerReadable) {
    var _this__vertexBufferBindings_;
    this._updateVertexElements();
    var vertexBuffer = (_this__vertexBufferBindings_ = this._vertexBufferBindings[0]) == null ? void 0 : _this__vertexBufferBindings_._buffer;
    if (this._vertexCountChanged) {
      this._vertexBufferUpdateFlag = 65535;
      vertexBuffer == null ? void 0 : vertexBuffer.destroy();
      var elementCount = this._bufferStrides[0] / 4;
      var vertexFloatCount = elementCount * this.vertexCount;
      var vertices = new Float32Array(vertexFloatCount);
      this._verticesFloat32 = vertices;
      this._verticesUint8 = new Uint8Array(vertices.buffer);
      this._updateVertices(vertices);
      var bufferUsage = noLongerReadable ? BufferUsage.Static : BufferUsage.Dynamic;
      var newVertexBuffer = new Buffer(this._engine, BufferBindFlag.VertexBuffer, vertices, bufferUsage);
      this._setVertexBufferBinding(0, new VertexBufferBinding(newVertexBuffer, elementCount * 4));
      this._vertexCountChanged = false;
    } else {
      if (this._vertexBufferUpdateFlag & 65535) {
        var vertices1 = this._verticesFloat32;
        if (!vertices1) {
          var elementCount1 = this._bufferStrides[0] / 4;
          var vertexFloatCount1 = elementCount1 * this.vertexCount;
          this._verticesFloat32 = vertices1 = new Float32Array(vertexFloatCount1);
        }
        this._updateVertices(vertices1);
        vertexBuffer.setData(vertices1);
      }
    }
    if (this._indicesChangeFlag) {
      var _this__indexBufferBinding;
      var _this = this, indices = _this._indices;
      var indexBuffer = (_this__indexBufferBinding = this._indexBufferBinding) == null ? void 0 : _this__indexBufferBinding._buffer;
      if (indices) {
        if (!indexBuffer || indices.byteLength != indexBuffer.byteLength) {
          indexBuffer == null ? void 0 : indexBuffer.destroy();
          var newIndexBuffer = new Buffer(this._engine, BufferBindFlag.IndexBuffer, indices);
          this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer, this._indicesFormat));
        } else {
          indexBuffer.setData(indices);
          if (this._indexBufferBinding._format !== this._indicesFormat) {
            this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer, this._indicesFormat));
          }
        }
      } else if (indexBuffer) {
        indexBuffer.destroy();
        this._setIndexBufferBinding(null);
      }
      this._indicesChangeFlag = false;
    }
    var _this1 = this, blendShapeManager = _this1._blendShapeManager;
    blendShapeManager._blendShapeCount > 0 && blendShapeManager._update(this._vertexCountChanged, noLongerReadable);
    if (noLongerReadable) {
      this._readable = false;
      this._releaseCache();
    }
  };
  _proto.calculateTangents = function calculateTangents() {
    if (!this._normals || !this._uv) {
      throw "Set normal and uv before calculation.";
    }
    var _this = this, indices = _this._indices, positions = _this._positions, normals = _this._normals, uvs = _this._uv, vertexCount = _this._vertexCount;
    var e1 = ModelMesh2._tempVec0, e2 = ModelMesh2._tempVec1, t = ModelMesh2._tempVec2, b = ModelMesh2._tempVec3, temp = ModelMesh2._tempVec4;
    var triangleCount = indices ? indices.length / 3 : positions.length / 3;
    var tangents = new Array(vertexCount);
    var biTangents = new Array(vertexCount);
    for (var i = 0; i < vertexCount; i++) {
      tangents[i] = new Vector4();
      biTangents[i] = new Vector3();
    }
    for (var k2 = 0; k2 < triangleCount; k2++) {
      var i0 = 3 * k2;
      var i1 = 3 * k2 + 1;
      var i2 = 3 * k2 + 2;
      if (indices) {
        i0 = indices[i0];
        i1 = indices[i1];
        i2 = indices[i2];
      }
      var p0 = positions[i0];
      var p1 = positions[i1];
      var p2 = positions[i2];
      var w0 = uvs[i0];
      var w1 = uvs[i1];
      var w2 = uvs[i2];
      Vector3.subtract(p1, p0, e1);
      Vector3.subtract(p2, p0, e2);
      var x1 = w1.x - w0.x;
      var x2 = w2.x - w0.x;
      var y1 = w1.y - w0.y;
      var y2 = w2.y - w0.y;
      var r = 1 / (x1 * y2 - x2 * y1);
      Vector3.scale(e1, y2 * r, t);
      Vector3.scale(e2, y1 * r, temp);
      Vector3.subtract(t, temp, t);
      Vector3.scale(e2, x1 * r, b);
      Vector3.scale(e1, x2 * r, temp);
      Vector3.subtract(b, temp, b);
      var tangent = tangents[i0];
      tangent.set(tangent.x + t.x, tangent.y + t.y, tangent.z + t.z, 1);
      tangent = tangents[i1];
      tangent.set(tangent.x + t.x, tangent.y + t.y, tangent.z + t.z, 1);
      tangent = tangents[i2];
      tangent.set(tangent.x + t.x, tangent.y + t.y, tangent.z + t.z, 1);
      biTangents[i0].add(b);
      biTangents[i1].add(b);
      biTangents[i2].add(b);
    }
    for (var i3 = 0; i3 < vertexCount; i3++) {
      var n = normals[i3];
      var b1 = biTangents[i3];
      var tangent1 = tangents[i3];
      t.set(tangent1.x, tangent1.y, tangent1.z);
      Vector3.cross(t, b1, temp);
      var w = Vector3.dot(temp, n) > 0 ? 1 : -1;
      Vector3.scale(n, Vector3.dot(t, n), temp);
      Vector3.subtract(t, temp, t);
      t.normalize();
      tangent1.set(t.x, t.y, t.z, w);
    }
    this.setTangents(tangents);
  };
  _proto._onDestroy = function _onDestroy() {
    Mesh2.prototype._onDestroy.call(this);
    this._readable && this._releaseCache();
  };
  _proto._supplementaryVertexElements = function _supplementaryVertexElements() {
    this._clearVertexElements();
    var customVertexElements = this._customVertexElements;
    for (var i = 0, n = customVertexElements.length; i < n; i++) {
      this._addVertexElement(customVertexElements[i]);
    }
    var vertexElementMap = this._vertexElementMap;
    if (this._positions && !vertexElementMap[VertexAttribute.Position]) {
      this._insertVertexAttribute(VertexAttribute.Position);
    }
    if (this._normals && !vertexElementMap[VertexAttribute.Normal]) {
      this._insertVertexAttribute(VertexAttribute.Normal);
    }
    if (this._colors && !vertexElementMap[VertexAttribute.Color]) {
      this._insertVertexAttribute(VertexAttribute.Color);
    }
    if (this._boneWeights && !vertexElementMap[VertexAttribute.BoneWeight]) {
      this._insertVertexAttribute(VertexAttribute.BoneWeight);
    }
    if (this._boneIndices && !vertexElementMap[VertexAttribute.BoneIndex]) {
      this._insertVertexAttribute(VertexAttribute.BoneIndex);
    }
    if (this._tangents && !vertexElementMap[VertexAttribute.Tangent]) {
      this._insertVertexAttribute(VertexAttribute.Tangent);
    }
    if (this._uv && !vertexElementMap[VertexAttribute.UV]) {
      this._insertVertexAttribute(VertexAttribute.UV);
    }
    if (this._uv1 && !vertexElementMap[VertexAttribute.UV1]) {
      this._insertVertexAttribute(VertexAttribute.UV1);
    }
    if (this._uv2 && !vertexElementMap[VertexAttribute.UV2]) {
      this._insertVertexAttribute(VertexAttribute.UV2);
    }
    if (this._uv3 && !vertexElementMap[VertexAttribute.UV3]) {
      this._insertVertexAttribute(VertexAttribute.UV3);
    }
    if (this._uv4 && !vertexElementMap[VertexAttribute.UV4]) {
      this._insertVertexAttribute(VertexAttribute.UV4);
    }
    if (this._uv5 && !vertexElementMap[VertexAttribute.UV5]) {
      this._insertVertexAttribute(VertexAttribute.UV5);
    }
    if (this._uv6 && !vertexElementMap[VertexAttribute.UV6]) {
      this._insertVertexAttribute(VertexAttribute.UV6);
    }
    if (this._uv7 && !vertexElementMap[VertexAttribute.UV7]) {
      this._insertVertexAttribute(VertexAttribute.UV7);
    }
  };
  _proto._updateVertexElements = function _updateVertexElements() {
    var bsManager = this._blendShapeManager;
    var bsAttributeUpdate = !bsManager._useTextureMode() && bsManager._vertexElementsNeedUpdate();
    if (this._vertexElementsUpdate || bsAttributeUpdate) {
      this._supplementaryVertexElements();
      if (bsAttributeUpdate && bsManager._blendShapeCount > 0) {
        bsManager._setAttributeModeOffsetInfo(this._vertexElements.length, this._vertexBufferBindings.length || 1);
        bsManager._addVertexElements(this);
      }
      this._vertexElementsUpdate = false;
    }
  };
  _proto._updateVertices = function _updateVertices(vertices) {
    var _this = this, _bufferStrides = _this._bufferStrides, _vertexCount = _this._vertexCount, _positions = _this._positions, _normals = _this._normals, _colors = _this._colors, _vertexChangeFlag = _this._vertexBufferUpdateFlag, _boneWeights = _this._boneWeights, _boneIndices = _this._boneIndices, _tangents = _this._tangents, _uv = _this._uv, _uv1 = _this._uv1, _uv2 = _this._uv2, _uv3 = _this._uv3, _uv4 = _this._uv4, _uv5 = _this._uv5, _uv6 = _this._uv6, _uv7 = _this._uv7;
    var _vertexStrideFloat = _bufferStrides[0] / 4;
    if (_vertexChangeFlag & 1) {
      for (var i = 0; i < _vertexCount; i++) {
        var start = _vertexStrideFloat * i;
        var position = _positions[i];
        vertices[start] = position.x;
        vertices[start + 1] = position.y;
        vertices[start + 2] = position.z;
      }
    }
    var offset = 3;
    if (_normals) {
      if (_vertexChangeFlag & 2) {
        for (var i1 = 0; i1 < _vertexCount; i1++) {
          var start1 = _vertexStrideFloat * i1 + offset;
          var normal = _normals[i1];
          if (normal) {
            vertices[start1] = normal.x;
            vertices[start1 + 1] = normal.y;
            vertices[start1 + 2] = normal.z;
          }
        }
      }
      offset += 3;
    }
    if (_colors) {
      if (_vertexChangeFlag & 4) {
        for (var i2 = 0; i2 < _vertexCount; i2++) {
          var start2 = _vertexStrideFloat * i2 + offset;
          var color = _colors[i2];
          if (color) {
            vertices[start2] = color.r;
            vertices[start2 + 1] = color.g;
            vertices[start2 + 2] = color.b;
            vertices[start2 + 3] = color.a;
          }
        }
      }
      offset += 4;
    }
    if (_boneWeights) {
      if (_vertexChangeFlag & 16) {
        for (var i3 = 0; i3 < _vertexCount; i3++) {
          var start3 = _vertexStrideFloat * i3 + offset;
          var weight = _boneWeights[i3];
          if (weight) {
            vertices[start3] = weight.x;
            vertices[start3 + 1] = weight.y;
            vertices[start3 + 2] = weight.z;
            vertices[start3 + 3] = weight.w;
          }
        }
      }
      offset += 4;
    }
    if (_boneIndices) {
      if (_vertexChangeFlag & 32) {
        var _verticesUint8 = this._verticesUint8;
        for (var i4 = 0; i4 < _vertexCount; i4++) {
          var start4 = _vertexStrideFloat * i4 + offset;
          var joint = _boneIndices[i4];
          if (joint) {
            var internalStart = start4 * 4;
            _verticesUint8[internalStart] = joint.x;
            _verticesUint8[internalStart + 1] = joint.y;
            _verticesUint8[internalStart + 2] = joint.z;
            _verticesUint8[internalStart + 3] = joint.w;
          }
        }
      }
      offset += 1;
    }
    if (_tangents) {
      if (_vertexChangeFlag & 8) {
        for (var i5 = 0; i5 < _vertexCount; i5++) {
          var start5 = _vertexStrideFloat * i5 + offset;
          var tangent = _tangents[i5];
          if (tangent) {
            vertices[start5] = tangent.x;
            vertices[start5 + 1] = tangent.y;
            vertices[start5 + 2] = tangent.z;
            vertices[start5 + 3] = tangent.w;
          }
        }
      }
      offset += 4;
    }
    if (_uv) {
      if (_vertexChangeFlag & 64) {
        for (var i6 = 0; i6 < _vertexCount; i6++) {
          var start6 = _vertexStrideFloat * i6 + offset;
          var uv = _uv[i6];
          if (uv) {
            vertices[start6] = uv.x;
            vertices[start6 + 1] = uv.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv1) {
      if (_vertexChangeFlag & 128) {
        for (var i7 = 0; i7 < _vertexCount; i7++) {
          var start7 = _vertexStrideFloat * i7 + offset;
          var uv1 = _uv1[i7];
          if (uv1) {
            vertices[start7] = uv1.x;
            vertices[start7 + 1] = uv1.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv2) {
      if (_vertexChangeFlag & 256) {
        for (var i8 = 0; i8 < _vertexCount; i8++) {
          var start8 = _vertexStrideFloat * i8 + offset;
          var uv2 = _uv2[i8];
          if (uv2) {
            vertices[start8] = uv2.x;
            vertices[start8 + 1] = uv2.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv3) {
      if (_vertexChangeFlag & 512) {
        for (var i9 = 0; i9 < _vertexCount; i9++) {
          var start9 = _vertexStrideFloat * i9 + offset;
          var uv3 = _uv3[i9];
          if (uv3) {
            vertices[start9] = uv3.x;
            vertices[start9 + 1] = uv3.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv4) {
      if (_vertexChangeFlag & 1024) {
        for (var i10 = 0; i10 < _vertexCount; i10++) {
          var start10 = _vertexStrideFloat * i10 + offset;
          var uv4 = _uv4[i10];
          if (uv4) {
            vertices[start10] = uv4.x;
            vertices[start10 + 1] = uv4.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv5) {
      if (_vertexChangeFlag & 2048) {
        for (var i11 = 0; i11 < _vertexCount; i11++) {
          var start11 = _vertexStrideFloat * i11 + offset;
          var uv5 = _uv5[i11];
          if (uv5) {
            vertices[start11] = uv5.x;
            vertices[start11 + 1] = uv5.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv6) {
      if (_vertexChangeFlag & 4096) {
        for (var i12 = 0; i12 < _vertexCount; i12++) {
          var start12 = _vertexStrideFloat * i12 + offset;
          var uv6 = _uv6[i12];
          if (uv6) {
            vertices[start12] = uv6.x;
            vertices[start12 + 1] = uv6.y;
          }
        }
      }
      offset += 2;
    }
    if (_uv7) {
      if (_vertexChangeFlag & 8192) {
        for (var i13 = 0; i13 < _vertexCount; i13++) {
          var start13 = _vertexStrideFloat * i13 + offset;
          var uv7 = _uv7[i13];
          if (uv7) {
            vertices[start13] = uv7.x;
            vertices[start13 + 1] = uv7.y;
          }
        }
      }
      offset += 2;
    }
    this._vertexBufferUpdateFlag = 0;
  };
  _proto._insertVertexAttribute = function _insertVertexAttribute(vertexAttribute) {
    var format = this._getAttributeFormat(vertexAttribute);
    var needByteLength = this._getAttributeByteLength(vertexAttribute);
    var vertexElements = this._vertexElements;
    var i = 0;
    var lastOffset = 0;
    for (var n = vertexElements.length; i < n; i++) {
      var vertexElement = vertexElements[i];
      if (vertexElement.bindingIndex == 0) {
        if (vertexElement.offset - lastOffset >= needByteLength) {
          break;
        }
        lastOffset = vertexElement.offset + this._getAttributeByteLength(vertexElement.semantic);
      }
    }
    this._insertVertexElement(i, new VertexElement(vertexAttribute, lastOffset, format, 0));
    this._bufferStrides[0] = lastOffset + needByteLength;
  };
  _proto._getAttributeFormat = function _getAttributeFormat(attribute) {
    switch (attribute) {
      case VertexAttribute.Position:
        return VertexElementFormat.Vector3;
      case VertexAttribute.Normal:
        return VertexElementFormat.Vector3;
      case VertexAttribute.Color:
        return VertexElementFormat.Vector4;
      case VertexAttribute.BoneWeight:
        return VertexElementFormat.Vector4;
      case VertexAttribute.BoneIndex:
        return VertexElementFormat.UByte4;
      case VertexAttribute.Tangent:
        return VertexElementFormat.Vector4;
      case VertexAttribute.UV:
      case VertexAttribute.UV1:
      case VertexAttribute.UV2:
      case VertexAttribute.UV3:
      case VertexAttribute.UV4:
      case VertexAttribute.UV5:
      case VertexAttribute.UV6:
      case VertexAttribute.UV7:
        return VertexElementFormat.Vector2;
    }
  };
  _proto._getAttributeByteLength = function _getAttributeByteLength(attribute) {
    switch (attribute) {
      case VertexAttribute.Position:
        return 12;
      case VertexAttribute.Normal:
        return 12;
      case VertexAttribute.Color:
        return 16;
      case VertexAttribute.BoneWeight:
        return 16;
      case VertexAttribute.BoneIndex:
        return 4;
      case VertexAttribute.Tangent:
        return 16;
      case VertexAttribute.UV:
      case VertexAttribute.UV1:
      case VertexAttribute.UV2:
      case VertexAttribute.UV3:
      case VertexAttribute.UV4:
      case VertexAttribute.UV5:
      case VertexAttribute.UV6:
      case VertexAttribute.UV7:
        return 8;
    }
  };
  _proto._releaseCache = function _releaseCache() {
    this._verticesUint8 = null;
    this._indices = null;
    this._verticesFloat32 = null;
    this._positions = null;
    this._tangents = null;
    this._normals = null;
    this._colors = null;
    this._uv = null;
    this._uv1 = null;
    this._uv2 = null;
    this._uv3 = null;
    this._uv4 = null;
    this._uv5 = null;
    this._uv6 = null;
    this._uv7 = null;
    this._blendShapeManager._releaseMemoryCache();
  };
  _create_class$4(ModelMesh2, [
    {
      key: "readable",
      get: function get3() {
        return this._readable;
      }
    },
    {
      key: "vertexCount",
      get: function get3() {
        if (this._vertexDataUpdateFlag & 1) {
          var vertexCount = 0;
          var positionElement = this._vertexElementMap[VertexAttribute.Position];
          if (positionElement) {
            var positionBufferBinding = this._vertexBufferBindings[positionElement.bindingIndex];
            if (positionBufferBinding) {
              vertexCount = positionBufferBinding.buffer.byteLength / positionBufferBinding.stride;
            }
          }
          this._vertexCount = vertexCount;
          this._vertexDataUpdateFlag &= ~1;
        }
        return this._vertexCount;
      }
    },
    {
      key: "vertexElements",
      get: function get3() {
        this._updateVertexElements();
        return this._vertexElements;
      }
    },
    {
      key: "vertexBufferBindings",
      get: function get3() {
        return this._vertexBufferBindings;
      }
    },
    {
      key: "blendShapes",
      get: function get3() {
        return this._blendShapeManager._blendShapes;
      }
    },
    {
      key: "blendShapeCount",
      get: function get3() {
        return this._blendShapeManager._blendShapeCount;
      }
    }
  ]);
  return ModelMesh2;
}(Mesh);
(function() {
  ModelMesh._tempVec0 = new Vector3();
})();
(function() {
  ModelMesh._tempVec1 = new Vector3();
})();
(function() {
  ModelMesh._tempVec2 = new Vector3();
})();
(function() {
  ModelMesh._tempVec3 = new Vector3();
})();
(function() {
  ModelMesh._tempVec4 = new Vector3();
})();
var VertexChangedFlags;
(function(VertexChangedFlags2) {
  VertexChangedFlags2[VertexChangedFlags2["Position"] = 1] = "Position";
  VertexChangedFlags2[VertexChangedFlags2["Normal"] = 2] = "Normal";
  VertexChangedFlags2[VertexChangedFlags2["Color"] = 4] = "Color";
  VertexChangedFlags2[VertexChangedFlags2["Tangent"] = 8] = "Tangent";
  VertexChangedFlags2[VertexChangedFlags2["BoneWeight"] = 16] = "BoneWeight";
  VertexChangedFlags2[VertexChangedFlags2["BoneIndex"] = 32] = "BoneIndex";
  VertexChangedFlags2[VertexChangedFlags2["UV"] = 64] = "UV";
  VertexChangedFlags2[VertexChangedFlags2["UV1"] = 128] = "UV1";
  VertexChangedFlags2[VertexChangedFlags2["UV2"] = 256] = "UV2";
  VertexChangedFlags2[VertexChangedFlags2["UV3"] = 512] = "UV3";
  VertexChangedFlags2[VertexChangedFlags2["UV4"] = 1024] = "UV4";
  VertexChangedFlags2[VertexChangedFlags2["UV5"] = 2048] = "UV5";
  VertexChangedFlags2[VertexChangedFlags2["UV6"] = 4096] = "UV6";
  VertexChangedFlags2[VertexChangedFlags2["UV7"] = 8192] = "UV7";
  VertexChangedFlags2[VertexChangedFlags2["All"] = 65535] = "All";
})(VertexChangedFlags || (VertexChangedFlags = {}));
var Skin = /* @__PURE__ */ function(EngineObject2) {
  _inherits$2(Skin2, EngineObject2);
  function Skin2(name2) {
    var _this;
    _this = EngineObject2.call(this, null) || this;
    _this.name = name2;
    _this.inverseBindMatrices = [];
    _this.joints = [];
    _this.skeleton = "none";
    return _this;
  }
  return Skin2;
}(EngineObject);
var MeshRenderer = /* @__PURE__ */ function(Renderer2) {
  _inherits$2(MeshRenderer2, Renderer2);
  function MeshRenderer2(entity) {
    var _this;
    _this = Renderer2.call(this, entity) || this;
    _this._enableVertexColor = false;
    _this._onMeshChanged = _this._onMeshChanged.bind(_assert_this_initialized(_this));
    return _this;
  }
  var _proto = MeshRenderer2.prototype;
  _proto._onDestroy = function _onDestroy() {
    Renderer2.prototype._onDestroy.call(this);
    var mesh = this._mesh;
    if (mesh) {
      mesh.destroyed || mesh._addReferCount(-1);
      mesh._updateFlagManager.removeListener(this._onMeshChanged);
      this._mesh = null;
    }
  };
  _proto._prepareRender = function _prepareRender(context) {
    if (!this._mesh) {
      Logger.error("mesh is null.");
      return;
    }
    Renderer2.prototype._prepareRender.call(this, context);
  };
  _proto._cloneTo = function _cloneTo(target) {
    Renderer2.prototype._cloneTo.call(this, target);
    target.mesh = this._mesh;
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    var mesh = this._mesh;
    if (mesh) {
      var localBounds = mesh.bounds;
      var worldMatrix = this._entity.transform.worldMatrix;
      BoundingBox.transform(localBounds, worldMatrix, worldBounds);
    } else {
      worldBounds.min.set(0, 0, 0);
      worldBounds.max.set(0, 0, 0);
    }
  };
  _proto._render = function _render(context) {
    var mesh = this._mesh;
    if (this._dirtyUpdateFlag & 2) {
      var shaderData = this.shaderData;
      var vertexElements = mesh._vertexElements;
      shaderData.disableMacro(MeshRenderer2._uvMacro);
      shaderData.disableMacro(MeshRenderer2._uv1Macro);
      shaderData.disableMacro(MeshRenderer2._normalMacro);
      shaderData.disableMacro(MeshRenderer2._tangentMacro);
      shaderData.disableMacro(MeshRenderer2._enableVertexColorMacro);
      for (var i = 0, n = vertexElements.length; i < n; i++) {
        switch (vertexElements[i].semantic) {
          case "TEXCOORD_0":
            shaderData.enableMacro(MeshRenderer2._uvMacro);
            break;
          case "TEXCOORD_1":
            shaderData.enableMacro(MeshRenderer2._uv1Macro);
            break;
          case "NORMAL":
            shaderData.enableMacro(MeshRenderer2._normalMacro);
            break;
          case "TANGENT":
            shaderData.enableMacro(MeshRenderer2._tangentMacro);
            break;
          case "COLOR_0":
            this._enableVertexColor && shaderData.enableMacro(MeshRenderer2._enableVertexColorMacro);
            break;
        }
      }
      this._dirtyUpdateFlag &= ~2;
    }
    var materials = this._materials;
    var subMeshes = mesh.subMeshes;
    var renderPipeline = context.camera._renderPipeline;
    var meshRenderDataPool = this._engine._meshRenderDataPool;
    for (var i1 = 0, n1 = subMeshes.length; i1 < n1; i1++) {
      var material = materials[i1];
      if (!material)
        continue;
      var renderData = meshRenderDataPool.getFromPool();
      renderData.set(this, material, mesh, subMeshes[i1]);
      renderPipeline.pushRenderData(context, renderData);
    }
  };
  _proto._setMesh = function _setMesh(mesh) {
    var lastMesh = this._mesh;
    if (lastMesh) {
      lastMesh._addReferCount(-1);
      lastMesh._updateFlagManager.removeListener(this._onMeshChanged);
    }
    if (mesh) {
      mesh._addReferCount(1);
      mesh._updateFlagManager.addListener(this._onMeshChanged);
      this._dirtyUpdateFlag |= 3;
    }
    this._mesh = mesh;
  };
  _proto._onMeshChanged = function _onMeshChanged(type) {
    type & MeshModifyFlags.Bounds && (this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume);
    type & MeshModifyFlags.VertexElements && (this._dirtyUpdateFlag |= 2);
  };
  _create_class$4(MeshRenderer2, [
    {
      key: "mesh",
      get: function get3() {
        return this._mesh;
      },
      set: function set(value) {
        if (this._mesh !== value) {
          this._setMesh(value);
        }
      }
    },
    {
      key: "enableVertexColor",
      get: function get3() {
        return this._enableVertexColor;
      },
      set: function set(value) {
        if (value !== this._enableVertexColor) {
          this._dirtyUpdateFlag |= 2;
          this._enableVertexColor = value;
        }
      }
    }
  ]);
  return MeshRenderer2;
}(Renderer);
(function() {
  MeshRenderer._uvMacro = ShaderMacro.getByName("RENDERER_HAS_UV");
})();
(function() {
  MeshRenderer._uv1Macro = ShaderMacro.getByName("RENDERER_HAS_UV1");
})();
(function() {
  MeshRenderer._normalMacro = ShaderMacro.getByName("RENDERER_HAS_NORMAL");
})();
(function() {
  MeshRenderer._tangentMacro = ShaderMacro.getByName("RENDERER_HAS_TANGENT");
})();
(function() {
  MeshRenderer._enableVertexColorMacro = ShaderMacro.getByName("RENDERER_ENABLE_VERTEXCOLOR");
})();
__decorate$2([
  ignoreClone
], MeshRenderer.prototype, "_mesh", void 0);
__decorate$2([
  ignoreClone
], MeshRenderer.prototype, "_onMeshChanged", null);
var MeshRendererUpdateFlags;
(function(MeshRendererUpdateFlags2) {
  MeshRendererUpdateFlags2[MeshRendererUpdateFlags2["VertexElementMacro"] = 2] = "VertexElementMacro";
  MeshRendererUpdateFlags2[MeshRendererUpdateFlags2["All"] = 3] = "All";
})(MeshRendererUpdateFlags || (MeshRendererUpdateFlags = {}));
var SkinnedMeshRenderer = /* @__PURE__ */ function(MeshRenderer2) {
  _inherits$2(SkinnedMeshRenderer2, MeshRenderer2);
  function SkinnedMeshRenderer2(entity) {
    var _this;
    _this = MeshRenderer2.call(this, entity) || this;
    _this._hasInitSkin = false;
    _this._jointDataCreateCache = new Vector2(-1, -1);
    _this._localBounds = new BoundingBox();
    _this._skin = null;
    var rhi = _this.entity.engine._hardwareRenderer;
    var maxVertexUniformVectors = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
    maxVertexUniformVectors = Math.min(maxVertexUniformVectors, rhi._options._maxAllowSkinUniformVectorCount);
    _this._maxVertexUniformVectors = maxVertexUniformVectors;
    _this._onLocalBoundsChanged = _this._onLocalBoundsChanged.bind(_assert_this_initialized(_this));
    var localBounds = _this._localBounds;
    localBounds.min._onValueChanged = _this._onLocalBoundsChanged;
    localBounds.max._onValueChanged = _this._onLocalBoundsChanged;
    return _this;
  }
  var _proto = SkinnedMeshRenderer2.prototype;
  _proto.update = function update() {
    if (!this._hasInitSkin) {
      this._initSkin();
      this._hasInitSkin = true;
    }
    var skin = this._skin;
    if (skin) {
      var ibms = skin.inverseBindMatrices;
      var worldToLocal = this._rootBone.getInvModelMatrix();
      var _this = this, joints = _this._jointEntities, jointMatrices = _this._jointMatrices;
      for (var i = joints.length - 1; i >= 0; i--) {
        var joint = joints[i];
        var offset = i * 16;
        if (joint) {
          Utils._floatMatrixMultiply(joint.transform.worldMatrix, ibms[i].elements, 0, jointMatrices, offset);
        } else {
          jointMatrices.set(ibms[i].elements, offset);
        }
        Utils._floatMatrixMultiply(worldToLocal, jointMatrices, offset, jointMatrices, offset);
      }
    }
  };
  _proto._updateShaderData = function _updateShaderData(context) {
    var entity = this.entity;
    var worldMatrix = this._rootBone ? this._rootBone.transform.worldMatrix : entity.transform.worldMatrix;
    this._updateTransformShaderData(context, worldMatrix);
    var shaderData = this.shaderData;
    var mesh = this.mesh;
    var blendShapeManager = mesh._blendShapeManager;
    blendShapeManager._updateShaderData(shaderData, this);
    var skin = this._skin;
    if (skin) {
      var bsUniformOccupiesCount = blendShapeManager._uniformOccupiesCount;
      var jointCount = skin.joints.length;
      var jointDataCreateCache = this._jointDataCreateCache;
      var jointCountChange = jointCount !== jointDataCreateCache.x;
      if (jointCountChange || bsUniformOccupiesCount !== jointDataCreateCache.y) {
        var remainUniformJointCount = Math.ceil((this._maxVertexUniformVectors - (44 + bsUniformOccupiesCount)) / 4);
        if (jointCount > remainUniformJointCount) {
          var engine = this.engine;
          if (engine._hardwareRenderer.canIUseMoreJoints) {
            if (jointCountChange) {
              var _this__jointTexture;
              (_this__jointTexture = this._jointTexture) == null ? void 0 : _this__jointTexture.destroy();
              this._jointTexture = new Texture2D(engine, 4, jointCount, TextureFormat.R32G32B32A32, false);
              this._jointTexture.filterMode = TextureFilterMode.Point;
              this._jointTexture.isGCIgnored = true;
            }
            shaderData.disableMacro("RENDERER_JOINTS_NUM");
            shaderData.enableMacro("RENDERER_USE_JOINT_TEXTURE");
            shaderData.setTexture(SkinnedMeshRenderer2._jointSamplerProperty, this._jointTexture);
          } else {
            Logger.error("component's joints count(" + jointCount + ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number " + this._maxVertexUniformVectors + ", and don't support jointTexture in this device. suggest joint count less than " + remainUniformJointCount + ".", this);
          }
        } else {
          var _this__jointTexture1;
          (_this__jointTexture1 = this._jointTexture) == null ? void 0 : _this__jointTexture1.destroy();
          shaderData.disableMacro("RENDERER_USE_JOINT_TEXTURE");
          shaderData.enableMacro("RENDERER_JOINTS_NUM", remainUniformJointCount.toString());
          shaderData.setFloatArray(SkinnedMeshRenderer2._jointMatrixProperty, this._jointMatrices);
        }
        jointDataCreateCache.set(jointCount, bsUniformOccupiesCount);
      }
      if (this._jointTexture) {
        this._jointTexture.setPixelBuffer(this._jointMatrices);
      }
    }
    var layer = entity.layer;
    this._rendererLayer.set(layer & 65535, layer >>> 16 & 65535, 0, 0);
  };
  _proto._onDestroy = function _onDestroy() {
    var _this__rootBone, _this__jointTexture;
    MeshRenderer2.prototype._onDestroy.call(this);
    (_this__rootBone = this._rootBone) == null ? void 0 : _this__rootBone.transform._updateFlagManager.removeListener(this._onTransformChanged);
    this._rootBone = null;
    this._jointDataCreateCache = null;
    this._skin = null;
    this._blendShapeWeights = null;
    this._localBounds = null;
    this._jointMatrices = null;
    (_this__jointTexture = this._jointTexture) == null ? void 0 : _this__jointTexture.destroy();
    this._jointTexture = null;
    if (this._jointEntities) {
      this._jointEntities.length = 0;
      this._jointEntities = null;
    }
  };
  _proto._cloneTo = function _cloneTo(target) {
    MeshRenderer2.prototype._cloneTo.call(this, target);
    this._blendShapeWeights && (target._blendShapeWeights = this._blendShapeWeights.slice());
  };
  _proto._registerEntityTransformListener = function _registerEntityTransformListener() {
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    if (this._rootBone) {
      var localBounds = this._localBounds;
      var worldMatrix = this._rootBone.transform.worldMatrix;
      BoundingBox.transform(localBounds, worldMatrix, worldBounds);
    } else {
      MeshRenderer2.prototype._updateBounds.call(this, worldBounds);
    }
  };
  _proto._initSkin = function _initSkin() {
    var rhi = this.entity.engine._hardwareRenderer;
    if (!rhi)
      return;
    var _this = this, skin = _this._skin, shaderData = _this.shaderData;
    if (!skin) {
      shaderData.disableMacro("RENDERER_HAS_SKIN");
      return;
    }
    var joints = skin.joints;
    var jointCount = joints.length;
    var jointEntities = new Array(jointCount);
    for (var i = jointCount - 1; i >= 0; i--) {
      jointEntities[i] = this._findByEntityName(this.entity, joints[i]);
    }
    this._jointEntities = jointEntities;
    this._jointMatrices = new Float32Array(jointCount * 16);
    var lastRootBone = this._rootBone;
    var rootBone = this._findByEntityName(this.entity, skin.skeleton);
    lastRootBone && lastRootBone.transform._updateFlagManager.removeListener(this._onTransformChanged);
    rootBone.transform._updateFlagManager.addListener(this._onTransformChanged);
    var rootIndex = joints.indexOf(skin.skeleton);
    if (rootIndex !== -1) {
      BoundingBox.transform(this._mesh.bounds, skin.inverseBindMatrices[rootIndex], this._localBounds);
    } else {
      var approximateBindMatrix = new Matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      var subRootBoneCount = this._computeApproximateBindMatrix(jointEntities, skin.inverseBindMatrices, rootBone, approximateBindMatrix);
      if (subRootBoneCount !== 0) {
        Matrix.multiplyScalar(approximateBindMatrix, 1 / subRootBoneCount, approximateBindMatrix);
        BoundingBox.transform(this._mesh.bounds, approximateBindMatrix, this._localBounds);
      } else {
        this._localBounds.copyFrom(this._mesh.bounds);
      }
    }
    this._rootBone = rootBone;
    if (jointCount) {
      shaderData.enableMacro("RENDERER_HAS_SKIN");
      shaderData.setInt(SkinnedMeshRenderer2._jointCountProperty, jointCount);
    } else {
      shaderData.disableMacro("RENDERER_HAS_SKIN");
    }
  };
  _proto._computeApproximateBindMatrix = function _computeApproximateBindMatrix(jointEntities, inverseBindMatrices, rootEntity, approximateBindMatrix) {
    var subRootBoneCount = 0;
    var children = rootEntity.children;
    for (var i = 0, n = children.length; i < n; i++) {
      var rootChild = children[i];
      var index = jointEntities.indexOf(rootChild);
      if (index !== -1) {
        Matrix.add(approximateBindMatrix, inverseBindMatrices[index], approximateBindMatrix);
        subRootBoneCount++;
      } else {
        subRootBoneCount += this._computeApproximateBindMatrix(jointEntities, inverseBindMatrices, rootChild, approximateBindMatrix);
      }
    }
    return subRootBoneCount;
  };
  _proto._findByEntityName = function _findByEntityName(rootEntity, name2) {
    if (!rootEntity) {
      return null;
    }
    var result2 = rootEntity.findByName(name2);
    if (result2) {
      return result2;
    }
    return this._findByEntityName(rootEntity.parent, name2);
  };
  _proto._checkBlendShapeWeightLength = function _checkBlendShapeWeightLength() {
    var mesh = this._mesh;
    var newBlendShapeCount = mesh ? mesh.blendShapeCount : 0;
    var lastBlendShapeWeights = this._blendShapeWeights;
    if (lastBlendShapeWeights) {
      var lastBlendShapeWeightsCount = lastBlendShapeWeights.length;
      if (lastBlendShapeWeightsCount !== newBlendShapeCount) {
        var newBlendShapeWeights = new Float32Array(newBlendShapeCount);
        if (newBlendShapeCount > lastBlendShapeWeightsCount) {
          newBlendShapeWeights.set(lastBlendShapeWeights);
        } else {
          for (var i = 0; i < newBlendShapeCount; i++) {
            newBlendShapeWeights[i] = lastBlendShapeWeights[i];
          }
        }
        this._blendShapeWeights = newBlendShapeWeights;
      }
    } else {
      this._blendShapeWeights = new Float32Array(newBlendShapeCount);
    }
  };
  _proto._onLocalBoundsChanged = function _onLocalBoundsChanged() {
    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
  };
  _create_class$4(SkinnedMeshRenderer2, [
    {
      key: "blendShapeWeights",
      get: function get3() {
        this._checkBlendShapeWeightLength();
        return this._blendShapeWeights;
      },
      set: function set(value) {
        this._checkBlendShapeWeightLength();
        var blendShapeWeights = this._blendShapeWeights;
        if (value.length <= blendShapeWeights.length) {
          blendShapeWeights.set(value);
        } else {
          for (var i = 0, n = blendShapeWeights.length; i < n; i++) {
            blendShapeWeights[i] = value[i];
          }
        }
      }
    },
    {
      key: "skin",
      get: function get3() {
        return this._skin;
      },
      set: function set(value) {
        if (this._skin !== value) {
          this._skin = value;
          this._hasInitSkin = false;
        }
      }
    },
    {
      key: "localBounds",
      get: function get3() {
        return this._localBounds;
      },
      set: function set(value) {
        if (this._localBounds !== value) {
          this._localBounds.copyFrom(value);
        }
      }
    },
    {
      key: "rootBone",
      get: function get3() {
        return this._rootBone;
      },
      set: function set(value) {
        this._skin.skeleton = value.name;
        this._hasInitSkin = false;
        this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
      }
    }
  ]);
  return SkinnedMeshRenderer2;
}(MeshRenderer);
(function() {
  SkinnedMeshRenderer._jointCountProperty = ShaderProperty.getByName("renderer_JointCount");
})();
(function() {
  SkinnedMeshRenderer._jointSamplerProperty = ShaderProperty.getByName("renderer_JointSampler");
})();
(function() {
  SkinnedMeshRenderer._jointMatrixProperty = ShaderProperty.getByName("renderer_JointMatrix");
})();
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_hasInitSkin", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_jointDataCreateCache", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_blendShapeWeights", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_maxVertexUniformVectors", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_rootBone", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_localBounds", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_jointMatrices", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_jointTexture", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_jointEntities", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_condensedBlendShapeWeights", void 0);
__decorate$2([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_onLocalBoundsChanged", null);
var PrimitiveMeshRestorer = /* @__PURE__ */ function(ContentRestorer3) {
  _inherits$2(PrimitiveMeshRestorer2, ContentRestorer3);
  function PrimitiveMeshRestorer2(resource, primitiveInfo) {
    var _this;
    _this = ContentRestorer3.call(this, resource) || this;
    _this.primitiveInfo = primitiveInfo;
    return _this;
  }
  var _proto = PrimitiveMeshRestorer2.prototype;
  _proto.restoreContent = function restoreContent() {
    var primitiveInfo = this.primitiveInfo;
    switch (primitiveInfo.type) {
      case 0:
        var sphereInfo = primitiveInfo;
        PrimitiveMesh._setSphereData(this.resource, sphereInfo.radius, sphereInfo.segments, sphereInfo.noLongerAccessible, true);
        break;
      case 1:
        var cuboidInfo = primitiveInfo;
        PrimitiveMesh._setCuboidData(this.resource, cuboidInfo.width, cuboidInfo.height, cuboidInfo.depth, cuboidInfo.noLongerAccessible, true);
        break;
      case 2:
        var planeInfo = primitiveInfo;
        PrimitiveMesh._setPlaneData(this.resource, planeInfo.width, planeInfo.height, planeInfo.horizontalSegments, planeInfo.verticalSegments, planeInfo.noLongerAccessible, true);
        break;
      case 3:
        var cylinderInfo = primitiveInfo;
        PrimitiveMesh._setCylinderData(this.resource, cylinderInfo.radiusTop, cylinderInfo.radiusBottom, cylinderInfo.height, cylinderInfo.radialSegments, cylinderInfo.heightSegments, cylinderInfo.noLongerAccessible, true);
        break;
      case 4:
        var torusInfo = primitiveInfo;
        PrimitiveMesh._setTorusData(this.resource, torusInfo.radius, torusInfo.tubeRadius, torusInfo.radialSegments, torusInfo.tubularSegments, torusInfo.arc, torusInfo.noLongerAccessible, true);
        break;
      case 5:
        var coneInfo = primitiveInfo;
        PrimitiveMesh._setConeData(this.resource, coneInfo.radius, coneInfo.height, coneInfo.radialSegments, coneInfo.heightSegments, coneInfo.noLongerAccessible, true);
        break;
      case 6:
        var capsuleInfo = primitiveInfo;
        PrimitiveMesh._setCapsuleData(this.resource, capsuleInfo.radius, capsuleInfo.height, capsuleInfo.radialSegments, capsuleInfo.heightSegments, capsuleInfo.noLongerAccessible, true);
        break;
    }
  };
  return PrimitiveMeshRestorer2;
}(ContentRestorer);
var PrimitiveType;
(function(PrimitiveType2) {
  PrimitiveType2[PrimitiveType2["Sphere"] = 0] = "Sphere";
  PrimitiveType2[PrimitiveType2["Cuboid"] = 1] = "Cuboid";
  PrimitiveType2[PrimitiveType2["Plane"] = 2] = "Plane";
  PrimitiveType2[PrimitiveType2["Cylinder"] = 3] = "Cylinder";
  PrimitiveType2[PrimitiveType2["Torus"] = 4] = "Torus";
  PrimitiveType2[PrimitiveType2["Cone"] = 5] = "Cone";
  PrimitiveType2[PrimitiveType2["Capsule"] = 6] = "Capsule";
})(PrimitiveType || (PrimitiveType = {}));
var PrimitiveRestoreInfo = function PrimitiveRestoreInfo2(type, noLongerAccessible) {
  this.type = type;
  this.noLongerAccessible = noLongerAccessible;
};
var SphereRestoreInfo = /* @__PURE__ */ function(PrimitiveRestoreInfo3) {
  _inherits$2(SphereRestoreInfo2, PrimitiveRestoreInfo3);
  function SphereRestoreInfo2(radius, segments, noLongerAccessible) {
    var _this;
    _this = PrimitiveRestoreInfo3.call(this, 0, noLongerAccessible) || this;
    _this.radius = radius;
    _this.segments = segments;
    return _this;
  }
  return SphereRestoreInfo2;
}(PrimitiveRestoreInfo);
var CuboidRestoreInfo = /* @__PURE__ */ function(PrimitiveRestoreInfo3) {
  _inherits$2(CuboidRestoreInfo2, PrimitiveRestoreInfo3);
  function CuboidRestoreInfo2(width, height, depth, noLongerAccessible) {
    var _this;
    _this = PrimitiveRestoreInfo3.call(this, 1, noLongerAccessible) || this;
    _this.width = width;
    _this.height = height;
    _this.depth = depth;
    return _this;
  }
  return CuboidRestoreInfo2;
}(PrimitiveRestoreInfo);
var PlaneRestoreInfo = /* @__PURE__ */ function(PrimitiveRestoreInfo3) {
  _inherits$2(PlaneRestoreInfo2, PrimitiveRestoreInfo3);
  function PlaneRestoreInfo2(width, height, horizontalSegments, verticalSegments, noLongerAccessible) {
    var _this;
    _this = PrimitiveRestoreInfo3.call(this, 2, noLongerAccessible) || this;
    _this.width = width;
    _this.height = height;
    _this.horizontalSegments = horizontalSegments;
    _this.verticalSegments = verticalSegments;
    return _this;
  }
  return PlaneRestoreInfo2;
}(PrimitiveRestoreInfo);
var CylinderRestoreInfo = /* @__PURE__ */ function(PrimitiveRestoreInfo3) {
  _inherits$2(CylinderRestoreInfo2, PrimitiveRestoreInfo3);
  function CylinderRestoreInfo2(radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible) {
    var _this;
    _this = PrimitiveRestoreInfo3.call(this, 3, noLongerAccessible) || this;
    _this.radiusTop = radiusTop;
    _this.radiusBottom = radiusBottom;
    _this.height = height;
    _this.radialSegments = radialSegments;
    _this.heightSegments = heightSegments;
    return _this;
  }
  return CylinderRestoreInfo2;
}(PrimitiveRestoreInfo);
var TorusRestoreInfo = /* @__PURE__ */ function(PrimitiveRestoreInfo3) {
  _inherits$2(TorusRestoreInfo2, PrimitiveRestoreInfo3);
  function TorusRestoreInfo2(radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible) {
    var _this;
    _this = PrimitiveRestoreInfo3.call(this, 4, noLongerAccessible) || this;
    _this.radius = radius;
    _this.tubeRadius = tubeRadius;
    _this.radialSegments = radialSegments;
    _this.tubularSegments = tubularSegments;
    _this.arc = arc;
    return _this;
  }
  return TorusRestoreInfo2;
}(PrimitiveRestoreInfo);
var ConeRestoreInfo = /* @__PURE__ */ function(PrimitiveRestoreInfo3) {
  _inherits$2(ConeRestoreInfo2, PrimitiveRestoreInfo3);
  function ConeRestoreInfo2(radius, height, radialSegments, heightSegments, noLongerAccessible) {
    var _this;
    _this = PrimitiveRestoreInfo3.call(this, 5, noLongerAccessible) || this;
    _this.radius = radius;
    _this.height = height;
    _this.radialSegments = radialSegments;
    _this.heightSegments = heightSegments;
    return _this;
  }
  return ConeRestoreInfo2;
}(PrimitiveRestoreInfo);
var CapsuleRestoreInfo = /* @__PURE__ */ function(PrimitiveRestoreInfo3) {
  _inherits$2(CapsuleRestoreInfo2, PrimitiveRestoreInfo3);
  function CapsuleRestoreInfo2(radius, height, radialSegments, heightSegments, noLongerAccessible) {
    var _this;
    _this = PrimitiveRestoreInfo3.call(this, 6, noLongerAccessible) || this;
    _this.radius = radius;
    _this.height = height;
    _this.radialSegments = radialSegments;
    _this.heightSegments = heightSegments;
    return _this;
  }
  return CapsuleRestoreInfo2;
}(PrimitiveRestoreInfo);
var PrimitiveMesh = /* @__PURE__ */ function() {
  function PrimitiveMesh2() {
  }
  PrimitiveMesh2.createSphere = function createSphere(engine, radius, segments, noLongerAccessible) {
    if (radius === void 0)
      radius = 0.5;
    if (segments === void 0)
      segments = 18;
    if (noLongerAccessible === void 0)
      noLongerAccessible = true;
    var sphereMesh = new ModelMesh(engine);
    PrimitiveMesh2._setSphereData(sphereMesh, radius, segments, noLongerAccessible, false);
    engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(sphereMesh, new SphereRestoreInfo(radius, segments, noLongerAccessible)));
    return sphereMesh;
  };
  PrimitiveMesh2.createCuboid = function createCuboid(engine, width, height, depth, noLongerAccessible) {
    if (width === void 0)
      width = 1;
    if (height === void 0)
      height = 1;
    if (depth === void 0)
      depth = 1;
    if (noLongerAccessible === void 0)
      noLongerAccessible = true;
    var mesh = new ModelMesh(engine);
    PrimitiveMesh2._setCuboidData(mesh, width, height, depth, noLongerAccessible, false);
    engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new CuboidRestoreInfo(width, height, depth, noLongerAccessible)));
    return mesh;
  };
  PrimitiveMesh2.createPlane = function createPlane(engine, width, height, horizontalSegments, verticalSegments, noLongerAccessible) {
    if (width === void 0)
      width = 1;
    if (height === void 0)
      height = 1;
    if (horizontalSegments === void 0)
      horizontalSegments = 1;
    if (verticalSegments === void 0)
      verticalSegments = 1;
    if (noLongerAccessible === void 0)
      noLongerAccessible = true;
    var mesh = new ModelMesh(engine);
    PrimitiveMesh2._setPlaneData(mesh, width, height, horizontalSegments, verticalSegments, noLongerAccessible, false);
    engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new PlaneRestoreInfo(width, height, horizontalSegments, verticalSegments, noLongerAccessible)));
    return mesh;
  };
  PrimitiveMesh2.createCylinder = function createCylinder(engine, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radiusTop === void 0)
      radiusTop = 0.5;
    if (radiusBottom === void 0)
      radiusBottom = 0.5;
    if (height === void 0)
      height = 2;
    if (radialSegments === void 0)
      radialSegments = 20;
    if (heightSegments === void 0)
      heightSegments = 1;
    if (noLongerAccessible === void 0)
      noLongerAccessible = true;
    var mesh = new ModelMesh(engine);
    PrimitiveMesh2._setCylinderData(mesh, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible, false);
    engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new CylinderRestoreInfo(radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible)));
    return mesh;
  };
  PrimitiveMesh2.createTorus = function createTorus(engine, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible) {
    if (radius === void 0)
      radius = 0.5;
    if (tubeRadius === void 0)
      tubeRadius = 0.1;
    if (radialSegments === void 0)
      radialSegments = 30;
    if (tubularSegments === void 0)
      tubularSegments = 30;
    if (arc === void 0)
      arc = 360;
    if (noLongerAccessible === void 0)
      noLongerAccessible = true;
    var mesh = new ModelMesh(engine);
    PrimitiveMesh2._setTorusData(mesh, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible, false);
    engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new TorusRestoreInfo(radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible)));
    return mesh;
  };
  PrimitiveMesh2.createCone = function createCone(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radius === void 0)
      radius = 0.5;
    if (height === void 0)
      height = 2;
    if (radialSegments === void 0)
      radialSegments = 20;
    if (heightSegments === void 0)
      heightSegments = 1;
    if (noLongerAccessible === void 0)
      noLongerAccessible = true;
    var mesh = new ModelMesh(engine);
    PrimitiveMesh2._setConeData(mesh, radius, height, radialSegments, heightSegments, noLongerAccessible, false);
    engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new ConeRestoreInfo(radius, height, radialSegments, heightSegments, noLongerAccessible)));
    return mesh;
  };
  PrimitiveMesh2.createCapsule = function createCapsule(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
    if (radius === void 0)
      radius = 0.5;
    if (height === void 0)
      height = 2;
    if (radialSegments === void 0)
      radialSegments = 6;
    if (heightSegments === void 0)
      heightSegments = 1;
    if (noLongerAccessible === void 0)
      noLongerAccessible = true;
    var mesh = new ModelMesh(engine);
    PrimitiveMesh2._setCapsuleData(mesh, radius, height, radialSegments, heightSegments, noLongerAccessible, false);
    engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new CapsuleRestoreInfo(radius, height, radialSegments, heightSegments, noLongerAccessible)));
    return mesh;
  };
  PrimitiveMesh2._setSphereData = function _setSphereData(sphereMesh, radius, segments, noLongerAccessible, isRestoreMode) {
    segments = Math.max(2, Math.floor(segments));
    var count = segments + 1;
    var vertexCount = count * count;
    var rectangleCount = segments * segments;
    var indices = PrimitiveMesh2._generateIndices(sphereMesh.engine, vertexCount, rectangleCount * 6);
    var thetaRange = Math.PI;
    var alphaRange = thetaRange * 2;
    var countReciprocal = 1 / count;
    var segmentsReciprocal = 1 / segments;
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    for (var i = 0; i < vertexCount; ++i) {
      var x = i % count;
      var y = i * countReciprocal | 0;
      var u = x * segmentsReciprocal;
      var v = y * segmentsReciprocal;
      var alphaDelta = u * alphaRange;
      var thetaDelta = v * thetaRange;
      var sinTheta = Math.sin(thetaDelta);
      var posX = -radius * Math.cos(alphaDelta) * sinTheta;
      var posY = radius * Math.cos(thetaDelta);
      var posZ = radius * Math.sin(alphaDelta) * sinTheta;
      positions[i] = new Vector3(posX, posY, posZ);
      normals[i] = new Vector3(posX, posY, posZ);
      uvs[i] = new Vector2(u, v);
    }
    var offset = 0;
    for (var i1 = 0; i1 < rectangleCount; ++i1) {
      var x1 = i1 % segments;
      var y1 = i1 * segmentsReciprocal | 0;
      var a = y1 * count + x1;
      var b = a + 1;
      var c = a + count;
      var d = c + 1;
      indices[offset++] = b;
      indices[offset++] = a;
      indices[offset++] = d;
      indices[offset++] = a;
      indices[offset++] = c;
      indices[offset++] = d;
    }
    if (!isRestoreMode) {
      var bounds = sphereMesh.bounds;
      bounds.min.set(-radius, -radius, -radius);
      bounds.max.set(radius, radius, radius);
    }
    PrimitiveMesh2._initialize(sphereMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
  };
  PrimitiveMesh2._setCuboidData = function _setCuboidData(cuboidMesh, width, height, depth, noLongerAccessible, isRestoreMode) {
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var halfDepth = depth / 2;
    var positions = new Array(24);
    var normals = new Array(24);
    var uvs = new Array(24);
    positions[0] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[1] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[2] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[3] = new Vector3(-halfWidth, halfHeight, halfDepth);
    normals[0] = new Vector3(0, 1, 0);
    normals[1] = new Vector3(0, 1, 0);
    normals[2] = new Vector3(0, 1, 0);
    normals[3] = new Vector3(0, 1, 0);
    uvs[0] = new Vector2(0, 0);
    uvs[1] = new Vector2(1, 0);
    uvs[2] = new Vector2(1, 1);
    uvs[3] = new Vector2(0, 1);
    positions[4] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    positions[5] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    positions[6] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[7] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    normals[4] = new Vector3(0, -1, 0);
    normals[5] = new Vector3(0, -1, 0);
    normals[6] = new Vector3(0, -1, 0);
    normals[7] = new Vector3(0, -1, 0);
    uvs[4] = new Vector2(0, 1);
    uvs[5] = new Vector2(1, 1);
    uvs[6] = new Vector2(1, 0);
    uvs[7] = new Vector2(0, 0);
    positions[8] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[9] = new Vector3(-halfWidth, halfHeight, halfDepth);
    positions[10] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    positions[11] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    normals[8] = new Vector3(-1, 0, 0);
    normals[9] = new Vector3(-1, 0, 0);
    normals[10] = new Vector3(-1, 0, 0);
    normals[11] = new Vector3(-1, 0, 0);
    uvs[8] = new Vector2(0, 0);
    uvs[9] = new Vector2(1, 0);
    uvs[10] = new Vector2(1, 1);
    uvs[11] = new Vector2(0, 1);
    positions[12] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[13] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[14] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[15] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    normals[12] = new Vector3(1, 0, 0);
    normals[13] = new Vector3(1, 0, 0);
    normals[14] = new Vector3(1, 0, 0);
    normals[15] = new Vector3(1, 0, 0);
    uvs[12] = new Vector2(1, 0);
    uvs[13] = new Vector2(0, 0);
    uvs[14] = new Vector2(0, 1);
    uvs[15] = new Vector2(1, 1);
    positions[16] = new Vector3(-halfWidth, halfHeight, halfDepth);
    positions[17] = new Vector3(halfWidth, halfHeight, halfDepth);
    positions[18] = new Vector3(halfWidth, -halfHeight, halfDepth);
    positions[19] = new Vector3(-halfWidth, -halfHeight, halfDepth);
    normals[16] = new Vector3(0, 0, 1);
    normals[17] = new Vector3(0, 0, 1);
    normals[18] = new Vector3(0, 0, 1);
    normals[19] = new Vector3(0, 0, 1);
    uvs[16] = new Vector2(0, 0);
    uvs[17] = new Vector2(1, 0);
    uvs[18] = new Vector2(1, 1);
    uvs[19] = new Vector2(0, 1);
    positions[20] = new Vector3(-halfWidth, halfHeight, -halfDepth);
    positions[21] = new Vector3(halfWidth, halfHeight, -halfDepth);
    positions[22] = new Vector3(halfWidth, -halfHeight, -halfDepth);
    positions[23] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
    normals[20] = new Vector3(0, 0, -1);
    normals[21] = new Vector3(0, 0, -1);
    normals[22] = new Vector3(0, 0, -1);
    normals[23] = new Vector3(0, 0, -1);
    uvs[20] = new Vector2(1, 0);
    uvs[21] = new Vector2(0, 0);
    uvs[22] = new Vector2(0, 1);
    uvs[23] = new Vector2(1, 1);
    var indices = new Uint16Array(36);
    indices[0] = 0, indices[1] = 2, indices[2] = 1, indices[3] = 2, indices[4] = 0, indices[5] = 3, indices[6] = 4, indices[7] = 6, indices[8] = 7, indices[9] = 6, indices[10] = 4, indices[11] = 5, indices[12] = 8, indices[13] = 10, indices[14] = 9, indices[15] = 10, indices[16] = 8, indices[17] = 11, indices[18] = 12, indices[19] = 14, indices[20] = 15, indices[21] = 14, indices[22] = 12, indices[23] = 13, indices[24] = 16, indices[25] = 18, indices[26] = 17, indices[27] = 18, indices[28] = 16, indices[29] = 19, indices[30] = 20, indices[31] = 22, indices[32] = 23, indices[33] = 22, indices[34] = 20, indices[35] = 21;
    if (!isRestoreMode) {
      var bounds = cuboidMesh.bounds;
      bounds.min.set(-halfWidth, -halfHeight, -halfDepth);
      bounds.max.set(halfWidth, halfHeight, halfDepth);
    }
    PrimitiveMesh2._initialize(cuboidMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
  };
  PrimitiveMesh2._setPlaneData = function _setPlaneData(planeMesh, width, height, horizontalSegments, verticalSegments, noLongerAccessible, isRestoreMode) {
    horizontalSegments = Math.max(1, Math.floor(horizontalSegments));
    verticalSegments = Math.max(1, Math.floor(verticalSegments));
    var horizontalCount = horizontalSegments + 1;
    var verticalCount = verticalSegments + 1;
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var gridWidth = width / horizontalSegments;
    var gridHeight = height / verticalSegments;
    var vertexCount = horizontalCount * verticalCount;
    var rectangleCount = verticalSegments * horizontalSegments;
    var indices = PrimitiveMesh2._generateIndices(planeMesh.engine, vertexCount, rectangleCount * 6);
    var horizontalCountReciprocal = 1 / horizontalCount;
    var horizontalSegmentsReciprocal = 1 / horizontalSegments;
    var verticalSegmentsReciprocal = 1 / verticalSegments;
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    for (var i = 0; i < vertexCount; ++i) {
      var x = i % horizontalCount;
      var z2 = i * horizontalCountReciprocal | 0;
      positions[i] = new Vector3(x * gridWidth - halfWidth, 0, z2 * gridHeight - halfHeight);
      normals[i] = new Vector3(0, 1, 0);
      uvs[i] = new Vector2(x * horizontalSegmentsReciprocal, z2 * verticalSegmentsReciprocal);
    }
    var offset = 0;
    for (var i1 = 0; i1 < rectangleCount; ++i1) {
      var x1 = i1 % horizontalSegments;
      var y = i1 * horizontalSegmentsReciprocal | 0;
      var a = y * horizontalCount + x1;
      var b = a + 1;
      var c = a + horizontalCount;
      var d = c + 1;
      indices[offset++] = a;
      indices[offset++] = c;
      indices[offset++] = b;
      indices[offset++] = c;
      indices[offset++] = d;
      indices[offset++] = b;
    }
    if (!isRestoreMode) {
      var bounds = planeMesh.bounds;
      bounds.min.set(-halfWidth, 0, -halfHeight);
      bounds.max.set(halfWidth, 0, halfHeight);
    }
    PrimitiveMesh2._initialize(planeMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
  };
  PrimitiveMesh2._setCylinderData = function _setCylinderData(cylinderMesh, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible, isRestoreMode) {
    if (radiusTop === void 0)
      radiusTop = 0.5;
    if (radiusBottom === void 0)
      radiusBottom = 0.5;
    if (height === void 0)
      height = 2;
    if (radialSegments === void 0)
      radialSegments = 20;
    if (heightSegments === void 0)
      heightSegments = 1;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var capTriangleCount = radialSegments * 2;
    var totalVertexCount = torsoVertexCount + 2 + capTriangleCount;
    var indices = PrimitiveMesh2._generateIndices(cylinderMesh.engine, totalVertexCount, torsoRectangleCount * 6 + capTriangleCount * 3);
    var radialCountReciprocal = 1 / radialCount;
    var radialSegmentsReciprocal = 1 / radialSegments;
    var heightSegmentsReciprocal = 1 / heightSegments;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0;
    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var radiusDiff = radiusBottom - radiusTop;
    var slope = radiusDiff / height;
    var radiusSlope = radiusDiff / heightSegments;
    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var radius = radiusBottom - y * radiusSlope;
      var posX = radius * sinTheta;
      var posY = y * unitHeight - halfHeight;
      var posZ = radius * cosTheta;
      positions[i] = new Vector3(posX, posY, posZ);
      normals[i] = new Vector3(sinTheta, slope, cosTheta);
      uvs[i] = new Vector2(u, 1 - v);
    }
    for (var i1 = 0; i1 < torsoRectangleCount; ++i1) {
      var x1 = i1 % radialSegments;
      var y1 = i1 * radialSegmentsReciprocal | 0;
      var a = y1 * radialCount + x1;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    }
    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);
    normals[torsoVertexCount] = new Vector3(0, -1, 0);
    uvs[torsoVertexCount] = new Vector2(0.5, 0.5);
    positions[torsoVertexCount + 1] = new Vector3(0, halfHeight, 0);
    normals[torsoVertexCount + 1] = new Vector3(0, 1, 0);
    uvs[torsoVertexCount + 1] = new Vector2(0.5, 0.5);
    var offset = torsoVertexCount + 2;
    var diameterTopReciprocal = 1 / (radiusTop * 2);
    var diameterBottomReciprocal = 1 / (radiusBottom * 2);
    var positionStride = radialCount * heightSegments;
    for (var i2 = 0; i2 < radialSegments; ++i2) {
      var curPosBottom = positions[i2];
      var curPosX = curPosBottom.x;
      var curPosZ = curPosBottom.z;
      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);
      normals[offset] = new Vector3(0, -1, 0);
      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
      var curPosTop = positions[i2 + positionStride];
      curPosX = curPosTop.x;
      curPosZ = curPosTop.z;
      positions[offset] = new Vector3(curPosX, halfHeight, curPosZ);
      normals[offset] = new Vector3(0, 1, 0);
      uvs[offset++] = new Vector2(curPosX * diameterTopReciprocal + 0.5, curPosZ * diameterTopReciprocal + 0.5);
    }
    var topCapIndex = torsoVertexCount + 1;
    var bottomIndiceIndex = torsoVertexCount + 2;
    var topIndiceIndex = bottomIndiceIndex + 1;
    for (var i3 = 0; i3 < radialSegments; ++i3) {
      var firstStride = i3 * 2;
      var secondStride = i3 === radialSegments - 1 ? 0 : firstStride + 2;
      indices[indicesOffset++] = torsoVertexCount;
      indices[indicesOffset++] = bottomIndiceIndex + secondStride;
      indices[indicesOffset++] = bottomIndiceIndex + firstStride;
      indices[indicesOffset++] = topCapIndex;
      indices[indicesOffset++] = topIndiceIndex + firstStride;
      indices[indicesOffset++] = topIndiceIndex + secondStride;
    }
    if (!isRestoreMode) {
      var bounds = cylinderMesh.bounds;
      var radiusMax = Math.max(radiusTop, radiusBottom);
      bounds.min.set(-radiusMax, -halfHeight, -radiusMax);
      bounds.max.set(radiusMax, halfHeight, radiusMax);
    }
    PrimitiveMesh2._initialize(cylinderMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
  };
  PrimitiveMesh2._setTorusData = function _setTorusData(torusMesh, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible, isRestoreMode) {
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
    var rectangleCount = radialSegments * tubularSegments;
    var indices = PrimitiveMesh2._generateIndices(torusMesh.engine, vertexCount, rectangleCount * 6);
    var positions = new Array(vertexCount);
    var normals = new Array(vertexCount);
    var uvs = new Array(vertexCount);
    arc = arc / 180 * Math.PI;
    var offset = 0;
    for (var i = 0; i <= radialSegments; i++) {
      for (var j2 = 0; j2 <= tubularSegments; j2++) {
        var u = j2 / tubularSegments * arc;
        var v = i / radialSegments * Math.PI * 2;
        var cosV = Math.cos(v);
        var sinV = Math.sin(v);
        var cosU = Math.cos(u);
        var sinU = Math.sin(u);
        var position = new Vector3((radius + tubeRadius * cosV) * cosU, (radius + tubeRadius * cosV) * sinU, tubeRadius * sinV);
        positions[offset] = position;
        var centerX = radius * cosU;
        var centerY = radius * sinU;
        normals[offset] = new Vector3(position.x - centerX, position.y - centerY, position.z).normalize();
        uvs[offset++] = new Vector2(j2 / tubularSegments, i / radialSegments);
      }
    }
    offset = 0;
    for (var i1 = 1; i1 <= radialSegments; i1++) {
      for (var j1 = 1; j1 <= tubularSegments; j1++) {
        var a = (tubularSegments + 1) * i1 + j1 - 1;
        var b = (tubularSegments + 1) * (i1 - 1) + j1 - 1;
        var c = (tubularSegments + 1) * (i1 - 1) + j1;
        var d = (tubularSegments + 1) * i1 + j1;
        indices[offset++] = a;
        indices[offset++] = b;
        indices[offset++] = d;
        indices[offset++] = b;
        indices[offset++] = c;
        indices[offset++] = d;
      }
    }
    if (!isRestoreMode) {
      var bounds = torusMesh.bounds;
      var outerRadius = radius + tubeRadius;
      bounds.min.set(-outerRadius, -outerRadius, -tubeRadius);
      bounds.max.set(outerRadius, outerRadius, tubeRadius);
    }
    PrimitiveMesh2._initialize(torusMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
  };
  PrimitiveMesh2._setConeData = function _setConeData(coneMesh, radius, height, radialSegments, heightSegments, noLongerAccessible, isRestoreMode) {
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var totalVertexCount = torsoVertexCount + 1 + radialSegments;
    var indices = PrimitiveMesh2._generateIndices(coneMesh.engine, totalVertexCount, torsoRectangleCount * 6 + radialSegments * 3);
    var radialCountReciprocal = 1 / radialCount;
    var radialSegmentsReciprocal = 1 / radialSegments;
    var heightSegmentsReciprocal = 1 / heightSegments;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0;
    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var slope = radius / height;
    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var curRadius = radius - y * radius;
      var posX = curRadius * sinTheta;
      var posY = y * unitHeight - halfHeight;
      var posZ = curRadius * cosTheta;
      positions[i] = new Vector3(posX, posY, posZ);
      normals[i] = new Vector3(sinTheta, slope, cosTheta);
      uvs[i] = new Vector2(u, 1 - v);
    }
    for (var i1 = 0; i1 < torsoRectangleCount; ++i1) {
      var x1 = i1 % radialSegments;
      var y1 = i1 * radialSegmentsReciprocal | 0;
      var a = y1 * radialCount + x1;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    }
    positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);
    normals[torsoVertexCount] = new Vector3(0, -1, 0);
    uvs[torsoVertexCount] = new Vector2(0.5, 0.5);
    var offset = torsoVertexCount + 1;
    var diameterBottomReciprocal = 1 / (radius * 2);
    for (var i2 = 0; i2 < radialSegments; ++i2) {
      var curPos = positions[i2];
      var curPosX = curPos.x;
      var curPosZ = curPos.z;
      positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);
      normals[offset] = new Vector3(0, -1, 0);
      uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
    }
    var bottomIndiceIndex = torsoVertexCount + 1;
    for (var i3 = 0; i3 < radialSegments; ++i3) {
      var firstStride = i3;
      var secondStride = i3 === radialSegments - 1 ? 0 : firstStride + 1;
      indices[indicesOffset++] = torsoVertexCount;
      indices[indicesOffset++] = bottomIndiceIndex + secondStride;
      indices[indicesOffset++] = bottomIndiceIndex + firstStride;
    }
    if (!isRestoreMode) {
      var bounds = coneMesh.bounds;
      bounds.min.set(-radius, -halfHeight, -radius);
      bounds.max.set(radius, halfHeight, radius);
    }
    PrimitiveMesh2._initialize(coneMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
  };
  PrimitiveMesh2._setCapsuleData = function _setCapsuleData(capsuleMesh, radius, height, radialSegments, heightSegments, noLongerAccessible, isRestoreMode) {
    radialSegments = Math.max(2, Math.floor(radialSegments));
    heightSegments = Math.floor(heightSegments);
    var radialCount = radialSegments + 1;
    var verticalCount = heightSegments + 1;
    var halfHeight = height * 0.5;
    var unitHeight = height / heightSegments;
    var torsoVertexCount = radialCount * verticalCount;
    var torsoRectangleCount = radialSegments * heightSegments;
    var capVertexCount = radialCount * radialCount;
    var capRectangleCount = radialSegments * radialSegments;
    var totalVertexCount = torsoVertexCount + 2 * capVertexCount;
    var indices = PrimitiveMesh2._generateIndices(capsuleMesh.engine, totalVertexCount, (torsoRectangleCount + 2 * capRectangleCount) * 6);
    var radialCountReciprocal = 1 / radialCount;
    var radialSegmentsReciprocal = 1 / radialSegments;
    var heightSegmentsReciprocal = 1 / heightSegments;
    var thetaStart = Math.PI;
    var thetaRange = Math.PI * 2;
    var positions = new Array(totalVertexCount);
    var normals = new Array(totalVertexCount);
    var uvs = new Array(totalVertexCount);
    var indicesOffset = 0;
    for (var i = 0; i < torsoVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * heightSegmentsReciprocal;
      var theta = thetaStart + u * thetaRange;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      positions[i] = new Vector3(radius * sinTheta, y * unitHeight - halfHeight, radius * cosTheta);
      normals[i] = new Vector3(sinTheta, 0, cosTheta);
      uvs[i] = new Vector2(u, 1 - v);
    }
    for (var i1 = 0; i1 < torsoRectangleCount; ++i1) {
      var x1 = i1 % radialSegments;
      var y1 = i1 * radialSegmentsReciprocal | 0;
      var a = y1 * radialCount + x1;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = c;
    }
    PrimitiveMesh2._createCapsuleCap(radius, height, radialSegments, thetaRange, torsoVertexCount, 1, positions, normals, uvs, indices, indicesOffset);
    PrimitiveMesh2._createCapsuleCap(radius, height, radialSegments, -thetaRange, torsoVertexCount + capVertexCount, -1, positions, normals, uvs, indices, indicesOffset + 6 * capRectangleCount);
    if (!isRestoreMode) {
      var bounds = capsuleMesh.bounds;
      bounds.min.set(-radius, -radius - halfHeight, -radius);
      bounds.max.set(radius, radius + halfHeight, radius);
    }
    PrimitiveMesh2._initialize(capsuleMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
  };
  PrimitiveMesh2._initialize = function _initialize(mesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode) {
    mesh.setPositions(positions);
    mesh.setNormals(normals);
    mesh.setUVs(uvs);
    mesh.setIndices(indices);
    mesh.calculateTangents();
    mesh.uploadData(noLongerAccessible);
    if (!isRestoreMode) {
      mesh.addSubMesh(0, indices.length);
    }
  };
  PrimitiveMesh2._generateIndices = function _generateIndices(engine, vertexCount, indexCount) {
    var indices = null;
    if (vertexCount > 65535) {
      if (engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
        indices = new Uint32Array(indexCount);
      } else {
        throw Error("The vertex count is over limit.");
      }
    } else {
      indices = new Uint16Array(indexCount);
    }
    return indices;
  };
  PrimitiveMesh2._createCapsuleCap = function _createCapsuleCap(radius, height, radialSegments, capAlphaRange, offset, posIndex, positions, normals, uvs, indices, indicesOffset) {
    var radialCount = radialSegments + 1;
    var halfHeight = height * 0.5 * posIndex;
    var capVertexCount = radialCount * radialCount;
    var capRectangleCount = radialSegments * radialSegments;
    var radialCountReciprocal = 1 / radialCount;
    var radialSegmentsReciprocal = 1 / radialSegments;
    for (var i = 0; i < capVertexCount; ++i) {
      var x = i % radialCount;
      var y = i * radialCountReciprocal | 0;
      var u = x * radialSegmentsReciprocal;
      var v = y * radialSegmentsReciprocal;
      var alphaDelta = u * capAlphaRange;
      var thetaDelta = v * Math.PI / 2;
      var sinTheta = Math.sin(thetaDelta);
      var posX = -radius * Math.cos(alphaDelta) * sinTheta;
      var posY = radius * Math.cos(thetaDelta) * posIndex + halfHeight;
      var posZ = radius * Math.sin(alphaDelta) * sinTheta;
      var index = i + offset;
      positions[index] = new Vector3(posX, posY, posZ);
      normals[index] = new Vector3(posX, posY - halfHeight, posZ);
      uvs[index] = new Vector2(u, v);
    }
    for (var i1 = 0; i1 < capRectangleCount; ++i1) {
      var x1 = i1 % radialSegments;
      var y1 = i1 * radialSegmentsReciprocal | 0;
      var a = y1 * radialCount + x1 + offset;
      var b = a + 1;
      var c = a + radialCount;
      var d = c + 1;
      indices[indicesOffset++] = b;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = d;
      indices[indicesOffset++] = a;
      indices[indicesOffset++] = c;
      indices[indicesOffset++] = d;
    }
  };
  return PrimitiveMesh2;
}();
var BufferMesh = /* @__PURE__ */ function(Mesh2) {
  _inherits$2(BufferMesh2, Mesh2);
  function BufferMesh2() {
    return Mesh2.apply(this, arguments);
  }
  var _proto = BufferMesh2.prototype;
  _proto.setVertexElements = function setVertexElements(elements) {
    this._setVertexElements(elements);
  };
  _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, index) {
    if (strideOrFirstIndex === void 0)
      strideOrFirstIndex = 0;
    if (index === void 0)
      index = 0;
    var binding = bufferOrBinding;
    var isBinding = binding.buffer !== void 0;
    isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
    var bindings = this._vertexBufferBindings;
    bindings.length <= index && (bindings.length = index + 1);
    this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);
  };
  _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
    if (firstIndex === void 0)
      firstIndex = 0;
    var bindings = this._vertexBufferBindings;
    var count = vertexBufferBindings.length;
    var needLength = firstIndex + count;
    bindings.length < needLength && (bindings.length = needLength);
    for (var i = 0; i < count; i++) {
      this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
    }
  };
  _proto.setIndexBufferBinding = function setIndexBufferBinding(bufferOrBinding, format) {
    var binding = bufferOrBinding;
    if (binding) {
      var isBinding = binding.buffer !== void 0;
      isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
    }
    this._setIndexBufferBinding(binding);
  };
  _create_class$4(BufferMesh2, [
    {
      key: "instanceCount",
      get: function get3() {
        return this._instanceCount;
      },
      set: function set(value) {
        this._instanceCount = value;
      }
    },
    {
      key: "vertexBufferBindings",
      get: function get3() {
        return this._vertexBufferBindings;
      }
    },
    {
      key: "indexBufferBinding",
      get: function get3() {
        return this._indexBufferBinding;
      }
    },
    {
      key: "vertexElements",
      get: function get3() {
        return this._vertexElements;
      }
    }
  ]);
  return BufferMesh2;
}(Mesh);
var BlendShapeFrame = /* @__PURE__ */ function() {
  function BlendShapeFrame2(weight, deltaPositions, deltaNormals, deltaTangents) {
    if (deltaNormals === void 0)
      deltaNormals = null;
    if (deltaTangents === void 0)
      deltaTangents = null;
    this._dataChangeManager = new UpdateFlagManager();
    this._dirty = 7;
    if (deltaNormals && deltaNormals.length !== deltaPositions.length) {
      throw "deltaNormals length must same with deltaPositions length.";
    }
    if (deltaTangents && deltaTangents.length !== deltaPositions.length) {
      throw "deltaTangents length must same with deltaPositions length.";
    }
    this.weight = weight;
    this._deltaPositions = deltaPositions;
    this._deltaNormals = deltaNormals;
    this._deltaTangents = deltaTangents;
  }
  var _proto = BlendShapeFrame2.prototype;
  _proto._releaseData = function _releaseData() {
    this._deltaPositions = null;
    this._deltaNormals = null;
    this._deltaTangents = null;
  };
  _create_class$4(BlendShapeFrame2, [
    {
      key: "deltaPositions",
      get: function get3() {
        return this._deltaPositions;
      },
      set: function set(value) {
        this._deltaPositions = value;
        this._dirty |= 1;
        this._dataChangeManager.dispatch(this._dirty, this);
      }
    },
    {
      key: "deltaNormals",
      get: function get3() {
        return this._deltaNormals;
      },
      set: function set(value) {
        this._deltaNormals = value;
        this._dirty |= 2;
        this._dataChangeManager.dispatch(this._dirty, this);
      }
    },
    {
      key: "deltaTangents",
      get: function get3() {
        return this._deltaTangents;
      },
      set: function set(value) {
        this._deltaTangents = value;
        this._dirty |= 4;
        this._dataChangeManager.dispatch(this._dirty, this);
      }
    }
  ]);
  return BlendShapeFrame2;
}();
var BlendShapeFrameDirty;
(function(BlendShapeFrameDirty2) {
  BlendShapeFrameDirty2[BlendShapeFrameDirty2["Position"] = 1] = "Position";
  BlendShapeFrameDirty2[BlendShapeFrameDirty2["Normal"] = 2] = "Normal";
  BlendShapeFrameDirty2[BlendShapeFrameDirty2["Tangent"] = 4] = "Tangent";
  BlendShapeFrameDirty2[BlendShapeFrameDirty2["All"] = 7] = "All";
})(BlendShapeFrameDirty || (BlendShapeFrameDirty = {}));
var BlendShape = /* @__PURE__ */ function() {
  function BlendShape2(name2) {
    this._useBlendShapeNormal = true;
    this._useBlendShapeTangent = true;
    this._layoutChangeManager = new UpdateFlagManager();
    this._dataChangeManager = new UpdateFlagManager();
    this._frames = [];
    this.name = name2;
    this._frameDataChangeListener = this._frameDataChangeListener.bind(this);
  }
  var _proto = BlendShape2.prototype;
  _proto.addFrame = function addFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents) {
    if (typeof frameOrWeight === "number") {
      var frame = new BlendShapeFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents);
      this._addFrame(frame);
      return frame;
    } else {
      this._addFrame(frameOrWeight);
    }
  };
  _proto.clearFrames = function clearFrames() {
    var frames = this._frames;
    for (var i = 0, n = frames.length; i < n; i++) {
      frames[i]._dataChangeManager.removeListener(this._frameDataChangeListener);
    }
    frames.length = 0;
    this._updateUseNormalAndTangent(true, true);
    this._dataChangeManager.dispatch();
  };
  _proto._releaseData = function _releaseData() {
    var frames = this._frames;
    for (var i = 0, n = frames.length; i < n; i++) {
      frames[i]._releaseData();
    }
  };
  _proto._addFrame = function _addFrame(frame) {
    var frames = this._frames;
    var frameCount = frames.length;
    if (frameCount > 0 && frame.deltaPositions.length !== frames[frameCount - 1].deltaPositions.length) {
      throw "Frame's deltaPositions length must same with before frame deltaPositions length.";
    }
    this._frames.push(frame);
    this._frameDataChangeListener(BlendShapeFrameDirty.All, frame);
    frame._dataChangeManager.addListener(this._frameDataChangeListener);
  };
  _proto._updateUseNormalAndTangent = function _updateUseNormalAndTangent(useNormal, useTangent) {
    var useBlendShapeNormal = this._useBlendShapeNormal && useNormal;
    var useBlendShapeTangent = this._useBlendShapeTangent && useTangent;
    if (this._useBlendShapeNormal !== useBlendShapeNormal || this._useBlendShapeTangent !== useBlendShapeTangent) {
      this._useBlendShapeNormal = useBlendShapeNormal;
      this._useBlendShapeTangent = useBlendShapeTangent;
      this._layoutChangeManager.dispatch(0, this);
    }
  };
  _proto._frameDataChangeListener = function _frameDataChangeListener(type, frame) {
    this._updateUseNormalAndTangent(!!frame.deltaNormals, !!frame.deltaTangents);
    this._dataChangeManager.dispatch();
  };
  _create_class$4(BlendShape2, [
    {
      key: "frames",
      get: function get3() {
        return this._frames;
      }
    }
  ]);
  return BlendShape2;
}();
var Basic2DBatcher = /* @__PURE__ */ function() {
  function Basic2DBatcher2(engine) {
    this._subMeshPool = new ClassPool(SubMesh);
    this._batchedQueue = [];
    this._meshes = [];
    this._meshCount = 1;
    this._vertexBuffers = [];
    this._indiceBuffers = [];
    this._flushId = 0;
    this._vertexCount = 0;
    this._elementCount = 0;
    this._engine = engine;
    this._initMeshes(engine);
  }
  var _proto = Basic2DBatcher2.prototype;
  _proto.drawElement = function drawElement(element, camera) {
    var data = element.data;
    if (data.multiRenderData) {
      var charsData = data.charsData;
      var pool = camera.engine._renderElementPool;
      for (var i = 0, n = charsData.length; i < n; ++i) {
        var charRenderElement = pool.getFromPool();
        charRenderElement.set(charsData[i], element.shaderPass, element.renderState);
        this._drawSubElement(charRenderElement, camera);
      }
    } else {
      this._drawSubElement(element, camera);
    }
  };
  _proto._initMeshes = function _initMeshes(engine) {
    var MAX_VERTEX_COUNT = Basic2DBatcher2.MAX_VERTEX_COUNT;
    this._vertices = new Float32Array(MAX_VERTEX_COUNT * 9);
    this._indices = new Uint16Array(MAX_VERTEX_COUNT * 3);
    var _this = this, _meshes = _this._meshes, _meshCount = _this._meshCount;
    for (var i = 0; i < _meshCount; i++) {
      _meshes[i] = this._createMesh(engine, i);
    }
  };
  _proto.flush = function flush(camera) {
    var batchedQueue = this._batchedQueue;
    if (batchedQueue.length === 0) {
      return;
    }
    this._updateData(this._engine);
    this.drawBatches(camera);
    if (!Basic2DBatcher2._canUploadSameBuffer) {
      this._flushId++;
    }
    batchedQueue.length = 0;
    this._subMeshPool.resetPool();
    this._vertexCount = 0;
    this._elementCount = 0;
  };
  _proto.clear = function clear() {
    this._flushId = 0;
    this._vertexCount = 0;
    this._elementCount = 0;
    this._batchedQueue.length = 0;
  };
  _proto.destroy = function destroy2() {
    this._batchedQueue = null;
    var _this = this, meshes = _this._meshes, vertexBuffers = _this._vertexBuffers, indiceBuffers = _this._indiceBuffers;
    for (var i = 0, n = meshes.length; i < n; ++i) {
      meshes[i].destroy();
    }
    this._meshes = null;
    for (var i1 = 0, n1 = vertexBuffers.length; i1 < n1; ++i1) {
      vertexBuffers[i1].destroy();
    }
    this._vertexBuffers = null;
    for (var i2 = 0, n2 = indiceBuffers.length; i2 < n2; ++i2) {
      indiceBuffers[i2].destroy();
    }
    this._indiceBuffers = null;
  };
  _proto._drawSubElement = function _drawSubElement(element, camera) {
    var vertexCount = element.data.verticesData.vertexCount;
    if (this._vertexCount + vertexCount > Basic2DBatcher2.MAX_VERTEX_COUNT) {
      this.flush(camera);
    }
    this._vertexCount += vertexCount;
    this._batchedQueue[this._elementCount++] = element;
  };
  _proto._createMesh = function _createMesh(engine, index) {
    var MAX_VERTEX_COUNT = Basic2DBatcher2.MAX_VERTEX_COUNT;
    var mesh = new BufferMesh(engine, "BufferMesh" + index);
    mesh.isGCIgnored = true;
    var vertexElements = [];
    var vertexStride = this.createVertexElements(vertexElements);
    var vertexBuffer = this._vertexBuffers[index] = new Buffer(engine, BufferBindFlag.VertexBuffer, MAX_VERTEX_COUNT * vertexStride, BufferUsage.Dynamic);
    vertexBuffer.isGCIgnored = true;
    var indiceBuffer = this._indiceBuffers[index] = new Buffer(engine, BufferBindFlag.IndexBuffer, MAX_VERTEX_COUNT * 6, BufferUsage.Dynamic);
    indiceBuffer.isGCIgnored = true;
    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
    mesh.setIndexBufferBinding(indiceBuffer, IndexFormat.UInt16);
    mesh.setVertexElements(vertexElements);
    return mesh;
  };
  _proto._updateData = function _updateData(engine) {
    var _this = this, _meshes = _this._meshes, _flushId = _this._flushId;
    if (!Basic2DBatcher2._canUploadSameBuffer && this._meshCount <= _flushId) {
      this._meshCount++;
      _meshes[_flushId] = this._createMesh(engine, _flushId);
    }
    var _this1 = this, batchedQueue = _this1._batchedQueue, vertices = _this1._vertices, indices = _this1._indices;
    var mesh = _meshes[_flushId];
    mesh.clearSubMesh();
    var vertexIndex = 0;
    var indiceIndex = 0;
    var vertexStartIndex = 0;
    var vertexCount = 0;
    var curIndiceStartIndex = 0;
    var curMeshIndex = 0;
    var preElement = null;
    for (var i = 0, len = batchedQueue.length; i < len; i++) {
      var curElement = batchedQueue[i];
      var curData = curElement.data;
      vertexIndex = this.updateVertices(curData, vertices, vertexIndex);
      var triangles = curData.verticesData.triangles;
      var triangleNum = triangles.length;
      for (var j2 = 0; j2 < triangleNum; j2++) {
        indices[indiceIndex++] = triangles[j2] + curIndiceStartIndex;
      }
      curIndiceStartIndex += curData.verticesData.vertexCount;
      if (preElement === null) {
        vertexCount += triangleNum;
      } else {
        if (this.canBatch(preElement, curElement)) {
          vertexCount += triangleNum;
        } else {
          mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
          vertexStartIndex += vertexCount;
          vertexCount = triangleNum;
          batchedQueue[curMeshIndex++] = preElement;
        }
      }
      preElement = curElement;
    }
    mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
    batchedQueue[curMeshIndex] = preElement;
    this._vertexBuffers[_flushId].setData(vertices, 0, 0, vertexIndex);
    this._indiceBuffers[_flushId].setData(indices, 0, 0, indiceIndex);
  };
  _proto._getSubMeshFromPool = function _getSubMeshFromPool(start, count) {
    var subMesh = this._subMeshPool.getFromPool();
    subMesh.start = start;
    subMesh.count = count;
    subMesh.topology = MeshTopology.Triangles;
    return subMesh;
  };
  return Basic2DBatcher2;
}();
(function() {
  Basic2DBatcher._disableBatchTag = ShaderTagKey.getByName("spriteDisableBatching");
})();
(function() {
  Basic2DBatcher.MAX_VERTEX_COUNT = 4096;
})();
(function() {
  Basic2DBatcher._canUploadSameBuffer = true;
})();
var SpriteMaskBatcher = /* @__PURE__ */ function(Basic2DBatcher2) {
  _inherits$2(SpriteMaskBatcher2, Basic2DBatcher2);
  function SpriteMaskBatcher2() {
    return Basic2DBatcher2.apply(this, arguments);
  }
  var _proto = SpriteMaskBatcher2.prototype;
  _proto.createVertexElements = function createVertexElements(vertexElements) {
    vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
    vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
    return 20;
  };
  _proto.canBatch = function canBatch(preElement, curElement) {
    var preSpriteData = preElement.data;
    var curSpriteData = curElement.data;
    if (preSpriteData.isAdd !== curSpriteData.isAdd) {
      return false;
    }
    var preShaderData = preSpriteData.component.shaderData;
    var curShaderData = curSpriteData.component.shaderData;
    var textureProperty = SpriteMask._textureProperty;
    var alphaCutoffProperty = SpriteMask._alphaCutoffProperty;
    return preShaderData.getTexture(textureProperty) === curShaderData.getTexture(textureProperty) && preShaderData.getTexture(alphaCutoffProperty) === curShaderData.getTexture(alphaCutoffProperty);
  };
  _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
    var _element_verticesData = element.verticesData, positions = _element_verticesData.positions, uvs = _element_verticesData.uvs, vertexCount = _element_verticesData.vertexCount;
    for (var i = 0; i < vertexCount; i++) {
      var curPos = positions[i];
      var curUV = uvs[i];
      vertices[vertexIndex++] = curPos.x;
      vertices[vertexIndex++] = curPos.y;
      vertices[vertexIndex++] = curPos.z;
      vertices[vertexIndex++] = curUV.x;
      vertices[vertexIndex++] = curUV.y;
    }
    return vertexIndex;
  };
  _proto.drawBatches = function drawBatches(camera) {
    var _this = this, engine = _this._engine, batchedQueue = _this._batchedQueue;
    var mesh = this._meshes[this._flushId];
    var subMeshes = mesh.subMeshes;
    var sceneData = camera.scene.shaderData;
    var cameraData = camera.shaderData;
    for (var i = 0, len = subMeshes.length; i < len; i++) {
      var subMesh = subMeshes[i];
      var spriteMaskElement = batchedQueue[i];
      var spritMaskData = spriteMaskElement.data;
      if (!subMesh || !spriteMaskElement) {
        return;
      }
      var renderer = spritMaskData.component;
      var material = spritMaskData.material;
      var compileMacros = Shader._compileMacros;
      ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);
      var stencilState = material.renderState.stencilState;
      var op = spritMaskData.isAdd ? StencilOperation.IncrementSaturate : StencilOperation.DecrementSaturate;
      stencilState.passOperationFront = op;
      stencilState.passOperationBack = op;
      var program = material.shader.subShaders[0].passes[0]._getShaderProgram(engine, compileMacros);
      if (!program.isValid) {
        return;
      }
      program.bind();
      program.groupingOtherUniformBlock();
      program.uploadAll(program.sceneUniformBlock, sceneData);
      program.uploadAll(program.cameraUniformBlock, cameraData);
      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
      program.uploadAll(program.materialUniformBlock, material.shaderData);
      material.renderState._apply(engine, false);
      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
    }
  };
  return SpriteMaskBatcher2;
}(Basic2DBatcher);
var SpriteMaskManager = /* @__PURE__ */ function() {
  function SpriteMaskManager2(engine) {
    this._preMaskLayer = 0;
    this._batcher = new SpriteMaskBatcher(engine);
  }
  var _proto = SpriteMaskManager2.prototype;
  _proto.clear = function clear() {
    this._preMaskLayer = 0;
    this._batcher.clear();
  };
  _proto.preRender = function preRender(camera, renderer) {
    if (renderer.maskInteraction === SpriteMaskInteraction.None) {
      return;
    }
    this._batcher.clear();
    this._processMasksDiff(camera, renderer);
    this._batcher.flush(camera);
  };
  _proto.postRender = function postRender(renderer) {
    if (renderer.maskInteraction === SpriteMaskInteraction.None) {
      return;
    }
    this._preMaskLayer = renderer.maskLayer;
  };
  _proto.destroy = function destroy2() {
    this._batcher.destroy();
    this._batcher = null;
  };
  _proto._processMasksDiff = function _processMasksDiff(camera, renderer) {
    var preMaskLayer = this._preMaskLayer;
    var curMaskLayer = renderer.maskLayer;
    if (preMaskLayer !== curMaskLayer) {
      var allMasks = camera._renderPipeline._allSpriteMasks;
      var commonLayer = preMaskLayer & curMaskLayer;
      var addLayer = curMaskLayer & ~preMaskLayer;
      var reduceLayer = preMaskLayer & ~curMaskLayer;
      var allMaskElements = allMasks._elements;
      for (var i = 0, n = allMasks.length; i < n; i++) {
        var mask = allMaskElements[i];
        var influenceLayers = mask.influenceLayers;
        if (influenceLayers & commonLayer) {
          continue;
        }
        if (influenceLayers & addLayer) {
          var maskRenderElement = mask._maskElement;
          maskRenderElement.data.isAdd = true;
          this._batcher.drawElement(maskRenderElement, camera);
          continue;
        }
        if (influenceLayers & reduceLayer) {
          var maskRenderElement1 = mask._maskElement;
          maskRenderElement1.data.isAdd = false;
          this._batcher.drawElement(maskRenderElement1, camera);
        }
      }
    }
  };
  return SpriteMaskManager2;
}();
var SpriteMaskRenderData = /* @__PURE__ */ function(RenderData3) {
  _inherits$2(SpriteMaskRenderData2, RenderData3);
  function SpriteMaskRenderData2() {
    var _this;
    _this = RenderData3.call(this) || this;
    _this.isAdd = true;
    _this.multiRenderData = false;
    return _this;
  }
  var _proto = SpriteMaskRenderData2.prototype;
  _proto.set = function set(component, material, verticesData) {
    this.component = component;
    this.material = material;
    this.verticesData = verticesData;
  };
  _proto.dispose = function dispose() {
    this.component = this.material = this.verticesData = null;
  };
  return SpriteMaskRenderData2;
}(RenderData);
var SpriteRenderData = /* @__PURE__ */ function(RenderData3) {
  _inherits$2(SpriteRenderData2, RenderData3);
  function SpriteRenderData2() {
    var _this;
    _this = RenderData3.call(this) || this;
    _this.multiRenderData = false;
    return _this;
  }
  var _proto = SpriteRenderData2.prototype;
  _proto.set = function set(component, material, verticesData, texture, dataIndex) {
    if (dataIndex === void 0)
      dataIndex = 0;
    this.component = component;
    this.material = material;
    this.verticesData = verticesData;
    this.texture = texture;
    this.dataIndex = dataIndex;
  };
  _proto.dispose = function dispose() {
    this.component = this.material = this.verticesData = this.texture = null;
  };
  return SpriteRenderData2;
}(RenderData);
var TextRenderData = /* @__PURE__ */ function(RenderData3) {
  _inherits$2(TextRenderData2, RenderData3);
  function TextRenderData2() {
    var _this;
    _this = RenderData3.call(this) || this;
    _this.charsData = [];
    _this.multiRenderData = true;
    return _this;
  }
  var _proto = TextRenderData2.prototype;
  _proto.dispose = function dispose() {
    this.component = this.material = null;
    this.charsData.length = 0;
  };
  return TextRenderData2;
}(RenderData);
var BackgroundMode;
(function(BackgroundMode2) {
  BackgroundMode2[BackgroundMode2["SolidColor"] = 0] = "SolidColor";
  BackgroundMode2[BackgroundMode2["Sky"] = 1] = "Sky";
  BackgroundMode2[BackgroundMode2["Texture"] = 2] = "Texture";
})(BackgroundMode || (BackgroundMode = {}));
var BackgroundTextureFillMode;
(function(BackgroundTextureFillMode2) {
  BackgroundTextureFillMode2[BackgroundTextureFillMode2["AspectFitWidth"] = 0] = "AspectFitWidth";
  BackgroundTextureFillMode2[BackgroundTextureFillMode2["AspectFitHeight"] = 1] = "AspectFitHeight";
  BackgroundTextureFillMode2[BackgroundTextureFillMode2["Fill"] = 2] = "Fill";
})(BackgroundTextureFillMode || (BackgroundTextureFillMode = {}));
var Sky = /* @__PURE__ */ function() {
  function Sky2() {
  }
  var _proto = Sky2.prototype;
  _proto.destroy = function destroy2() {
    this.mesh = null;
    this.material = null;
  };
  _proto._render = function _render(context) {
    var _this = this, material = _this.material, mesh = _this.mesh;
    if (!material) {
      Logger.warn("The material of sky is not defined.");
      return;
    }
    if (!mesh) {
      Logger.warn("The mesh of sky is not defined.");
      return;
    }
    var _context_camera = context.camera, engine = _context_camera.engine, aspectRatio = _context_camera.aspectRatio, fieldOfView = _context_camera.fieldOfView, viewMatrix = _context_camera.viewMatrix, cameraShaderData = _context_camera.shaderData;
    var sceneData = context.camera.scene.shaderData;
    var viewProjMatrix = Sky2._viewProjMatrix, projectionMatrix = Sky2._projectionMatrix;
    var rhi = engine._hardwareRenderer;
    var materialShaderData = material.shaderData, shader = material.shader, renderState = material.renderState;
    viewProjMatrix.copyFrom(viewMatrix);
    var e = viewProjMatrix.elements;
    e[12] = e[13] = e[14] = 0;
    var f = 1 / Math.tan(MathUtil$1.degreeToRadian(fieldOfView) / 2);
    projectionMatrix.elements[0] = f / aspectRatio;
    projectionMatrix.elements[5] = f;
    Matrix.multiply(projectionMatrix, viewProjMatrix, viewProjMatrix);
    var originViewProjMatrix = cameraShaderData.getMatrix(RenderContext.vpMatrixProperty);
    cameraShaderData.setMatrix(RenderContext.vpMatrixProperty, viewProjMatrix);
    var compileMacros = Shader._compileMacros;
    ShaderMacroCollection.unionCollection(context.camera._globalShaderMacro, materialShaderData._macroCollection, compileMacros);
    var program = shader.subShaders[0].passes[0]._getShaderProgram(engine, compileMacros);
    program.bind();
    program.groupingOtherUniformBlock();
    program.uploadAll(program.sceneUniformBlock, sceneData);
    program.uploadAll(program.cameraUniformBlock, cameraShaderData);
    program.uploadAll(program.materialUniformBlock, materialShaderData);
    program.uploadUnGroupTextures();
    renderState._apply(engine, false);
    rhi.drawPrimitive(mesh, mesh.subMesh, program);
    cameraShaderData.setMatrix(RenderContext.vpMatrixProperty, originViewProjMatrix);
  };
  _create_class$4(Sky2, [
    {
      key: "material",
      get: function get3() {
        return this._material;
      },
      set: function set(value) {
        if (this._material !== value) {
          var _this__material;
          value == null ? void 0 : value._addReferCount(1);
          (_this__material = this._material) == null ? void 0 : _this__material._addReferCount(-1);
          this._material = value;
        }
      }
    },
    {
      key: "mesh",
      get: function get3() {
        return this._mesh;
      },
      set: function set(value) {
        if (this._mesh !== value) {
          var _this__mesh;
          value == null ? void 0 : value._addReferCount(1);
          (_this__mesh = this._mesh) == null ? void 0 : _this__mesh._addReferCount(-1);
          this._mesh = value;
        }
      }
    }
  ]);
  return Sky2;
}();
(function() {
  Sky._epsilon = 1e-6;
})();
(function() {
  Sky._viewProjMatrix = new Matrix();
})();
(function() {
  Sky._projectionMatrix = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, Sky._epsilon - 1, -1, 0, 0, 0, 0);
})();
var Background = /* @__PURE__ */ function() {
  function Background2(_engine) {
    this._engine = _engine;
    this.mode = BackgroundMode.SolidColor;
    this.solidColor = new Color$1(0.25, 0.25, 0.25, 1);
    this.sky = new Sky();
    this._textureFillMode = BackgroundTextureFillMode.AspectFitHeight;
    this._texture = null;
    this._initMesh(_engine);
  }
  var _proto = Background2.prototype;
  _proto.destroy = function destroy2() {
    this._mesh._addReferCount(-1);
    this._mesh = null;
    this.texture = null;
    this.solidColor = null;
    this.sky.destroy();
  };
  _proto._initMesh = function _initMesh(engine) {
    this._mesh = this._createPlane(engine);
    this._mesh._addReferCount(1);
  };
  _proto._resizeBackgroundTexture = function _resizeBackgroundTexture() {
    if (!this._texture) {
      return;
    }
    var canvas = this._engine.canvas;
    var width = canvas.width, height = canvas.height;
    var _this = this, _backgroundTextureMesh = _this._mesh;
    var positions = _backgroundTextureMesh.getPositions();
    switch (this._textureFillMode) {
      case BackgroundTextureFillMode.Fill:
        positions[0].set(-1, -1, 1);
        positions[1].set(1, -1, 1);
        positions[2].set(-1, 1, 1);
        positions[3].set(1, 1, 1);
        break;
      case BackgroundTextureFillMode.AspectFitWidth:
        var fitWidthScale = this._texture.height * width / this.texture.width / height;
        positions[0].set(-1, -fitWidthScale, 1);
        positions[1].set(1, -fitWidthScale, 1);
        positions[2].set(-1, fitWidthScale, 1);
        positions[3].set(1, fitWidthScale, 1);
        break;
      case BackgroundTextureFillMode.AspectFitHeight:
        var fitHeightScale = this._texture.width * height / this.texture.height / width;
        positions[0].set(-fitHeightScale, -1, 1);
        positions[1].set(fitHeightScale, -1, 1);
        positions[2].set(-fitHeightScale, 1, 1);
        positions[3].set(fitHeightScale, 1, 1);
        break;
    }
    _backgroundTextureMesh.setPositions(positions);
    _backgroundTextureMesh.uploadData(false);
  };
  _proto._createPlane = function _createPlane(engine) {
    var mesh = new ModelMesh(engine);
    mesh.isGCIgnored = true;
    var indices = new Uint8Array([
      1,
      2,
      0,
      1,
      3,
      2
    ]);
    var positions = new Array(4);
    var uvs = new Array(4);
    for (var i = 0; i < 4; ++i) {
      positions[i] = new Vector3();
      uvs[i] = new Vector2(i % 2, 1 - (i * 0.5 | 0));
    }
    mesh.setPositions(positions);
    mesh.setUVs(uvs);
    mesh.setIndices(indices);
    mesh.uploadData(false);
    mesh.addSubMesh(0, indices.length);
    return mesh;
  };
  _create_class$4(Background2, [
    {
      key: "texture",
      get: function get3() {
        return this._texture;
      },
      set: function set(value) {
        if (this._texture !== value) {
          var _this__texture;
          value == null ? void 0 : value._addReferCount(1);
          (_this__texture = this._texture) == null ? void 0 : _this__texture._addReferCount(-1);
          this._texture = value;
          this._engine._backgroundTextureMaterial.shaderData.setTexture("material_BaseTexture", value);
        }
      }
    },
    {
      key: "textureFillMode",
      get: function get3() {
        return this._textureFillMode;
      },
      set: function set(value) {
        if (value !== this._textureFillMode) {
          this._textureFillMode = value;
          this._resizeBackgroundTexture();
        }
      }
    }
  ]);
  return Background2;
}();
var FogMode;
(function(FogMode2) {
  FogMode2[FogMode2["None"] = 0] = "None";
  FogMode2[FogMode2["Linear"] = 1] = "Linear";
  FogMode2[FogMode2["Exponential"] = 2] = "Exponential";
  FogMode2[FogMode2["ExponentialSquared"] = 3] = "ExponentialSquared";
})(FogMode || (FogMode = {}));
var DiffuseMode;
(function(DiffuseMode2) {
  DiffuseMode2[DiffuseMode2["SolidColor"] = 0] = "SolidColor";
  DiffuseMode2[DiffuseMode2["SphericalHarmonics"] = 1] = "SphericalHarmonics";
})(DiffuseMode || (DiffuseMode = {}));
var AmbientLight = /* @__PURE__ */ function(ReferResource2) {
  _inherits$2(AmbientLight2, ReferResource2);
  function AmbientLight2(engine) {
    var _this;
    _this = ReferResource2.call(this, engine) || this;
    _this._diffuseSolidColor = new Color$1(0.212, 0.227, 0.259);
    _this._diffuseIntensity = 1;
    _this._specularIntensity = 1;
    _this._diffuseMode = DiffuseMode.SolidColor;
    _this._shArray = new Float32Array(27);
    _this._scenes = [];
    _this._specularTextureDecodeRGBM = false;
    return _this;
  }
  var _proto = AmbientLight2.prototype;
  _proto._addToScene = function _addToScene(scene) {
    this._addReferCount(1);
    this._scenes.push(scene);
    var shaderData = scene.shaderData;
    shaderData.setColor(AmbientLight2._diffuseColorProperty, this._diffuseSolidColor);
    shaderData.setFloat(AmbientLight2._diffuseIntensityProperty, this._diffuseIntensity);
    shaderData.setFloat(AmbientLight2._specularIntensityProperty, this._specularIntensity);
    shaderData.setFloatArray(AmbientLight2._diffuseSHProperty, this._shArray);
    this._setDiffuseMode(shaderData);
    this._setSpecularTextureDecodeRGBM(shaderData);
    this._setSpecularTexture(shaderData);
  };
  _proto._removeFromScene = function _removeFromScene(scene) {
    this._addReferCount(-1);
    var scenes = this._scenes;
    var index = scenes.indexOf(scene);
    scenes.splice(index, 1);
    var shaderData = scene.shaderData;
    shaderData.setTexture(AmbientLight2._specularTextureProperty, null);
    shaderData.disableMacro(AmbientLight2._specularMacro);
  };
  _proto._setDiffuseMode = function _setDiffuseMode(sceneShaderData) {
    if (this._diffuseMode === DiffuseMode.SphericalHarmonics) {
      sceneShaderData.enableMacro(AmbientLight2._shMacro);
    } else {
      sceneShaderData.disableMacro(AmbientLight2._shMacro);
    }
  };
  _proto._setSpecularTexture = function _setSpecularTexture(sceneShaderData) {
    if (this._specularTexture) {
      sceneShaderData.setTexture(AmbientLight2._specularTextureProperty, this._specularTexture);
      sceneShaderData.setFloat(AmbientLight2._mipLevelProperty, this._specularTexture.mipmapCount - 1);
      sceneShaderData.enableMacro(AmbientLight2._specularMacro);
    } else {
      sceneShaderData.disableMacro(AmbientLight2._specularMacro);
    }
  };
  _proto._setSpecularTextureDecodeRGBM = function _setSpecularTextureDecodeRGBM(sceneShaderData) {
    if (this._specularTextureDecodeRGBM) {
      sceneShaderData.enableMacro(AmbientLight2._decodeRGBMMacro);
    } else {
      sceneShaderData.disableMacro(AmbientLight2._decodeRGBMMacro);
    }
  };
  _proto._preComputeSH = function _preComputeSH(sh, out) {
    var src = sh.coefficients;
    out[0] = src[0] * 0.886227;
    out[1] = src[1] * 0.886227;
    out[2] = src[2] * 0.886227;
    out[3] = src[3] * -1.023327;
    out[4] = src[4] * -1.023327;
    out[5] = src[5] * -1.023327;
    out[6] = src[6] * 1.023327;
    out[7] = src[7] * 1.023327;
    out[8] = src[8] * 1.023327;
    out[9] = src[9] * -1.023327;
    out[10] = src[10] * -1.023327;
    out[11] = src[11] * -1.023327;
    out[12] = src[12] * 0.858086;
    out[13] = src[13] * 0.858086;
    out[14] = src[14] * 0.858086;
    out[15] = src[15] * -0.858086;
    out[16] = src[16] * -0.858086;
    out[17] = src[17] * -0.858086;
    out[18] = src[18] * 0.247708;
    out[19] = src[19] * 0.247708;
    out[20] = src[20] * 0.247708;
    out[21] = src[21] * -0.858086;
    out[22] = src[22] * -0.858086;
    out[23] = src[23] * -0.858086;
    out[24] = src[24] * 0.429042;
    out[25] = src[25] * 0.429042;
    out[26] = src[26] * 0.429042;
  };
  _create_class$4(AmbientLight2, [
    {
      key: "specularTextureDecodeRGBM",
      get: function get3() {
        return this._specularTextureDecodeRGBM;
      },
      set: function set(value) {
        this._specularTextureDecodeRGBM = value;
        var scenes = this._scenes;
        for (var i = 0, n = scenes.length; i < n; i++) {
          this._setSpecularTextureDecodeRGBM(scenes[i].shaderData);
        }
      }
    },
    {
      key: "diffuseMode",
      get: function get3() {
        return this._diffuseMode;
      },
      set: function set(value) {
        this._diffuseMode = value;
        var scenes = this._scenes;
        for (var i = 0, n = scenes.length; i < n; i++) {
          this._setDiffuseMode(scenes[i].shaderData);
        }
      }
    },
    {
      key: "diffuseSolidColor",
      get: function get3() {
        return this._diffuseSolidColor;
      },
      set: function set(value) {
        if (value !== this._diffuseSolidColor) {
          this._diffuseSolidColor.copyFrom(value);
        }
      }
    },
    {
      key: "diffuseSphericalHarmonics",
      get: function get3() {
        return this._diffuseSphericalHarmonics;
      },
      set: function set(value) {
        this._diffuseSphericalHarmonics = value;
        if (value) {
          this._preComputeSH(value, this._shArray);
          var scenes = this._scenes;
          for (var i = 0, n = scenes.length; i < n; i++) {
            scenes[i].shaderData.setFloatArray(AmbientLight2._diffuseSHProperty, this._shArray);
          }
        }
      }
    },
    {
      key: "diffuseIntensity",
      get: function get3() {
        return this._diffuseIntensity;
      },
      set: function set(value) {
        this._diffuseIntensity = value;
        var scenes = this._scenes;
        for (var i = 0, n = scenes.length; i < n; i++) {
          scenes[i].shaderData.setFloat(AmbientLight2._diffuseIntensityProperty, value);
        }
      }
    },
    {
      key: "specularTexture",
      get: function get3() {
        return this._specularTexture;
      },
      set: function set(value) {
        this._specularTexture = value;
        var scenes = this._scenes;
        for (var i = 0, n = scenes.length; i < n; i++) {
          this._setSpecularTexture(scenes[i].shaderData);
        }
      }
    },
    {
      key: "specularIntensity",
      get: function get3() {
        return this._specularIntensity;
      },
      set: function set(value) {
        this._specularIntensity = value;
        for (var i = 0, n = this._scenes.length; i < n; i++) {
          this._scenes[i].shaderData.setFloat(AmbientLight2._specularIntensityProperty, value);
        }
      }
    }
  ]);
  return AmbientLight2;
}(ReferResource);
(function() {
  AmbientLight._shMacro = ShaderMacro.getByName("SCENE_USE_SH");
})();
(function() {
  AmbientLight._specularMacro = ShaderMacro.getByName("SCENE_USE_SPECULAR_ENV");
})();
(function() {
  AmbientLight._decodeRGBMMacro = ShaderMacro.getByName("SCENE_IS_DECODE_ENV_RGBM");
})();
(function() {
  AmbientLight._diffuseColorProperty = ShaderProperty.getByName("scene_EnvMapLight.diffuse");
})();
(function() {
  AmbientLight._diffuseSHProperty = ShaderProperty.getByName("scene_EnvSH");
})();
(function() {
  AmbientLight._diffuseIntensityProperty = ShaderProperty.getByName("scene_EnvMapLight.diffuseIntensity");
})();
(function() {
  AmbientLight._specularTextureProperty = ShaderProperty.getByName("scene_EnvSpecularSampler");
})();
(function() {
  AmbientLight._specularIntensityProperty = ShaderProperty.getByName("scene_EnvMapLight.specularIntensity");
})();
(function() {
  AmbientLight._mipLevelProperty = ShaderProperty.getByName("scene_EnvMapLight.mipMapLevel");
})();
var ShadowCascadesMode;
(function(ShadowCascadesMode2) {
  ShadowCascadesMode2[ShadowCascadesMode2["NoCascades"] = 1] = "NoCascades";
  ShadowCascadesMode2[ShadowCascadesMode2["TwoCascades"] = 2] = "TwoCascades";
  ShadowCascadesMode2[ShadowCascadesMode2["FourCascades"] = 4] = "FourCascades";
})(ShadowCascadesMode || (ShadowCascadesMode = {}));
var ShadowResolution;
(function(ShadowResolution2) {
  ShadowResolution2[ShadowResolution2["Low"] = 0] = "Low";
  ShadowResolution2[ShadowResolution2["Medium"] = 1] = "Medium";
  ShadowResolution2[ShadowResolution2["High"] = 2] = "High";
  ShadowResolution2[ShadowResolution2["VeryHigh"] = 3] = "VeryHigh";
})(ShadowResolution || (ShadowResolution = {}));
var ShadowType;
(function(ShadowType2) {
  ShadowType2[ShadowType2["None"] = 0] = "None";
  ShadowType2[ShadowType2["Hard"] = 1] = "Hard";
  ShadowType2[ShadowType2["SoftLow"] = 2] = "SoftLow";
  ShadowType2[ShadowType2["SoftHigh"] = 3] = "SoftHigh";
})(ShadowType || (ShadowType = {}));
var Scene$1 = /* @__PURE__ */ function(EngineObject2) {
  _inherits$2(Scene2, EngineObject2);
  function Scene2(engine, name2) {
    var _this;
    _this = EngineObject2.call(this, engine) || this;
    _this.castShadows = true;
    _this.shadowResolution = ShadowResolution.Medium;
    _this.shadowTwoCascadeSplits = 1 / 3;
    _this.shadowFourCascadeSplits = new Vector3(1 / 15, 3 / 15, 7 / 15);
    _this.shadowDistance = 50;
    _this._activeCameras = [];
    _this._isActiveInEngine = false;
    _this._globalShaderMacro = new ShaderMacroCollection();
    _this._rootEntities = [];
    _this._background = new Background(_this._engine);
    _this._shaderData = new ShaderData(ShaderDataGroup.Scene);
    _this._shadowCascades = ShadowCascadesMode.NoCascades;
    _this._fogMode = FogMode.None;
    _this._fogColor = new Color$1(0.5, 0.5, 0.5, 1);
    _this._fogStart = 0;
    _this._fogEnd = 300;
    _this._fogDensity = 0.01;
    _this._fogParams = new Vector4();
    _this.name = name2 || "";
    var shaderData = _this.shaderData;
    shaderData._addReferCount(1);
    _this.ambientLight = new AmbientLight(engine);
    engine.sceneManager._allScenes.push(_assert_this_initialized(_this));
    shaderData.enableMacro("SCENE_FOG_MODE", _this._fogMode.toString());
    shaderData.enableMacro("SCENE_SHADOW_CASCADED_COUNT", _this.shadowCascades.toString());
    shaderData.setColor(Scene2._fogColorProperty, _this._fogColor);
    shaderData.setVector4(Scene2._fogParamsProperty, _this._fogParams);
    _this._computeLinearFogParams(_this._fogStart, _this._fogEnd);
    _this._computeExponentialFogParams(_this._fogDensity);
    return _this;
  }
  var _proto = Scene2.prototype;
  _proto.createRootEntity = function createRootEntity(name2) {
    var entity = new Entity(this._engine, name2);
    this.addRootEntity(entity);
    return entity;
  };
  _proto.addRootEntity = function addRootEntity(indexOrChild, entity) {
    var index;
    if (typeof indexOrChild === "number") {
      index = indexOrChild;
    } else {
      index = void 0;
      entity = indexOrChild;
    }
    var isRoot = entity._isRoot;
    if (!isRoot) {
      entity._isRoot = true;
      entity._removeFromParent();
    }
    var oldScene = entity._scene;
    if (oldScene !== this) {
      if (oldScene && isRoot) {
        oldScene._removeFromEntityList(entity);
      }
      this._addToRootEntityList(index, entity);
      Entity._traverseSetOwnerScene(entity, this);
    } else if (!isRoot) {
      this._addToRootEntityList(index, entity);
    }
    if (this._isActiveInEngine) {
      !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
    } else {
      entity._isActiveInHierarchy && entity._processInActive();
    }
  };
  _proto.removeRootEntity = function removeRootEntity(entity) {
    if (entity._isRoot && entity._scene == this) {
      this._removeFromEntityList(entity);
      entity._isRoot = false;
      this._isActiveInEngine && entity._isActiveInHierarchy && entity._processInActive();
      Entity._traverseSetOwnerScene(entity, null);
    }
  };
  _proto.getRootEntity = function getRootEntity(index) {
    if (index === void 0)
      index = 0;
    return this._rootEntities[index];
  };
  _proto.findEntityByName = function findEntityByName(name2) {
    var rootEntities = this._rootEntities;
    for (var i = 0, n = rootEntities.length; i < n; i++) {
      var entity = rootEntities[i].findByName(name2);
      if (entity) {
        return entity;
      }
    }
    return null;
  };
  _proto.findEntityByPath = function findEntityByPath(path) {
    var splits = path.split("/").filter(Boolean);
    for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
      var findEntity = this.getRootEntity(i);
      if (findEntity.name != splits[0])
        continue;
      for (var j2 = 1, m = splits.length; j2 < m; ++j2) {
        findEntity = Entity._findChildByName(findEntity, splits[j2]);
        if (!findEntity)
          break;
      }
      return findEntity;
    }
    return null;
  };
  _proto.destroy = function destroy2() {
    if (this._destroyed) {
      return;
    }
    EngineObject2.prototype.destroy.call(this);
    this._destroy();
    var allScenes = this.engine.sceneManager._allScenes;
    allScenes.splice(allScenes.indexOf(this), 1);
  };
  _proto._attachRenderCamera = function _attachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);
    if (index === -1) {
      this._activeCameras.push(camera);
    } else {
      Logger.warn("Camera already attached.");
    }
  };
  _proto._detachRenderCamera = function _detachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);
    if (index !== -1) {
      this._activeCameras.splice(index, 1);
    }
  };
  _proto._processActive = function _processActive(active) {
    this._isActiveInEngine = active;
    var rootEntities = this._rootEntities;
    for (var i = rootEntities.length - 1; i >= 0; i--) {
      var entity = rootEntities[i];
      if (entity._isActive) {
        active ? entity._processActive() : entity._processInActive();
      }
    }
  };
  _proto._updateShaderData = function _updateShaderData() {
    var shaderData = this.shaderData;
    var engine = this._engine;
    var lightManager = engine._lightManager;
    engine.time._updateSceneShaderData(shaderData);
    lightManager._updateShaderData(this.shaderData);
    lightManager._updateSunLightIndex();
    if (lightManager._directLights.length > 0) {
      var sunlight = lightManager._directLights.get(0);
      shaderData.setColor(Scene2._sunlightColorProperty, sunlight._getLightIntensityColor());
      shaderData.setVector3(Scene2._sunlightDirectionProperty, sunlight.direction);
      this._sunLight = sunlight;
    } else {
      this._sunLight = null;
    }
    if (this.castShadows && this._sunLight && this._sunLight.shadowType !== ShadowType.None) {
      shaderData.enableMacro("SCENE_SHADOW_TYPE", this._sunLight.shadowType.toString());
    } else {
      shaderData.disableMacro("SCENE_SHADOW_TYPE");
    }
    ShaderMacroCollection.unionCollection(this.engine._macroCollection, shaderData._macroCollection, this._globalShaderMacro);
  };
  _proto._removeFromEntityList = function _removeFromEntityList(entity) {
    var rootEntities = this._rootEntities;
    var index = entity._siblingIndex;
    rootEntities.splice(index, 1);
    for (var n = rootEntities.length; index < n; index++) {
      rootEntities[index]._siblingIndex--;
    }
    entity._siblingIndex = -1;
  };
  _proto._destroy = function _destroy() {
    this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
    while (this.rootEntitiesCount > 0) {
      this._rootEntities[0].destroy();
    }
    this._activeCameras.length = 0;
    this.background.destroy();
    this._ambientLight && this._ambientLight._removeFromScene(this);
    this.shaderData._addReferCount(-1);
  };
  _proto._addToRootEntityList = function _addToRootEntityList(index, rootEntity) {
    var rootEntities = this._rootEntities;
    var rootEntityCount = rootEntities.length;
    if (index === void 0) {
      rootEntity._siblingIndex = rootEntityCount;
      rootEntities.push(rootEntity);
    } else {
      if (index < 0 || index > rootEntityCount) {
        throw "The index " + index + " is out of child list bounds " + rootEntityCount;
      }
      rootEntity._siblingIndex = index;
      rootEntities.splice(index, 0, rootEntity);
      for (var i = index + 1, n = rootEntityCount + 1; i < n; i++) {
        rootEntities[i]._siblingIndex++;
      }
    }
  };
  _proto._computeLinearFogParams = function _computeLinearFogParams(fogStart, fogEnd) {
    var fogRange = fogEnd - fogStart;
    var fogParams = this._fogParams;
    fogParams.x = -1 / fogRange;
    fogParams.y = fogEnd / fogRange;
  };
  _proto._computeExponentialFogParams = function _computeExponentialFogParams(density) {
    this._fogParams.z = density / Math.LN2;
    this._fogParams.w = density / Math.sqrt(Math.LN2);
  };
  _create_class$4(Scene2, [
    {
      key: "shaderData",
      get: function get3() {
        return this._shaderData;
      }
    },
    {
      key: "background",
      get: function get3() {
        return this._background;
      }
    },
    {
      key: "shadowCascades",
      get: function get3() {
        return this._shadowCascades;
      },
      set: function set(value) {
        if (this._shadowCascades !== value) {
          this.shaderData.enableMacro("SCENE_SHADOW_CASCADED_COUNT", value.toString());
          this._shadowCascades = value;
        }
      }
    },
    {
      key: "ambientLight",
      get: function get3() {
        return this._ambientLight;
      },
      set: function set(value) {
        if (!value) {
          Logger.warn("The scene must have one ambient light");
          return;
        }
        var lastAmbientLight = this._ambientLight;
        if (lastAmbientLight !== value) {
          lastAmbientLight && lastAmbientLight._removeFromScene(this);
          value._addToScene(this);
          this._ambientLight = value;
        }
      }
    },
    {
      key: "fogMode",
      get: function get3() {
        return this._fogMode;
      },
      set: function set(value) {
        if (this._fogMode !== value) {
          this.shaderData.enableMacro("SCENE_FOG_MODE", value.toString());
          this._fogMode = value;
        }
      }
    },
    {
      key: "fogColor",
      get: function get3() {
        return this._fogColor;
      },
      set: function set(value) {
        if (this._fogColor !== value) {
          this._fogColor.copyFrom(value);
        }
      }
    },
    {
      key: "fogStart",
      get: function get3() {
        return this._fogStart;
      },
      set: function set(value) {
        if (this._fogStart !== value) {
          this._computeLinearFogParams(value, this._fogEnd);
          this._fogStart = value;
        }
      }
    },
    {
      key: "fogEnd",
      get: function get3() {
        return this._fogEnd;
      },
      set: function set(value) {
        if (this._fogEnd !== value) {
          this._computeLinearFogParams(this._fogStart, value);
          this._fogEnd = value;
        }
      }
    },
    {
      key: "fogDensity",
      get: function get3() {
        return this._fogDensity;
      },
      set: function set(value) {
        if (this._fogDensity !== value) {
          this._computeExponentialFogParams(value);
          this._fogDensity = value;
        }
      }
    },
    {
      key: "rootEntitiesCount",
      get: function get3() {
        return this._rootEntities.length;
      }
    },
    {
      key: "rootEntities",
      get: function get3() {
        return this._rootEntities;
      }
    }
  ]);
  return Scene2;
}(EngineObject);
(function() {
  Scene$1._fogColorProperty = ShaderProperty.getByName("scene_FogColor");
})();
(function() {
  Scene$1._fogParamsProperty = ShaderProperty.getByName("scene_FogParams");
})();
(function() {
  Scene$1._sunlightColorProperty = ShaderProperty.getByName("scene_SunlightColor");
})();
(function() {
  Scene$1._sunlightDirectionProperty = ShaderProperty.getByName("scene_SunlightDirection");
})();
var SceneManager = /* @__PURE__ */ function() {
  function SceneManager2(engine) {
    this.engine = engine;
    this._allScenes = [];
  }
  var _proto = SceneManager2.prototype;
  _proto.loadScene = function loadScene(url, destroyOldScene) {
    if (destroyOldScene === void 0)
      destroyOldScene = true;
    var _this = this;
    var scenePromise = this.engine.resourceManager.load(url);
    scenePromise.then(function(scene) {
      var oldScene = _this._activeScene;
      _this.activeScene = scene;
      if (oldScene && destroyOldScene) {
        oldScene.destroy();
      }
    });
    return scenePromise;
  };
  _proto.mergeScenes = function mergeScenes(sourceScene, destScene) {
    var oldRootEntities = sourceScene.rootEntities;
    for (var i = 0, n = oldRootEntities.length; i < n; i++) {
      destScene.addRootEntity(oldRootEntities[i]);
    }
  };
  _proto._destroyAllScene = function _destroyAllScene() {
    var allScenes = this._allScenes;
    while (allScenes[0]) {
      allScenes[0].destroy();
    }
  };
  _create_class$4(SceneManager2, [
    {
      key: "activeScene",
      get: function get3() {
        return this._activeScene;
      },
      set: function set(scene) {
        var oldScene = this._activeScene;
        if (oldScene !== scene) {
          oldScene && oldScene._processActive(false);
          scene && scene._processActive(true);
          this._activeScene = scene;
        }
      }
    }
  ]);
  return SceneManager2;
}();
var AssetPromise = /* @__PURE__ */ function() {
  function AssetPromise2(executor) {
    var _this = this;
    this._state = "pending";
    this._onProgressCallback = [];
    this._promise = new Promise(function(resolve, reject) {
      _this._reject = reject;
      var onResolve = function(value) {
        if (_this._state === "pending") {
          resolve(value);
          _this._state = "fulfilled";
          _this._onProgressCallback = void 0;
        }
      };
      var onReject = function(reason) {
        if (_this._state === "pending") {
          reject(reason);
          _this._state = "rejected";
          _this._onProgressCallback = void 0;
        }
      };
      var onCancel = function(callback) {
        if (_this._state === "pending") {
          _this._onCancelHandler = callback;
        }
      };
      var setProgress = function(progress) {
        if (_this._state === "pending") {
          _this._onProgressCallback.forEach(function(callback) {
            return callback(progress);
          });
        }
      };
      executor(onResolve, onReject, setProgress, onCancel);
    });
  }
  var _proto = AssetPromise2.prototype;
  _proto.onProgress = function onProgress(callback) {
    this._onProgressCallback.push(callback);
    return this;
  };
  _proto.then = function then(onfulfilled, onrejected) {
    var _this = this;
    return new AssetPromise2(function(resolve, reject) {
      _this._promise.then(onfulfilled, onrejected).then(resolve).catch(reject);
    });
  };
  _proto.catch = function _catch(onRejected) {
    var _this = this;
    return new AssetPromise2(function(resolve, reject) {
      _this._promise.catch(onRejected).then(resolve).catch(reject);
    });
  };
  _proto.finally = function _finally(onFinally) {
    return this._promise.finally(onFinally);
  };
  _proto.cancel = function cancel() {
    if (this._state !== "pending") {
      return;
    }
    this._state = "canceled";
    this._reject("canceled");
    this._onCancelHandler && this._onCancelHandler();
    return this;
  };
  AssetPromise2.all = function all(promises) {
    return new AssetPromise2(function(resolve, reject, setProgress) {
      var onComplete = function onComplete2(index, resultValue) {
        completed++;
        results[index] = resultValue;
        setProgress(completed / count);
        if (completed === count) {
          resolve(results);
        }
      };
      var onProgress = function onProgress2(promise, index) {
        if (_instanceof$2(promise, Promise) || _instanceof$2(promise, AssetPromise2)) {
          promise.then(function(value) {
            onComplete(index, value);
          }, reject);
        } else {
          Promise.resolve().then(function() {
            onComplete(index, promise);
          });
        }
      };
      var count = promises.length;
      var results = new Array(count);
      var completed = 0;
      if (count === 0) {
        return resolve(results);
      }
      for (var i = 0; i < count; i++) {
        onProgress(promises[i], i);
      }
    });
  };
  _create_class$4(AssetPromise2, [
    {
      key: Symbol.toStringTag,
      get: function get3() {
        return "AssetPromise";
      }
    }
  ]);
  return AssetPromise2;
}();
var PromiseState;
(function(PromiseState2) {
  PromiseState2["Pending"] = "pending";
  PromiseState2["Fulfilled"] = "fulfilled";
  PromiseState2["Rejected"] = "rejected";
  PromiseState2["Canceled"] = "canceled";
})(PromiseState || (PromiseState = {}));
var ResourceManager = /* @__PURE__ */ function() {
  function ResourceManager2(engine) {
    this.engine = engine;
    this.retryCount = 1;
    this.retryInterval = 0;
    this.timeout = Infinity;
    this._loadingPromises = {};
    this._assetPool = /* @__PURE__ */ Object.create(null);
    this._assetUrlPool = /* @__PURE__ */ Object.create(null);
    this._referResourcePool = /* @__PURE__ */ Object.create(null);
    this._graphicResourcePool = /* @__PURE__ */ Object.create(null);
    this._contentRestorerPool = /* @__PURE__ */ Object.create(null);
    this._objectPool = /* @__PURE__ */ Object.create(null);
    this._editorResourceConfig = /* @__PURE__ */ Object.create(null);
    this._virtualPathMap = /* @__PURE__ */ Object.create(null);
  }
  var _proto = ResourceManager2.prototype;
  _proto.load = function load2(assetInfo) {
    var _this = this;
    if (!Array.isArray(assetInfo)) {
      return this._loadSingleItem(assetInfo);
    }
    var promises = assetInfo.map(function(item) {
      return _this._loadSingleItem(item);
    });
    return AssetPromise.all(promises);
  };
  _proto.getFromCache = function getFromCache(url) {
    var _this__assetUrlPool_url;
    return (_this__assetUrlPool_url = this._assetUrlPool[url]) != null ? _this__assetUrlPool_url : null;
  };
  _proto.getAssetPath = function getAssetPath(instanceId) {
    return this._assetPool[instanceId];
  };
  _proto.cancelNotLoaded = function cancelNotLoaded(url) {
    var _this = this;
    if (!url) {
      Utils.objectValues(this._loadingPromises).forEach(function(promise) {
        promise.cancel();
      });
    } else if (typeof url === "string") {
      var _this__loadingPromises_url;
      (_this__loadingPromises_url = this._loadingPromises[url]) == null ? void 0 : _this__loadingPromises_url.cancel();
    } else {
      url.forEach(function(p) {
        var _this__loadingPromises_p;
        (_this__loadingPromises_p = _this._loadingPromises[p]) == null ? void 0 : _this__loadingPromises_p.cancel();
      });
    }
  };
  _proto.gc = function gc() {
    this._gc(false);
    this.engine._pendingGC();
  };
  _proto.addContentRestorer = function addContentRestorer(restorer) {
    this._contentRestorerPool[restorer.resource.instanceId] = restorer;
  };
  _proto._addAsset = function _addAsset(path, asset) {
    this._assetPool[asset.instanceId] = path;
    this._assetUrlPool[path] = asset;
  };
  _proto._deleteAsset = function _deleteAsset(asset) {
    var id = asset.instanceId;
    var path = this._assetPool[id];
    if (path) {
      delete this._assetPool[id];
      delete this._assetUrlPool[path];
    }
  };
  _proto._addReferResource = function _addReferResource(resource) {
    this._referResourcePool[resource.instanceId] = resource;
  };
  _proto._deleteReferResource = function _deleteReferResource(resource) {
    delete this._referResourcePool[resource.instanceId];
  };
  _proto._addGraphicResource = function _addGraphicResource(resource) {
    this._graphicResourcePool[resource.instanceId] = resource;
  };
  _proto._deleteGraphicResource = function _deleteGraphicResource(resource) {
    delete this._graphicResourcePool[resource.instanceId];
  };
  _proto._deleteContentRestorer = function _deleteContentRestorer(resource) {
    delete this._contentRestorerPool[resource.instanceId];
  };
  _proto._restoreGraphicResources = function _restoreGraphicResources() {
    var graphicResourcePool = this._graphicResourcePool;
    for (var id in graphicResourcePool) {
      graphicResourcePool[id]._rebuild();
    }
  };
  _proto._restoreResourcesContent = function _restoreResourcesContent() {
    var restoreContentInfoPool = this._contentRestorerPool;
    var restorePromises = new Array();
    for (var k2 in restoreContentInfoPool) {
      var restoreInfo = restoreContentInfoPool[k2];
      var promise = restoreInfo.restoreContent();
      promise && restorePromises.push(promise);
    }
    return Promise.all(restorePromises);
  };
  _proto._destroy = function _destroy() {
    this.cancelNotLoaded();
    this._gc(true);
    this._assetPool = null;
    this._assetUrlPool = null;
    this._referResourcePool = null;
    this._graphicResourcePool = null;
    this._contentRestorerPool = null;
    this._loadingPromises = null;
  };
  _proto._assignDefaultOptions = function _assignDefaultOptions(assetInfo) {
    var _assetInfo_type;
    assetInfo.type = (_assetInfo_type = assetInfo.type) != null ? _assetInfo_type : ResourceManager2._getTypeByUrl(assetInfo.url);
    if (assetInfo.type === void 0) {
      throw "asset type should be specified: " + assetInfo.url;
    }
    var _assetInfo_retryCount;
    assetInfo.retryCount = (_assetInfo_retryCount = assetInfo.retryCount) != null ? _assetInfo_retryCount : this.retryCount;
    var _assetInfo_timeout;
    assetInfo.timeout = (_assetInfo_timeout = assetInfo.timeout) != null ? _assetInfo_timeout : this.timeout;
    var _assetInfo_retryInterval;
    assetInfo.retryInterval = (_assetInfo_retryInterval = assetInfo.retryInterval) != null ? _assetInfo_retryInterval : this.retryInterval;
    var _assetInfo_url;
    assetInfo.url = (_assetInfo_url = assetInfo.url) != null ? _assetInfo_url : assetInfo.urls.join(",");
    return assetInfo;
  };
  _proto._loadSingleItem = function _loadSingleItem(itemOrURL) {
    var _this = this;
    var item = this._assignDefaultOptions(typeof itemOrURL === "string" ? {
      url: itemOrURL
    } : itemOrURL);
    var itemURL = item.url;
    var url = this._virtualPathMap[itemURL] ? this._virtualPathMap[itemURL] : itemURL;
    var _this__parseURL = this._parseURL(url), assetBaseURL = _this__parseURL.assetBaseURL, queryPath = _this__parseURL.queryPath;
    var paths = queryPath ? this._parseQueryPath(queryPath) : [];
    var cacheObject = this._assetUrlPool[assetBaseURL];
    if (cacheObject) {
      return new AssetPromise(function(resolve) {
        resolve(_this._getResolveResource(cacheObject, paths));
      });
    }
    var assetURL = assetBaseURL;
    if (queryPath) {
      assetURL += "?q=" + paths.shift();
    }
    var loadingPromises = this._loadingPromises;
    var loadingPromise = loadingPromises[assetURL];
    if (loadingPromise) {
      return new AssetPromise(function(resolve, reject) {
        loadingPromise.then(function(resource) {
          resolve(_this._getResolveResource(resource, paths));
        }).catch(function(error2) {
          reject(error2);
        });
      });
    }
    var loader = ResourceManager2._loaders[item.type];
    if (!loader) {
      throw "loader not found: " + item.type;
    }
    item.url = assetBaseURL;
    var promise = loader.load(item, this);
    if (_instanceof$2(promise, AssetPromise)) {
      loadingPromises[assetBaseURL] = promise;
      promise.then(function(resource) {
        if (loader.useCache) {
          _this._addAsset(assetBaseURL, resource);
        }
        delete loadingPromises[assetBaseURL];
      }, function() {
        return delete loadingPromises[assetBaseURL];
      });
      return promise;
    } else {
      var _loop = function(subURL2) {
        var subPromise = promise[subURL2];
        var isMaster = assetBaseURL === subURL2;
        loadingPromises[subURL2] = subPromise;
        subPromise.then(function(resource) {
          if (isMaster) {
            if (loader.useCache) {
              _this._addAsset(subURL2, resource);
              for (var k2 in promise)
                delete loadingPromises[k2];
            }
          }
        }, function() {
          for (var k2 in promise)
            delete loadingPromises[k2];
        });
      };
      for (var subURL in promise)
        _loop(subURL);
      return promise[assetURL].then(function(resource) {
        return _this._getResolveResource(resource, paths);
      });
    }
  };
  _proto._gc = function _gc(forceDestroy) {
    var objects = Utils.objectValues(this._referResourcePool);
    for (var i = 0, len = objects.length; i < len; i++) {
      if (!objects[i].isGCIgnored || forceDestroy) {
        objects[i].destroy();
      }
    }
  };
  _proto._getResolveResource = function _getResolveResource(resource, paths) {
    var subResource = resource;
    if (paths) {
      for (var i = 0, n = paths.length; i < n; i++) {
        var path = paths[i];
        subResource = subResource[path];
      }
    }
    return subResource;
  };
  _proto._parseURL = function _parseURL(path) {
    var assetBaseURL = path;
    var index = assetBaseURL.indexOf("?");
    if (index !== -1) {
      assetBaseURL = assetBaseURL.slice(0, index);
    }
    return {
      assetBaseURL,
      queryPath: this._getParameterByName("q", path)
    };
  };
  _proto._getParameterByName = function _getParameterByName(name2, url) {
    if (url === void 0)
      url = window.location.href;
    name2 = name2.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name2 + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
    if (!results)
      return null;
    if (!results[2])
      return "";
    return decodeURIComponent(results[2].replace(/\+/g, " "));
  };
  _proto._parseQueryPath = function _parseQueryPath(string) {
    var result2 = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
      result2.push("");
    }
    string.replace(rePropName, function(match, expression, quote, subString) {
      var key = match;
      if (quote) {
        key = subString.replace(reEscapeChar, "$1");
      } else if (expression) {
        key = expression.trim();
      }
      result2.push(key);
    });
    return result2;
  };
  _proto.getResourceByRef = function getResourceByRef(ref) {
    var refId = ref.refId, key = ref.key, isClone = ref.isClone;
    var obj = this._objectPool[refId];
    var promise;
    if (obj) {
      promise = Promise.resolve(obj);
    } else {
      var _this__editorResourceConfig_refId;
      var url = (_this__editorResourceConfig_refId = this._editorResourceConfig[refId]) == null ? void 0 : _this__editorResourceConfig_refId.path;
      if (!url) {
        Logger.warn("refId:" + refId + " is not find in this._editorResourceConfig.");
        return Promise.resolve(null);
      }
      url = key ? "" + url + (url.indexOf("?") > -1 ? "&" : "?") + "q=" + key : url;
      promise = this.load({
        url,
        type: this._editorResourceConfig[refId].type,
        params: this._editorResourceConfig[refId].params
      });
    }
    return promise.then(function(item) {
      return isClone ? item.clone() : item;
    });
  };
  _proto.initVirtualResources = function initVirtualResources(config) {
    var _this = this;
    config.forEach(function(element) {
      _this._virtualPathMap[element.virtualPath] = element.path;
      _this._editorResourceConfig[element.id] = element;
    });
  };
  ResourceManager2._addLoader = function _addLoader(type, loader, extNames) {
    this._loaders[type] = loader;
    for (var i = 0, len = extNames.length; i < len; i++) {
      this._extTypeMapping[extNames[i]] = type;
    }
  };
  ResourceManager2._getTypeByUrl = function _getTypeByUrl(url) {
    var path = url.split("?")[0];
    return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
  };
  return ResourceManager2;
}();
(function() {
  ResourceManager._loaders = {};
})();
(function() {
  ResourceManager._extTypeMapping = {};
})();
function resourceLoader(assetType, extNames, useCache) {
  if (useCache === void 0)
    useCache = true;
  return function(Target) {
    var loader = new Target(useCache);
    ResourceManager._addLoader(assetType, loader, extNames);
  };
}
var charCodeOfDot = ".".charCodeAt(0);
var reEscapeChar = /\\(\\)?/g;
var rePropName = RegExp(
  `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
  "g"
);
var PointerPhase;
(function(PointerPhase2) {
  PointerPhase2[PointerPhase2["Down"] = 0] = "Down";
  PointerPhase2[PointerPhase2["Move"] = 1] = "Move";
  PointerPhase2[PointerPhase2["Stationary"] = 2] = "Stationary";
  PointerPhase2[PointerPhase2["Up"] = 3] = "Up";
  PointerPhase2[PointerPhase2["Leave"] = 4] = "Leave";
})(PointerPhase || (PointerPhase = {}));
var Pointer = /* @__PURE__ */ function() {
  function Pointer2(id) {
    this.phase = PointerPhase.Leave;
    this.position = new Vector2();
    this.deltaPosition = new Vector2();
    this._events = [];
    this._upMap = [];
    this._downMap = [];
    this._upList = new DisorderedArray();
    this._downList = new DisorderedArray();
    this.id = id;
  }
  var _proto = Pointer2.prototype;
  _proto._firePointerExitAndEnter = function _firePointerExitAndEnter(rayCastEntity) {
    if (this._currentEnteredEntity !== rayCastEntity) {
      if (this._currentEnteredEntity) {
        var scripts = this._currentEnteredEntity._scripts;
        for (var i = scripts.length - 1; i >= 0; i--) {
          var script = scripts.get(i);
          script._waitHandlingInValid || script.onPointerExit(this);
        }
      }
      if (rayCastEntity) {
        var scripts1 = rayCastEntity._scripts;
        for (var i1 = scripts1.length - 1; i1 >= 0; i1--) {
          var script1 = scripts1.get(i1);
          script1._waitHandlingInValid || script1.onPointerEnter(this);
        }
      }
      this._currentEnteredEntity = rayCastEntity;
    }
  };
  _proto._firePointerDown = function _firePointerDown(rayCastEntity) {
    if (rayCastEntity) {
      var scripts = rayCastEntity._scripts;
      for (var i = scripts.length - 1; i >= 0; i--) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onPointerDown(this);
      }
    }
    this._currentPressedEntity = rayCastEntity;
  };
  _proto._firePointerDrag = function _firePointerDrag() {
    if (this._currentPressedEntity) {
      var scripts = this._currentPressedEntity._scripts;
      for (var i = scripts.length - 1; i >= 0; i--) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onPointerDrag(this);
      }
    }
  };
  _proto._firePointerUpAndClick = function _firePointerUpAndClick(rayCastEntity) {
    var _this = this, pressedEntity = _this._currentPressedEntity;
    if (pressedEntity) {
      var sameTarget = pressedEntity === rayCastEntity;
      var scripts = pressedEntity._scripts;
      for (var i = scripts.length - 1; i >= 0; i--) {
        var script = scripts.get(i);
        if (!script._waitHandlingInValid) {
          sameTarget && script.onPointerClick(this);
          script.onPointerUp(this);
        }
      }
      this._currentPressedEntity = null;
    }
  };
  return Pointer2;
}();
var SystemInfo = /* @__PURE__ */ function() {
  function SystemInfo2() {
  }
  SystemInfo2._initialize = function _initialize() {
    {
      if (typeof navigator == "undefined") {
        return;
      }
      var userAgent = navigator.userAgent;
      if (/iPhone/i.test(userAgent)) {
        SystemInfo2.platform = Platform.IPhone;
      } else if (/iPad/i.test(userAgent)) {
        SystemInfo2.platform = Platform.IPad;
      } else if (/Android/i.test(userAgent)) {
        SystemInfo2.platform = Platform.Android;
      } else if (/Macintosh/i.test(userAgent)) {
        SystemInfo2.platform = Platform.Mac;
      }
      var v;
      switch (SystemInfo2.platform) {
        case Platform.IPhone:
          v = userAgent.match(/OS (\d+)_?(\d+)?_?(\d+)?/);
          this.operatingSystem = v ? "iPhone OS " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "iPhone OS";
          break;
        case Platform.IPad:
          v = userAgent.match(/OS (\d+)_?(\d+)?_?(\d+)?/);
          this.operatingSystem = v ? "iPad OS " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "iPad OS";
          break;
        case Platform.Android:
          v = userAgent.match(/Android (\d+).?(\d+)?.?(\d+)?/);
          this.operatingSystem = v ? "Android " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "Android";
          break;
        case Platform.Mac:
          v = userAgent.match(/Mac OS X (\d+)_?(\d+)?_?(\d+)?/);
          this.operatingSystem = v ? "Mac OS X " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "Mac OS X";
          break;
      }
    }
  };
  _create_class$4(SystemInfo2, null, [
    {
      key: "devicePixelRatio",
      get: function get3() {
        return window.devicePixelRatio;
      }
    }
  ]);
  return SystemInfo2;
}();
(function() {
  SystemInfo.platform = Platform.Unknown;
})();
(function() {
  SystemInfo.operatingSystem = "";
})();
SystemInfo._initialize();
var Keys;
(function(Keys2) {
  Keys2[Keys2["Backquote"] = 0] = "Backquote";
  Keys2[Keys2["Backslash"] = 1] = "Backslash";
  Keys2[Keys2["Backspace"] = 2] = "Backspace";
  Keys2[Keys2["BracketLeft"] = 3] = "BracketLeft";
  Keys2[Keys2["BracketRight"] = 4] = "BracketRight";
  Keys2[Keys2["Comma"] = 5] = "Comma";
  Keys2[Keys2["Digit0"] = 6] = "Digit0";
  Keys2[Keys2["Digit1"] = 7] = "Digit1";
  Keys2[Keys2["Digit2"] = 8] = "Digit2";
  Keys2[Keys2["Digit3"] = 9] = "Digit3";
  Keys2[Keys2["Digit4"] = 10] = "Digit4";
  Keys2[Keys2["Digit5"] = 11] = "Digit5";
  Keys2[Keys2["Digit6"] = 12] = "Digit6";
  Keys2[Keys2["Digit7"] = 13] = "Digit7";
  Keys2[Keys2["Digit8"] = 14] = "Digit8";
  Keys2[Keys2["Digit9"] = 15] = "Digit9";
  Keys2[Keys2["Equal"] = 16] = "Equal";
  Keys2[Keys2["IntlBackslash"] = 17] = "IntlBackslash";
  Keys2[Keys2["IntlRo"] = 18] = "IntlRo";
  Keys2[Keys2["IntlYen"] = 19] = "IntlYen";
  Keys2[Keys2["KeyA"] = 20] = "KeyA";
  Keys2[Keys2["KeyB"] = 21] = "KeyB";
  Keys2[Keys2["KeyC"] = 22] = "KeyC";
  Keys2[Keys2["KeyD"] = 23] = "KeyD";
  Keys2[Keys2["KeyE"] = 24] = "KeyE";
  Keys2[Keys2["KeyF"] = 25] = "KeyF";
  Keys2[Keys2["KeyG"] = 26] = "KeyG";
  Keys2[Keys2["KeyH"] = 27] = "KeyH";
  Keys2[Keys2["KeyI"] = 28] = "KeyI";
  Keys2[Keys2["KeyJ"] = 29] = "KeyJ";
  Keys2[Keys2["KeyK"] = 30] = "KeyK";
  Keys2[Keys2["KeyL"] = 31] = "KeyL";
  Keys2[Keys2["KeyM"] = 32] = "KeyM";
  Keys2[Keys2["KeyN"] = 33] = "KeyN";
  Keys2[Keys2["KeyO"] = 34] = "KeyO";
  Keys2[Keys2["KeyP"] = 35] = "KeyP";
  Keys2[Keys2["KeyQ"] = 36] = "KeyQ";
  Keys2[Keys2["KeyR"] = 37] = "KeyR";
  Keys2[Keys2["KeyS"] = 38] = "KeyS";
  Keys2[Keys2["KeyT"] = 39] = "KeyT";
  Keys2[Keys2["KeyU"] = 40] = "KeyU";
  Keys2[Keys2["KeyV"] = 41] = "KeyV";
  Keys2[Keys2["KeyW"] = 42] = "KeyW";
  Keys2[Keys2["KeyX"] = 43] = "KeyX";
  Keys2[Keys2["KeyY"] = 44] = "KeyY";
  Keys2[Keys2["KeyZ"] = 45] = "KeyZ";
  Keys2[Keys2["Minus"] = 46] = "Minus";
  Keys2[Keys2["Period"] = 47] = "Period";
  Keys2[Keys2["Quote"] = 48] = "Quote";
  Keys2[Keys2["Semicolon"] = 49] = "Semicolon";
  Keys2[Keys2["Slash"] = 50] = "Slash";
  Keys2[Keys2["AltLeft"] = 51] = "AltLeft";
  Keys2[Keys2["AltRight"] = 52] = "AltRight";
  Keys2[Keys2["CapsLock"] = 53] = "CapsLock";
  Keys2[Keys2["ContextMenu"] = 54] = "ContextMenu";
  Keys2[Keys2["ControlLeft"] = 55] = "ControlLeft";
  Keys2[Keys2["ControlRight"] = 56] = "ControlRight";
  Keys2[Keys2["Enter"] = 57] = "Enter";
  Keys2[Keys2["MetaLeft"] = 58] = "MetaLeft";
  Keys2[Keys2["MetaRight"] = 59] = "MetaRight";
  Keys2[Keys2["ShiftLeft"] = 60] = "ShiftLeft";
  Keys2[Keys2["ShiftRight"] = 61] = "ShiftRight";
  Keys2[Keys2["Space"] = 62] = "Space";
  Keys2[Keys2["Tab"] = 63] = "Tab";
  Keys2[Keys2["Convert"] = 64] = "Convert";
  Keys2[Keys2["KanaMode"] = 65] = "KanaMode";
  Keys2[Keys2["Lang1"] = 66] = "Lang1";
  Keys2[Keys2["Lang2"] = 67] = "Lang2";
  Keys2[Keys2["Lang3"] = 68] = "Lang3";
  Keys2[Keys2["Lang4"] = 69] = "Lang4";
  Keys2[Keys2["Lang5"] = 70] = "Lang5";
  Keys2[Keys2["NonConvert"] = 71] = "NonConvert";
  Keys2[Keys2["Delete"] = 72] = "Delete";
  Keys2[Keys2["End"] = 73] = "End";
  Keys2[Keys2["Help"] = 74] = "Help";
  Keys2[Keys2["Home"] = 75] = "Home";
  Keys2[Keys2["Insert"] = 76] = "Insert";
  Keys2[Keys2["PageDown"] = 77] = "PageDown";
  Keys2[Keys2["PageUp"] = 78] = "PageUp";
  Keys2[Keys2["ArrowDown"] = 79] = "ArrowDown";
  Keys2[Keys2["ArrowLeft"] = 80] = "ArrowLeft";
  Keys2[Keys2["ArrowRight"] = 81] = "ArrowRight";
  Keys2[Keys2["ArrowUp"] = 82] = "ArrowUp";
  Keys2[Keys2["NumLock"] = 83] = "NumLock";
  Keys2[Keys2["Numpad0"] = 84] = "Numpad0";
  Keys2[Keys2["Numpad1"] = 85] = "Numpad1";
  Keys2[Keys2["Numpad2"] = 86] = "Numpad2";
  Keys2[Keys2["Numpad3"] = 87] = "Numpad3";
  Keys2[Keys2["Numpad4"] = 88] = "Numpad4";
  Keys2[Keys2["Numpad5"] = 89] = "Numpad5";
  Keys2[Keys2["Numpad6"] = 90] = "Numpad6";
  Keys2[Keys2["Numpad7"] = 91] = "Numpad7";
  Keys2[Keys2["Numpad8"] = 92] = "Numpad8";
  Keys2[Keys2["Numpad9"] = 93] = "Numpad9";
  Keys2[Keys2["NumpadAdd"] = 94] = "NumpadAdd";
  Keys2[Keys2["NumpadBackspace"] = 95] = "NumpadBackspace";
  Keys2[Keys2["NumpadClear"] = 96] = "NumpadClear";
  Keys2[Keys2["NumpadClearEntry"] = 97] = "NumpadClearEntry";
  Keys2[Keys2["NumpadComma"] = 98] = "NumpadComma";
  Keys2[Keys2["NumpadDecimal"] = 99] = "NumpadDecimal";
  Keys2[Keys2["NumpadDivide"] = 100] = "NumpadDivide";
  Keys2[Keys2["NumpadEnter"] = 101] = "NumpadEnter";
  Keys2[Keys2["NumpadEqual"] = 102] = "NumpadEqual";
  Keys2[Keys2["NumpadHash"] = 103] = "NumpadHash";
  Keys2[Keys2["NumpadMemoryAdd"] = 104] = "NumpadMemoryAdd";
  Keys2[Keys2["NumpadMemoryClear"] = 105] = "NumpadMemoryClear";
  Keys2[Keys2["NumpadMemoryRecall"] = 106] = "NumpadMemoryRecall";
  Keys2[Keys2["NumpadMemoryStore"] = 107] = "NumpadMemoryStore";
  Keys2[Keys2["NumpadMemorySubtract"] = 108] = "NumpadMemorySubtract";
  Keys2[Keys2["NumpadMultiply"] = 109] = "NumpadMultiply";
  Keys2[Keys2["NumpadParenLeft"] = 110] = "NumpadParenLeft";
  Keys2[Keys2["NumpadParenRight"] = 111] = "NumpadParenRight";
  Keys2[Keys2["NumpadStar"] = 112] = "NumpadStar";
  Keys2[Keys2["NumpadSubtract"] = 113] = "NumpadSubtract";
  Keys2[Keys2["Escape"] = 114] = "Escape";
  Keys2[Keys2["F1"] = 115] = "F1";
  Keys2[Keys2["F2"] = 116] = "F2";
  Keys2[Keys2["F3"] = 117] = "F3";
  Keys2[Keys2["F4"] = 118] = "F4";
  Keys2[Keys2["F5"] = 119] = "F5";
  Keys2[Keys2["F6"] = 120] = "F6";
  Keys2[Keys2["F7"] = 121] = "F7";
  Keys2[Keys2["F8"] = 122] = "F8";
  Keys2[Keys2["F9"] = 123] = "F9";
  Keys2[Keys2["F10"] = 124] = "F10";
  Keys2[Keys2["F11"] = 125] = "F11";
  Keys2[Keys2["F12"] = 126] = "F12";
  Keys2[Keys2["F13"] = 127] = "F13";
  Keys2[Keys2["F14"] = 128] = "F14";
  Keys2[Keys2["F15"] = 129] = "F15";
  Keys2[Keys2["Fn"] = 130] = "Fn";
  Keys2[Keys2["FnLock"] = 131] = "FnLock";
  Keys2[Keys2["PrintScreen"] = 132] = "PrintScreen";
  Keys2[Keys2["ScrollLock"] = 133] = "ScrollLock";
  Keys2[Keys2["Pause"] = 134] = "Pause";
  Keys2[Keys2["BrowserBack"] = 135] = "BrowserBack";
  Keys2[Keys2["BrowserFavorites"] = 136] = "BrowserFavorites";
  Keys2[Keys2["BrowserForward"] = 137] = "BrowserForward";
  Keys2[Keys2["BrowserHome"] = 138] = "BrowserHome";
  Keys2[Keys2["BrowserRefresh"] = 139] = "BrowserRefresh";
  Keys2[Keys2["BrowserSearch"] = 140] = "BrowserSearch";
  Keys2[Keys2["BrowserStop"] = 141] = "BrowserStop";
  Keys2[Keys2["Eject"] = 142] = "Eject";
  Keys2[Keys2["LaunchApp1"] = 143] = "LaunchApp1";
  Keys2[Keys2["LaunchApp2"] = 144] = "LaunchApp2";
  Keys2[Keys2["LaunchMail"] = 145] = "LaunchMail";
  Keys2[Keys2["MediaPlayPause"] = 146] = "MediaPlayPause";
  Keys2[Keys2["MediaSelect"] = 147] = "MediaSelect";
  Keys2[Keys2["MediaStop"] = 148] = "MediaStop";
  Keys2[Keys2["MediaTrackNext"] = 149] = "MediaTrackNext";
  Keys2[Keys2["MediaTrackPrevious"] = 150] = "MediaTrackPrevious";
  Keys2[Keys2["Power"] = 151] = "Power";
  Keys2[Keys2["Sleep"] = 152] = "Sleep";
  Keys2[Keys2["AudioVolumeDown"] = 153] = "AudioVolumeDown";
  Keys2[Keys2["AudioVolumeMute"] = 154] = "AudioVolumeMute";
  Keys2[Keys2["AudioVolumeUp"] = 155] = "AudioVolumeUp";
  Keys2[Keys2["WakeUp"] = 156] = "WakeUp";
  Keys2[Keys2["Hyper"] = 157] = "Hyper";
  Keys2[Keys2["Super"] = 158] = "Super";
  Keys2[Keys2["Turbo"] = 159] = "Turbo";
  Keys2[Keys2["Abort"] = 160] = "Abort";
  Keys2[Keys2["Resume"] = 161] = "Resume";
  Keys2[Keys2["Suspend"] = 162] = "Suspend";
  Keys2[Keys2["Again"] = 163] = "Again";
  Keys2[Keys2["Copy"] = 164] = "Copy";
  Keys2[Keys2["Cut"] = 165] = "Cut";
  Keys2[Keys2["Find"] = 166] = "Find";
  Keys2[Keys2["Open"] = 167] = "Open";
  Keys2[Keys2["Paste"] = 168] = "Paste";
  Keys2[Keys2["Props"] = 169] = "Props";
  Keys2[Keys2["Select"] = 170] = "Select";
  Keys2[Keys2["Undo"] = 171] = "Undo";
  Keys2[Keys2["Hiragana"] = 172] = "Hiragana";
  Keys2[Keys2["Katakana"] = 173] = "Katakana";
  Keys2[Keys2["Unidentified"] = 174] = "Unidentified";
})(Keys || (Keys = {}));
var KeyboardManager = /* @__PURE__ */ function() {
  function KeyboardManager2(engine) {
    this._curHeldDownKeyToIndexMap = [];
    this._upKeyToFrameCountMap = [];
    this._downKeyToFrameCountMap = [];
    this._curFrameHeldDownList = new DisorderedArray();
    this._curFrameDownList = new DisorderedArray();
    this._curFrameUpList = new DisorderedArray();
    this._nativeEvents = [];
    this._hadListener = false;
    var htmlCanvas = engine._canvas._webCanvas;
    this._engine = engine;
    this._htmlCanvas = htmlCanvas;
    htmlCanvas.tabIndex = htmlCanvas.tabIndex;
    this._onKeyEvent = this._onKeyEvent.bind(this);
    htmlCanvas.addEventListener("keydown", this._onKeyEvent);
    htmlCanvas.addEventListener("keyup", this._onKeyEvent);
    this._hadListener = true;
  }
  var _proto = KeyboardManager2.prototype;
  _proto._update = function _update() {
    var _this = this, nativeEvents = _this._nativeEvents, curFrameDownList = _this._curFrameDownList, curFrameUpList = _this._curFrameUpList;
    curFrameDownList.length = 0;
    curFrameUpList.length = 0;
    if (nativeEvents.length > 0) {
      var frameCount = this._engine.time.frameCount;
      var _this1 = this, curHeldDownKeyToIndexMap = _this1._curHeldDownKeyToIndexMap, curFrameHeldDownList = _this1._curFrameHeldDownList, downKeyToFrameCountMap = _this1._downKeyToFrameCountMap, upKeyToFrameCountMap = _this1._upKeyToFrameCountMap;
      for (var i = 0, n = nativeEvents.length; i < n; i++) {
        var evt = nativeEvents[i];
        var codeKey = Keys[evt.code];
        switch (evt.type) {
          case "keydown":
            if (curHeldDownKeyToIndexMap[codeKey] == null) {
              curFrameDownList.add(codeKey);
              curFrameHeldDownList.add(codeKey);
              curHeldDownKeyToIndexMap[codeKey] = curFrameHeldDownList.length - 1;
              downKeyToFrameCountMap[codeKey] = frameCount;
            }
            break;
          case "keyup":
            var delIndex = curHeldDownKeyToIndexMap[codeKey];
            if (delIndex != null) {
              curHeldDownKeyToIndexMap[codeKey] = null;
              var swapCode = curFrameHeldDownList.deleteByIndex(delIndex);
              swapCode && (curHeldDownKeyToIndexMap[swapCode] = delIndex);
            }
            curFrameUpList.add(codeKey);
            upKeyToFrameCountMap[codeKey] = frameCount;
            if (SystemInfo.platform === Platform.Mac && (codeKey === Keys.MetaLeft || codeKey === Keys.MetaRight)) {
              for (var i1 = 0, n1 = curFrameHeldDownList.length; i1 < n1; i1++) {
                curHeldDownKeyToIndexMap[curFrameHeldDownList.get(i1)] = null;
              }
              curFrameHeldDownList.length = 0;
            }
            break;
        }
      }
      nativeEvents.length = 0;
    }
  };
  _proto._onFocus = function _onFocus() {
    if (!this._hadListener) {
      this._htmlCanvas.addEventListener("keydown", this._onKeyEvent);
      this._htmlCanvas.addEventListener("keyup", this._onKeyEvent);
      this._hadListener = true;
    }
  };
  _proto._onBlur = function _onBlur() {
    if (this._hadListener) {
      this._htmlCanvas.removeEventListener("keydown", this._onKeyEvent);
      this._htmlCanvas.removeEventListener("keyup", this._onKeyEvent);
      this._curHeldDownKeyToIndexMap.length = 0;
      this._curFrameHeldDownList.length = 0;
      this._curFrameDownList.length = 0;
      this._curFrameUpList.length = 0;
      this._nativeEvents.length = 0;
      this._hadListener = false;
    }
  };
  _proto._destroy = function _destroy() {
    if (this._hadListener) {
      this._htmlCanvas.removeEventListener("keydown", this._onKeyEvent);
      this._htmlCanvas.removeEventListener("keyup", this._onKeyEvent);
      this._hadListener = false;
    }
    this._curHeldDownKeyToIndexMap = null;
    this._upKeyToFrameCountMap = null;
    this._downKeyToFrameCountMap = null;
    this._nativeEvents = null;
    this._curFrameHeldDownList = null;
    this._curFrameDownList = null;
    this._curFrameUpList = null;
  };
  _proto._onKeyEvent = function _onKeyEvent(evt) {
    this._nativeEvents.push(evt);
  };
  return KeyboardManager2;
}();
var CameraClearFlags;
(function(CameraClearFlags2) {
  CameraClearFlags2[CameraClearFlags2["None"] = 0] = "None";
  CameraClearFlags2[CameraClearFlags2["Color"] = 1] = "Color";
  CameraClearFlags2[CameraClearFlags2["Depth"] = 2] = "Depth";
  CameraClearFlags2[CameraClearFlags2["Stencil"] = 4] = "Stencil";
  CameraClearFlags2[CameraClearFlags2["ColorDepth"] = 3] = "ColorDepth";
  CameraClearFlags2[CameraClearFlags2["ColorStencil"] = 5] = "ColorStencil";
  CameraClearFlags2[CameraClearFlags2["DepthStencil"] = 6] = "DepthStencil";
  CameraClearFlags2[CameraClearFlags2["All"] = 7] = "All";
})(CameraClearFlags || (CameraClearFlags = {}));
var HitResult = function HitResult2() {
  this.entity = null;
  this.distance = 0;
  this.point = new Vector3();
  this.normal = new Vector3();
};
var Collision = function Collision2() {
};
var PhysicsManager = /* @__PURE__ */ function() {
  function PhysicsManager2(engine) {
    var _this = this;
    this._initialized = false;
    this._restTime = 0;
    this._fixedTimeStep = 1 / 60;
    this._colliders = new DisorderedArray();
    this._gravity = new Vector3(0, -9.81, 0);
    this._physicalObjectsMap = {};
    this._onContactEnter = function(obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        if (!script._waitHandlingInValid) {
          var collision = PhysicsManager2._collision;
          collision.shape = shape2;
          script.onCollisionEnter(collision);
        }
      }
      scripts = shape2.collider.entity._scripts;
      for (var i1 = 0, len1 = scripts.length; i1 < len1; i1++) {
        var script1 = scripts.get(i1);
        if (!script1._waitHandlingInValid) {
          var collision1 = PhysicsManager2._collision;
          collision1.shape = shape1;
          script1.onCollisionEnter(collision1);
        }
      }
    };
    this._onContactExit = function(obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        if (!script._waitHandlingInValid) {
          var collision = PhysicsManager2._collision;
          collision.shape = shape2;
          script.onCollisionExit(collision);
        }
      }
      scripts = shape2.collider.entity._scripts;
      for (var i1 = 0, len1 = scripts.length; i1 < len1; i1++) {
        var script1 = scripts.get(i1);
        if (!script1._waitHandlingInValid) {
          var collision1 = PhysicsManager2._collision;
          collision1.shape = shape1;
          script1.onCollisionExit(collision1);
        }
      }
    };
    this._onContactStay = function(obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        if (!script._waitHandlingInValid) {
          var collision = PhysicsManager2._collision;
          collision.shape = shape2;
          script.onCollisionStay(collision);
        }
      }
      scripts = shape2.collider.entity._scripts;
      for (var i1 = 0, len1 = scripts.length; i1 < len1; i1++) {
        var script1 = scripts.get(i1);
        if (!script1._waitHandlingInValid) {
          var collision1 = PhysicsManager2._collision;
          collision1.shape = shape1;
          script1.onCollisionStay(collision1);
        }
      }
    };
    this._onTriggerEnter = function(obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onTriggerEnter(shape2);
      }
      scripts = shape2.collider.entity._scripts;
      for (var i1 = 0, len1 = scripts.length; i1 < len1; i1++) {
        var script1 = scripts.get(i1);
        script1._waitHandlingInValid || script1.onTriggerEnter(shape1);
      }
    };
    this._onTriggerExit = function(obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, n = scripts.length; i < n; i++) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onTriggerExit(shape2);
      }
      scripts = shape2.collider.entity._scripts;
      for (var i1 = 0, n1 = scripts.length; i1 < n1; i1++) {
        var script1 = scripts.get(i1);
        script1._waitHandlingInValid || script1.onTriggerExit(shape1);
      }
    };
    this._onTriggerStay = function(obj1, obj2) {
      var shape1 = _this._physicalObjectsMap[obj1];
      var shape2 = _this._physicalObjectsMap[obj2];
      var scripts = shape1.collider.entity._scripts;
      for (var i = 0, len = scripts.length; i < len; i++) {
        var script = scripts.get(i);
        script._waitHandlingInValid || script.onTriggerStay(shape2);
      }
      scripts = shape2.collider.entity._scripts;
      for (var i1 = 0, len1 = scripts.length; i1 < len1; i1++) {
        var script1 = scripts.get(i1);
        script1._waitHandlingInValid || script1.onTriggerStay(shape1);
      }
    };
    this._engine = engine;
    this._setGravity = this._setGravity.bind(this);
    this._gravity._onValueChanged = this._setGravity;
  }
  var _proto = PhysicsManager2.prototype;
  _proto.raycast = function raycast(ray, distanceOrResult, layerMaskOrResult, outHitResult) {
    var _this = this;
    var hitResult;
    var distance = Number.MAX_VALUE;
    if (typeof distanceOrResult === "number") {
      distance = distanceOrResult;
    } else if (distanceOrResult != void 0) {
      hitResult = distanceOrResult;
    }
    var layerMask = Layer.Everything;
    if (typeof layerMaskOrResult === "number") {
      layerMask = layerMaskOrResult;
    } else if (layerMaskOrResult != void 0) {
      hitResult = layerMaskOrResult;
    }
    if (outHitResult) {
      hitResult = outHitResult;
    }
    var onRaycast = function(obj) {
      var shape = _this._physicalObjectsMap[obj];
      return shape.collider.entity.layer & layerMask && shape.isSceneQuery;
    };
    if (hitResult != void 0) {
      var result2 = this._nativePhysicsManager.raycast(ray, distance, onRaycast, function(idx, distance2, position, normal) {
        hitResult.entity = _this._physicalObjectsMap[idx]._collider.entity;
        hitResult.distance = distance2;
        hitResult.normal.copyFrom(normal);
        hitResult.point.copyFrom(position);
      });
      if (result2) {
        return true;
      } else {
        hitResult.entity = null;
        hitResult.distance = 0;
        hitResult.point.set(0, 0, 0);
        hitResult.normal.set(0, 0, 0);
        return false;
      }
    } else {
      return this._nativePhysicsManager.raycast(ray, distance, onRaycast);
    }
  };
  _proto._initialize = function _initialize(physics) {
    PhysicsManager2._nativePhysics = physics;
    this._nativePhysicsManager = PhysicsManager2._nativePhysics.createPhysicsManager(this._onContactEnter, this._onContactExit, this._onContactStay, this._onTriggerEnter, this._onTriggerExit, this._onTriggerStay);
    this._initialized = true;
  };
  _proto._update = function _update(deltaTime) {
    var _this = this, fixedTimeStep = _this._fixedTimeStep, nativePhysicsManager = _this._nativePhysicsManager;
    var componentsManager = this._engine._componentsManager;
    var simulateTime = this._restTime + deltaTime;
    var step = Math.floor(simulateTime / fixedTimeStep);
    this._restTime = simulateTime - step * fixedTimeStep;
    for (var i = 0; i < step; i++) {
      componentsManager.callScriptOnPhysicsUpdate();
      this._callColliderOnUpdate();
      nativePhysicsManager.update(fixedTimeStep);
      this._callColliderOnLateUpdate();
    }
  };
  _proto._addColliderShape = function _addColliderShape(colliderShape) {
    this._physicalObjectsMap[colliderShape.id] = colliderShape;
    this._nativePhysicsManager.addColliderShape(colliderShape._nativeShape);
  };
  _proto._removeColliderShape = function _removeColliderShape(colliderShape) {
    delete this._physicalObjectsMap[colliderShape.id];
    this._nativePhysicsManager.removeColliderShape(colliderShape._nativeShape);
  };
  _proto._addCollider = function _addCollider(collider) {
    if (collider._index === -1) {
      collider._index = this._colliders.length;
      this._colliders.add(collider);
    }
    this._nativePhysicsManager.addCollider(collider._nativeCollider);
  };
  _proto._addCharacterController = function _addCharacterController(controller) {
    if (controller._index === -1) {
      controller._index = this._colliders.length;
      this._colliders.add(controller);
    }
    this._nativePhysicsManager.addCharacterController(controller._nativeCollider);
  };
  _proto._removeCollider = function _removeCollider(collider) {
    var replaced = this._colliders.deleteByIndex(collider._index);
    replaced && (replaced._index = collider._index);
    collider._index = -1;
    this._nativePhysicsManager.removeCollider(collider._nativeCollider);
  };
  _proto._removeCharacterController = function _removeCharacterController(controller) {
    var replaced = this._colliders.deleteByIndex(controller._index);
    replaced && (replaced._index = controller._index);
    controller._index = -1;
    this._nativePhysicsManager.removeCharacterController(controller._nativeCollider);
  };
  _proto._callColliderOnUpdate = function _callColliderOnUpdate() {
    var elements = this._colliders._elements;
    for (var i = this._colliders.length - 1; i >= 0; --i) {
      elements[i]._onUpdate();
    }
  };
  _proto._callColliderOnLateUpdate = function _callColliderOnLateUpdate() {
    var elements = this._colliders._elements;
    for (var i = this._colliders.length - 1; i >= 0; --i) {
      elements[i]._onLateUpdate();
    }
  };
  _proto._gc = function _gc() {
    this._colliders.garbageCollection();
  };
  _proto._setGravity = function _setGravity() {
    this._nativePhysicsManager.setGravity(this._gravity);
  };
  _create_class$4(PhysicsManager2, [
    {
      key: "gravity",
      get: function get3() {
        return this._gravity;
      },
      set: function set(value) {
        var gravity = this._gravity;
        if (gravity !== value) {
          gravity.copyFrom(value);
        }
      }
    },
    {
      key: "fixedTimeStep",
      get: function get3() {
        return this._fixedTimeStep;
      },
      set: function set(value) {
        this._fixedTimeStep = Math.max(value, MathUtil$1.zeroTolerance);
      }
    }
  ]);
  return PhysicsManager2;
}();
(function() {
  PhysicsManager._collision = new Collision();
})();
var PhysicsMaterialCombineMode;
(function(PhysicsMaterialCombineMode2) {
  PhysicsMaterialCombineMode2[PhysicsMaterialCombineMode2["Average"] = 0] = "Average";
  PhysicsMaterialCombineMode2[PhysicsMaterialCombineMode2["Minimum"] = 1] = "Minimum";
  PhysicsMaterialCombineMode2[PhysicsMaterialCombineMode2["Multiply"] = 2] = "Multiply";
  PhysicsMaterialCombineMode2[PhysicsMaterialCombineMode2["Maximum"] = 3] = "Maximum";
})(PhysicsMaterialCombineMode || (PhysicsMaterialCombineMode = {}));
var PhysicsMaterial = /* @__PURE__ */ function() {
  function PhysicsMaterial2() {
    this._bounciness = 0.1;
    this._dynamicFriction = 0.1;
    this._staticFriction = 0.1;
    this._bounceCombine = PhysicsMaterialCombineMode.Average;
    this._frictionCombine = PhysicsMaterialCombineMode.Average;
    this._nativeMaterial = PhysicsManager._nativePhysics.createPhysicsMaterial(this._staticFriction, this._dynamicFriction, this._bounciness, this._bounceCombine, this._frictionCombine);
  }
  var _proto = PhysicsMaterial2.prototype;
  _proto._destroy = function _destroy() {
    this._nativeMaterial.destroy();
  };
  _create_class$4(PhysicsMaterial2, [
    {
      key: "bounciness",
      get: function get3() {
        return this._bounciness;
      },
      set: function set(value) {
        if (this._bounciness !== value) {
          this._bounciness = value;
          this._nativeMaterial.setBounciness(value);
        }
      }
    },
    {
      key: "dynamicFriction",
      get: function get3() {
        return this._dynamicFriction;
      },
      set: function set(value) {
        if (this._dynamicFriction !== value) {
          this._dynamicFriction = value;
          this._nativeMaterial.setDynamicFriction(value);
        }
      }
    },
    {
      key: "staticFriction",
      get: function get3() {
        return this._staticFriction;
      },
      set: function set(value) {
        if (this._staticFriction !== value) {
          this._staticFriction = value;
          this._nativeMaterial.setStaticFriction(value);
        }
      }
    },
    {
      key: "bounceCombine",
      get: function get3() {
        return this._bounceCombine;
      },
      set: function set(value) {
        if (this._bounceCombine !== value) {
          this._bounceCombine = value;
          this._nativeMaterial.setBounceCombine(value);
        }
      }
    },
    {
      key: "frictionCombine",
      get: function get3() {
        return this._frictionCombine;
      },
      set: function set(value) {
        if (this._frictionCombine !== value) {
          this._frictionCombine = value;
          this._nativeMaterial.setFrictionCombine(value);
        }
      }
    }
  ]);
  return PhysicsMaterial2;
}();
var Collider = /* @__PURE__ */ function(Component2) {
  _inherits$2(Collider2, Component2);
  function Collider2(entity) {
    var _this;
    _this = Component2.call(this, entity) || this;
    _this._index = -1;
    _this._shapes = [];
    _this._updateFlag = _this.entity.transform.registerWorldChangeFlag();
    return _this;
  }
  var _proto = Collider2.prototype;
  _proto.addShape = function addShape(shape) {
    var oldCollider = shape._collider;
    if (oldCollider !== this) {
      if (oldCollider) {
        oldCollider.removeShape(shape);
      }
      this._shapes.push(shape);
      this.engine.physicsManager._addColliderShape(shape);
      shape._collider = this;
      this._nativeCollider.addShape(shape._nativeShape);
    }
  };
  _proto.removeShape = function removeShape(shape) {
    var index = this._shapes.indexOf(shape);
    if (index !== -1) {
      this._shapes.splice(index, 1);
      this.engine.physicsManager._removeColliderShape(shape);
      shape._collider = null;
      this._nativeCollider.removeShape(shape._nativeShape);
    }
  };
  _proto.clearShapes = function clearShapes() {
    var shapes = this._shapes;
    for (var i = 0, n = shapes.length; i < n; i++) {
      var shape = shapes[i];
      this.engine.physicsManager._removeColliderShape(shape);
      shape._destroy();
      this._nativeCollider.removeShape(shape._nativeShape);
    }
    shapes.length = 0;
  };
  _proto._onUpdate = function _onUpdate() {
    if (this._updateFlag.flag) {
      var transform = this.entity.transform;
      this._nativeCollider.setWorldTransform(transform.worldPosition, transform.worldRotationQuaternion);
      var worldScale = transform.lossyWorldScale;
      for (var i = 0, n = this.shapes.length; i < n; i++) {
        this.shapes[i]._nativeShape.setWorldScale(worldScale);
      }
      this._updateFlag.flag = false;
    }
  };
  _proto._onLateUpdate = function _onLateUpdate() {
  };
  _proto._onEnable = function _onEnable() {
    this.engine.physicsManager._addCollider(this);
  };
  _proto._onDisable = function _onDisable() {
    this.engine.physicsManager._removeCollider(this);
  };
  _proto._onDestroy = function _onDestroy() {
    Component2.prototype._onDestroy.call(this);
    this.clearShapes();
    this._nativeCollider.destroy();
  };
  _create_class$4(Collider2, [
    {
      key: "shapes",
      get: function get3() {
        return this._shapes;
      }
    }
  ]);
  return Collider2;
}(Component);
__decorate$2([
  ignoreClone
], Collider.prototype, "_index", void 0);
Collider = __decorate$2([
  dependentComponents(Transform, DependentMode.CheckOnly)
], Collider);
var ControllerNonWalkableMode;
(function(ControllerNonWalkableMode2) {
  ControllerNonWalkableMode2[ControllerNonWalkableMode2["PreventClimbing"] = 0] = "PreventClimbing";
  ControllerNonWalkableMode2[ControllerNonWalkableMode2["PreventClimbingAndForceSliding"] = 1] = "PreventClimbingAndForceSliding";
})(ControllerNonWalkableMode || (ControllerNonWalkableMode = {}));
var CharacterController = /* @__PURE__ */ function(Collider2) {
  _inherits$2(CharacterController2, Collider2);
  function CharacterController2(entity) {
    var _this;
    _this = Collider2.call(this, entity) || this;
    _this._stepOffset = 0.5;
    _this._nonWalkableMode = ControllerNonWalkableMode.PreventClimbing;
    _this._upDirection = new Vector3(0, 1, 0);
    _this._slopeLimit = 0.707;
    _this._nativeCollider = PhysicsManager._nativePhysics.createCharacterController();
    _this._setUpDirection = _this._setUpDirection.bind(_assert_this_initialized(_this));
    _this._upDirection._onValueChanged = _this._setUpDirection;
    return _this;
  }
  var _proto = CharacterController2.prototype;
  _proto.move = function move(disp, minDist, elapsedTime) {
    return this._nativeCollider.move(disp, minDist, elapsedTime);
  };
  _proto.addShape = function addShape(shape) {
    if (this._shapes.length > 0) {
      throw "only allow single shape on controller!";
    }
    Collider2.prototype.addShape.call(this, shape);
    this._updateFlag.flag = true;
  };
  _proto.clearShapes = function clearShapes() {
    if (this._shapes.length > 0) {
      Collider2.prototype.removeShape.call(this, this._shapes[0]);
    }
  };
  _proto._onUpdate = function _onUpdate() {
    if (this._updateFlag.flag) {
      var transform = this.entity.transform;
      var shapes = this.shapes;
      this._nativeCollider.setWorldPosition(transform.worldPosition);
      var worldScale = transform.lossyWorldScale;
      for (var i = 0, n = shapes.length; i < n; i++) {
        shapes[i]._nativeShape.setWorldScale(worldScale);
      }
      this._updateFlag.flag = false;
    }
  };
  _proto._onLateUpdate = function _onLateUpdate() {
    var position = this.entity.transform.worldPosition;
    this._nativeCollider.getWorldPosition(position);
    this.entity.transform.worldPosition = position;
    this._updateFlag.flag = false;
  };
  _proto._onEnable = function _onEnable() {
    this.engine.physicsManager._addCharacterController(this);
  };
  _proto._onDisable = function _onDisable() {
    this.engine.physicsManager._removeCharacterController(this);
  };
  _proto._setUpDirection = function _setUpDirection() {
    this._nativeCollider.setUpDirection(this._upDirection);
  };
  _create_class$4(CharacterController2, [
    {
      key: "stepOffset",
      get: function get3() {
        return this._stepOffset;
      },
      set: function set(value) {
        if (this._stepOffset !== value) {
          this._stepOffset = value;
          this._nativeCollider.setStepOffset(value);
        }
      }
    },
    {
      key: "nonWalkableMode",
      get: function get3() {
        return this._nonWalkableMode;
      },
      set: function set(value) {
        if (this._nonWalkableMode !== value) {
          this._nonWalkableMode = value;
          this._nativeCollider.setNonWalkableMode(value);
        }
      }
    },
    {
      key: "upDirection",
      get: function get3() {
        return this._upDirection;
      },
      set: function set(value) {
        if (this._upDirection !== value) {
          this._upDirection.copyFrom(value);
        }
      }
    },
    {
      key: "slopeLimit",
      get: function get3() {
        return this._slopeLimit;
      },
      set: function set(value) {
        if (this._slopeLimit !== value) {
          this._slopeLimit = value;
          this._nativeCollider.setSlopeLimit(value);
        }
      }
    }
  ]);
  return CharacterController2;
}(Collider);
var ColliderShape = /* @__PURE__ */ function() {
  function ColliderShape2() {
    this._isTrigger = false;
    this._rotation = new Vector3();
    this._position = new Vector3();
    this._contactOffset = 0.02;
    this.isSceneQuery = true;
    this._material = new PhysicsMaterial();
    this._id = ColliderShape2._idGenerator++;
    this._setRotation = this._setRotation.bind(this);
    this._setPosition = this._setPosition.bind(this);
    this._rotation._onValueChanged = this._setRotation;
    this._position._onValueChanged = this._setPosition;
  }
  var _proto = ColliderShape2.prototype;
  _proto._destroy = function _destroy() {
    this._material._destroy();
    this._nativeShape.destroy();
  };
  _proto._setPosition = function _setPosition() {
    this._nativeShape.setPosition(this._position);
  };
  _proto._setRotation = function _setRotation() {
    this._nativeShape.setRotation(this._rotation);
  };
  _create_class$4(ColliderShape2, [
    {
      key: "collider",
      get: function get3() {
        return this._collider;
      }
    },
    {
      key: "id",
      get: function get3() {
        return this._id;
      }
    },
    {
      key: "contactOffset",
      get: function get3() {
        return this._contactOffset;
      },
      set: function set(value) {
        if (this._contactOffset !== value) {
          this._contactOffset = value;
          this._nativeShape.setContactOffset(value);
        }
      }
    },
    {
      key: "material",
      get: function get3() {
        return this._material;
      },
      set: function set(value) {
        if (this._material !== value) {
          this._material = value;
          this._nativeShape.setMaterial(value._nativeMaterial);
        }
      }
    },
    {
      key: "rotation",
      get: function get3() {
        return this._rotation;
      },
      set: function set(value) {
        if (this._rotation != value) {
          this._rotation.copyFrom(value);
        }
      }
    },
    {
      key: "position",
      get: function get3() {
        return this._position;
      },
      set: function set(value) {
        if (this._position !== value) {
          this._position.copyFrom(value);
        }
      }
    },
    {
      key: "isTrigger",
      get: function get3() {
        return this._isTrigger;
      },
      set: function set(value) {
        if (this._isTrigger !== value) {
          this._isTrigger = value;
          this._nativeShape.setIsTrigger(value);
        }
      }
    }
  ]);
  return ColliderShape2;
}();
(function() {
  ColliderShape._idGenerator = 0;
})();
var BoxColliderShape = /* @__PURE__ */ function(ColliderShape2) {
  _inherits$2(BoxColliderShape2, ColliderShape2);
  function BoxColliderShape2() {
    var _this;
    _this = ColliderShape2.call(this) || this;
    _this._size = new Vector3(1, 1, 1);
    _this._nativeShape = PhysicsManager._nativePhysics.createBoxColliderShape(_this._id, _this._size, _this._material._nativeMaterial);
    _this._setSize = _this._setSize.bind(_assert_this_initialized(_this));
    _this._size._onValueChanged = _this._setSize;
    return _this;
  }
  var _proto = BoxColliderShape2.prototype;
  _proto._setSize = function _setSize() {
    this._nativeShape.setSize(this._size);
  };
  _create_class$4(BoxColliderShape2, [
    {
      key: "size",
      get: function get3() {
        return this._size;
      },
      set: function set(value) {
        if (this._size !== value) {
          this._size.copyFrom(value);
        }
      }
    }
  ]);
  return BoxColliderShape2;
}(ColliderShape);
var SphereColliderShape = /* @__PURE__ */ function(ColliderShape2) {
  _inherits$2(SphereColliderShape2, ColliderShape2);
  function SphereColliderShape2() {
    var _this;
    _this = ColliderShape2.call(this) || this;
    _this._radius = 1;
    _this._nativeShape = PhysicsManager._nativePhysics.createSphereColliderShape(_this._id, _this._radius, _this._material._nativeMaterial);
    return _this;
  }
  _create_class$4(SphereColliderShape2, [
    {
      key: "radius",
      get: function get3() {
        return this._radius;
      },
      set: function set(value) {
        if (this._radius !== value) {
          this._radius = value;
          this._nativeShape.setRadius(value);
        }
      }
    }
  ]);
  return SphereColliderShape2;
}(ColliderShape);
var PlaneColliderShape = /* @__PURE__ */ function(ColliderShape2) {
  _inherits$2(PlaneColliderShape2, ColliderShape2);
  function PlaneColliderShape2() {
    var _this;
    _this = ColliderShape2.call(this) || this;
    _this._nativeShape = PhysicsManager._nativePhysics.createPlaneColliderShape(_this._id, _this._material._nativeMaterial);
    return _this;
  }
  return PlaneColliderShape2;
}(ColliderShape);
var ColliderShapeUpAxis;
(function(ColliderShapeUpAxis2) {
  ColliderShapeUpAxis2[ColliderShapeUpAxis2["X"] = 0] = "X";
  ColliderShapeUpAxis2[ColliderShapeUpAxis2["Y"] = 1] = "Y";
  ColliderShapeUpAxis2[ColliderShapeUpAxis2["Z"] = 2] = "Z";
})(ColliderShapeUpAxis || (ColliderShapeUpAxis = {}));
var CapsuleColliderShape = /* @__PURE__ */ function(ColliderShape2) {
  _inherits$2(CapsuleColliderShape2, ColliderShape2);
  function CapsuleColliderShape2() {
    var _this;
    _this = ColliderShape2.call(this) || this;
    _this._radius = 1;
    _this._height = 2;
    _this._upAxis = ColliderShapeUpAxis.Y;
    _this._nativeShape = PhysicsManager._nativePhysics.createCapsuleColliderShape(_this._id, _this._radius, _this._height, _this._material._nativeMaterial);
    return _this;
  }
  _create_class$4(CapsuleColliderShape2, [
    {
      key: "radius",
      get: function get3() {
        return this._radius;
      },
      set: function set(value) {
        if (this._radius !== value) {
          this._radius = value;
          this._nativeShape.setRadius(value);
        }
      }
    },
    {
      key: "height",
      get: function get3() {
        return this._height;
      },
      set: function set(value) {
        if (this._height !== value) {
          this._height = value;
          this._nativeShape.setHeight(value);
        }
      }
    },
    {
      key: "upAxis",
      get: function get3() {
        return this._upAxis;
      },
      set: function set(value) {
        if (this._upAxis !== value) {
          this._upAxis = value;
          this._nativeShape.setUpAxis(value);
        }
      }
    }
  ]);
  return CapsuleColliderShape2;
}(ColliderShape);
var Joint = /* @__PURE__ */ function(Component2) {
  _inherits$2(Joint2, Component2);
  function Joint2(entity) {
    var _this;
    _this = Component2.call(this, entity) || this;
    _this._connectedCollider = new JointCollider();
    _this._collider = new JointCollider();
    _this._force = 0;
    _this._torque = 0;
    _this._connectedCollider.localPosition = new Vector3();
    return _this;
  }
  _create_class$4(Joint2, [
    {
      key: "connectedCollider",
      get: function get3() {
        return this._connectedCollider.collider;
      },
      set: function set(value) {
        if (this._connectedCollider.collider !== value) {
          this._connectedCollider.collider = value;
          this._nativeJoint.setConnectedCollider(value._nativeCollider);
        }
      }
    },
    {
      key: "connectedAnchor",
      get: function get3() {
        return this._connectedCollider.localPosition;
      },
      set: function set(value) {
        var connectedAnchor = this._connectedCollider.localPosition;
        if (value !== connectedAnchor) {
          connectedAnchor.copyFrom(value);
        }
        this._nativeJoint.setConnectedAnchor(value);
      }
    },
    {
      key: "connectedMassScale",
      get: function get3() {
        return this._connectedCollider.massScale;
      },
      set: function set(value) {
        if (value !== this._connectedCollider.massScale) {
          this._connectedCollider.massScale = value;
          this._nativeJoint.setConnectedMassScale(value);
        }
      }
    },
    {
      key: "connectedInertiaScale",
      get: function get3() {
        return this._connectedCollider.inertiaScale;
      },
      set: function set(value) {
        if (value !== this._connectedCollider.inertiaScale) {
          this._connectedCollider.inertiaScale = value;
          this._nativeJoint.setConnectedInertiaScale(value);
        }
      }
    },
    {
      key: "massScale",
      get: function get3() {
        return this._collider.massScale;
      },
      set: function set(value) {
        if (value !== this._collider.massScale) {
          this._collider.massScale = value;
          this._nativeJoint.setMassScale(value);
        }
      }
    },
    {
      key: "inertiaScale",
      get: function get3() {
        return this._collider.inertiaScale;
      },
      set: function set(value) {
        if (value !== this._collider.inertiaScale) {
          this._collider.inertiaScale = value;
          this._nativeJoint.setInertiaScale(value);
        }
      }
    },
    {
      key: "breakForce",
      get: function get3() {
        return this._force;
      },
      set: function set(value) {
        if (value !== this._force) {
          this._force = value;
          this._nativeJoint.setBreakForce(value);
        }
      }
    },
    {
      key: "breakTorque",
      get: function get3() {
        return this._torque;
      },
      set: function set(value) {
        if (value !== this._torque) {
          this._torque = value;
          this._nativeJoint.setBreakTorque(value);
        }
      }
    }
  ]);
  return Joint2;
}(Component);
Joint = __decorate$2([
  dependentComponents(Collider, DependentMode.CheckOnly)
], Joint);
var JointCollider = function JointCollider2() {
  this.collider = null;
  this.massScale = 0;
  this.inertiaScale = 0;
};
var FixedJoint = /* @__PURE__ */ function(Joint2) {
  _inherits$2(FixedJoint2, Joint2);
  function FixedJoint2() {
    return Joint2.apply(this, arguments);
  }
  var _proto = FixedJoint2.prototype;
  _proto._onAwake = function _onAwake() {
    var collider = this._collider;
    collider.collider = this.entity.getComponent(Collider);
    this._nativeJoint = PhysicsManager._nativePhysics.createFixedJoint(collider.collider._nativeCollider);
  };
  return FixedJoint2;
}(Joint);
var HingeJointFlag;
(function(HingeJointFlag2) {
  HingeJointFlag2[HingeJointFlag2["None"] = 0] = "None";
  HingeJointFlag2[HingeJointFlag2["LimitEnabled"] = 1] = "LimitEnabled";
  HingeJointFlag2[HingeJointFlag2["DriveEnabled"] = 2] = "DriveEnabled";
  HingeJointFlag2[HingeJointFlag2["DriveFreeSpin"] = 4] = "DriveFreeSpin";
})(HingeJointFlag || (HingeJointFlag = {}));
var HingeJoint = /* @__PURE__ */ function(Joint2) {
  _inherits$2(HingeJoint2, Joint2);
  function HingeJoint2() {
    var _this;
    _this = Joint2.apply(this, arguments) || this;
    _this._axis = new Vector3(1, 0, 0);
    _this._hingeFlags = HingeJointFlag.None;
    _this._useSpring = false;
    return _this;
  }
  var _proto = HingeJoint2.prototype;
  _proto._onAwake = function _onAwake() {
    var collider = this._collider;
    collider.localPosition = new Vector3();
    collider.collider = this.entity.getComponent(Collider);
    this._nativeJoint = PhysicsManager._nativePhysics.createHingeJoint(collider.collider._nativeCollider);
  };
  _create_class$4(HingeJoint2, [
    {
      key: "axis",
      get: function get3() {
        return this._axis;
      },
      set: function set(value) {
        var axis = this._axis;
        if (value !== axis) {
          axis.copyFrom(value);
        }
        this._nativeJoint.setAxis(axis);
      }
    },
    {
      key: "swingOffset",
      get: function get3() {
        return this._collider.localPosition;
      },
      set: function set(value) {
        var swingOffset = this._collider.localPosition;
        if (value !== swingOffset) {
          swingOffset.copyFrom(value);
        }
        this._nativeJoint.setSwingOffset(swingOffset);
      }
    },
    {
      key: "angle",
      get: function get3() {
        return this._nativeJoint.getAngle();
      }
    },
    {
      key: "velocity",
      get: function get3() {
        return this._nativeJoint.getVelocity();
      }
    },
    {
      key: "useLimits",
      get: function get3() {
        return (this._hingeFlags & HingeJointFlag.LimitEnabled) == HingeJointFlag.LimitEnabled;
      },
      set: function set(value) {
        if (value !== this.useLimits) {
          value ? this._hingeFlags |= HingeJointFlag.LimitEnabled : this._hingeFlags &= ~HingeJointFlag.LimitEnabled;
          this._nativeJoint.setHingeJointFlag(HingeJointFlag.LimitEnabled, value);
        }
      }
    },
    {
      key: "useMotor",
      get: function get3() {
        return (this._hingeFlags & HingeJointFlag.DriveEnabled) == HingeJointFlag.DriveEnabled;
      },
      set: function set(value) {
        if (value !== this.useMotor) {
          value ? this._hingeFlags |= HingeJointFlag.DriveEnabled : this._hingeFlags &= ~HingeJointFlag.DriveEnabled;
          this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveEnabled, value);
        }
      }
    },
    {
      key: "useSpring",
      get: function get3() {
        return this._useSpring;
      },
      set: function set(value) {
        if (this._useSpring !== value) {
          this._useSpring = value;
          this.limits = this._limits;
        }
      }
    },
    {
      key: "motor",
      get: function get3() {
        return this._jointMonitor;
      },
      set: function set(value) {
        if (this._jointMonitor !== value) {
          this._jointMonitor = value;
          this._nativeJoint.setDriveVelocity(value.targetVelocity);
          this._nativeJoint.setDriveForceLimit(value.forceLimit);
          this._nativeJoint.setDriveGearRatio(value.gearRation);
          this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveFreeSpin, value.freeSpin);
        }
      }
    },
    {
      key: "limits",
      get: function get3() {
        return this._limits;
      },
      set: function set(value) {
        if (this._limits !== value) {
          this._limits = value;
          if (this.useSpring) {
            this._nativeJoint.setSoftLimit(value.min, value.max, value.stiffness, value.damping);
          } else {
            this._nativeJoint.setHardLimit(value.min, value.max, value.contactDistance);
          }
        }
      }
    }
  ]);
  return HingeJoint2;
}(Joint);
var SpringJoint = /* @__PURE__ */ function(Joint2) {
  _inherits$2(SpringJoint2, Joint2);
  function SpringJoint2() {
    var _this;
    _this = Joint2.apply(this, arguments) || this;
    _this._minDistance = 0;
    _this._maxDistance = 0;
    _this._tolerance = 0.25;
    _this._stiffness = 0;
    _this._damping = 0;
    return _this;
  }
  var _proto = SpringJoint2.prototype;
  _proto._onAwake = function _onAwake() {
    var collider = this._collider;
    collider.localPosition = new Vector3();
    collider.collider = this.entity.getComponent(Collider);
    this._nativeJoint = PhysicsManager._nativePhysics.createSpringJoint(collider.collider._nativeCollider);
  };
  _create_class$4(SpringJoint2, [
    {
      key: "swingOffset",
      get: function get3() {
        return this._collider.localPosition;
      },
      set: function set(value) {
        var swingOffset = this._collider.localPosition;
        if (value !== swingOffset) {
          swingOffset.copyFrom(value);
        }
        this._nativeJoint.setSwingOffset(value);
      }
    },
    {
      key: "minDistance",
      get: function get3() {
        return this._minDistance;
      },
      set: function set(value) {
        if (this._minDistance !== value) {
          this._minDistance = value;
          this._nativeJoint.setMinDistance(value);
        }
      }
    },
    {
      key: "maxDistance",
      get: function get3() {
        return this._maxDistance;
      },
      set: function set(value) {
        if (this._maxDistance !== value) {
          this._maxDistance = value;
          this._nativeJoint.setMaxDistance(value);
        }
      }
    },
    {
      key: "tolerance",
      get: function get3() {
        return this._tolerance;
      },
      set: function set(value) {
        if (this._tolerance !== value) {
          this._tolerance = value;
          this._nativeJoint.setTolerance(value);
        }
      }
    },
    {
      key: "stiffness",
      get: function get3() {
        return this._stiffness;
      },
      set: function set(value) {
        if (this._stiffness !== value) {
          this._stiffness = value;
          this._nativeJoint.setStiffness(value);
        }
      }
    },
    {
      key: "damping",
      get: function get3() {
        return this._damping;
      },
      set: function set(value) {
        if (this._damping !== value) {
          this._damping = value;
          this._nativeJoint.setDamping(value);
        }
      }
    }
  ]);
  return SpringJoint2;
}(Joint);
var JointLimits = function JointLimits2() {
  this.max = 0;
  this.min = 0;
  this.contactDistance = -1;
  this.stiffness = 0;
  this.damping = 0;
};
var JointMotor = function JointMotor2() {
  this.targetVelocity = 0;
  this.forceLimit = Number.MAX_VALUE;
  this.gearRation = 1;
  this.freeSpin = false;
};
var ControllerCollisionFlag;
(function(ControllerCollisionFlag2) {
  ControllerCollisionFlag2[ControllerCollisionFlag2["Sides"] = 1] = "Sides";
  ControllerCollisionFlag2[ControllerCollisionFlag2["Up"] = 2] = "Up";
  ControllerCollisionFlag2[ControllerCollisionFlag2["Down"] = 4] = "Down";
})(ControllerCollisionFlag || (ControllerCollisionFlag = {}));
var StaticCollider = /* @__PURE__ */ function(Collider2) {
  _inherits$2(StaticCollider2, Collider2);
  function StaticCollider2(entity) {
    var _this;
    _this = Collider2.call(this, entity) || this;
    var transform = _this.entity.transform;
    _this._nativeCollider = PhysicsManager._nativePhysics.createStaticCollider(transform.worldPosition, transform.worldRotationQuaternion);
    return _this;
  }
  return StaticCollider2;
}(Collider);
var DynamicCollider = /* @__PURE__ */ function(Collider2) {
  _inherits$2(DynamicCollider2, Collider2);
  function DynamicCollider2(entity) {
    var _this;
    _this = Collider2.call(this, entity) || this;
    _this._linearDamping = 0;
    _this._angularDamping = 0.05;
    _this._linearVelocity = new Vector3();
    _this._angularVelocity = new Vector3();
    _this._mass = 1;
    _this._centerOfMass = new Vector3();
    _this._inertiaTensor = new Vector3(1, 1, 1);
    _this._maxAngularVelocity = 100;
    _this._maxDepenetrationVelocity = 1e3;
    _this._solverIterations = 4;
    _this._isKinematic = false;
    _this._constraints = 0;
    _this._collisionDetectionMode = 0;
    _this._sleepThreshold = 5e-3;
    var transform = _this.entity.transform;
    _this._nativeCollider = PhysicsManager._nativePhysics.createDynamicCollider(transform.worldPosition, transform.worldRotationQuaternion);
    _this._setLinearVelocity = _this._setLinearVelocity.bind(_assert_this_initialized(_this));
    _this._setAngularVelocity = _this._setAngularVelocity.bind(_assert_this_initialized(_this));
    _this._setCenterOfMass = _this._setCenterOfMass.bind(_assert_this_initialized(_this));
    _this._setInertiaTensor = _this._setInertiaTensor.bind(_assert_this_initialized(_this));
    _this._linearVelocity._onValueChanged = _this._setLinearVelocity;
    _this._angularVelocity._onValueChanged = _this._setAngularVelocity;
    _this._centerOfMass._onValueChanged = _this._setCenterOfMass;
    _this._inertiaTensor._onValueChanged = _this._setInertiaTensor;
    return _this;
  }
  var _proto = DynamicCollider2.prototype;
  _proto.applyForce = function applyForce(force) {
    this._nativeCollider.addForce(force);
  };
  _proto.applyTorque = function applyTorque(torque) {
    this._nativeCollider.addTorque(torque);
  };
  _proto.move = function move(positionOrRotation, rotation) {
    this._nativeCollider.move(positionOrRotation, rotation);
  };
  _proto.sleep = function sleep() {
    this._nativeCollider.sleep();
  };
  _proto.wakeUp = function wakeUp() {
    this._nativeCollider.wakeUp();
  };
  _proto._onLateUpdate = function _onLateUpdate() {
    var transform = this.entity.transform;
    var worldPosition = transform.worldPosition, worldRotationQuaternion = transform.worldRotationQuaternion;
    this._nativeCollider.getWorldTransform(worldPosition, worldRotationQuaternion);
    this._updateFlag.flag = false;
  };
  _proto._setLinearVelocity = function _setLinearVelocity() {
    this._nativeCollider.setLinearVelocity(this._linearVelocity);
  };
  _proto._setAngularVelocity = function _setAngularVelocity() {
    this._nativeCollider.setAngularVelocity(this._angularVelocity);
  };
  _proto._setCenterOfMass = function _setCenterOfMass() {
    this._nativeCollider.setCenterOfMass(this._centerOfMass);
  };
  _proto._setInertiaTensor = function _setInertiaTensor() {
    this._nativeCollider.setInertiaTensor(this._inertiaTensor);
  };
  _create_class$4(DynamicCollider2, [
    {
      key: "linearDamping",
      get: function get3() {
        return this._linearDamping;
      },
      set: function set(value) {
        if (this._linearDamping !== value) {
          this._linearDamping = value;
          this._nativeCollider.setLinearDamping(value);
        }
      }
    },
    {
      key: "angularDamping",
      get: function get3() {
        return this._angularDamping;
      },
      set: function set(value) {
        if (this._angularDamping !== value) {
          this._angularDamping = value;
          this._nativeCollider.setAngularDamping(value);
        }
      }
    },
    {
      key: "linearVelocity",
      get: function get3() {
        return this._linearVelocity;
      },
      set: function set(value) {
        if (this._linearVelocity !== value) {
          this._linearVelocity.copyFrom(value);
        }
      }
    },
    {
      key: "angularVelocity",
      get: function get3() {
        return this._angularVelocity;
      },
      set: function set(value) {
        if (this._angularVelocity !== value) {
          this._angularVelocity.copyFrom(value);
        }
      }
    },
    {
      key: "mass",
      get: function get3() {
        return this._mass;
      },
      set: function set(value) {
        if (this._mass !== value) {
          this._mass = value;
          this._nativeCollider.setMass(value);
        }
      }
    },
    {
      key: "centerOfMass",
      get: function get3() {
        return this._centerOfMass;
      },
      set: function set(value) {
        if (this._centerOfMass !== value) {
          this._centerOfMass.copyFrom(value);
        }
      }
    },
    {
      key: "inertiaTensor",
      get: function get3() {
        return this._inertiaTensor;
      },
      set: function set(value) {
        if (this._inertiaTensor !== value) {
          this._inertiaTensor.copyFrom(value);
        }
      }
    },
    {
      key: "maxAngularVelocity",
      get: function get3() {
        return this._maxAngularVelocity;
      },
      set: function set(value) {
        if (this._maxAngularVelocity !== value) {
          this._maxAngularVelocity = value;
          this._nativeCollider.setMaxAngularVelocity(value);
        }
      }
    },
    {
      key: "maxDepenetrationVelocity",
      get: function get3() {
        return this._maxDepenetrationVelocity;
      },
      set: function set(value) {
        if (this._maxDepenetrationVelocity !== value) {
          this._maxDepenetrationVelocity = value;
          this._nativeCollider.setMaxDepenetrationVelocity(value);
        }
      }
    },
    {
      key: "sleepThreshold",
      get: function get3() {
        return this._sleepThreshold;
      },
      set: function set(value) {
        if (value !== this._sleepThreshold) {
          this._sleepThreshold = value;
          this._nativeCollider.setSleepThreshold(value);
        }
      }
    },
    {
      key: "solverIterations",
      get: function get3() {
        return this._solverIterations;
      },
      set: function set(value) {
        if (this._solverIterations !== value) {
          this._solverIterations = value;
          this._nativeCollider.setSolverIterations(value);
        }
      }
    },
    {
      key: "isKinematic",
      get: function get3() {
        return this._isKinematic;
      },
      set: function set(value) {
        if (this._isKinematic !== value) {
          this._isKinematic = value;
          this._nativeCollider.setIsKinematic(value);
        }
      }
    },
    {
      key: "constraints",
      get: function get3() {
        return this._constraints;
      },
      set: function set(value) {
        if (this._constraints !== value) {
          this._constraints = value;
          this._nativeCollider.setConstraints(value);
        }
      }
    },
    {
      key: "collisionDetectionMode",
      get: function get3() {
        return this._collisionDetectionMode;
      },
      set: function set(value) {
        if (this._collisionDetectionMode !== value) {
          this._collisionDetectionMode = value;
          this._nativeCollider.setCollisionDetectionMode(value);
        }
      }
    }
  ]);
  return DynamicCollider2;
}(Collider);
var CollisionDetectionMode;
(function(CollisionDetectionMode2) {
  CollisionDetectionMode2[CollisionDetectionMode2["Discrete"] = 0] = "Discrete";
  CollisionDetectionMode2[CollisionDetectionMode2["Continuous"] = 1] = "Continuous";
  CollisionDetectionMode2[CollisionDetectionMode2["ContinuousDynamic"] = 2] = "ContinuousDynamic";
  CollisionDetectionMode2[CollisionDetectionMode2["ContinuousSpeculative"] = 3] = "ContinuousSpeculative";
})(CollisionDetectionMode || (CollisionDetectionMode = {}));
var DynamicColliderConstraints;
(function(DynamicColliderConstraints2) {
  DynamicColliderConstraints2[DynamicColliderConstraints2["None"] = 0] = "None";
  DynamicColliderConstraints2[DynamicColliderConstraints2["FreezePositionX"] = 1] = "FreezePositionX";
  DynamicColliderConstraints2[DynamicColliderConstraints2["FreezePositionY"] = 2] = "FreezePositionY";
  DynamicColliderConstraints2[DynamicColliderConstraints2["FreezePositionZ"] = 4] = "FreezePositionZ";
  DynamicColliderConstraints2[DynamicColliderConstraints2["FreezeRotationX"] = 8] = "FreezeRotationX";
  DynamicColliderConstraints2[DynamicColliderConstraints2["FreezeRotationY"] = 16] = "FreezeRotationY";
  DynamicColliderConstraints2[DynamicColliderConstraints2["FreezeRotationZ"] = 32] = "FreezeRotationZ";
})(DynamicColliderConstraints || (DynamicColliderConstraints = {}));
var PointerButton;
(function(PointerButton2) {
  PointerButton2[PointerButton2["None"] = 0] = "None";
  PointerButton2[PointerButton2["Primary"] = 1] = "Primary";
  PointerButton2[PointerButton2["Secondary"] = 2] = "Secondary";
  PointerButton2[PointerButton2["Auxiliary"] = 4] = "Auxiliary";
  PointerButton2[PointerButton2["XButton1"] = 8] = "XButton1";
  PointerButton2[PointerButton2["XButton2"] = 16] = "XButton2";
  PointerButton2[PointerButton2["XButton3"] = 32] = "XButton3";
  PointerButton2[PointerButton2["XButton4"] = 64] = "XButton4";
  PointerButton2[PointerButton2["XButton5"] = 128] = "XButton5";
  PointerButton2[PointerButton2["XButton6"] = 256] = "XButton6";
  PointerButton2[PointerButton2["XButton7"] = 512] = "XButton7";
  PointerButton2[PointerButton2["XButton8"] = 1024] = "XButton8";
})(PointerButton || (PointerButton = {}));
var _pointerDec2BinMap = [
  1,
  4,
  2,
  8,
  16,
  32,
  64,
  128,
  256,
  512,
  1024
];
var _pointerBin2DecMap = {
  1: 0,
  2: 2,
  4: 1,
  8: 3,
  16: 4,
  32: 5,
  64: 6,
  128: 7,
  256: 8,
  512: 9,
  1024: 10
};
var PointerManager = /* @__PURE__ */ function() {
  function PointerManager2(engine) {
    this._pointers = [];
    this._multiPointerEnabled = true;
    this._buttons = PointerButton.None;
    this._upMap = [];
    this._downMap = [];
    this._upList = new DisorderedArray();
    this._downList = new DisorderedArray();
    this._nativeEvents = [];
    this._hadListener = false;
    var htmlCanvas = engine._canvas._webCanvas;
    this._engine = engine;
    this._canvas = engine.canvas;
    this._htmlCanvas = htmlCanvas;
    this._onPointerEvent = this._onPointerEvent.bind(this);
    this._updatePointerWithPhysics = this._updatePointerWithPhysics.bind(this);
    this._updatePointerWithoutPhysics = this._updatePointerWithoutPhysics.bind(this);
    this._onFocus();
    this._pointerPool = new Array(11);
  }
  var _proto = PointerManager2.prototype;
  _proto._update = function _update() {
    var _this = this, pointers = _this._pointers, nativeEvents = _this._nativeEvents;
    var lastIndex = pointers.length - 1;
    if (lastIndex >= 0) {
      for (var i = lastIndex; i >= 0; i--) {
        if (pointers[i].phase === PointerPhase.Leave) {
          pointers.splice(i, 1);
        }
      }
    }
    lastIndex = nativeEvents.length - 1;
    if (lastIndex >= 0) {
      for (var i1 = 0; i1 <= lastIndex; i1++) {
        var _this__getPointer;
        var evt = nativeEvents[i1];
        (_this__getPointer = this._getPointer(evt.pointerId)) == null ? void 0 : _this__getPointer._events.push(evt);
      }
      nativeEvents.length = 0;
    }
    this._upList.length = this._downList.length = 0;
    this._buttons = PointerButton.None;
    lastIndex = pointers.length - 1;
    if (lastIndex >= 0) {
      var frameCount = this._engine.time.frameCount;
      var updatePointer = this._engine.physicsManager._initialized ? this._updatePointerWithPhysics : this._updatePointerWithoutPhysics;
      var clientRect = this._htmlCanvas.getBoundingClientRect();
      var _this__htmlCanvas = this._htmlCanvas, clientWidth = _this__htmlCanvas.clientWidth, clientHeight = _this__htmlCanvas.clientHeight;
      var _this__canvas = this._canvas, width = _this__canvas.width, height = _this__canvas.height;
      for (var i2 = lastIndex; i2 >= 0; i2--) {
        var pointer = pointers[i2];
        pointer._upList.length = pointer._downList.length = 0;
        updatePointer(frameCount, pointer, clientRect, clientWidth, clientHeight, width, height);
        this._buttons |= pointer.pressedButtons;
      }
    }
  };
  _proto._onFocus = function _onFocus() {
    if (!this._hadListener) {
      var _this = this, htmlCanvas = _this._htmlCanvas, onPointerEvent = _this._onPointerEvent;
      htmlCanvas.addEventListener("pointerdown", onPointerEvent);
      htmlCanvas.addEventListener("pointerup", onPointerEvent);
      htmlCanvas.addEventListener("pointerleave", onPointerEvent);
      htmlCanvas.addEventListener("pointermove", onPointerEvent);
      htmlCanvas.addEventListener("pointercancel", onPointerEvent);
      this._hadListener = true;
    }
  };
  _proto._onBlur = function _onBlur() {
    if (this._hadListener) {
      var _this = this, htmlCanvas = _this._htmlCanvas, onPointerEvent = _this._onPointerEvent;
      htmlCanvas.removeEventListener("pointerdown", onPointerEvent);
      htmlCanvas.removeEventListener("pointerup", onPointerEvent);
      htmlCanvas.removeEventListener("pointerleave", onPointerEvent);
      htmlCanvas.removeEventListener("pointermove", onPointerEvent);
      htmlCanvas.removeEventListener("pointercancel", onPointerEvent);
      this._hadListener = false;
      this._downList.length = 0;
      this._upList.length = 0;
      var _this1 = this, pointers = _this1._pointers;
      for (var i = pointers.length - 1; i >= 0; i--) {
        pointers[i].phase = PointerPhase.Leave;
      }
      pointers.length = 0;
    }
  };
  _proto._destroy = function _destroy() {
    if (this._hadListener) {
      var _this = this, htmlCanvas = _this._htmlCanvas, onPointerEvent = _this._onPointerEvent;
      htmlCanvas.removeEventListener("pointerdown", onPointerEvent);
      htmlCanvas.removeEventListener("pointerup", onPointerEvent);
      htmlCanvas.removeEventListener("pointerleave", onPointerEvent);
      htmlCanvas.removeEventListener("pointermove", onPointerEvent);
      htmlCanvas.removeEventListener("pointercancel", onPointerEvent);
      this._hadListener = false;
    }
    this._pointerPool.length = 0;
    this._pointers.length = 0;
    this._downList.length = 0;
    this._upList.length = 0;
    this._htmlCanvas = null;
    this._engine = null;
  };
  _proto._onPointerEvent = function _onPointerEvent(evt) {
    evt.type === "pointerdown" && this._htmlCanvas.focus();
    this._nativeEvents.push(evt);
  };
  _proto._getIndexByPointerID = function _getIndexByPointerID(pointerId) {
    var _this = this, pointers = _this._pointers;
    for (var i = pointers.length - 1; i >= 0; i--) {
      if (pointers[i]._uniqueID === pointerId) {
        return i;
      }
    }
    return -1;
  };
  _proto._getPointer = function _getPointer(pointerId) {
    var _this = this, pointers = _this._pointers;
    var index = this._getIndexByPointerID(pointerId);
    if (index >= 0) {
      return pointers[index];
    } else {
      var lastCount = pointers.length;
      if (lastCount === 0 || this._multiPointerEnabled) {
        var _this1 = this, pointerPool = _this1._pointerPool;
        var i = 0;
        for (; i < lastCount; i++) {
          if (pointers[i].id > i) {
            break;
          }
        }
        var pointer = pointerPool[i];
        if (!pointer) {
          pointer = pointerPool[i] = new Pointer(i);
        }
        pointer._uniqueID = pointerId;
        pointers.splice(i, 0, pointer);
        return pointer;
      } else {
        return null;
      }
    }
  };
  _proto._pointerRayCast = function _pointerRayCast(normalizedX, normalizedY) {
    var point = PointerManager2._tempPoint, ray = PointerManager2._tempRay, hitResult = PointerManager2._tempHitResult;
    var _this__engine_sceneManager_activeScene = this._engine.sceneManager.activeScene, cameras = _this__engine_sceneManager_activeScene._activeCameras;
    for (var i = cameras.length - 1; i >= 0; i--) {
      var camera = cameras[i];
      if (!camera.enabled || camera.renderTarget) {
        continue;
      }
      var _camera_viewport = camera.viewport, vpX = _camera_viewport.x, vpY = _camera_viewport.y, vpW = _camera_viewport.z, vpH = _camera_viewport.w;
      if (normalizedX >= vpX && normalizedY >= vpY && normalizedX - vpX <= vpW && normalizedY - vpY <= vpH) {
        point.set((normalizedX - vpX) / vpW, (normalizedY - vpY) / vpH);
        if (this._engine.physicsManager.raycast(camera.viewportPointToRay(point, ray), Number.MAX_VALUE, camera.cullingMask, hitResult)) {
          return hitResult.entity;
        } else if (camera.clearFlags & CameraClearFlags.Color) {
          return null;
        }
      }
    }
  };
  _proto._updatePointerWithPhysics = function _updatePointerWithPhysics(frameCount, pointer, rect, clientW, clientH, canvasW, canvasH) {
    var events = pointer._events, position = pointer.position;
    var length2 = events.length;
    if (length2 > 0) {
      var _this = this, _upList = _this._upList, _upMap = _this._upMap, _downList = _this._downList, _downMap = _this._downMap;
      var latestEvent = events[length2 - 1];
      var normalizedX = (latestEvent.clientX - rect.left) / clientW;
      var normalizedY = (latestEvent.clientY - rect.top) / clientH;
      var currX = normalizedX * canvasW;
      var currY = normalizedY * canvasH;
      pointer.deltaPosition.set(currX - position.x, currY - position.y);
      position.set(currX, currY);
      pointer._firePointerDrag();
      var rayCastEntity = this._pointerRayCast(normalizedX, normalizedY);
      pointer._firePointerExitAndEnter(rayCastEntity);
      for (var i = 0; i < length2; i++) {
        var event = events[i];
        var button = event.button;
        pointer.button = _pointerDec2BinMap[button] || PointerButton.None;
        pointer.pressedButtons = event.buttons;
        switch (event.type) {
          case "pointerdown":
            _downList.add(button);
            _downMap[button] = frameCount;
            pointer._downList.add(button);
            pointer._downMap[button] = frameCount;
            pointer.phase = PointerPhase.Down;
            pointer._firePointerDown(rayCastEntity);
            break;
          case "pointerup":
            _upList.add(button);
            _upMap[button] = frameCount;
            pointer._upList.add(button);
            pointer._upMap[button] = frameCount;
            pointer.phase = PointerPhase.Up;
            pointer._firePointerUpAndClick(rayCastEntity);
            break;
          case "pointermove":
            pointer.phase = PointerPhase.Move;
            break;
          case "pointerleave":
          case "pointercancel":
            pointer.phase = PointerPhase.Leave;
            pointer._firePointerExitAndEnter(null);
        }
      }
      pointer._events.length = 0;
    } else {
      pointer.deltaPosition.set(0, 0);
      pointer.phase = PointerPhase.Stationary;
      pointer._firePointerDrag();
      pointer._firePointerExitAndEnter(this._pointerRayCast(position.x / canvasW, position.y / canvasH));
    }
  };
  _proto._updatePointerWithoutPhysics = function _updatePointerWithoutPhysics(frameCount, pointer, rect, clientW, clientH, canvasW, canvasH) {
    var events = pointer._events;
    var length2 = events.length;
    if (length2 > 0) {
      var position = pointer.position;
      var latestEvent = events[length2 - 1];
      var currX = (latestEvent.clientX - rect.left) / clientW * canvasW;
      var currY = (latestEvent.clientY - rect.top) / clientH * canvasH;
      pointer.deltaPosition.set(currX - position.x, currY - position.y);
      position.set(currX, currY);
      pointer.button = _pointerDec2BinMap[latestEvent.button] || PointerButton.None;
      pointer.pressedButtons = latestEvent.buttons;
      var _this = this, _upList = _this._upList, _upMap = _this._upMap, _downList = _this._downList, _downMap = _this._downMap;
      for (var i = 0; i < length2; i++) {
        var button = events[i].button;
        switch (events[i].type) {
          case "pointerdown":
            _downList.add(button);
            _downMap[button] = frameCount;
            pointer._downList.add(button);
            pointer._downMap[button] = frameCount;
            pointer.phase = PointerPhase.Down;
            break;
          case "pointerup":
            _upList.add(button);
            _upMap[button] = frameCount;
            pointer._upList.add(button);
            pointer._upMap[button] = frameCount;
            pointer.phase = PointerPhase.Up;
            break;
          case "pointermove":
            pointer.phase = PointerPhase.Move;
            break;
          case "pointerleave":
          case "pointercancel":
            pointer.phase = PointerPhase.Leave;
        }
      }
      pointer._events.length = 0;
    } else {
      pointer.deltaPosition.set(0, 0);
      pointer.phase = PointerPhase.Stationary;
    }
  };
  return PointerManager2;
}();
(function() {
  PointerManager._tempRay = new Ray();
})();
(function() {
  PointerManager._tempPoint = new Vector2();
})();
(function() {
  PointerManager._tempHitResult = new HitResult();
})();
var WheelManager = /* @__PURE__ */ function() {
  function WheelManager2(engine) {
    this._delta = new Vector3();
    this._nativeEvents = [];
    var htmlCanvas = engine._canvas._webCanvas;
    this._onWheelEvent = this._onWheelEvent.bind(this);
    htmlCanvas.addEventListener("wheel", this._onWheelEvent);
    this._canvas = htmlCanvas;
    this._hadListener = true;
  }
  var _proto = WheelManager2.prototype;
  _proto._update = function _update() {
    var _this = this, delta = _this._delta;
    delta.set(0, 0, 0);
    var _this1 = this, nativeEvents = _this1._nativeEvents;
    if (nativeEvents.length > 0) {
      for (var i = nativeEvents.length - 1; i >= 0; i--) {
        var evt = nativeEvents[i];
        delta.x += evt.deltaX;
        delta.y += evt.deltaY;
        delta.z += evt.deltaZ;
      }
      nativeEvents.length = 0;
    }
  };
  _proto._onFocus = function _onFocus() {
    if (!this._hadListener) {
      this._canvas.addEventListener("wheel", this._onWheelEvent);
      this._hadListener = true;
    }
  };
  _proto._onBlur = function _onBlur() {
    if (this._hadListener) {
      this._canvas.removeEventListener("wheel", this._onWheelEvent);
      this._nativeEvents.length = 0;
      this._delta.set(0, 0, 0);
      this._hadListener = false;
    }
  };
  _proto._destroy = function _destroy() {
    if (this._hadListener) {
      this._canvas.removeEventListener("wheel", this._onWheelEvent);
      this._hadListener = false;
    }
    this._nativeEvents = null;
  };
  _proto._onWheelEvent = function _onWheelEvent(evt) {
    evt.cancelable && evt.preventDefault();
    this._nativeEvents.push(evt);
  };
  return WheelManager2;
}();
var InputManager = /* @__PURE__ */ function() {
  function InputManager2(engine) {
    this._initialized = false;
    this._engine = engine;
    var canvas = engine._canvas._webCanvas;
    if (typeof OffscreenCanvas === "undefined" || !_instanceof$2(canvas, OffscreenCanvas)) {
      this._wheelManager = new WheelManager(engine);
      this._pointerManager = new PointerManager(engine);
      this._keyboardManager = new KeyboardManager(engine);
      this._onBlur = this._onBlur.bind(this);
      window.addEventListener("blur", this._onBlur);
      this._onFocus = this._onFocus.bind(this);
      window.addEventListener("focus", this._onFocus);
      this._initialized = true;
    }
  }
  var _proto = InputManager2.prototype;
  _proto.isKeyHeldDown = function isKeyHeldDown(key) {
    if (this._initialized) {
      if (key === void 0) {
        return this._keyboardManager._curFrameHeldDownList.length > 0;
      } else {
        return this._keyboardManager._curHeldDownKeyToIndexMap[key] != null;
      }
    } else {
      return false;
    }
  };
  _proto.isKeyDown = function isKeyDown(key) {
    if (this._initialized) {
      if (key === void 0) {
        return this._keyboardManager._curFrameDownList.length > 0;
      } else {
        return this._keyboardManager._downKeyToFrameCountMap[key] === this._engine.time.frameCount;
      }
    } else {
      return false;
    }
  };
  _proto.isKeyUp = function isKeyUp(key) {
    if (this._initialized) {
      if (key === void 0) {
        return this._keyboardManager._curFrameUpList.length > 0;
      } else {
        return this._keyboardManager._upKeyToFrameCountMap[key] === this._engine.time.frameCount;
      }
    } else {
      return false;
    }
  };
  _proto.isPointerHeldDown = function isPointerHeldDown(pointerButton) {
    if (this._initialized) {
      if (pointerButton === void 0) {
        return this._pointerManager._buttons !== 0;
      } else {
        return (this._pointerManager._buttons & pointerButton) !== 0;
      }
    } else {
      return false;
    }
  };
  _proto.isPointerDown = function isPointerDown(pointerButton) {
    if (this._initialized) {
      if (pointerButton === void 0) {
        return this._pointerManager._downList.length > 0;
      } else {
        return this._pointerManager._downMap[_pointerBin2DecMap[pointerButton]] === this._engine.time.frameCount;
      }
    } else {
      return false;
    }
  };
  _proto.isPointerUp = function isPointerUp(pointerButton) {
    if (this._initialized) {
      if (pointerButton === void 0) {
        return this._pointerManager._upList.length > 0;
      } else {
        return this._pointerManager._upMap[_pointerBin2DecMap[pointerButton]] === this._engine.time.frameCount;
      }
    } else {
      return false;
    }
  };
  _proto._update = function _update() {
    if (this._initialized) {
      this._wheelManager._update();
      this._pointerManager._update();
      this._keyboardManager._update();
    }
  };
  _proto._destroy = function _destroy() {
    if (this._initialized) {
      window.removeEventListener("blur", this._onBlur);
      window.removeEventListener("focus", this._onFocus);
      this._wheelManager._destroy();
      this._pointerManager._destroy();
      this._keyboardManager._destroy();
    }
  };
  _proto._onBlur = function _onBlur() {
    this._wheelManager._onBlur();
    this._pointerManager._onBlur();
    this._keyboardManager._onBlur();
  };
  _proto._onFocus = function _onFocus() {
    this._wheelManager._onFocus();
    this._pointerManager._onFocus();
    this._keyboardManager._onFocus();
  };
  _create_class$4(InputManager2, [
    {
      key: "pointers",
      get: function get3() {
        return this._initialized ? this._pointerManager._pointers : [];
      }
    },
    {
      key: "multiPointerEnabled",
      get: function get3() {
        return this._initialized ? this._pointerManager._multiPointerEnabled : false;
      },
      set: function set(enabled) {
        this._initialized && (this._pointerManager._multiPointerEnabled = enabled);
      }
    },
    {
      key: "wheelDelta",
      get: function get3() {
        return this._initialized ? this._wheelManager._delta : null;
      }
    }
  ]);
  return InputManager2;
}();
var Light = /* @__PURE__ */ function(Component2) {
  _inherits$2(Light2, Component2);
  function Light2() {
    var _this;
    _this = Component2.apply(this, arguments) || this;
    _this.intensity = 1;
    _this.cullingMask = Layer.Everything;
    _this.shadowType = ShadowType.None;
    _this.shadowBias = 1;
    _this.shadowNormalBias = 1;
    _this.shadowNearPlane = 0.1;
    _this.shadowStrength = 1;
    _this._lightIndex = -1;
    _this._color = new Color$1(1, 1, 1, 1);
    _this._lightColor = new Color$1();
    return _this;
  }
  var _proto = Light2.prototype;
  _proto._getLightIntensityColor = function _getLightIntensityColor() {
    this._lightColor.r = this.color.r * this.intensity;
    this._lightColor.g = this.color.g * this.intensity;
    this._lightColor.b = this.color.b * this.intensity;
    this._lightColor.a = this.color.a * this.intensity;
    return this._lightColor;
  };
  _create_class$4(Light2, [
    {
      key: "color",
      get: function get3() {
        return this._color;
      },
      set: function set(value) {
        if (this._color !== value) {
          this._color.copyFrom(value);
        }
      }
    },
    {
      key: "viewMatrix",
      get: function get3() {
        if (!this._viewMat)
          this._viewMat = new Matrix();
        Matrix.invert(this.entity.transform.worldMatrix, this._viewMat);
        return this._viewMat;
      }
    },
    {
      key: "inverseViewMatrix",
      get: function get3() {
        if (!this._inverseViewMat)
          this._inverseViewMat = new Matrix();
        Matrix.invert(this.viewMatrix, this._inverseViewMat);
        return this._inverseViewMat;
      }
    }
  ]);
  return Light2;
}(Component);
(function() {
  Light._maxLight = 10;
})();
__decorate$2([
  ignoreClone
], Light.prototype, "_lightIndex", void 0);
var DirectLight = /* @__PURE__ */ function(Light2) {
  _inherits$2(DirectLight2, Light2);
  function DirectLight2() {
    var _this;
    _this = Light2.apply(this, arguments) || this;
    _this._reverseDirection = new Vector3();
    return _this;
  }
  var _proto = DirectLight2.prototype;
  _proto._appendData = function _appendData(lightIndex) {
    var cullingMaskStart = lightIndex * 2;
    var colorStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var lightColor = this._getLightIntensityColor();
    var direction = this.direction;
    var data = DirectLight2._combinedData;
    var cullingMask = this.cullingMask;
    data.cullingMask[cullingMaskStart] = cullingMask & 65535;
    data.cullingMask[cullingMaskStart + 1] = cullingMask >>> 16 & 65535;
    if (this.engine.settings.colorSpace === ColorSpace.Linear) {
      data.color[colorStart] = Color$1.gammaToLinearSpace(lightColor.r);
      data.color[colorStart + 1] = Color$1.gammaToLinearSpace(lightColor.g);
      data.color[colorStart + 2] = Color$1.gammaToLinearSpace(lightColor.b);
    } else {
      data.color[colorStart] = lightColor.r;
      data.color[colorStart + 1] = lightColor.g;
      data.color[colorStart + 2] = lightColor.b;
    }
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
  };
  _proto._onEnable = function _onEnable() {
    this.engine._lightManager._attachDirectLight(this);
  };
  _proto._onDisable = function _onDisable() {
    this.engine._lightManager._detachDirectLight(this);
  };
  DirectLight2._updateShaderData = function _updateShaderData(shaderData) {
    var data = DirectLight2._combinedData;
    shaderData.setIntArray(DirectLight2._cullingMaskProperty, data.cullingMask);
    shaderData.setFloatArray(DirectLight2._colorProperty, data.color);
    shaderData.setFloatArray(DirectLight2._directionProperty, data.direction);
  };
  _create_class$4(DirectLight2, [
    {
      key: "direction",
      get: function get3() {
        return this.entity.transform.worldForward;
      }
    },
    {
      key: "reverseDirection",
      get: function get3() {
        Vector3.scale(this.direction, -1, this._reverseDirection);
        return this._reverseDirection;
      }
    },
    {
      key: "_shadowProjectionMatrix",
      get: function get3() {
        throw "Unknown!";
      }
    }
  ]);
  return DirectLight2;
}(Light);
(function() {
  DirectLight._cullingMaskProperty = ShaderProperty.getByName("scene_DirectLightCullingMask");
})();
(function() {
  DirectLight._colorProperty = ShaderProperty.getByName("scene_DirectLightColor");
})();
(function() {
  DirectLight._directionProperty = ShaderProperty.getByName("scene_DirectLightDirection");
})();
(function() {
  DirectLight._combinedData = {
    cullingMask: new Int32Array(Light._maxLight * 2),
    color: new Float32Array(Light._maxLight * 3),
    direction: new Float32Array(Light._maxLight * 3)
  };
})();
var PointLight = /* @__PURE__ */ function(Light2) {
  _inherits$2(PointLight2, Light2);
  function PointLight2() {
    var _this;
    _this = Light2.apply(this, arguments) || this;
    _this.distance = 100;
    return _this;
  }
  var _proto = PointLight2.prototype;
  _proto._appendData = function _appendData(lightIndex) {
    var cullingMaskStart = lightIndex * 2;
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var lightColor = this._getLightIntensityColor();
    var lightPosition = this.position;
    var data = PointLight2._combinedData;
    var cullingMask = this.cullingMask;
    data.cullingMask[cullingMaskStart] = cullingMask & 65535;
    data.cullingMask[cullingMaskStart + 1] = cullingMask >>> 16 & 65535;
    if (this.engine.settings.colorSpace === ColorSpace.Linear) {
      data.color[colorStart] = Color$1.gammaToLinearSpace(lightColor.r);
      data.color[colorStart + 1] = Color$1.gammaToLinearSpace(lightColor.g);
      data.color[colorStart + 2] = Color$1.gammaToLinearSpace(lightColor.b);
    } else {
      data.color[colorStart] = lightColor.r;
      data.color[colorStart + 1] = lightColor.g;
      data.color[colorStart + 2] = lightColor.b;
    }
    data.position[positionStart] = lightPosition.x;
    data.position[positionStart + 1] = lightPosition.y;
    data.position[positionStart + 2] = lightPosition.z;
    data.distance[distanceStart] = this.distance;
  };
  _proto._onEnable = function _onEnable() {
    this.engine._lightManager._attachPointLight(this);
  };
  _proto._onDisable = function _onDisable() {
    this.engine._lightManager._detachPointLight(this);
  };
  PointLight2._updateShaderData = function _updateShaderData(shaderData) {
    var data = PointLight2._combinedData;
    shaderData.setIntArray(PointLight2._cullingMaskProperty, data.cullingMask);
    shaderData.setFloatArray(PointLight2._colorProperty, data.color);
    shaderData.setFloatArray(PointLight2._positionProperty, data.position);
    shaderData.setFloatArray(PointLight2._distanceProperty, data.distance);
  };
  _create_class$4(PointLight2, [
    {
      key: "position",
      get: function get3() {
        return this.entity.transform.worldPosition;
      }
    },
    {
      key: "_shadowProjectionMatrix",
      get: function get3() {
        throw "Unknown!";
      }
    }
  ]);
  return PointLight2;
}(Light);
(function() {
  PointLight._cullingMaskProperty = ShaderProperty.getByName("scene_PointLightCullingMask");
})();
(function() {
  PointLight._colorProperty = ShaderProperty.getByName("scene_PointLightColor");
})();
(function() {
  PointLight._positionProperty = ShaderProperty.getByName("scene_PointLightPosition");
})();
(function() {
  PointLight._distanceProperty = ShaderProperty.getByName("scene_PointLightDistance");
})();
(function() {
  PointLight._combinedData = {
    cullingMask: new Int32Array(Light._maxLight * 2),
    color: new Float32Array(Light._maxLight * 3),
    position: new Float32Array(Light._maxLight * 3),
    distance: new Float32Array(Light._maxLight)
  };
})();
var SpotLight = /* @__PURE__ */ function(Light2) {
  _inherits$2(SpotLight2, Light2);
  function SpotLight2() {
    var _this;
    _this = Light2.apply(this, arguments) || this;
    _this.distance = 100;
    _this.angle = Math.PI / 6;
    _this.penumbra = Math.PI / 12;
    _this._inverseDirection = new Vector3();
    _this._projectMatrix = new Matrix();
    return _this;
  }
  var _proto = SpotLight2.prototype;
  _proto._appendData = function _appendData(lightIndex) {
    var cullingMaskStart = lightIndex * 2;
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var penumbraCosStart = lightIndex;
    var angleCosStart = lightIndex;
    var lightColor = this._getLightIntensityColor();
    var position = this.position;
    var direction = this.direction;
    var data = SpotLight2._combinedData;
    var cullingMask = this.cullingMask;
    data.cullingMask[cullingMaskStart] = cullingMask & 65535;
    data.cullingMask[cullingMaskStart + 1] = cullingMask >>> 16 & 65535;
    if (this.engine.settings.colorSpace === ColorSpace.Linear) {
      data.color[colorStart] = Color$1.gammaToLinearSpace(lightColor.r);
      data.color[colorStart + 1] = Color$1.gammaToLinearSpace(lightColor.g);
      data.color[colorStart + 2] = Color$1.gammaToLinearSpace(lightColor.b);
    } else {
      data.color[colorStart] = lightColor.r;
      data.color[colorStart + 1] = lightColor.g;
      data.color[colorStart + 2] = lightColor.b;
    }
    data.position[positionStart] = position.x;
    data.position[positionStart + 1] = position.y;
    data.position[positionStart + 2] = position.z;
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
    data.distance[distanceStart] = this.distance;
    data.angleCos[angleCosStart] = Math.cos(this.angle);
    data.penumbraCos[penumbraCosStart] = Math.cos(this.angle + this.penumbra);
  };
  _proto._onEnable = function _onEnable() {
    this.engine._lightManager._attachSpotLight(this);
  };
  _proto._onDisable = function _onDisable() {
    this.engine._lightManager._detachSpotLight(this);
  };
  SpotLight2._updateShaderData = function _updateShaderData(shaderData) {
    var data = SpotLight2._combinedData;
    shaderData.setIntArray(SpotLight2._cullingMaskProperty, data.cullingMask);
    shaderData.setFloatArray(SpotLight2._colorProperty, data.color);
    shaderData.setFloatArray(SpotLight2._positionProperty, data.position);
    shaderData.setFloatArray(SpotLight2._directionProperty, data.direction);
    shaderData.setFloatArray(SpotLight2._distanceProperty, data.distance);
    shaderData.setFloatArray(SpotLight2._angleCosProperty, data.angleCos);
    shaderData.setFloatArray(SpotLight2._penumbraCosProperty, data.penumbraCos);
  };
  _create_class$4(SpotLight2, [
    {
      key: "position",
      get: function get3() {
        return this.entity.transform.worldPosition;
      }
    },
    {
      key: "direction",
      get: function get3() {
        return this.entity.transform.worldForward;
      }
    },
    {
      key: "reverseDirection",
      get: function get3() {
        Vector3.scale(this.direction, -1, this._inverseDirection);
        return this._inverseDirection;
      }
    },
    {
      key: "_shadowProjectionMatrix",
      get: function get3() {
        var matrix = this._projectMatrix;
        var fov = Math.min(Math.PI / 2, this.angle * 2 * Math.sqrt(2));
        Matrix.perspective(fov, 1, this.shadowNearPlane, this.distance + this.shadowNearPlane, matrix);
        return matrix;
      }
    }
  ]);
  return SpotLight2;
}(Light);
(function() {
  SpotLight._cullingMaskProperty = ShaderProperty.getByName("scene_SpotLightCullingMask");
})();
(function() {
  SpotLight._colorProperty = ShaderProperty.getByName("scene_SpotLightColor");
})();
(function() {
  SpotLight._positionProperty = ShaderProperty.getByName("scene_SpotLightPosition");
})();
(function() {
  SpotLight._directionProperty = ShaderProperty.getByName("scene_SpotLightDirection");
})();
(function() {
  SpotLight._distanceProperty = ShaderProperty.getByName("scene_SpotLightDistance");
})();
(function() {
  SpotLight._angleCosProperty = ShaderProperty.getByName("scene_SpotLightAngleCos");
})();
(function() {
  SpotLight._penumbraCosProperty = ShaderProperty.getByName("scene_SpotLightPenumbraCos");
})();
(function() {
  SpotLight._combinedData = {
    cullingMask: new Int32Array(Light._maxLight * 2),
    color: new Float32Array(Light._maxLight * 3),
    position: new Float32Array(Light._maxLight * 3),
    direction: new Float32Array(Light._maxLight * 3),
    distance: new Float32Array(Light._maxLight),
    angleCos: new Float32Array(Light._maxLight),
    penumbraCos: new Float32Array(Light._maxLight)
  };
})();
var LightManager = /* @__PURE__ */ function() {
  function LightManager2() {
    this._spotLights = new DisorderedArray();
    this._pointLights = new DisorderedArray();
    this._directLights = new DisorderedArray();
  }
  var _proto = LightManager2.prototype;
  _proto._attachSpotLight = function _attachSpotLight(light) {
    light._lightIndex = this._spotLights.length;
    this._spotLights.add(light);
  };
  _proto._detachSpotLight = function _detachSpotLight(light) {
    var replaced = this._spotLights.deleteByIndex(light._lightIndex);
    replaced && (replaced._lightIndex = light._lightIndex);
    light._lightIndex = -1;
  };
  _proto._attachPointLight = function _attachPointLight(light) {
    light._lightIndex = this._pointLights.length;
    this._pointLights.add(light);
  };
  _proto._detachPointLight = function _detachPointLight(light) {
    var replaced = this._pointLights.deleteByIndex(light._lightIndex);
    replaced && (replaced._lightIndex = light._lightIndex);
    light._lightIndex = -1;
  };
  _proto._attachDirectLight = function _attachDirectLight(light) {
    light._lightIndex = this._directLights.length;
    this._directLights.add(light);
  };
  _proto._detachDirectLight = function _detachDirectLight(light) {
    var replaced = this._directLights.deleteByIndex(light._lightIndex);
    replaced && (replaced._lightIndex = light._lightIndex);
    light._lightIndex = -1;
  };
  _proto._updateSunLightIndex = function _updateSunLightIndex() {
    var directLights = this._directLights;
    var index = this._getSunLightIndex();
    if (index > 0) {
      var firstLight = directLights.get(0);
      var sunLight = directLights.get(index);
      directLights.set(0, sunLight);
      directLights.set(index, firstLight);
      sunLight._lightIndex = 0;
      firstLight._lightIndex = index;
    }
  };
  _proto._updateShaderData = function _updateShaderData(shaderData) {
    var spotLight = this._spotLights;
    var pointLight = this._pointLights;
    var directLight = this._directLights;
    var spotLightCount = spotLight.length;
    var pointLightCount = pointLight.length;
    var directLightCount = directLight.length;
    for (var i = 0, len = spotLightCount; i < len; i++) {
      var light = spotLight.get(i);
      light._appendData(i);
    }
    for (var i1 = 0, len1 = pointLightCount; i1 < len1; i1++) {
      var light1 = pointLight.get(i1);
      light1._appendData(i1);
    }
    for (var i2 = 0, len2 = directLightCount; i2 < len2; i2++) {
      var light2 = directLight.get(i2);
      light2._appendData(i2);
    }
    if (directLightCount) {
      DirectLight._updateShaderData(shaderData);
      shaderData.enableMacro("SCENE_DIRECT_LIGHT_COUNT", directLightCount.toString());
    } else {
      shaderData.disableMacro("SCENE_DIRECT_LIGHT_COUNT");
    }
    if (pointLightCount) {
      PointLight._updateShaderData(shaderData);
      shaderData.enableMacro("SCENE_POINT_LIGHT_COUNT", pointLightCount.toString());
    } else {
      shaderData.disableMacro("SCENE_POINT_LIGHT_COUNT");
    }
    if (spotLightCount) {
      SpotLight._updateShaderData(shaderData);
      shaderData.enableMacro("SCENE_SPOT_LIGHT_COUNT", spotLightCount.toString());
    } else {
      shaderData.disableMacro("SCENE_SPOT_LIGHT_COUNT");
    }
  };
  _proto._gc = function _gc() {
    this._spotLights.garbageCollection();
    this._pointLights.garbageCollection();
    this._directLights.garbageCollection();
  };
  _proto._getSunLightIndex = function _getSunLightIndex() {
    var directLights = this._directLights;
    var sunLightIndex = -1;
    var maxIntensity = Number.NEGATIVE_INFINITY;
    var hasShadowLight = false;
    for (var i = 0, n = directLights.length; i < n; i++) {
      var directLight = directLights.get(i);
      if (directLight.shadowType !== ShadowType.None && !hasShadowLight) {
        maxIntensity = Number.NEGATIVE_INFINITY;
        hasShadowLight = true;
      }
      var intensity = directLight.intensity * directLight.color.getBrightness();
      if (hasShadowLight) {
        if (directLight.shadowType !== ShadowType.None && maxIntensity < intensity) {
          maxIntensity = intensity;
          sunLightIndex = i;
        }
      } else {
        if (maxIntensity < intensity) {
          maxIntensity = intensity;
          sunLightIndex = i;
        }
      }
    }
    return sunLightIndex;
  };
  return LightManager2;
}();
var Material = /* @__PURE__ */ function(ReferResource2) {
  _inherits$2(Material2, ReferResource2);
  function Material2(engine, shader) {
    var _this;
    _this = ReferResource2.call(this, engine) || this;
    _this._renderStates = [];
    _this._shaderData = new ShaderData(ShaderDataGroup.Material);
    _this.shader = shader;
    return _this;
  }
  var _proto = Material2.prototype;
  _proto.clone = function clone() {
    var dest = new Material2(this._engine, this.shader);
    this.cloneTo(dest);
    return dest;
  };
  _proto.cloneTo = function cloneTo(target) {
    target.shader = this.shader;
    this.shaderData.cloneTo(target.shaderData);
    CloneManager.deepCloneObject(this.renderStates, target.renderStates);
  };
  _proto._addReferCount = function _addReferCount(value) {
    if (this._destroyed)
      return;
    ReferResource2.prototype._addReferCount.call(this, value);
    this.shaderData._addReferCount(value);
  };
  _proto._onDestroy = function _onDestroy() {
    ReferResource2.prototype._onDestroy.call(this);
    this._shader = null;
    this._shaderData = null;
    this._renderStates.length = 0;
    this._renderStates = null;
  };
  _create_class$4(Material2, [
    {
      key: "shaderData",
      get: function get3() {
        return this._shaderData;
      }
    },
    {
      key: "shader",
      get: function get3() {
        return this._shader;
      },
      set: function set(value) {
        this._shader = value;
        var renderStates = this._renderStates;
        var lastStatesCount = renderStates.length;
        var maxPassCount = 0;
        var subShaders = value.subShaders;
        for (var i = 0; i < subShaders.length; i++) {
          maxPassCount = Math.max(subShaders[i].passes.length, maxPassCount);
        }
        if (lastStatesCount < maxPassCount) {
          for (var i1 = lastStatesCount; i1 < maxPassCount; i1++) {
            renderStates.push(new RenderState());
          }
        } else {
          renderStates.length = maxPassCount;
        }
      }
    },
    {
      key: "renderState",
      get: function get3() {
        return this._renderStates[0];
      }
    },
    {
      key: "renderStates",
      get: function get3() {
        return this._renderStates;
      }
    }
  ]);
  return Material2;
}(ReferResource);
var backgroundTextureFs = "#define GLSLIFY 1\nuniform sampler2D material_BaseTexture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(material_BaseTexture,v_uv);}";
var backgroundTextureVs = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
var blinnPhongFs = "#define GLSLIFY 1\n#include <common>\n#include <camera_declare>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <ShadowFragmentDeclaration>\n#include <mobile_material_frag>\n#include <FogFragmentDeclaration>\n#include <normal_get>\nvoid main(){\n#include <begin_mobile_frag>\n#include <begin_viewdir_frag>\n#include <mobile_blinnphong_frag>\ngl_FragColor=emission+ambient+diffuse+specular;\n#ifdef MATERIAL_IS_TRANSPARENT\ngl_FragColor.a=diffuse.a;\n#else\ngl_FragColor.a=1.0;\n#endif\n#include <FogFragment>\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}";
var blinnPhongVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <position_vert>\n#include <ShadowVertex>\n#include <FogVertex>\n}";
var particleFs = "#define GLSLIFY 1\nvarying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;uniform sampler2D u_texture;void main(){if(v_lifeLeft==1.0){discard;}float alphaFactor=1.0;\n#ifdef fadeIn\nfloat fadeInFactor=step(0.5,v_lifeLeft);alphaFactor=2.0*fadeInFactor*(1.0-v_lifeLeft)+(1.0-fadeInFactor);\n#endif\n#ifdef fadeOut\nfloat fadeOutFactor=step(0.5,v_lifeLeft);alphaFactor=alphaFactor*2.0*(1.0-fadeOutFactor)*v_lifeLeft+alphaFactor*fadeOutFactor;\n#endif\n#ifdef particleTexture\nvec4 tex=texture2D(u_texture,v_uv);\n#ifdef useOriginColor\ngl_FragColor=vec4(tex.rgb,alphaFactor*tex.a*v_color.w);\n#else\ngl_FragColor=vec4(v_color.xyz*tex.rgb,alphaFactor*tex.a*v_color.w);\n#endif\n#else\ngl_FragColor=vec4(v_color.xyz,alphaFactor*v_color.w);\n#endif\n}";
var particleVs = "#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_velocity;attribute vec3 a_acceleration;attribute vec4 a_color;attribute vec4 a_lifeAndSize;attribute vec2 a_rotation;attribute vec3 a_uv;attribute vec2 a_normalizedUv;uniform float u_time;uniform bool u_once;uniform mat4 renderer_MVPMat;varying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;\n#ifdef is2d\nuniform mat4 camera_ViewInvMat;uniform mat4 camera_ProjMat;uniform mat4 camera_ViewMat;uniform mat4 renderer_ModelMat;\n#endif\nmat2 rotation2d(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_color=a_color;v_uv=a_uv.xy;float life=a_lifeAndSize.y;float startTime=a_lifeAndSize.x;float deltaTime=max(mod(u_time-startTime,life),0.0);if((u_once&&u_time>life+startTime)){deltaTime=0.0;}v_lifeLeft=1.0-deltaTime/life;float scale=a_lifeAndSize.z;vec3 position=a_position+(a_velocity+a_acceleration*deltaTime*0.5)*deltaTime;\n#ifdef isScaleByLifetime\nscale*=v_lifeLeft;\n#else\nscale*=pow(a_lifeAndSize.w,deltaTime);\n#endif\n#ifdef rotateToVelocity\nvec3 v=a_velocity+a_acceleration*deltaTime;float angle=atan(v.z,v.x)*2.0;\n#else\nfloat deltaAngle=deltaTime*a_rotation.y;float angle=a_rotation.x+deltaAngle;\n#endif\n#ifdef is2d\nvec2 rotatedPoint=rotation2d(angle)*vec2(a_normalizedUv.x,a_normalizedUv.y*a_uv.z);vec3 basisX=camera_ViewInvMat[0].xyz;vec3 basisZ=camera_ViewInvMat[1].xyz;vec3 localPosition=vec3(basisX*rotatedPoint.x+basisZ*rotatedPoint.y)*scale+position;gl_Position=camera_ProjMat*camera_ViewMat*vec4(localPosition+renderer_ModelMat[3].xyz,1.);\n#else\n#ifdef rotateToVelocity\nfloat s=sin(angle);float c=cos(angle);\n#else\nfloat s=sin(angle);float c=cos(angle);\n#endif\nvec4 rotatedPoint=vec4((a_normalizedUv.x*c+a_normalizedUv.y*a_uv.z*s)*scale,0.,(a_normalizedUv.x*s-a_normalizedUv.y*a_uv.z*c)*scale,1.);vec4 orientation=vec4(0,0,0,1);vec4 q2=orientation+orientation;vec4 qx=orientation.xxxw*q2.xyzx;vec4 qy=orientation.xyyw*q2.xyzy;vec4 qz=orientation.xxzw*q2.xxzz;mat4 localMatrix=mat4((1.0-qy.y)-qz.z,qx.y+qz.w,qx.z-qy.w,0,qx.y-qz.w,(1.0-qx.x)-qz.z,qy.z+qx.w,0,qx.z+qy.w,qy.z-qx.w,(1.0-qx.x)-qy.y,0,position.x,position.y,position.z,1);rotatedPoint=localMatrix*rotatedPoint;gl_Position=renderer_MVPMat*rotatedPoint;\n#endif\n}";
var pbrSpecularFs = "#define GLSLIFY 1\n#include <common>\n#include <camera_declare>\n#include <FogFragmentDeclaration>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <FogFragment>\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}";
var pbrFs = "#define GLSLIFY 1\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <camera_declare>\n#include <FogFragmentDeclaration>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <FogFragment>\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}";
var pbrVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <position_vert>\n#include <ShadowVertex>\n#include <FogVertex>\n}";
var shadowMapFs = "#define GLSLIFY 1\n#ifdef ENGINE_NO_DEPTH_TEXTURE\nvec4 pack(float depth){const vec4 bitShift=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);const vec4 bitMask=vec4(1.0/256.0,1.0/256.0,1.0/256.0,0.0);vec4 rgbaDepth=fract(depth*bitShift);rgbaDepth-=rgbaDepth.gbaa*bitMask;return rgbaDepth;}\n#endif\nvoid main(){\n#ifdef ENGINE_NO_DEPTH_TEXTURE\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(0.0,0.0,0.0,0.0);\n#endif\n}";
var shadowMapVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <normal_share>\nuniform mat4 camera_VPMat;uniform vec2 scene_ShadowBias;uniform vec3 scene_LightDirection;vec3 applyShadowBias(vec3 positionWS){positionWS-=scene_LightDirection*scene_ShadowBias.x;return positionWS;}vec3 applyShadowNormalBias(vec3 positionWS,vec3 normalWS){float invNdotL=1.0-clamp(dot(-scene_LightDirection,normalWS),0.0,1.0);float scale=invNdotL*scene_ShadowBias.y;positionWS+=normalWS*vec3(scale);return positionWS;}void main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\nvec4 positionWS=renderer_ModelMat*position;positionWS.xyz=applyShadowBias(positionWS.xyz);\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nvec3 normalWS=normalize(mat3(renderer_NormalMat)*normal);positionWS.xyz=applyShadowNormalBias(positionWS.xyz,normalWS);\n#endif\n#endif\nvec4 positionCS=camera_VPMat*positionWS;positionCS.z=max(positionCS.z,-1.0);gl_Position=positionCS;}";
var skyboxFs = "#define GLSLIFY 1\n#include <common>\nuniform samplerCube material_CubeTexture;varying vec3 v_cubeUV;uniform float material_Exposure;uniform vec4 material_TintColor;void main(){vec4 textureColor=textureCube(material_CubeTexture,v_cubeUV);\n#ifdef MATERIAL_IS_DECODE_SKY_RGBM\ntextureColor=RGBMToLinear(textureColor,5.0);\n#elif !defined(ENGINE_IS_COLORSPACE_GAMMA)\ntextureColor=gammaToLinear(textureColor);\n#endif\ntextureColor.rgb*=material_Exposure*material_TintColor.rgb;gl_FragColor=textureColor;\n#if defined(MATERIAL_IS_DECODE_SKY_RGBM) || !defined(ENGINE_IS_COLORSPACE_GAMMA)\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}";
var skyboxVs = "#define GLSLIFY 1\n#include <common_vert>\nuniform mat4 camera_VPMat;varying vec3 v_cubeUV;uniform float material_Rotation;vec4 rotateY(vec4 v,float angle){const float deg2rad=3.1415926/180.0;float radian=angle*deg2rad;float sina=sin(radian);float cosa=cos(radian);mat2 m=mat2(cosa,-sina,sina,cosa);return vec4(m*v.xz,v.yw).xzyw;}void main(){v_cubeUV=vec3(-POSITION.x,POSITION.yz);gl_Position=camera_VPMat*rotateY(vec4(POSITION,1.0),material_Rotation);}";
var skyProceduralFs = "#define GLSLIFY 1\n#include <common>\nconst float MIE_G=-0.990;const float MIE_G2=0.9801;const float SKY_GROUND_THRESHOLD=0.02;uniform float material_SunSize;uniform float material_SunSizeConvergence;uniform vec4 scene_SunlightColor;uniform vec3 scene_SunlightDirection;varying vec3 v_GroundColor;varying vec3 v_SkyColor;\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nvarying vec3 v_Vertex;\n#elif defined(MATERIAL_SUN_SIMPLE)\nvarying vec3 v_RayDir;\n#else\nvarying float v_SkyGroundFactor;\n#endif\n#if defined(MATERIAL_SUN_HIGH_QUALITY)||defined(MATERIAL_SUN_SIMPLE)\nvarying vec3 v_SunColor;\n#endif\n#if defined(ENGINE_IS_COLORSPACE_GAMMA)\n#define LINEAR_2_OUTPUT(color) sqrt(color)\n#endif\nfloat getMiePhase(float eyeCos,float eyeCos2){float temp=1.0+MIE_G2-2.0*MIE_G*eyeCos;temp=pow(temp,pow(material_SunSize,0.65)*10.0);temp=max(temp,1.0e-4);temp=1.5*((1.0-MIE_G2)/(2.0+MIE_G2))*(1.0+eyeCos2)/temp;return temp;}float calcSunAttenuation(vec3 lightPos,vec3 ray){\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nfloat focusedEyeCos=pow(clamp(dot(lightPos,ray),0.0,1.0),material_SunSizeConvergence);return getMiePhase(-focusedEyeCos,focusedEyeCos*focusedEyeCos);\n#else\nvec3 delta=lightPos-ray;float dist=length(delta);float spot=1.0-smoothstep(0.0,material_SunSize,dist);return spot*spot;\n#endif\n}void main(){vec3 col=vec3(0.0,0.0,0.0);\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nvec3 ray=normalize(v_Vertex);float y=ray.y/SKY_GROUND_THRESHOLD;\n#elif defined(MATERIAL_SUN_SIMPLE)\nvec3 ray=v_RayDir;float y=ray.y/SKY_GROUND_THRESHOLD;\n#else\nfloat y=v_SkyGroundFactor;\n#endif\ncol=mix(v_SkyColor,v_GroundColor,clamp(y,0.0,1.0));\n#if defined(MATERIAL_SUN_HIGH_QUALITY)||defined(MATERIAL_SUN_SIMPLE)\nif(y<0.0)col+=v_SunColor*calcSunAttenuation(-scene_SunlightDirection,-ray);\n#endif\n#ifdef ENGINE_IS_COLORSPACE_GAMMA\ncol=LINEAR_2_OUTPUT(col);\n#endif\ngl_FragColor=vec4(col,1.0);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}";
var skyProceduralVs = "#define GLSLIFY 1\n#define OUTER_RADIUS 1.025\n#define RAYLEIGH (mix(0.0, 0.0025, pow(material_AtmosphereThickness,2.5)))\n#define MIE 0.0010\n#define SUN_BRIGHTNESS 20.0\n#define MAX_SCATTER 50.0\nconst float SKY_GROUND_THRESHOLD=0.02;const float outerRadius=OUTER_RADIUS;const float outerRadius2=OUTER_RADIUS*OUTER_RADIUS;const float innerRadius=1.0;const float innerRadius2=1.0;const float cameraHeight=0.0001;const float HDSundiskIntensityFactor=15.0;const float simpleSundiskIntensityFactor=27.0;const float sunScale=400.0*SUN_BRIGHTNESS;const float kmESun=MIE*SUN_BRIGHTNESS;const float km4PI=MIE*4.0*3.14159265;const float scale=1.0/(OUTER_RADIUS-1.0);const float scaleDepth=0.25;const float scaleOverScaleDepth=(1.0/(OUTER_RADIUS-1.0))/0.25;const float samples=2.0;const vec3 c_DefaultScatteringWavelength=vec3(0.65,0.57,0.475);const vec3 c_VariableRangeForScatteringWavelength=vec3(0.15,0.15,0.15);attribute vec4 POSITION;uniform mat4 camera_VPMat;uniform vec3 material_SkyTint;uniform vec3 material_GroundTint;uniform float material_Exposure;uniform float material_AtmosphereThickness;uniform vec4 scene_SunlightColor;uniform vec3 scene_SunlightDirection;varying vec3 v_GroundColor;varying vec3 v_SkyColor;\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nvarying vec3 v_Vertex;\n#elif defined(MATERIAL_SUN_SIMPLE)\nvarying vec3 v_RayDir;\n#else\nvarying float v_SkyGroundFactor;\n#endif\n#if defined(MATERIAL_SUN_HIGH_QUALITY)||defined(MATERIAL_SUN_SIMPLE)\nvarying vec3 v_SunColor;\n#endif\n#if defined(ENGINE_IS_COLORSPACE_GAMMA)\n#define COLOR_2_GAMMA(color) color\n#define COLOR_2_LINEAR(color) color*color\n#else\n#define GAMMA 2.2\n#define COLOR_2_GAMMA(color) pow(color,vec3(1.0/GAMMA))\n#define COLOR_2_LINEAR(color) color\n#endif\nfloat getRayleighPhase(vec3 light,vec3 ray){float eyeCos=dot(light,ray);return 0.75+0.75*eyeCos*eyeCos;}float scaleAngle(float inCos){float x=1.0-inCos;return 0.25*exp(-0.00287+x*(0.459+x*(3.83+x*(-6.80+x*5.25))));}void main(){gl_Position=camera_VPMat*vec4(POSITION.xyz,1.0);vec3 skyTintInGammaSpace=COLOR_2_GAMMA(material_SkyTint);vec3 scatteringWavelength=mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0)-skyTintInGammaSpace);vec3 invWavelength=1.0/pow(scatteringWavelength,vec3(4.0));float krESun=RAYLEIGH*SUN_BRIGHTNESS;float kr4PI=RAYLEIGH*4.0*3.14159265;vec3 cameraPos=vec3(0.0,innerRadius+cameraHeight,0.0);vec3 eyeRay=normalize(POSITION.xyz);float far=0.0;vec3 cIn,cOut;if(eyeRay.y>=0.0){far=sqrt(outerRadius2+innerRadius2*eyeRay.y*eyeRay.y-innerRadius2)-innerRadius*eyeRay.y;float height=innerRadius+cameraHeight;float depth=exp(scaleOverScaleDepth*-cameraHeight);float startAngle=dot(eyeRay,cameraPos)/height;float startOffset=depth*scaleAngle(startAngle);float sampleLength=far/samples;float scaledLength=sampleLength*scale;vec3 sampleRay=eyeRay*sampleLength;vec3 samplePoint=cameraPos+sampleRay*0.5;vec3 frontColor=vec3(0.0);{float height=length(samplePoint);float depth=exp(scaleOverScaleDepth*(innerRadius-height));float lightAngle=dot(-scene_SunlightDirection,samplePoint)/height;float cameraAngle=dot(eyeRay,samplePoint)/height;float scatter=(startOffset+depth*(scaleAngle(lightAngle)-scaleAngle(cameraAngle)));vec3 attenuate=exp(-clamp(scatter,0.0,MAX_SCATTER)*(invWavelength*kr4PI+km4PI));frontColor+=attenuate*(depth*scaledLength);samplePoint+=sampleRay;}{float height=length(samplePoint);float depth=exp(scaleOverScaleDepth*(innerRadius-height));float lightAngle=dot(-scene_SunlightDirection,samplePoint)/height;float cameraAngle=dot(eyeRay,samplePoint)/height;float scatter=(startOffset+depth*(scaleAngle(lightAngle)-scaleAngle(cameraAngle)));vec3 attenuate=exp(-clamp(scatter,0.0,MAX_SCATTER)*(invWavelength*kr4PI+km4PI));frontColor+=attenuate*(depth*scaledLength);samplePoint+=sampleRay;}cIn=frontColor*(invWavelength*krESun);cOut=frontColor*kmESun;}else{far=(-cameraHeight)/(min(-0.001,eyeRay.y));vec3 pos=cameraPos+far*eyeRay;float depth=exp((-cameraHeight)*(1.0/scaleDepth));float cameraAngle=dot(-eyeRay,pos);float lightAngle=dot(-scene_SunlightDirection,pos);float cameraScale=scaleAngle(cameraAngle);float lightScale=scaleAngle(lightAngle);float cameraOffset=depth*cameraScale;float temp=lightScale+cameraScale;float sampleLength=far/samples;float scaledLength=sampleLength*scale;vec3 sampleRay=eyeRay*sampleLength;vec3 samplePoint=cameraPos+sampleRay*0.5;vec3 frontColor=vec3(0.0,0.0,0.0);vec3 attenuate;{float height=length(samplePoint);float depth=exp(scaleOverScaleDepth*(innerRadius-height));float scatter=depth*temp-cameraOffset;attenuate=exp(-clamp(scatter,0.0,MAX_SCATTER)*(invWavelength*kr4PI+km4PI));frontColor+=attenuate*(depth*scaledLength);samplePoint+=sampleRay;}cIn=frontColor*(invWavelength*krESun+kmESun);cOut=clamp(attenuate,0.0,1.0);}\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nv_Vertex=-POSITION.xyz;\n#elif defined(MATERIAL_SUN_SIMPLE)\nv_RayDir=-eyeRay;\n#else\nv_SkyGroundFactor=-eyeRay.y/SKY_GROUND_THRESHOLD;\n#endif\nv_GroundColor=material_Exposure*(cIn+COLOR_2_LINEAR(material_GroundTint)*cOut);v_SkyColor=material_Exposure*(cIn*getRayleighPhase(-scene_SunlightDirection,-eyeRay));float lightColorIntensity=clamp(length(scene_SunlightColor.xyz),0.25,1.0);\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nv_SunColor=HDSundiskIntensityFactor*clamp(cOut,0.0,1.0)*scene_SunlightColor.xyz/lightColorIntensity;\n#elif defined(MATERIAL_SUN_SIMPLE)\nv_SunColor=simpleSundiskIntensityFactor*clamp(cOut*sunScale,0.0,1.0)*scene_SunlightColor.xyz/lightColorIntensity;\n#endif\n}";
var spriteMaskFs = "#define GLSLIFY 1\nuniform sampler2D renderer_MaskTexture;uniform float renderer_MaskAlphaCutoff;varying vec2 v_uv;void main(){vec4 color=texture2D(renderer_MaskTexture,v_uv);if(color.a<renderer_MaskAlphaCutoff){discard;}gl_FragColor=color;}";
var spriteMaskVs = "#define GLSLIFY 1\nuniform mat4 camera_VPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=camera_VPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
var spriteFs = "#define GLSLIFY 1\nuniform sampler2D renderer_SpriteTexture;varying vec2 v_uv;varying vec4 v_color;void main(){vec4 baseColor=texture2D(renderer_SpriteTexture,v_uv);gl_FragColor=baseColor*v_color;}";
var spriteVs = "#define GLSLIFY 1\nuniform mat4 renderer_MVPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;attribute vec4 COLOR_0;varying vec2 v_uv;varying vec4 v_color;void main(){gl_Position=renderer_MVPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;v_color=COLOR_0;}";
var unlitFs = "#define GLSLIFY 1\n#include <common>\n#include <uv_share>\n#include <FogFragmentDeclaration>\nuniform vec4 material_BaseColor;uniform float material_AlphaCutoff;\n#ifdef MATERIAL_HAS_BASETEXTURE\nuniform sampler2D material_BaseTexture;\n#endif\nvoid main(){vec4 baseColor=material_BaseColor;\n#ifdef MATERIAL_HAS_BASETEXTURE\nvec4 textureColor=texture2D(material_BaseTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ntextureColor=gammaToLinear(textureColor);\n#endif\nbaseColor*=textureColor;\n#endif\n#ifdef MATERIAL_IS_ALPHA_CUTOFF\nif(baseColor.a<material_AlphaCutoff){discard;}\n#endif\ngl_FragColor=baseColor;\n#ifndef MATERIAL_IS_TRANSPARENT\ngl_FragColor.a=1.0;\n#endif\n#include <FogFragment>\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}";
var unlitVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <FogVertexDeclaration>\nvoid main(){\n#include <begin_position_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <position_vert>\n#include <FogVertex>\n}";
var ShaderPool = /* @__PURE__ */ function() {
  function ShaderPool2() {
  }
  ShaderPool2.init = function init() {
    var shadowCasterPassTags = {
      pipelineStage: PipelineStage.ShadowCaster
    };
    var forwardPassTags = {
      pipelineStage: PipelineStage.Forward
    };
    var shadowCasterPass = new ShaderPass(shadowMapVs, shadowMapFs, shadowCasterPassTags);
    Shader.create("blinn-phong", [
      new ShaderPass(blinnPhongVs, blinnPhongFs, forwardPassTags),
      shadowCasterPass
    ]);
    Shader.create("pbr", [
      new ShaderPass(pbrVs, pbrFs, forwardPassTags),
      shadowCasterPass
    ]);
    Shader.create("pbr-specular", [
      new ShaderPass(pbrVs, pbrSpecularFs, forwardPassTags),
      shadowCasterPass
    ]);
    Shader.create("unlit", [
      new ShaderPass(unlitVs, unlitFs, forwardPassTags),
      shadowCasterPass
    ]);
    Shader.create("skybox", [
      new ShaderPass(skyboxVs, skyboxFs, forwardPassTags)
    ]);
    Shader.create("SkyProcedural", [
      new ShaderPass(skyProceduralVs, skyProceduralFs, forwardPassTags)
    ]);
    Shader.create("particle-shader", [
      new ShaderPass(particleVs, particleFs, forwardPassTags)
    ]);
    Shader.create("SpriteMask", [
      new ShaderPass(spriteMaskVs, spriteMaskFs, forwardPassTags)
    ]);
    Shader.create("Sprite", [
      new ShaderPass(spriteVs, spriteFs, forwardPassTags)
    ]);
    Shader.create("background-texture", [
      new ShaderPass(backgroundTextureVs, backgroundTextureFs, forwardPassTags)
    ]);
  };
  return ShaderPool2;
}();
var ShaderProgramPool = /* @__PURE__ */ function() {
  function ShaderProgramPool2() {
    this._cacheHierarchy = 1;
    this._cacheMap = /* @__PURE__ */ Object.create(null);
  }
  var _proto = ShaderProgramPool2.prototype;
  _proto.get = function get3(macros) {
    var cacheMap = this._cacheMap;
    var maskLength = macros._length;
    if (maskLength > this._cacheHierarchy) {
      this._resizeCacheMapHierarchy(cacheMap, 0, maskLength);
    }
    var mask = macros._mask;
    var endIndex = macros._length - 1;
    var maxEndIndex = this._cacheHierarchy - 1;
    for (var i = 0; i < maxEndIndex; i++) {
      var subMask = endIndex < i ? 0 : mask[i];
      var subCacheShaders = cacheMap[subMask];
      subCacheShaders || (cacheMap[subMask] = subCacheShaders = /* @__PURE__ */ Object.create(null));
      cacheMap = subCacheShaders;
    }
    var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
    var shader = cacheMap[cacheKey];
    if (!shader) {
      this._lastQueryKey = cacheKey;
      this._lastQueryMap = cacheMap;
    }
    return shader;
  };
  _proto.cache = function cache(shaderProgram) {
    this._lastQueryMap[this._lastQueryKey] = shaderProgram;
  };
  _proto._resizeCacheMapHierarchy = function _resizeCacheMapHierarchy(cacheMap, hierarchy, resizeLength) {
    var end = this._cacheHierarchy - 1;
    if (hierarchy == end) {
      for (var k2 in cacheMap) {
        var shader = cacheMap[k2];
        var subCacheMap = cacheMap;
        for (var i = 0, n = resizeLength - end; i < n; i++) {
          if (i == n - 1) {
            subCacheMap[0] = shader;
          } else {
            subCacheMap = subCacheMap[i == 0 ? k2 : 0] = /* @__PURE__ */ Object.create(null);
          }
        }
      }
      this._cacheHierarchy = resizeLength;
    } else {
      for (var k1 in cacheMap) {
        this._resizeCacheMapHierarchy(cacheMap[k1], ++hierarchy, resizeLength);
      }
    }
  };
  return ShaderProgramPool2;
}();
ShaderPool.init();
var Engine = /* @__PURE__ */ function(EventDispatcher2) {
  _inherits$2(Engine2, EventDispatcher2);
  function Engine2(canvas, hardwareRenderer, configuration) {
    var _this;
    _this = EventDispatcher2.call(this) || this;
    _this._lightManager = new LightManager();
    _this._componentsManager = new ComponentsManager();
    _this._lastRenderState = new RenderState();
    _this._renderElementPool = new ClassPool(RenderElement);
    _this._meshRenderDataPool = new ClassPool(MeshRenderData);
    _this._spriteRenderDataPool = new ClassPool(SpriteRenderData);
    _this._spriteMaskRenderDataPool = new ClassPool(SpriteMaskRenderData);
    _this._textRenderDataPool = new ClassPool(TextRenderData);
    _this._renderContext = new RenderContext();
    _this._renderCount = 0;
    _this._shaderProgramPools = [];
    _this._canSpriteBatch = true;
    _this._fontMap = {};
    _this._macroCollection = new ShaderMacroCollection();
    _this._settings = {};
    _this._resourceManager = new ResourceManager(_assert_this_initialized(_this));
    _this._sceneManager = new SceneManager(_assert_this_initialized(_this));
    _this._vSyncCount = 1;
    _this._targetFrameRate = 60;
    _this._time = new Time();
    _this._isPaused = true;
    _this._vSyncCounter = 1;
    _this._targetFrameInterval = 1e3 / 60;
    _this._destroyed = false;
    _this._frameInProcess = false;
    _this._waitingDestroy = false;
    _this._isDeviceLost = false;
    _this._waitingGC = false;
    _this._animate = function() {
      if (_this._vSyncCount) {
        _this._requestId = requestAnimationFrame(_this._animate);
        if (_this._vSyncCounter++ % _this._vSyncCount === 0) {
          _this.update();
          _this._vSyncCounter = 1;
        }
      } else {
        _this._timeoutId = window.setTimeout(_this._animate, _this._targetFrameInterval);
        _this.update();
      }
    };
    _this._hardwareRenderer = hardwareRenderer;
    _this._hardwareRenderer.init(canvas, _this._onDeviceLost.bind(_assert_this_initialized(_this)), _this._onDeviceRestored.bind(_assert_this_initialized(_this)));
    _this.physicsManager = new PhysicsManager(_assert_this_initialized(_this));
    _this._canvas = canvas;
    _this._sceneManager.activeScene = new Scene$1(_assert_this_initialized(_this), "DefaultScene");
    _this._spriteMaskManager = new SpriteMaskManager(_assert_this_initialized(_this));
    _this._spriteDefaultMaterial = _this._createSpriteMaterial();
    _this._spriteMaskDefaultMaterial = _this._createSpriteMaskMaterial();
    _this._textDefaultFont = Font.createFromOS(_assert_this_initialized(_this), "Arial");
    _this._textDefaultFont.isGCIgnored = true;
    _this.inputManager = new InputManager(_assert_this_initialized(_this));
    _this._initMagentaTextures(hardwareRenderer);
    if (!hardwareRenderer.canIUse(GLCapabilityType.depthTexture)) {
      _this._macroCollection.enable(Engine2._noDepthTextureMacro);
    } else {
      var depthTexture2D = new Texture2D(_assert_this_initialized(_this), 1, 1, TextureFormat.Depth16, false);
      depthTexture2D.isGCIgnored = true;
      _this._depthTexture2D = depthTexture2D;
    }
    var magentaMaterial = new Material(_assert_this_initialized(_this), Shader.find("unlit"));
    magentaMaterial.isGCIgnored = true;
    magentaMaterial.shaderData.setColor("material_BaseColor", new Color(1, 0, 1.01, 1));
    _this._magentaMaterial = magentaMaterial;
    var backgroundTextureMaterial = new Material(_assert_this_initialized(_this), Shader.find("background-texture"));
    backgroundTextureMaterial.isGCIgnored = true;
    backgroundTextureMaterial.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this._backgroundTextureMaterial = backgroundTextureMaterial;
    var innerSettings = _this._settings;
    var colorSpace = configuration.colorSpace || ColorSpace.Linear;
    colorSpace === ColorSpace.Gamma && _this._macroCollection.enable(Engine2._gammaMacro);
    innerSettings.colorSpace = colorSpace;
    return _this;
  }
  var _proto = Engine2.prototype;
  _proto.createEntity = function createEntity(name2) {
    return new Entity(this, name2);
  };
  _proto.pause = function pause() {
    this._isPaused = true;
    cancelAnimationFrame(this._requestId);
    clearTimeout(this._timeoutId);
  };
  _proto.resume = function resume() {
    if (!this._isPaused)
      return;
    this._isPaused = false;
    this.time._reset();
    this._requestId = requestAnimationFrame(this._animate);
  };
  _proto.update = function update() {
    var time = this._time;
    time._update();
    var deltaTime = time.deltaTime;
    this._frameInProcess = true;
    this._renderElementPool.resetPool();
    this._meshRenderDataPool.resetPool();
    this._spriteRenderDataPool.resetPool();
    this._spriteMaskRenderDataPool.resetPool();
    this._textRenderDataPool.resetPool();
    var scene = this._sceneManager._activeScene;
    var componentsManager = this._componentsManager;
    if (scene) {
      scene._activeCameras.sort(function(camera1, camera2) {
        return camera1.priority - camera2.priority;
      });
      componentsManager.callScriptOnStart();
      this.physicsManager._initialized && this.physicsManager._update(deltaTime);
      this.inputManager._update();
      componentsManager.callScriptOnUpdate(deltaTime);
      componentsManager.callAnimationUpdate(deltaTime);
      componentsManager.callScriptOnLateUpdate(deltaTime);
      if (!this._isDeviceLost) {
        this._render(scene);
      }
    }
    if (!this._waitingDestroy) {
      componentsManager.handlingInvalidScripts();
    }
    if (this._waitingDestroy) {
      this._destroy();
    }
    if (this._waitingGC) {
      this._gc();
      this._waitingGC = false;
    }
    this._frameInProcess = false;
  };
  _proto.run = function run() {
    this.resume();
    this.dispatch("run", this);
  };
  _proto.forceLoseDevice = function forceLoseDevice() {
    this._hardwareRenderer.forceLoseDevice();
  };
  _proto.forceRestoreDevice = function forceRestoreDevice() {
    this._hardwareRenderer.forceRestoreDevice();
  };
  _proto._destroy = function _destroy() {
    this._sceneManager._destroyAllScene();
    this._componentsManager.handlingInvalidScripts();
    this._resourceManager._destroy();
    this._magentaTexture2D.destroy(true);
    this._magentaTextureCube.destroy(true);
    this._textDefaultFont = null;
    this._fontMap = null;
    this.inputManager._destroy();
    this.dispatch("shutdown", this);
    this.pause();
    this._spriteMaskManager.destroy();
    this._hardwareRenderer.destroy();
    this.removeAllEventListeners();
    this._animate = null;
    this._sceneManager = null;
    this._resourceManager = null;
    this._canvas = null;
    this._time = null;
    this._waitingDestroy = false;
    this._destroyed = true;
  };
  _proto.destroy = function destroy2() {
    if (this._destroyed) {
      return;
    }
    if (this._frameInProcess) {
      this._waitingDestroy = true;
    } else {
      this._destroy();
    }
  };
  _proto._getShaderProgramPool = function _getShaderProgramPool(shaderPass) {
    var index = shaderPass._shaderPassId;
    var shaderProgramPools = this._shaderProgramPools;
    var pool = shaderProgramPools[index];
    if (!pool) {
      var length2 = index + 1;
      if (length2 > shaderProgramPools.length) {
        shaderProgramPools.length = length2;
      }
      shaderProgramPools[index] = pool = new ShaderProgramPool();
    }
    return pool;
  };
  _proto._render = function _render(scene) {
    var cameras = scene._activeCameras;
    var componentsManager = this._componentsManager;
    var deltaTime = this.time.deltaTime;
    componentsManager.callRendererOnUpdate(deltaTime);
    scene._updateShaderData();
    if (cameras.length > 0) {
      for (var i = 0, n = cameras.length; i < n; i++) {
        var camera = cameras[i];
        componentsManager.callCameraOnBeginRender(camera);
        camera.render();
        componentsManager.callCameraOnEndRender(camera);
        if (this._hardwareRenderer._options._forceFlush) {
          this._hardwareRenderer.flush();
        }
      }
    } else {
      Logger.debug("NO active camera.");
    }
  };
  _proto._initMagentaTextures = function _initMagentaTextures(hardwareRenderer) {
    var magentaPixel = new Uint8Array([
      255,
      0,
      255,
      255
    ]);
    var magentaTexture2D = new Texture2D(this, 1, 1, TextureFormat.R8G8B8A8, false);
    magentaTexture2D.setPixelBuffer(magentaPixel);
    magentaTexture2D.isGCIgnored = true;
    this.resourceManager.addContentRestorer(new (function(ContentRestorer3) {
      _inherits$2(_class, ContentRestorer3);
      function _class() {
        return ContentRestorer3.call(this, magentaTexture2D);
      }
      var _proto2 = _class.prototype;
      _proto2.restoreContent = function restoreContent() {
        this.resource.setPixelBuffer(magentaPixel);
      };
      return _class;
    }(ContentRestorer))());
    var magentaTextureCube = new TextureCube(this, 1, TextureFormat.R8G8B8A8, false);
    for (var i = 0; i < 6; i++) {
      magentaTextureCube.setPixelBuffer(TextureCubeFace.PositiveX + i, magentaPixel);
    }
    magentaTextureCube.isGCIgnored = true;
    this.resourceManager.addContentRestorer(new (function(ContentRestorer3) {
      _inherits$2(_class, ContentRestorer3);
      function _class() {
        return ContentRestorer3.call(this, magentaTextureCube);
      }
      var _proto2 = _class.prototype;
      _proto2.restoreContent = function restoreContent() {
        for (var i2 = 0; i2 < 6; i2++) {
          this.resource.setPixelBuffer(TextureCubeFace.PositiveX + i2, magentaPixel);
        }
      };
      return _class;
    }(ContentRestorer))());
    this._magentaTexture2D = magentaTexture2D;
    this._magentaTextureCube = magentaTextureCube;
    if (hardwareRenderer.isWebGL2) {
      var magentaTexture2DArray = new Texture2DArray(this, 1, 1, 1, TextureFormat.R8G8B8A8, false);
      magentaTexture2DArray.setPixelBuffer(0, magentaPixel);
      magentaTexture2DArray.isGCIgnored = true;
      this.resourceManager.addContentRestorer(new (function(ContentRestorer3) {
        _inherits$2(_class, ContentRestorer3);
        function _class() {
          return ContentRestorer3.call(this, magentaTexture2DArray);
        }
        var _proto2 = _class.prototype;
        _proto2.restoreContent = function restoreContent() {
          this.resource.setPixelBuffer(0, magentaPixel);
        };
        return _class;
      }(ContentRestorer))());
      this._magentaTexture2DArray = magentaTexture2DArray;
    }
  };
  _proto._pendingGC = function _pendingGC() {
    if (this._frameInProcess) {
      this._waitingGC = true;
    } else {
      this._gc();
    }
  };
  _proto._initialize = function _initialize(configuration) {
    var _this = this;
    var physics = configuration.physics;
    if (physics) {
      return physics.initialize().then(function() {
        _this.physicsManager._initialize(physics);
        return _this;
      });
    } else {
      return Promise.resolve(this);
    }
  };
  _proto._createSpriteMaterial = function _createSpriteMaterial() {
    var material = new Material(this, Shader.find("Sprite"));
    var renderState = material.renderState;
    var target = renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.sourceAlphaBlendFactor = BlendFactor.One;
    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
    renderState.depthState.writeEnabled = false;
    renderState.rasterState.cullMode = CullMode.Off;
    material.renderState.renderQueueType = RenderQueueType.Transparent;
    material.isGCIgnored = true;
    return material;
  };
  _proto._createSpriteMaskMaterial = function _createSpriteMaskMaterial() {
    var material = new Material(this, Shader.find("SpriteMask"));
    var renderState = material.renderState;
    renderState.blendState.targetBlendState.colorWriteMask = ColorWriteMask.None;
    renderState.rasterState.cullMode = CullMode.Off;
    renderState.stencilState.enabled = true;
    renderState.depthState.enabled = false;
    material.isGCIgnored = true;
    return material;
  };
  _proto._onDeviceLost = function _onDeviceLost() {
    this._isDeviceLost = true;
    console.log("Device lost.");
    this.dispatch("devicelost", this);
  };
  _proto._onDeviceRestored = function _onDeviceRestored() {
    var _this = this;
    this._hardwareRenderer.resetState();
    this._lastRenderState = new RenderState();
    this._shaderProgramPools.length = 0;
    var resourceManager = this.resourceManager;
    resourceManager._restoreGraphicResources();
    console.log("Graphic resource restored.");
    resourceManager._restoreResourcesContent().then(function() {
      console.log("Graphic resource content restored.\n\nDevice restored.");
      _this.dispatch("devicerestored", _this);
      _this._isDeviceLost = false;
    }).catch(function(error2) {
      console.error(error2);
    });
  };
  _proto._gc = function _gc() {
    this._renderElementPool.garbageCollection();
    this._meshRenderDataPool.garbageCollection();
    this._spriteRenderDataPool.garbageCollection();
    this._spriteMaskRenderDataPool.garbageCollection();
    this._textRenderDataPool.garbageCollection();
    this._componentsManager._gc();
    this._lightManager._gc();
    this.physicsManager._gc();
  };
  _create_class$4(Engine2, [
    {
      key: "settings",
      get: function get3() {
        return this._settings;
      }
    },
    {
      key: "canvas",
      get: function get3() {
        return this._canvas;
      }
    },
    {
      key: "resourceManager",
      get: function get3() {
        return this._resourceManager;
      }
    },
    {
      key: "sceneManager",
      get: function get3() {
        return this._sceneManager;
      }
    },
    {
      key: "time",
      get: function get3() {
        return this._time;
      }
    },
    {
      key: "isPaused",
      get: function get3() {
        return this._isPaused;
      }
    },
    {
      key: "vSyncCount",
      get: function get3() {
        return this._vSyncCount;
      },
      set: function set(value) {
        this._vSyncCount = Math.max(0, Math.floor(value));
      }
    },
    {
      key: "targetFrameRate",
      get: function get3() {
        return this._targetFrameRate;
      },
      set: function set(value) {
        value = Math.max(1e-6, value);
        this._targetFrameRate = value;
        this._targetFrameInterval = 1e3 / value;
      }
    },
    {
      key: "destroyed",
      get: function get3() {
        return this._destroyed;
      }
    }
  ]);
  return Engine2;
}(EventDispatcher);
(function() {
  Engine._gammaMacro = ShaderMacro.getByName("ENGINE_IS_COLORSPACE_GAMMA");
})();
(function() {
  Engine._noDepthTextureMacro = ShaderMacro.getByName("ENGINE_NO_DEPTH_TEXTURE");
})();
(function() {
  Engine._pixelsPerUnit = 100;
})();
var Script = /* @__PURE__ */ function(Component2) {
  _inherits$2(Script2, Component2);
  function Script2() {
    var _this;
    _this = Component2.apply(this, arguments) || this;
    _this._started = false;
    _this._onStartIndex = -1;
    _this._onUpdateIndex = -1;
    _this._onLateUpdateIndex = -1;
    _this._onPhysicsUpdateIndex = -1;
    _this._onPreRenderIndex = -1;
    _this._onPostRenderIndex = -1;
    _this._entityScriptsIndex = -1;
    _this._waitHandlingInValid = false;
    return _this;
  }
  var _proto = Script2.prototype;
  _proto.onAwake = function onAwake() {
  };
  _proto.onEnable = function onEnable() {
  };
  _proto.onStart = function onStart() {
  };
  _proto.onUpdate = function onUpdate(deltaTime) {
  };
  _proto.onLateUpdate = function onLateUpdate(deltaTime) {
  };
  _proto.onBeginRender = function onBeginRender(camera) {
  };
  _proto.onEndRender = function onEndRender(camera) {
  };
  _proto.onPhysicsUpdate = function onPhysicsUpdate() {
  };
  _proto.onTriggerEnter = function onTriggerEnter(other) {
  };
  _proto.onTriggerExit = function onTriggerExit(other) {
  };
  _proto.onTriggerStay = function onTriggerStay(other) {
  };
  _proto.onCollisionEnter = function onCollisionEnter(other) {
  };
  _proto.onCollisionExit = function onCollisionExit(other) {
  };
  _proto.onCollisionStay = function onCollisionStay(other) {
  };
  _proto.onPointerDown = function onPointerDown(pointer) {
  };
  _proto.onPointerUp = function onPointerUp(pointer) {
  };
  _proto.onPointerClick = function onPointerClick(pointer) {
  };
  _proto.onPointerEnter = function onPointerEnter(pointer) {
  };
  _proto.onPointerExit = function onPointerExit(pointer) {
  };
  _proto.onPointerDrag = function onPointerDrag(pointer) {
  };
  _proto.onDisable = function onDisable() {
  };
  _proto.onDestroy = function onDestroy() {
  };
  _proto._onAwake = function _onAwake() {
    this.onAwake();
  };
  _proto._onEnable = function _onEnable() {
    if (this._waitHandlingInValid) {
      this._waitHandlingInValid = false;
    } else {
      var _this_engine = this.engine, componentsManager = _this_engine._componentsManager;
      var prototype = Script2.prototype;
      if (!this._started) {
        componentsManager.addOnStartScript(this);
      }
      if (this.onUpdate !== prototype.onUpdate) {
        componentsManager.addOnUpdateScript(this);
      }
      if (this.onLateUpdate !== prototype.onLateUpdate) {
        componentsManager.addOnLateUpdateScript(this);
      }
      if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
        componentsManager.addOnPhysicsUpdateScript(this);
      }
      this._entity._addScript(this);
    }
    this.onEnable();
  };
  _proto._onDisable = function _onDisable() {
    this._waitHandlingInValid = true;
    this._engine._componentsManager.addDisableScript(this);
    this.onDisable();
  };
  _proto._handlingInValid = function _handlingInValid() {
    var componentsManager = this.engine._componentsManager;
    var prototype = Script2.prototype;
    if (this.onUpdate !== prototype.onUpdate) {
      componentsManager.removeOnUpdateScript(this);
    }
    if (this.onLateUpdate !== prototype.onLateUpdate) {
      componentsManager.removeOnLateUpdateScript(this);
    }
    if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
      componentsManager.removeOnPhysicsUpdateScript(this);
    }
    this._entity._removeScript(this);
    this._waitHandlingInValid = false;
  };
  _proto._onDestroy = function _onDestroy() {
    Component2.prototype._onDestroy.call(this);
    this._engine._componentsManager.addPendingDestroyScript(this);
  };
  return Script2;
}(Component);
__decorate$2([
  ignoreClone
], Script.prototype, "_started", void 0);
__decorate$2([
  ignoreClone
], Script.prototype, "_onStartIndex", void 0);
__decorate$2([
  ignoreClone
], Script.prototype, "_onUpdateIndex", void 0);
__decorate$2([
  ignoreClone
], Script.prototype, "_onLateUpdateIndex", void 0);
__decorate$2([
  ignoreClone
], Script.prototype, "_onPhysicsUpdateIndex", void 0);
__decorate$2([
  ignoreClone
], Script.prototype, "_onPreRenderIndex", void 0);
__decorate$2([
  ignoreClone
], Script.prototype, "_onPostRenderIndex", void 0);
__decorate$2([
  ignoreClone
], Script.prototype, "_entityScriptsIndex", void 0);
__decorate$2([
  ignoreClone
], Script.prototype, "_waitHandlingInValid", void 0);
var SpriteBatcher = /* @__PURE__ */ function(Basic2DBatcher1) {
  _inherits$2(SpriteBatcher2, Basic2DBatcher1);
  function SpriteBatcher2() {
    return Basic2DBatcher1.apply(this, arguments);
  }
  var _proto = SpriteBatcher2.prototype;
  _proto.createVertexElements = function createVertexElements(vertexElements) {
    vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
    vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
    vertexElements[2] = new VertexElement("COLOR_0", 20, VertexElementFormat.Vector4, 0);
    return 36;
  };
  _proto.canBatch = function canBatch(preElement, curElement) {
    if (!this._engine._canSpriteBatch || curElement.shaderPass.getTagValue(Basic2DBatcher._disableBatchTag) === true) {
      return false;
    }
    var preSpriteData = preElement.data;
    var curSpriteData = curElement.data;
    var preRenderer = preSpriteData.component;
    var curRenderer = curSpriteData.component;
    if (!this.checkBatchWithMask(preRenderer, curRenderer)) {
      return false;
    }
    if (preSpriteData.texture !== curSpriteData.texture) {
      return false;
    }
    return preSpriteData.material === curSpriteData.material;
  };
  _proto.checkBatchWithMask = function checkBatchWithMask(left, right) {
    var leftMaskInteraction = left.maskInteraction;
    if (leftMaskInteraction !== right.maskInteraction) {
      return false;
    }
    if (leftMaskInteraction === SpriteMaskInteraction.None) {
      return true;
    }
    return left.maskLayer === right.maskLayer;
  };
  _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
    var _element_verticesData = element.verticesData, positions = _element_verticesData.positions, uvs = _element_verticesData.uvs, color = _element_verticesData.color, vertexCount = _element_verticesData.vertexCount;
    for (var i = 0; i < vertexCount; i++) {
      var curPos = positions[i];
      var curUV = uvs[i];
      vertices[vertexIndex++] = curPos.x;
      vertices[vertexIndex++] = curPos.y;
      vertices[vertexIndex++] = curPos.z;
      vertices[vertexIndex++] = curUV.x;
      vertices[vertexIndex++] = curUV.y;
      vertices[vertexIndex++] = color.r;
      vertices[vertexIndex++] = color.g;
      vertices[vertexIndex++] = color.b;
      vertices[vertexIndex++] = color.a;
    }
    return vertexIndex;
  };
  _proto.drawBatches = function drawBatches(camera) {
    var _this = this, engine = _this._engine, batchedQueue = _this._batchedQueue;
    var mesh = this._meshes[this._flushId];
    var subMeshes = mesh.subMeshes;
    var maskManager = engine._spriteMaskManager;
    var sceneData = camera.scene.shaderData;
    var cameraData = camera.shaderData;
    for (var i = 0, len = subMeshes.length; i < len; i++) {
      var subMesh = subMeshes[i];
      var spriteElement = batchedQueue[i];
      var spriteData = spriteElement.data;
      if (!subMesh || !spriteElement) {
        return;
      }
      var renderer = spriteData.component;
      var material = spriteData.material;
      maskManager.preRender(camera, renderer);
      var compileMacros = Shader._compileMacros;
      ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);
      var program = spriteElement.shaderPass._getShaderProgram(engine, compileMacros);
      if (!program.isValid) {
        return;
      }
      renderer.shaderData.setTexture(SpriteBatcher2._textureProperty, spriteData.texture);
      program.bind();
      program.groupingOtherUniformBlock();
      program.uploadAll(program.sceneUniformBlock, sceneData);
      program.uploadAll(program.cameraUniformBlock, cameraData);
      program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
      program.uploadAll(program.materialUniformBlock, material.shaderData);
      spriteElement.renderState._apply(engine, false);
      engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
      maskManager.postRender(renderer);
    }
  };
  _proto.destroy = function destroy2() {
    this._batchedQueue = null;
    var _this = this, meshes = _this._meshes, vertexBuffers = _this._vertexBuffers, indiceBuffers = _this._indiceBuffers;
    for (var i = 0, n = meshes.length; i < n; ++i) {
      meshes[i].destroy();
    }
    this._meshes = null;
    for (var i1 = 0, n1 = vertexBuffers.length; i1 < n1; ++i1) {
      vertexBuffers[i1].destroy();
    }
    this._vertexBuffers = null;
    for (var i2 = 0, n2 = indiceBuffers.length; i2 < n2; ++i2) {
      indiceBuffers[i2].destroy();
    }
    this._indiceBuffers = null;
  };
  return SpriteBatcher2;
}(Basic2DBatcher);
(function() {
  SpriteBatcher._textureProperty = ShaderProperty.getByName("renderer_SpriteTexture");
})();
var RenderQueue = /* @__PURE__ */ function() {
  function RenderQueue2(engine) {
    this.elements = [];
    this._initSpriteBatcher(engine);
  }
  var _proto = RenderQueue2.prototype;
  _proto.pushRenderElement = function pushRenderElement(element) {
    this.elements.push(element);
  };
  _proto.render = function render(camera, mask) {
    var elements = this.elements;
    if (elements.length === 0) {
      return;
    }
    var engine = camera.engine, scene = camera.scene;
    var renderCount = engine._renderCount;
    var rhi = engine._hardwareRenderer;
    var sceneData = scene.shaderData;
    var cameraData = camera.shaderData;
    for (var i = 0, n = elements.length; i < n; i++) {
      var element = elements[i];
      var data = element.data;
      var renderPassFlag = data.component.entity.layer;
      if (!(renderPassFlag & mask)) {
        continue;
      }
      if (!!data.mesh) {
        this._spriteBatcher.flush(camera);
        var compileMacros = Shader._compileMacros;
        var meshData = data;
        var renderer = meshData.component;
        var material = meshData.material.destroyed ? engine._magentaMaterial : meshData.material;
        var rendererData = renderer.shaderData;
        var materialData = material.shaderData;
        ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, materialData._macroCollection, compileMacros);
        var program = element.shaderPass._getShaderProgram(engine, compileMacros);
        if (!program.isValid) {
          continue;
        }
        var switchProgram = program.bind();
        var switchRenderCount = renderCount !== program._uploadRenderCount;
        if (switchRenderCount) {
          program.groupingOtherUniformBlock();
          program.uploadAll(program.sceneUniformBlock, sceneData);
          program.uploadAll(program.cameraUniformBlock, cameraData);
          program.uploadAll(program.rendererUniformBlock, rendererData);
          program.uploadAll(program.materialUniformBlock, materialData);
          program.uploadUnGroupTextures();
          program._uploadScene = scene;
          program._uploadCamera = camera;
          program._uploadRenderer = renderer;
          program._uploadMaterial = material;
          program._uploadRenderCount = renderCount;
        } else {
          if (program._uploadScene !== scene) {
            program.uploadAll(program.sceneUniformBlock, sceneData);
            program._uploadScene = scene;
          } else if (switchProgram) {
            program.uploadTextures(program.sceneUniformBlock, sceneData);
          }
          if (program._uploadCamera !== camera) {
            program.uploadAll(program.cameraUniformBlock, cameraData);
            program._uploadCamera = camera;
          } else if (switchProgram) {
            program.uploadTextures(program.cameraUniformBlock, cameraData);
          }
          if (program._uploadRenderer !== renderer) {
            program.uploadAll(program.rendererUniformBlock, rendererData);
            program._uploadRenderer = renderer;
          } else if (switchProgram) {
            program.uploadTextures(program.rendererUniformBlock, rendererData);
          }
          if (program._uploadMaterial !== material) {
            program.uploadAll(program.materialUniformBlock, materialData);
            program._uploadMaterial = material;
          } else if (switchProgram) {
            program.uploadTextures(program.materialUniformBlock, materialData);
          }
          if (switchProgram) {
            program.uploadUnGroupTextures();
          }
        }
        element.renderState._apply(engine, renderer.entity.transform._isFrontFaceInvert());
        rhi.drawPrimitive(meshData.mesh, meshData.subMesh, program);
      } else {
        this._spriteBatcher.drawElement(element, camera);
      }
    }
    this._spriteBatcher.flush(camera);
  };
  _proto.clear = function clear() {
    this.elements.length = 0;
    this._spriteBatcher.clear();
  };
  _proto.destroy = function destroy2() {
    this._spriteBatcher.destroy();
    this._spriteBatcher = null;
  };
  _proto.sort = function sort(compareFunc) {
    this._quickSort(this.elements, 0, this.elements.length, compareFunc);
  };
  _proto._initSpriteBatcher = function _initSpriteBatcher(engine) {
    this._spriteBatcher = new SpriteBatcher(engine);
  };
  _proto._quickSort = function _quickSort(a, from, to, compareFunc) {
    while (true) {
      if (to - from <= 10) {
        this._insertionSort(a, from, to, compareFunc);
        return;
      }
      var third_index = from + to >> 1;
      var v0 = a[from];
      var v1 = a[to - 1];
      var v2 = a[third_index];
      var c01 = compareFunc(v0, v1);
      if (c01 > 0) {
        var tmp = v0;
        v0 = v1;
        v1 = tmp;
      }
      var c02 = compareFunc(v0, v2);
      if (c02 >= 0) {
        var tmp1 = v0;
        v0 = v2;
        v2 = v1;
        v1 = tmp1;
      } else {
        var c12 = compareFunc(v1, v2);
        if (c12 > 0) {
          var tmp2 = v1;
          v1 = v2;
          v2 = tmp2;
        }
      }
      a[from] = v0;
      a[to - 1] = v2;
      var pivot = v1;
      var low_end = from + 1;
      var high_start = to - 1;
      a[third_index] = a[low_end];
      a[low_end] = pivot;
      partition:
        for (var i = low_end + 1; i < high_start; i++) {
          var element = a[i];
          var order = compareFunc(element, pivot);
          if (order < 0) {
            a[i] = a[low_end];
            a[low_end] = element;
            low_end++;
          } else if (order > 0) {
            do {
              high_start--;
              if (high_start == i)
                break partition;
              var top_elem = a[high_start];
              order = compareFunc(top_elem, pivot);
            } while (order > 0);
            a[i] = a[high_start];
            a[high_start] = element;
            if (order < 0) {
              element = a[i];
              a[i] = a[low_end];
              a[low_end] = element;
              low_end++;
            }
          }
        }
      if (to - high_start < low_end - from) {
        this._quickSort(a, high_start, to, compareFunc);
        to = low_end;
      } else {
        this._quickSort(a, from, low_end, compareFunc);
        from = high_start;
      }
    }
  };
  _proto._insertionSort = function _insertionSort(a, from, to, compareFunc) {
    for (var i = from + 1; i < to; i++) {
      var j2 = void 0;
      var element = a[i];
      for (j2 = i - 1; j2 >= from; j2--) {
        var tmp = a[j2];
        var order = compareFunc(tmp, element);
        if (order > 0) {
          a[j2 + 1] = tmp;
        } else {
          break;
        }
      }
      a[j2 + 1] = element;
    }
  };
  RenderQueue2._compareFromNearToFar = function _compareFromNearToFar(a, b) {
    return a.data.component.priority - b.data.component.priority || a.data.component._distanceForSort - b.data.component._distanceForSort;
  };
  RenderQueue2._compareFromFarToNear = function _compareFromFarToNear(a, b) {
    return a.data.component.priority - b.data.component.priority || b.data.component._distanceForSort - a.data.component._distanceForSort;
  };
  return RenderQueue2;
}();
var VirtualCamera = function VirtualCamera2() {
  this.position = new Vector3();
  this.isOrthographic = false;
  this.viewMatrix = new Matrix();
  this.projectionMatrix = new Matrix();
  this.viewProjectionMatrix = new Matrix();
  this.forward = new Vector3();
};
var ShadowSliceData = function ShadowSliceData2() {
  this.virtualCamera = new VirtualCamera();
  this.cullPlanes = [
    new Plane(new Vector3()),
    new Plane(new Vector3()),
    new Plane(new Vector3()),
    new Plane(new Vector3()),
    new Plane(new Vector3()),
    new Plane(new Vector3()),
    new Plane(new Vector3()),
    new Plane(new Vector3()),
    new Plane(new Vector3()),
    new Plane(new Vector3())
  ];
  this.splitBoundSphere = new BoundingSphere(new Vector3(), 0);
};
var FrustumCorner;
(function(FrustumCorner2) {
  FrustumCorner2[FrustumCorner2["FarBottomLeft"] = 0] = "FarBottomLeft";
  FrustumCorner2[FrustumCorner2["FarTopLeft"] = 1] = "FarTopLeft";
  FrustumCorner2[FrustumCorner2["FarTopRight"] = 2] = "FarTopRight";
  FrustumCorner2[FrustumCorner2["FarBottomRight"] = 3] = "FarBottomRight";
  FrustumCorner2[FrustumCorner2["nearBottomLeft"] = 4] = "nearBottomLeft";
  FrustumCorner2[FrustumCorner2["nearTopLeft"] = 5] = "nearTopLeft";
  FrustumCorner2[FrustumCorner2["nearTopRight"] = 6] = "nearTopRight";
  FrustumCorner2[FrustumCorner2["nearBottomRight"] = 7] = "nearBottomRight";
  FrustumCorner2[FrustumCorner2["unknown"] = 8] = "unknown";
})(FrustumCorner || (FrustumCorner = {}));
var ShadowUtils = /* @__PURE__ */ function() {
  function ShadowUtils2() {
  }
  ShadowUtils2.shadowResolution = function shadowResolution(value) {
    switch (value) {
      case ShadowResolution.Low:
        return 512;
      case ShadowResolution.Medium:
        return 1024;
      case ShadowResolution.High:
        return 2048;
      case ShadowResolution.VeryHigh:
        return 4096;
    }
  };
  ShadowUtils2.shadowDepthFormat = function shadowDepthFormat(value, supportDepthTexture) {
    if (supportDepthTexture) {
      return TextureFormat.Depth16;
    } else {
      return TextureFormat.R8G8B8A8;
    }
  };
  ShadowUtils2.cullingRenderBounds = function cullingRenderBounds(bounds, cullPlaneCount, cullPlanes) {
    var min = bounds.min, max = bounds.max;
    for (var i = 0; i < cullPlaneCount; i++) {
      var plane = cullPlanes[i];
      var normal = plane.normal;
      if (normal.x * (normal.x >= 0 ? max.x : min.x) + normal.y * (normal.y >= 0 ? max.y : min.y) + normal.z * (normal.z >= 0 ? max.z : min.z) < -plane.distance) {
        return false;
      }
    }
    return true;
  };
  ShadowUtils2.shadowCullFrustum = function shadowCullFrustum(context, light, renderer, shadowSliceData) {
    var layer = renderer._entity.layer;
    if (context.camera.cullingMask & layer && light.cullingMask & layer) {
      if (renderer.castShadows && ShadowUtils2.cullingRenderBounds(renderer.bounds, shadowSliceData.cullPlaneCount, shadowSliceData.cullPlanes)) {
        renderer._renderFrameCount = renderer.engine.time.frameCount;
        renderer._prepareRender(context);
      }
    }
  };
  ShadowUtils2.getBoundSphereByFrustum = function getBoundSphereByFrustum(near, far, camera, forward, shadowSliceData) {
    var aspectRatio = camera.aspectRatio, fieldOfView = camera.fieldOfView;
    var centerZ;
    var radius;
    var k2 = Math.sqrt(1 + aspectRatio * aspectRatio) * Math.tan(MathUtil$1.degreeToRadian(fieldOfView) / 2);
    var k22 = k2 * k2;
    var farSNear = far - near;
    var farANear = far + near;
    if (k22 > farSNear / farANear) {
      centerZ = far;
      radius = far * k2;
    } else {
      centerZ = 0.5 * farANear * (1 + k22);
      radius = 0.5 * Math.sqrt(farSNear * farSNear + 2 * (far * far + near * near) * k22 + farANear * farANear * k22 * k22);
    }
    var center = shadowSliceData.splitBoundSphere.center;
    shadowSliceData.splitBoundSphere.radius = radius;
    Vector3.scale(forward, centerZ, center);
    Vector3.add(camera.entity.transform.worldPosition, center, center);
    shadowSliceData.sphereCenterZ = centerZ;
  };
  ShadowUtils2.getDirectionLightShadowCullPlanes = function getDirectionLightShadowCullPlanes(cameraFrustum, splitDistance, cameraNear, direction, shadowSliceData) {
    var frustumCorners = ShadowUtils2._frustumCorners;
    var backPlaneFaces = ShadowUtils2._backPlaneFaces;
    var planeNeighbors = ShadowUtils2._frustumPlaneNeighbors;
    var twoPlaneCorners = ShadowUtils2._frustumTwoPlaneCorners;
    var edgePlanePoint2 = ShadowUtils2._edgePlanePoint2;
    var out = shadowSliceData.cullPlanes;
    var near = cameraFrustum.getPlane(FrustumFace.Near);
    var far = cameraFrustum.getPlane(FrustumFace.Far);
    var left = cameraFrustum.getPlane(FrustumFace.Left);
    var right = cameraFrustum.getPlane(FrustumFace.Right);
    var bottom = cameraFrustum.getPlane(FrustumFace.Bottom);
    var top = cameraFrustum.getPlane(FrustumFace.Top);
    var splitNearDistance = splitDistance - cameraNear;
    var splitNear = ShadowUtils2._adjustNearPlane;
    var splitFar = ShadowUtils2._adjustFarPlane;
    splitNear.normal.copyFrom(near.normal);
    splitFar.normal.copyFrom(far.normal);
    splitNear.distance = near.distance - splitNearDistance;
    splitFar.distance = Math.min(-near.distance + shadowSliceData.sphereCenterZ + shadowSliceData.splitBoundSphere.radius, far.distance);
    CollisionUtil.intersectionPointThreePlanes(splitNear, bottom, right, frustumCorners[7]);
    CollisionUtil.intersectionPointThreePlanes(splitNear, top, right, frustumCorners[6]);
    CollisionUtil.intersectionPointThreePlanes(splitNear, top, left, frustumCorners[5]);
    CollisionUtil.intersectionPointThreePlanes(splitNear, bottom, left, frustumCorners[4]);
    CollisionUtil.intersectionPointThreePlanes(splitFar, bottom, right, frustumCorners[3]);
    CollisionUtil.intersectionPointThreePlanes(splitFar, top, right, frustumCorners[2]);
    CollisionUtil.intersectionPointThreePlanes(splitFar, top, left, frustumCorners[1]);
    CollisionUtil.intersectionPointThreePlanes(splitFar, bottom, left, frustumCorners[0]);
    var backIndex = 0;
    for (var i = 0; i < 6; i++) {
      var plane = void 0;
      switch (i) {
        case FrustumFace.Near:
          plane = splitNear;
          break;
        case FrustumFace.Far:
          plane = splitFar;
          break;
        default:
          plane = cameraFrustum.getPlane(i);
          break;
      }
      if (Vector3.dot(plane.normal, direction) < 0) {
        out[backIndex].copyFrom(plane);
        backPlaneFaces[backIndex] = i;
        backIndex++;
      }
    }
    var edgeIndex = backIndex;
    for (var i1 = 0; i1 < backIndex; i1++) {
      var backFace = backPlaneFaces[i1];
      var neighborFaces = planeNeighbors[backFace];
      for (var j2 = 0; j2 < 4; j2++) {
        var neighborFace = neighborFaces[j2];
        var notBackFace = true;
        for (var k2 = 0; k2 < backIndex; k2++)
          if (neighborFace == backPlaneFaces[k2]) {
            notBackFace = false;
            break;
          }
        if (notBackFace) {
          var corners = twoPlaneCorners[backFace][neighborFace];
          var point0 = frustumCorners[corners[0]];
          var point1 = frustumCorners[corners[1]];
          Vector3.add(point0, direction, edgePlanePoint2);
          Plane.fromPoints(point0, point1, edgePlanePoint2, out[edgeIndex++]);
        }
      }
    }
    shadowSliceData.cullPlaneCount = edgeIndex;
  };
  ShadowUtils2.getDirectionalLightMatrices = function getDirectionalLightMatrices(lightUp, lightSide, lightForward, cascadeIndex, nearPlane, shadowResolution, shadowSliceData, outShadowMatrices) {
    var boundSphere = shadowSliceData.splitBoundSphere;
    shadowSliceData.resolution = shadowResolution;
    var center = boundSphere.center;
    var radius = boundSphere.radius;
    var halfShadowResolution = shadowResolution / 2;
    var borderRadius = radius * halfShadowResolution / (halfShadowResolution - ShadowUtils2.atlasBorderSize);
    var borderDiam = borderRadius * 2;
    var sizeUnit = shadowResolution / borderDiam;
    var radiusUnit = borderDiam / shadowResolution;
    var upLen = Math.ceil(Vector3.dot(center, lightUp) * sizeUnit) * radiusUnit;
    var sideLen = Math.ceil(Vector3.dot(center, lightSide) * sizeUnit) * radiusUnit;
    var forwardLen = Vector3.dot(center, lightForward);
    center.x = lightUp.x * upLen + lightSide.x * sideLen + lightForward.x * forwardLen;
    center.y = lightUp.y * upLen + lightSide.y * sideLen + lightForward.y * forwardLen;
    center.z = lightUp.z * upLen + lightSide.z * sideLen + lightForward.z * forwardLen;
    var virtualCamera = shadowSliceData.virtualCamera;
    var position = virtualCamera.position;
    var viewMatrix = virtualCamera.viewMatrix;
    var projectMatrix = virtualCamera.projectionMatrix;
    Vector3.scale(lightForward, radius + nearPlane, position);
    Vector3.subtract(center, position, position);
    Matrix.lookAt(position, center, lightUp, viewMatrix);
    Matrix.ortho(-borderRadius, borderRadius, -borderRadius, borderRadius, 0, radius * 2 + nearPlane, projectMatrix);
    var viewProjectionMatrix = virtualCamera.viewProjectionMatrix;
    Matrix.multiply(projectMatrix, viewMatrix, viewProjectionMatrix);
    Utils._floatMatrixMultiply(ShadowUtils2._shadowMapCoordMatrix, viewProjectionMatrix.elements, 0, outShadowMatrices, cascadeIndex * 16);
  };
  ShadowUtils2.getMaxTileResolutionInAtlas = function getMaxTileResolutionInAtlas(atlasWidth, atlasHeight, tileCount) {
    var resolution = Math.min(atlasWidth, atlasHeight);
    var currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
    while (currentTileCount < tileCount) {
      resolution = Math.floor(resolution >> 1);
      currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
    }
    return resolution;
  };
  ShadowUtils2.getShadowBias = function getShadowBias(light, projectionMatrix, shadowResolution, out) {
    var frustumSize = 2 / projectionMatrix.elements[0];
    var texelSize = frustumSize / shadowResolution;
    var depthBias = -light.shadowBias * texelSize;
    var normalBias = -light.shadowNormalBias * texelSize;
    if (light.shadowType == ShadowType.SoftHigh) {
      var kernelRadius = 2.5;
      depthBias *= kernelRadius;
      normalBias *= kernelRadius;
    }
    out.set(depthBias, normalBias);
  };
  ShadowUtils2.applySliceTransform = function applySliceTransform(tileSize, atlasWidth, atlasHeight, cascadeIndex, atlasOffset, outShadowMatrices) {
    var sliceMatrix = ShadowUtils2._tempMatrix0;
    var slice = sliceMatrix.elements;
    var oneOverAtlasWidth = 1 / atlasWidth;
    var oneOverAtlasHeight = 1 / atlasHeight;
    var scaleX = tileSize * oneOverAtlasWidth;
    var scaleY = tileSize * oneOverAtlasHeight;
    var offsetX = atlasOffset.x * oneOverAtlasWidth;
    var offsetY = atlasOffset.y * oneOverAtlasHeight;
    slice[0] = scaleX, slice[1] = 0, slice[2] = 0, slice[3] = 0;
    slice[4] = 0, slice[5] = scaleY, slice[6] = 0, slice[7] = 0;
    slice[8] = 0, slice[9] = 0, slice[10] = 1, slice[11] = 0;
    slice[12] = offsetX, slice[13] = offsetY, slice[14] = 0, slice[15] = 1;
    var offset = cascadeIndex * 16;
    Utils._floatMatrixMultiply(sliceMatrix, outShadowMatrices, offset, outShadowMatrices, offset);
  };
  return ShadowUtils2;
}();
(function() {
  ShadowUtils._tempMatrix0 = new Matrix();
})();
(function() {
  ShadowUtils._shadowMapCoordMatrix = new Matrix(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1);
})();
(function() {
  ShadowUtils._frustumCorners = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3()
  ];
})();
(function() {
  ShadowUtils._adjustNearPlane = new Plane(new Vector3());
})();
(function() {
  ShadowUtils._adjustFarPlane = new Plane(new Vector3());
})();
(function() {
  ShadowUtils._backPlaneFaces = new Array(5);
})();
(function() {
  ShadowUtils._edgePlanePoint2 = new Vector3();
})();
(function() {
  ShadowUtils._frustumPlaneNeighbors = [
    [
      FrustumFace.Left,
      FrustumFace.Right,
      FrustumFace.Top,
      FrustumFace.Bottom
    ],
    [
      FrustumFace.Left,
      FrustumFace.Right,
      FrustumFace.Top,
      FrustumFace.Bottom
    ],
    [
      FrustumFace.Near,
      FrustumFace.Far,
      FrustumFace.Top,
      FrustumFace.Bottom
    ],
    [
      FrustumFace.Near,
      FrustumFace.Far,
      FrustumFace.Top,
      FrustumFace.Bottom
    ],
    [
      FrustumFace.Near,
      FrustumFace.Far,
      FrustumFace.Left,
      FrustumFace.Right
    ],
    [
      FrustumFace.Near,
      FrustumFace.Far,
      FrustumFace.Left,
      FrustumFace.Right
    ]
  ];
})();
(function() {
  ShadowUtils._frustumTwoPlaneCorners = [
    [
      [
        8,
        8
      ],
      [
        8,
        8
      ],
      [
        4,
        5
      ],
      [
        6,
        7
      ],
      [
        7,
        4
      ],
      [
        5,
        6
      ]
    ],
    [
      [
        8,
        8
      ],
      [
        8,
        8
      ],
      [
        1,
        0
      ],
      [
        3,
        2
      ],
      [
        0,
        3
      ],
      [
        2,
        1
      ]
    ],
    [
      [
        5,
        4
      ],
      [
        0,
        1
      ],
      [
        8,
        8
      ],
      [
        8,
        8
      ],
      [
        4,
        0
      ],
      [
        1,
        5
      ]
    ],
    [
      [
        7,
        6
      ],
      [
        2,
        3
      ],
      [
        8,
        8
      ],
      [
        8,
        8
      ],
      [
        3,
        7
      ],
      [
        6,
        2
      ]
    ],
    [
      [
        4,
        7
      ],
      [
        3,
        0
      ],
      [
        0,
        4
      ],
      [
        7,
        3
      ],
      [
        8,
        8
      ],
      [
        8,
        8
      ]
    ],
    [
      [
        6,
        5
      ],
      [
        1,
        2
      ],
      [
        5,
        1
      ],
      [
        2,
        6
      ],
      [
        8,
        8
      ],
      [
        8,
        8
      ]
    ]
  ];
})();
(function() {
  ShadowUtils.atlasBorderSize = 4;
})();
var CascadedShadowCasterPass = /* @__PURE__ */ function() {
  function CascadedShadowCasterPass2(camera) {
    this._shadowMapSize = new Vector4();
    this._shadowBias = new Vector2();
    this._shadowSliceData = new ShadowSliceData();
    this._lightUp = new Vector3();
    this._lightSide = new Vector3();
    this._existShadowMap = false;
    this._splitBoundSpheres = new Float32Array(CascadedShadowCasterPass2._maxCascades * 4);
    this._shadowMatrices = new Float32Array((CascadedShadowCasterPass2._maxCascades + 1) * 16);
    this._shadowInfos = new Vector3();
    this._viewportOffsets = [
      new Vector2(),
      new Vector2(),
      new Vector2(),
      new Vector2()
    ];
    this._camera = camera;
    this._engine = camera.engine;
    this._supportDepthTexture = camera.engine._hardwareRenderer.canIUse(GLCapabilityType.depthTexture);
    this._shadowSliceData.virtualCamera.isOrthographic = true;
  }
  var _proto = CascadedShadowCasterPass2.prototype;
  _proto._render = function _render(context) {
    this._updateShadowSettings();
    this._existShadowMap = false;
    this._renderDirectShadowMap(context);
    if (this._existShadowMap) {
      this._updateReceiversShaderData();
    }
  };
  _proto._renderDirectShadowMap = function _renderDirectShadowMap(context) {
    var _this = this, engine = _this._engine, camera = _this._camera, viewports = _this._viewportOffsets, shadowSliceData = _this._shadowSliceData, splitBoundSpheres = _this._splitBoundSpheres, shadowMatrices = _this._shadowMatrices;
    var _camera__renderPipeline = camera._renderPipeline, opaqueQueue = _camera__renderPipeline._opaqueQueue, alphaTestQueue = _camera__renderPipeline._alphaTestQueue, transparentQueue = _camera__renderPipeline._transparentQueue;
    var componentsManager = engine._componentsManager;
    var rhi = engine._hardwareRenderer;
    var shadowCascades = camera.scene.shadowCascades;
    var splitDistance = CascadedShadowCasterPass2._cascadesSplitDistance;
    var boundSphere = shadowSliceData.splitBoundSphere;
    var lightWorld = CascadedShadowCasterPass2._tempMatrix0;
    var lightWorldE = lightWorld.elements;
    var lightUp = this._lightUp;
    var lightSide = this._lightSide;
    var lightForward = shadowSliceData.virtualCamera.forward;
    var light = camera.scene._sunLight;
    if (light) {
      var shadowFar = Math.min(camera.scene.shadowDistance, camera.farClipPlane);
      this._getCascadesSplitDistance(shadowFar);
      var renderTarget = this._getAvailableRenderTarget();
      rhi.activeRenderTarget(renderTarget, CascadedShadowCasterPass2._viewport, 0);
      if (this._supportDepthTexture) {
        rhi.clearRenderTarget(engine, CameraClearFlags.Depth, null);
      } else {
        rhi.clearRenderTarget(engine, CameraClearFlags.All, CascadedShadowCasterPass2._clearColor);
      }
      this._shadowInfos.x = light.shadowStrength;
      this._shadowInfos.z = 0;
      Matrix.rotationQuaternion(light.entity.transform.worldRotationQuaternion, lightWorld);
      lightSide.set(lightWorldE[0], lightWorldE[1], lightWorldE[2]);
      lightUp.set(lightWorldE[4], lightWorldE[5], lightWorldE[6]);
      lightForward.set(-lightWorldE[8], -lightWorldE[9], -lightWorldE[10]);
      var cameraForward = CascadedShadowCasterPass2._tempVector;
      cameraForward.copyFrom(camera.entity.transform.worldForward);
      var shadowTileResolution = this._shadowTileResolution;
      for (var j2 = 0; j2 < shadowCascades; j2++) {
        ShadowUtils.getBoundSphereByFrustum(splitDistance[j2], splitDistance[j2 + 1], camera, cameraForward, shadowSliceData);
        ShadowUtils.getDirectionLightShadowCullPlanes(camera._frustum, splitDistance[j2], camera.nearClipPlane, lightForward, shadowSliceData);
        ShadowUtils.getDirectionalLightMatrices(lightUp, lightSide, lightForward, j2, light.shadowNearPlane, shadowTileResolution, shadowSliceData, shadowMatrices);
        if (shadowCascades > 1) {
          var shadowMapSize = this._shadowMapSize;
          ShadowUtils.applySliceTransform(shadowTileResolution, shadowMapSize.z, shadowMapSize.w, j2, this._viewportOffsets[j2], shadowMatrices);
        }
        this._updateSingleShadowCasterShaderData(light, shadowSliceData, context);
        var center = boundSphere.center;
        var radius = boundSphere.radius;
        var offset = j2 * 4;
        splitBoundSpheres[offset] = center.x;
        splitBoundSpheres[offset + 1] = center.y;
        splitBoundSpheres[offset + 2] = center.z;
        splitBoundSpheres[offset + 3] = radius * radius;
        opaqueQueue.clear();
        alphaTestQueue.clear();
        transparentQueue.clear();
        var renderers = componentsManager._renderers;
        var elements = renderers._elements;
        for (var k2 = renderers.length - 1; k2 >= 0; --k2) {
          ShadowUtils.shadowCullFrustum(context, light, elements[k2], shadowSliceData);
        }
        if (opaqueQueue.elements.length || alphaTestQueue.elements.length) {
          opaqueQueue.sort(RenderQueue._compareFromNearToFar);
          alphaTestQueue.sort(RenderQueue._compareFromNearToFar);
          var _viewports_j = viewports[j2], x = _viewports_j.x, y = _viewports_j.y;
          rhi.setGlobalDepthBias(1, 1);
          rhi.viewport(x, y, shadowTileResolution, shadowTileResolution);
          rhi.scissor(x + 1, y + 1, shadowTileResolution - 2, shadowTileResolution - 2);
          engine._renderCount++;
          opaqueQueue.render(camera, Layer.Everything);
          alphaTestQueue.render(camera, Layer.Everything);
          rhi.setGlobalDepthBias(0, 0);
        }
      }
      this._existShadowMap = true;
    }
  };
  _proto._updateReceiversShaderData = function _updateReceiversShaderData() {
    var scene = this._camera.scene;
    var splitBoundSpheres = this._splitBoundSpheres;
    var shadowMatrices = this._shadowMatrices;
    var shadowCascades = scene.shadowCascades;
    if (shadowCascades > 1) {
      for (var i = shadowCascades * 4, n = splitBoundSpheres.length; i < n; i++) {
        splitBoundSpheres[i] = 0;
      }
    }
    for (var i1 = shadowCascades * 16, n1 = shadowMatrices.length; i1 < n1; i1++) {
      shadowMatrices[i1] = 0;
    }
    var shaderData = scene.shaderData;
    shaderData.setFloatArray(CascadedShadowCasterPass2._shadowMatricesProperty, this._shadowMatrices);
    shaderData.setVector3(CascadedShadowCasterPass2._shadowInfosProperty, this._shadowInfos);
    shaderData.setTexture(CascadedShadowCasterPass2._shadowMapsProperty, this._depthTexture);
    shaderData.setFloatArray(CascadedShadowCasterPass2._shadowSplitSpheresProperty, this._splitBoundSpheres);
    shaderData.setVector4(CascadedShadowCasterPass2._shadowMapSize, this._shadowMapSize);
  };
  _proto._getCascadesSplitDistance = function _getCascadesSplitDistance(shadowFar) {
    var cascadesSplitDistance = CascadedShadowCasterPass2._cascadesSplitDistance;
    var _this__camera_scene = this._camera.scene, shadowTwoCascadeSplits = _this__camera_scene.shadowTwoCascadeSplits, shadowFourCascadeSplits = _this__camera_scene.shadowFourCascadeSplits, shadowCascades = _this__camera_scene.shadowCascades;
    var _this__camera = this._camera, nearClipPlane = _this__camera.nearClipPlane, aspectRatio = _this__camera.aspectRatio, fieldOfView = _this__camera.fieldOfView;
    cascadesSplitDistance[0] = nearClipPlane;
    var range = shadowFar - nearClipPlane;
    var tFov = Math.tan(MathUtil$1.degreeToRadian(fieldOfView) * 0.5);
    var denominator = 1 + tFov * tFov * (aspectRatio * aspectRatio + 1);
    switch (shadowCascades) {
      case ShadowCascadesMode.NoCascades:
        cascadesSplitDistance[1] = this._getFarWithRadius(shadowFar, denominator);
        break;
      case ShadowCascadesMode.TwoCascades:
        cascadesSplitDistance[1] = this._getFarWithRadius(nearClipPlane + range * shadowTwoCascadeSplits, denominator);
        cascadesSplitDistance[2] = this._getFarWithRadius(shadowFar, denominator);
        break;
      case ShadowCascadesMode.FourCascades:
        cascadesSplitDistance[1] = this._getFarWithRadius(nearClipPlane + range * shadowFourCascadeSplits.x, denominator);
        cascadesSplitDistance[2] = this._getFarWithRadius(nearClipPlane + range * shadowFourCascadeSplits.y, denominator);
        cascadesSplitDistance[3] = this._getFarWithRadius(nearClipPlane + range * shadowFourCascadeSplits.z, denominator);
        cascadesSplitDistance[4] = this._getFarWithRadius(shadowFar, denominator);
        break;
    }
  };
  _proto._getFarWithRadius = function _getFarWithRadius(radius, denominator) {
    return Math.sqrt(radius * radius / denominator);
  };
  _proto._getAvailableRenderTarget = function _getAvailableRenderTarget() {
    var engine = this._engine;
    var format = this._shadowMapFormat;
    var _this__shadowMapSize = this._shadowMapSize, width = _this__shadowMapSize.z, height = _this__shadowMapSize.w;
    var depthTexture = this._depthTexture;
    var renderTarget = this._renderTargets;
    if (renderTarget == null || (depthTexture == null ? void 0 : depthTexture.width) !== width || (depthTexture == null ? void 0 : depthTexture.height) !== height || (depthTexture == null ? void 0 : depthTexture.format) !== format) {
      depthTexture = this._depthTexture = new Texture2D(engine, width, height, format, false);
      depthTexture.wrapModeV = depthTexture.wrapModeU = TextureWrapMode$1.Clamp;
      if (engine._hardwareRenderer._isWebGL2) {
        depthTexture.depthCompareFunction = TextureDepthCompareFunction.Less;
      }
      renderTarget == null ? void 0 : renderTarget._addReferCount(-1);
      if (this._supportDepthTexture) {
        renderTarget = this._renderTargets = new RenderTarget(engine, width, height, null, depthTexture);
      } else {
        renderTarget = this._renderTargets = new RenderTarget(engine, width, height, depthTexture);
      }
      renderTarget._addReferCount(1);
    }
    return renderTarget;
  };
  _proto._updateShadowSettings = function _updateShadowSettings() {
    var scene = this._camera.scene;
    var shadowFormat = ShadowUtils.shadowDepthFormat(scene.shadowResolution, this._supportDepthTexture);
    var shadowResolution = ShadowUtils.shadowResolution(scene.shadowResolution);
    var shadowCascades = scene.shadowCascades;
    if (shadowFormat !== this._shadowMapFormat || shadowResolution !== this._shadowMapResolution || shadowCascades !== this._shadowCascadeMode) {
      this._shadowMapFormat = shadowFormat;
      this._shadowMapResolution = shadowResolution;
      this._shadowCascadeMode = shadowCascades;
      if (shadowCascades == ShadowCascadesMode.NoCascades) {
        this._shadowTileResolution = shadowResolution;
        this._shadowMapSize.set(1 / shadowResolution, 1 / shadowResolution, shadowResolution, shadowResolution);
      } else {
        var shadowTileResolution = ShadowUtils.getMaxTileResolutionInAtlas(shadowResolution, shadowResolution, shadowCascades);
        this._shadowTileResolution = shadowTileResolution;
        var width = shadowTileResolution * 2;
        var height = shadowCascades == ShadowCascadesMode.TwoCascades ? shadowTileResolution : shadowTileResolution * 2;
        this._shadowMapSize.set(1 / width, 1 / height, width, height);
      }
      var renderTargets = this._renderTargets;
      if (renderTargets) {
        renderTargets._addReferCount(-1);
        renderTargets.destroy();
        this._renderTargets = null;
      }
      var viewportOffset = this._viewportOffsets;
      var shadowTileResolution1 = this._shadowTileResolution;
      switch (shadowCascades) {
        case ShadowCascadesMode.NoCascades:
          viewportOffset[0].set(0, 0);
          break;
        case ShadowCascadesMode.TwoCascades:
          viewportOffset[0].set(0, 0);
          viewportOffset[1].set(shadowTileResolution1, 0);
          break;
        case ShadowCascadesMode.FourCascades:
          viewportOffset[0].set(0, 0);
          viewportOffset[1].set(shadowTileResolution1, 0);
          viewportOffset[2].set(0, shadowTileResolution1);
          viewportOffset[3].set(shadowTileResolution1, shadowTileResolution1);
      }
    }
  };
  _proto._updateSingleShadowCasterShaderData = function _updateSingleShadowCasterShaderData(light, shadowSliceData, context) {
    var virtualCamera = shadowSliceData.virtualCamera;
    ShadowUtils.getShadowBias(light, virtualCamera.projectionMatrix, this._shadowTileResolution, this._shadowBias);
    var sceneShaderData = this._camera.scene.shaderData;
    sceneShaderData.setVector2(CascadedShadowCasterPass2._lightShadowBiasProperty, this._shadowBias);
    sceneShaderData.setVector3(CascadedShadowCasterPass2._lightDirectionProperty, light.direction);
    context.applyVirtualCamera(virtualCamera);
  };
  return CascadedShadowCasterPass2;
}();
(function() {
  CascadedShadowCasterPass._lightShadowBiasProperty = ShaderProperty.getByName("scene_ShadowBias");
})();
(function() {
  CascadedShadowCasterPass._lightDirectionProperty = ShaderProperty.getByName("scene_LightDirection");
})();
(function() {
  CascadedShadowCasterPass._shadowMatricesProperty = ShaderProperty.getByName("scene_ShadowMatrices");
})();
(function() {
  CascadedShadowCasterPass._shadowMapSize = ShaderProperty.getByName("scene_ShadowMapSize");
})();
(function() {
  CascadedShadowCasterPass._shadowInfosProperty = ShaderProperty.getByName("scene_ShadowInfo");
})();
(function() {
  CascadedShadowCasterPass._shadowMapsProperty = ShaderProperty.getByName("scene_ShadowMap");
})();
(function() {
  CascadedShadowCasterPass._shadowSplitSpheresProperty = ShaderProperty.getByName("scene_ShadowSplitSpheres");
})();
(function() {
  CascadedShadowCasterPass._maxCascades = 4;
})();
(function() {
  CascadedShadowCasterPass._cascadesSplitDistance = new Array(CascadedShadowCasterPass._maxCascades + 1);
})();
(function() {
  CascadedShadowCasterPass._viewport = new Vector4(0, 0, 1, 1);
})();
(function() {
  CascadedShadowCasterPass._clearColor = new Color$1(1, 1, 1, 1);
})();
(function() {
  CascadedShadowCasterPass._tempVector = new Vector3();
})();
(function() {
  CascadedShadowCasterPass._tempMatrix0 = new Matrix();
})();
var passNum = 0;
var RenderPass = /* @__PURE__ */ function() {
  function RenderPass2(name2, priority, renderTarget, replaceMaterial, mask) {
    if (name2 === void 0)
      name2 = "RENDER_PASS" + passNum++;
    if (priority === void 0)
      priority = 0;
    if (renderTarget === void 0)
      renderTarget = null;
    if (replaceMaterial === void 0)
      replaceMaterial = null;
    if (mask === void 0)
      mask = null;
    this.name = name2;
    this.enabled = true;
    this.priority = priority;
    this.renderTarget = renderTarget;
    this.replaceMaterial = replaceMaterial;
    this.mask = mask || Layer.Everything;
    this.renderOverride = false;
  }
  var _proto = RenderPass2.prototype;
  _proto.render = function render(camera, opaqueQueue, alphaTestQueue, transparentQueue) {
  };
  _proto.preRender = function preRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {
  };
  _proto.postRender = function postRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {
  };
  return RenderPass2;
}();
var BasicRenderPipeline = /* @__PURE__ */ function() {
  function BasicRenderPipeline2(camera) {
    this._allSpriteMasks = new DisorderedArray();
    this._lastCanvasSize = new Vector2();
    this._camera = camera;
    var engine = camera.engine;
    this._opaqueQueue = new RenderQueue(engine);
    this._alphaTestQueue = new RenderQueue(engine);
    this._transparentQueue = new RenderQueue(engine);
    this._cascadedShadowCaster = new CascadedShadowCasterPass(camera);
    this._renderPassArray = [];
    this._defaultPass = new RenderPass("default", 0, null, null, 0);
    this.addRenderPass(this._defaultPass);
  }
  var _proto = BasicRenderPipeline2.prototype;
  _proto.addRenderPass = function addRenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask) {
    if (priority === void 0)
      priority = null;
    if (renderTarget === void 0)
      renderTarget = null;
    if (replaceMaterial === void 0)
      replaceMaterial = null;
    if (mask === void 0)
      mask = null;
    if (typeof nameOrPass === "string") {
      var renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask);
      this._renderPassArray.push(renderPass);
    } else if (_instanceof$2(nameOrPass, RenderPass)) {
      this._renderPassArray.push(nameOrPass);
    }
    this._renderPassArray.sort(function(p1, p2) {
      return p1.priority - p2.priority;
    });
  };
  _proto.removeRenderPass = function removeRenderPass(nameOrPass) {
    var pass;
    if (typeof nameOrPass === "string")
      pass = this.getRenderPass(nameOrPass);
    else if (_instanceof$2(nameOrPass, RenderPass))
      pass = nameOrPass;
    if (pass) {
      var idx = this._renderPassArray.indexOf(pass);
      this._renderPassArray.splice(idx, 1);
    }
  };
  _proto.getRenderPass = function getRenderPass(name2) {
    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      var pass = this._renderPassArray[i];
      if (pass.name === name2)
        return pass;
    }
    return null;
  };
  _proto.destroy = function destroy2() {
    this._opaqueQueue.destroy();
    this._alphaTestQueue.destroy();
    this._transparentQueue.destroy();
    this._allSpriteMasks = null;
    this._renderPassArray = null;
    this._defaultPass = null;
    this._camera = null;
  };
  _proto.render = function render(context, cubeFace, mipLevel) {
    var _scene__sunLight;
    var camera = this._camera;
    var scene = camera.scene;
    var opaqueQueue = this._opaqueQueue;
    var alphaTestQueue = this._alphaTestQueue;
    var transparentQueue = this._transparentQueue;
    camera.engine._spriteMaskManager.clear();
    context.pipelineStageTagValue = BasicRenderPipeline2._shadowCasterPipelineStageTagValue;
    if (scene.castShadows && ((_scene__sunLight = scene._sunLight) == null ? void 0 : _scene__sunLight.shadowType) !== ShadowType.None) {
      this._cascadedShadowCaster._render(context);
    }
    opaqueQueue.clear();
    alphaTestQueue.clear();
    transparentQueue.clear();
    this._allSpriteMasks.length = 0;
    context.applyVirtualCamera(camera._virtualCamera);
    context.pipelineStageTagValue = BasicRenderPipeline2._forwardPipelineStageTagValue;
    this._callRender(context);
    opaqueQueue.sort(RenderQueue._compareFromNearToFar);
    alphaTestQueue.sort(RenderQueue._compareFromNearToFar);
    transparentQueue.sort(RenderQueue._compareFromFarToNear);
    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      this._drawRenderPass(context, this._renderPassArray[i], camera, cubeFace, mipLevel);
    }
  };
  _proto._drawRenderPass = function _drawRenderPass(context, pass, camera, cubeFace, mipLevel) {
    pass.preRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
    if (pass.enabled) {
      var engine = camera.engine, scene = camera.scene;
      var background = scene.background;
      var rhi = engine._hardwareRenderer;
      var renderTarget = camera.renderTarget || pass.renderTarget;
      rhi.activeRenderTarget(renderTarget, camera.viewport, mipLevel);
      renderTarget == null ? void 0 : renderTarget._setRenderTargetInfo(cubeFace, mipLevel);
      var _pass_clearFlags;
      var clearFlags = (_pass_clearFlags = pass.clearFlags) != null ? _pass_clearFlags : camera.clearFlags;
      var _pass_clearColor;
      var color = (_pass_clearColor = pass.clearColor) != null ? _pass_clearColor : background.solidColor;
      if (clearFlags !== CameraClearFlags.None) {
        rhi.clearRenderTarget(camera.engine, clearFlags, color);
      }
      if (pass.renderOverride) {
        pass.render(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
      } else {
        this._opaqueQueue.render(camera, pass.mask);
        this._alphaTestQueue.render(camera, pass.mask);
        if (camera.clearFlags & CameraClearFlags.Color) {
          if (background.mode === BackgroundMode.Sky) {
            background.sky._render(context);
          } else if (background.mode === BackgroundMode.Texture && background.texture) {
            this._drawBackgroundTexture(engine, background);
          }
        }
        this._transparentQueue.render(camera, pass.mask);
      }
      renderTarget == null ? void 0 : renderTarget._blitRenderTarget();
      renderTarget == null ? void 0 : renderTarget.generateMipmaps();
    }
    pass.postRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
  };
  _proto.pushRenderData = function pushRenderData(context, data) {
    var material = data.material;
    var renderStates = material.renderStates;
    var materialSubShader = material.shader.subShaders[0];
    var replacementShader = context.replacementShader;
    if (replacementShader) {
      var replacementSubShaders = replacementShader.subShaders;
      var replacementTagKey = context.replacementTag;
      if (replacementTagKey) {
        for (var i = 0, n = replacementSubShaders.length; i < n; i++) {
          var subShader = replacementSubShaders[i];
          if (subShader.getTagValue(replacementTagKey) === materialSubShader.getTagValue(replacementTagKey)) {
            this.pushRenderDataWihShader(context, data, subShader.passes, renderStates);
            break;
          }
        }
      } else {
        this.pushRenderDataWihShader(context, data, replacementSubShaders[0].passes, renderStates);
      }
    } else {
      this.pushRenderDataWihShader(context, data, materialSubShader.passes, renderStates);
    }
  };
  _proto.pushRenderDataWihShader = function pushRenderDataWihShader(context, element, shaderPasses, renderStates) {
    var pipelineStage = context.pipelineStageTagValue;
    var renderElementPool = context.camera.engine._renderElementPool;
    for (var i = 0, n = shaderPasses.length; i < n; i++) {
      var shaderPass = shaderPasses[i];
      if (shaderPass.getTagValue(RenderContext.pipelineStageKey) === pipelineStage) {
        var renderElement = renderElementPool.getFromPool();
        renderElement.set(element, shaderPass, renderStates[i]);
        switch (renderElement.renderState.renderQueueType) {
          case RenderQueueType.Transparent:
            this._transparentQueue.pushRenderElement(renderElement);
            break;
          case RenderQueueType.AlphaTest:
            this._alphaTestQueue.pushRenderElement(renderElement);
            break;
          case RenderQueueType.Opaque:
            this._opaqueQueue.pushRenderElement(renderElement);
            break;
        }
      }
    }
  };
  _proto._drawBackgroundTexture = function _drawBackgroundTexture(engine, background) {
    var rhi = engine._hardwareRenderer;
    var _backgroundTextureMaterial = engine._backgroundTextureMaterial, canvas = engine.canvas;
    var mesh = background._mesh;
    if ((this._lastCanvasSize.x !== canvas.width || this._lastCanvasSize.y !== canvas.height) && background._textureFillMode !== BackgroundTextureFillMode.Fill) {
      this._lastCanvasSize.set(canvas.width, canvas.height);
      background._resizeBackgroundTexture();
    }
    var program = _backgroundTextureMaterial.shader.subShaders[0].passes[0]._getShaderProgram(engine, Shader._compileMacros);
    program.bind();
    program.uploadAll(program.materialUniformBlock, _backgroundTextureMaterial.shaderData);
    program.uploadUnGroupTextures();
    _backgroundTextureMaterial.renderState._apply(engine, false);
    rhi.drawPrimitive(mesh, mesh.subMesh, program);
  };
  _proto._callRender = function _callRender(context) {
    var engine = context.camera.engine;
    var renderers = engine._componentsManager._renderers;
    var camera = context.camera;
    var elements = renderers._elements;
    for (var i = renderers.length - 1; i >= 0; --i) {
      var renderer = elements[i];
      if (!(camera.cullingMask & renderer._entity.layer)) {
        continue;
      }
      if (camera.enableFrustumCulling) {
        if (!camera._frustum.intersectsBox(renderer.bounds)) {
          continue;
        }
      }
      renderer._renderFrameCount = engine.time.frameCount;
      renderer._prepareRender(context);
    }
  };
  _create_class$4(BasicRenderPipeline2, [
    {
      key: "defaultRenderPass",
      get: function get3() {
        return this._defaultPass;
      }
    }
  ]);
  return BasicRenderPipeline2;
}();
(function() {
  BasicRenderPipeline._shadowCasterPipelineStageTagValue = PipelineStage.ShadowCaster;
})();
(function() {
  BasicRenderPipeline._forwardPipelineStageTagValue = PipelineStage.Forward;
})();
var _Camera;
var MathTemp = function MathTemp2() {
};
(function() {
  MathTemp.tempVec4 = new Vector4();
})();
(function() {
  MathTemp.tempVec3 = new Vector3();
})();
(function() {
  MathTemp.tempVec2 = new Vector2();
})();
var Camera = (_Camera = /* @__PURE__ */ function(Component2) {
  _inherits$2(Camera1, Component2);
  function Camera1(entity) {
    var _this;
    _this = Component2.call(this, entity) || this;
    _this.priority = 0;
    _this.enableFrustumCulling = true;
    _this.clearFlags = CameraClearFlags.All;
    _this.cullingMask = Layer.Everything;
    _this._globalShaderMacro = new ShaderMacroCollection();
    _this._frustum = new BoundingFrustum();
    _this._virtualCamera = new VirtualCamera();
    _this._replacementShader = null;
    _this._replacementSubShaderTag = null;
    _this._shaderData = new ShaderData(ShaderDataGroup.Camera);
    _this._isProjMatSetting = false;
    _this._nearClipPlane = 0.1;
    _this._farClipPlane = 100;
    _this._fieldOfView = 45;
    _this._orthographicSize = 10;
    _this._isProjectionDirty = true;
    _this._isInvProjMatDirty = true;
    _this._isFrustumProjectDirty = true;
    _this._customAspectRatio = void 0;
    _this._renderTarget = null;
    _this._viewport = new Vector4(0, 0, 1, 1);
    _this._inverseProjectionMatrix = new Matrix();
    _this._lastAspectSize = new Vector2(0, 0);
    _this._invViewProjMat = new Matrix();
    var transform = _this.entity.transform;
    _this._transform = transform;
    _this._isViewMatrixDirty = transform.registerWorldChangeFlag();
    _this._isInvViewProjDirty = transform.registerWorldChangeFlag();
    _this._frustumViewChangeFlag = transform.registerWorldChangeFlag();
    _this._renderPipeline = new BasicRenderPipeline(_assert_this_initialized(_this));
    _this.shaderData._addReferCount(1);
    return _this;
  }
  var _proto = Camera1.prototype;
  _proto.resetProjectionMatrix = function resetProjectionMatrix() {
    this._isProjMatSetting = false;
    this._projMatChange();
  };
  _proto.resetAspectRatio = function resetAspectRatio() {
    this._customAspectRatio = void 0;
    this._projMatChange();
  };
  _proto.worldToViewportPoint = function worldToViewportPoint(point, out) {
    var cameraPoint = MathTemp.tempVec3;
    var viewportPoint = MathTemp.tempVec4;
    Vector3.transformCoordinate(point, this.viewMatrix, cameraPoint);
    Vector3.transformToVec4(cameraPoint, this.projectionMatrix, viewportPoint);
    var w = viewportPoint.w;
    out.set((viewportPoint.x / w + 1) * 0.5, (1 - viewportPoint.y / w) * 0.5, -cameraPoint.z);
    return out;
  };
  _proto.viewportToWorldPoint = function viewportToWorldPoint(point, out) {
    var _this = this, nearClipPlane = _this.nearClipPlane, farClipPlane = _this.farClipPlane;
    var nf = 1 / (nearClipPlane - farClipPlane);
    var z2;
    if (this.isOrthographic) {
      z2 = -point.z * 2 * nf;
      z2 += (farClipPlane + nearClipPlane) * nf;
    } else {
      var pointZ = point.z;
      z2 = -pointZ * (nearClipPlane + farClipPlane) * nf;
      z2 += 2 * nearClipPlane * farClipPlane * nf;
      z2 = z2 / pointZ;
    }
    this._innerViewportToWorldPoint(point.x, point.y, (z2 + 1) / 2, this._getInvViewProjMat(), out);
    return out;
  };
  _proto.viewportPointToRay = function viewportPointToRay(point, out) {
    var invViewProjMat = this._getInvViewProjMat();
    var origin = this._innerViewportToWorldPoint(point.x, point.y, 0, invViewProjMat, out.origin);
    var direction = this._innerViewportToWorldPoint(point.x, point.y, 1, invViewProjMat, out.direction);
    Vector3.subtract(direction, origin, direction);
    direction.normalize();
    return out;
  };
  _proto.screenToViewportPoint = function screenToViewportPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (point.x / canvas.width - viewport.x) / viewport.z;
    out.y = (point.y / canvas.height - viewport.y) / viewport.w;
    point.z !== void 0 && (out.z = point.z);
    return out;
  };
  _proto.viewportToScreenPoint = function viewportToScreenPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (viewport.x + point.x * viewport.z) * canvas.width;
    out.y = (viewport.y + point.y * viewport.w) * canvas.height;
    point.z !== void 0 && (out.z = point.z);
    return out;
  };
  _proto.worldToScreenPoint = function worldToScreenPoint(point, out) {
    this.worldToViewportPoint(point, out);
    return this.viewportToScreenPoint(out, out);
  };
  _proto.screenToWorldPoint = function screenToWorldPoint(point, out) {
    this.screenToViewportPoint(point, out);
    return this.viewportToWorldPoint(out, out);
  };
  _proto.screenPointToRay = function screenPointToRay(point, out) {
    var viewportPoint = MathTemp.tempVec2;
    this.screenToViewportPoint(point, viewportPoint);
    return this.viewportPointToRay(viewportPoint, out);
  };
  _proto.render = function render(cubeFace, mipLevel) {
    if (mipLevel === void 0)
      mipLevel = 0;
    var context = this.engine._renderContext;
    var virtualCamera = this._virtualCamera;
    var transform = this.entity.transform;
    Matrix.multiply(this.projectionMatrix, this.viewMatrix, virtualCamera.viewProjectionMatrix);
    virtualCamera.position.copyFrom(transform.worldPosition);
    if (virtualCamera.isOrthographic) {
      virtualCamera.forward.copyFrom(transform.worldForward);
    }
    context.camera = this;
    context.virtualCamera = virtualCamera;
    context.replacementShader = this._replacementShader;
    context.replacementTag = this._replacementSubShaderTag;
    if (this.enableFrustumCulling && (this._frustumViewChangeFlag.flag || this._isFrustumProjectDirty)) {
      this._frustum.calculateFromMatrix(virtualCamera.viewProjectionMatrix);
      this._frustumViewChangeFlag.flag = false;
      this._isFrustumProjectDirty = false;
    }
    this._updateShaderData();
    ShaderMacroCollection.unionCollection(this.scene._globalShaderMacro, this.shaderData._macroCollection, this._globalShaderMacro);
    if (mipLevel > 0 && !this.engine._hardwareRenderer.isWebGL2) {
      mipLevel = 0;
      Logger.error("mipLevel only take effect in WebGL2.0");
    }
    this._renderPipeline.render(context, cubeFace, mipLevel);
    this._engine._renderCount++;
  };
  _proto.setReplacementShader = function setReplacementShader(shader, replacementTag) {
    this._replacementShader = shader;
    this._replacementSubShaderTag = typeof replacementTag === "string" ? ShaderTagKey.getByName(replacementTag) : replacementTag;
  };
  _proto.resetReplacementShader = function resetReplacementShader() {
    this._replacementShader = null;
    this._replacementSubShaderTag = null;
  };
  _proto._onEnable = function _onEnable() {
    this.entity.scene._attachRenderCamera(this);
  };
  _proto._onDisable = function _onDisable() {
    this.entity.scene._detachRenderCamera(this);
  };
  _proto._onDestroy = function _onDestroy() {
    var _this__renderPipeline;
    Component2.prototype._onDestroy.call(this);
    (_this__renderPipeline = this._renderPipeline) == null ? void 0 : _this__renderPipeline.destroy();
    this._isInvViewProjDirty.destroy();
    this._isViewMatrixDirty.destroy();
    this.shaderData._addReferCount(-1);
    this._entity = null;
    this._globalShaderMacro = null;
    this._frustum = null;
    this._renderPipeline = null;
    this._virtualCamera = null;
    this._shaderData = null;
    this._frustumViewChangeFlag = null;
    this._transform = null;
    this._isViewMatrixDirty = null;
    this._isInvViewProjDirty = null;
    this._viewport = null;
    this._inverseProjectionMatrix = null;
    this._lastAspectSize = null;
    this._invViewProjMat = null;
  };
  _proto._projMatChange = function _projMatChange() {
    this._isFrustumProjectDirty = true;
    this._isProjectionDirty = true;
    this._isInvProjMatDirty = true;
    this._isInvViewProjDirty.flag = true;
  };
  _proto._innerViewportToWorldPoint = function _innerViewportToWorldPoint(x, y, z2, invViewProjMat, out) {
    var clipPoint = MathTemp.tempVec3;
    clipPoint.set(x * 2 - 1, 1 - y * 2, z2 * 2 - 1);
    Vector3.transformCoordinate(clipPoint, invViewProjMat, out);
    return out;
  };
  _proto._updateShaderData = function _updateShaderData() {
    var shaderData = this.shaderData;
    shaderData.setMatrix(Camera._inverseViewMatrixProperty, this._transform.worldMatrix);
    shaderData.setVector3(Camera._cameraPositionProperty, this._transform.worldPosition);
  };
  _proto._getInvViewProjMat = function _getInvViewProjMat() {
    if (this._isInvViewProjDirty.flag) {
      this._isInvViewProjDirty.flag = false;
      Matrix.multiply(this._transform.worldMatrix, this._getInverseProjectionMatrix(), this._invViewProjMat);
    }
    return this._invViewProjMat;
  };
  _proto._getInverseProjectionMatrix = function _getInverseProjectionMatrix() {
    if (this._isInvProjMatDirty) {
      this._isInvProjMatDirty = false;
      Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
    }
    return this._inverseProjectionMatrix;
  };
  _create_class$4(Camera1, [
    {
      key: "shaderData",
      get: function get3() {
        return this._shaderData;
      }
    },
    {
      key: "nearClipPlane",
      get: function get3() {
        return this._nearClipPlane;
      },
      set: function set(value) {
        this._nearClipPlane = value;
        this._projMatChange();
      }
    },
    {
      key: "farClipPlane",
      get: function get3() {
        return this._farClipPlane;
      },
      set: function set(value) {
        this._farClipPlane = value;
        this._projMatChange();
      }
    },
    {
      key: "fieldOfView",
      get: function get3() {
        return this._fieldOfView;
      },
      set: function set(value) {
        this._fieldOfView = value;
        this._projMatChange();
      }
    },
    {
      key: "aspectRatio",
      get: function get3() {
        var canvas = this._entity.engine.canvas;
        var _this__customAspectRatio;
        return (_this__customAspectRatio = this._customAspectRatio) != null ? _this__customAspectRatio : canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
      },
      set: function set(value) {
        this._customAspectRatio = value;
        this._projMatChange();
      }
    },
    {
      key: "viewport",
      get: function get3() {
        return this._viewport;
      },
      set: function set(value) {
        if (value !== this._viewport) {
          this._viewport.copyFrom(value);
        }
        this._projMatChange();
      }
    },
    {
      key: "isOrthographic",
      get: function get3() {
        return this._virtualCamera.isOrthographic;
      },
      set: function set(value) {
        this._virtualCamera.isOrthographic = value;
        this._projMatChange();
      }
    },
    {
      key: "orthographicSize",
      get: function get3() {
        return this._orthographicSize;
      },
      set: function set(value) {
        this._orthographicSize = value;
        this._projMatChange();
      }
    },
    {
      key: "viewMatrix",
      get: function get3() {
        var viewMatrix = this._virtualCamera.viewMatrix;
        if (this._isViewMatrixDirty.flag) {
          this._isViewMatrixDirty.flag = false;
          var transform = this._transform;
          Matrix.rotationTranslation(transform.worldRotationQuaternion, transform.worldPosition, viewMatrix);
          viewMatrix.invert();
        }
        return viewMatrix;
      }
    },
    {
      key: "projectionMatrix",
      get: function get3() {
        var virtualCamera = this._virtualCamera;
        var projectionMatrix = virtualCamera.projectionMatrix;
        var canvas = this._entity.engine.canvas;
        if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
          return projectionMatrix;
        }
        this._isProjectionDirty = false;
        this._lastAspectSize.x = canvas.width;
        this._lastAspectSize.y = canvas.height;
        var aspectRatio = this.aspectRatio;
        if (!virtualCamera.isOrthographic) {
          Matrix.perspective(MathUtil$1.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, projectionMatrix);
        } else {
          var width = this._orthographicSize * aspectRatio;
          var height = this._orthographicSize;
          Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, projectionMatrix);
        }
        return projectionMatrix;
      },
      set: function set(value) {
        this._virtualCamera.projectionMatrix.copyFrom(value);
        this._isProjMatSetting = true;
        this._projMatChange();
      }
    },
    {
      key: "enableHDR",
      get: function get3() {
        console.log("not implementation");
        return false;
      },
      set: function set(value) {
        console.log("not implementation");
      }
    },
    {
      key: "renderTarget",
      get: function get3() {
        return this._renderTarget;
      },
      set: function set(value) {
        if (this._renderTarget !== value) {
          var _this__renderTarget;
          value == null ? void 0 : value._addReferCount(1);
          (_this__renderTarget = this._renderTarget) == null ? void 0 : _this__renderTarget._addReferCount(-1);
          this._renderTarget = value;
        }
      }
    }
  ]);
  return Camera1;
}(Component), function() {
  _Camera._inverseViewMatrixProperty = ShaderProperty.getByName("camera_ViewInvMat");
}(), function() {
  _Camera._cameraPositionProperty = ShaderProperty.getByName("camera_Position");
}(), _Camera);
__decorate$2([
  deepClone
], Camera.prototype, "_frustum", void 0);
__decorate$2([
  ignoreClone
], Camera.prototype, "_renderPipeline", void 0);
__decorate$2([
  ignoreClone
], Camera.prototype, "_virtualCamera", void 0);
__decorate$2([
  ignoreClone
], Camera.prototype, "_frustumViewChangeFlag", void 0);
__decorate$2([
  ignoreClone
], Camera.prototype, "_transform", void 0);
__decorate$2([
  ignoreClone
], Camera.prototype, "_isViewMatrixDirty", void 0);
__decorate$2([
  ignoreClone
], Camera.prototype, "_isInvViewProjDirty", void 0);
__decorate$2([
  deepClone
], Camera.prototype, "_viewport", void 0);
__decorate$2([
  deepClone
], Camera.prototype, "_inverseProjectionMatrix", void 0);
__decorate$2([
  deepClone
], Camera.prototype, "_lastAspectSize", void 0);
__decorate$2([
  deepClone
], Camera.prototype, "_invViewProjMat", void 0);
Camera = __decorate$2([
  dependentComponents(Transform, DependentMode.CheckOnly)
], Camera);
var mimeType = {
  json: "json",
  gltf: "json",
  mtl: "json",
  prefab: "json",
  txt: "text",
  bin: "arraybuffer",
  png: "image",
  webp: "image",
  jpg: "image"
};
var defaultRetryCount = 1;
var defaultTimeout = Infinity;
var defaultInterval = 500;
function request(url, config) {
  if (config === void 0)
    config = {};
  return new AssetPromise(function(resolve, reject, setProgress) {
    var _config_retryCount;
    var retryCount = (_config_retryCount = config.retryCount) != null ? _config_retryCount : defaultRetryCount;
    var _config_retryInterval;
    var retryInterval = (_config_retryInterval = config.retryInterval) != null ? _config_retryInterval : defaultInterval;
    var _config_timeout;
    config.timeout = (_config_timeout = config.timeout) != null ? _config_timeout : defaultTimeout;
    var _config_type;
    config.type = (_config_type = config.type) != null ? _config_type : getMimeTypeFromUrl(url);
    var realRequest = config.type === "image" ? requestImage : requestRes;
    var executor = new MultiExecutor(function() {
      return realRequest(url, config).onProgress(setProgress);
    }, retryCount, retryInterval);
    executor.start().onError(reject).onComplete(resolve);
  });
}
function requestImage(url, config) {
  return new AssetPromise(function(resolve, reject) {
    var timeout = config.timeout;
    var img = new Image();
    var onerror = function() {
      reject(new Error("request " + url + " fail"));
    };
    img.onerror = onerror;
    img.onabort = onerror;
    var timeoutId = -1;
    if (timeout != Infinity) {
      timeoutId = window.setTimeout(function() {
        reject(new Error("request " + url + " timeout"));
      }, timeout);
    }
    img.onload = function(timeoutId2) {
      return function() {
        requestAnimationFrame(function() {
          resolve(img);
          img.onload = null;
          img.onerror = null;
          img.onabort = null;
        });
        clearTimeout(timeoutId2);
      };
    }(timeoutId);
    img.crossOrigin = "anonymous";
    img.src = url;
  });
}
function requestRes(url, config) {
  return new AssetPromise(function(resolve, reject, setProgress) {
    var xhr = new XMLHttpRequest();
    xhr.timeout = config.timeout;
    var _config_method;
    config.method = (_config_method = config.method) != null ? _config_method : "get";
    xhr.onload = function() {
      if (xhr.status < 200 || xhr.status >= 300) {
        reject(new Error("request failed from: " + url));
        return;
      }
      var _xhr_response;
      var result2 = (_xhr_response = xhr.response) != null ? _xhr_response : xhr.responseText;
      resolve(result2);
    };
    xhr.onerror = function() {
      reject(new Error("request failed from: " + url));
    };
    xhr.ontimeout = function() {
      reject(new Error("request timeout from: " + url));
    };
    xhr.onprogress = function(e) {
      setProgress(e.loaded / e.total);
    };
    xhr.open(config.method, url, true);
    xhr.withCredentials = config.credentials === "include";
    xhr.responseType = config.type;
    var headers = config.headers;
    if (headers) {
      Object.keys(headers).forEach(function(name2) {
        xhr.setRequestHeader(name2, headers[name2]);
      });
    }
    xhr.send(config.body);
  });
}
function getMimeTypeFromUrl(url) {
  var extname = url.substring(url.lastIndexOf(".") + 1);
  return mimeType[extname];
}
var MultiExecutor = /* @__PURE__ */ function() {
  function MultiExecutor2(execFunc, totalCount, interval) {
    this.execFunc = execFunc;
    this.totalCount = totalCount;
    this.interval = interval;
    this._timeoutId = -100;
    this._currentCount = 0;
    this.exec = this.exec.bind(this);
  }
  var _proto = MultiExecutor2.prototype;
  _proto.start = function start() {
    this.exec();
    return this;
  };
  _proto.onComplete = function onComplete(func) {
    this._onComplete = func;
    return this;
  };
  _proto.onError = function onError(func) {
    this._onError = func;
    return this;
  };
  _proto.cancel = function cancel() {
    window.clearTimeout(this._timeoutId);
  };
  _proto.exec = function exec() {
    var _this = this;
    if (this._currentCount >= this.totalCount) {
      this._onError && this._onError(this._error);
      return;
    }
    this._currentCount++;
    this.execFunc(this._currentCount).then(function(result2) {
      return _this._onComplete && _this._onComplete(result2);
    }).catch(function(e) {
      _this._error = e;
      _this._timeoutId = window.setTimeout(_this.exec, _this.interval);
    });
  };
  return MultiExecutor2;
}();
var Loader = /* @__PURE__ */ function() {
  function Loader2(useCache) {
    this.useCache = useCache;
    this.request = request;
  }
  Loader2.registerClass = function registerClass(className, classDefine) {
    this._engineObjects[className] = classDefine;
  };
  Loader2.getClass = function getClass(className) {
    return this._engineObjects[className];
  };
  return Loader2;
}();
(function() {
  Loader._engineObjects = {};
})();
var AssetType;
(function(AssetType2) {
  AssetType2["Text"] = "Text";
  AssetType2["JSON"] = "JSON";
  AssetType2["Buffer"] = "Buffer";
  AssetType2["Texture2D"] = "Texture2D";
  AssetType2["TextureCube"] = "TextureCube";
  AssetType2["Material"] = "Material";
  AssetType2["Mesh"] = "Mesh";
  AssetType2["AnimationClip"] = "AnimationClip";
  AssetType2["AnimatorController"] = "AnimatorController";
  AssetType2["GLTF"] = "GLTF";
  AssetType2["KTX"] = "KTX";
  AssetType2["KTXCube"] = "KTXCube";
  AssetType2["Sprite"] = "Sprite";
  AssetType2["SpriteAtlas"] = "SpriteAtlas";
  AssetType2["Env"] = "Environment";
  AssetType2["Scene"] = "Scene";
  AssetType2["HDR"] = "HDR";
  AssetType2["Font"] = "Font";
  AssetType2["SourceFont"] = "SourceFont";
})(AssetType || (AssetType = {}));
var BlendMode;
(function(BlendMode2) {
  BlendMode2[BlendMode2["Normal"] = 0] = "Normal";
  BlendMode2[BlendMode2["Additive"] = 1] = "Additive";
})(BlendMode || (BlendMode = {}));
var RenderFace;
(function(RenderFace2) {
  RenderFace2[RenderFace2["Front"] = 0] = "Front";
  RenderFace2[RenderFace2["Back"] = 1] = "Back";
  RenderFace2[RenderFace2["Double"] = 2] = "Double";
})(RenderFace || (RenderFace = {}));
var BaseMaterial = /* @__PURE__ */ function(Material2) {
  _inherits$2(BaseMaterial2, Material2);
  function BaseMaterial2(engine, shader) {
    var _this;
    _this = Material2.call(this, engine, shader) || this;
    _this._renderFace = RenderFace.Front;
    _this._isTransparent = false;
    _this._blendMode = BlendMode.Normal;
    _this.shaderData.setFloat(BaseMaterial2._alphaCutoffProp, 0);
    return _this;
  }
  var _proto = BaseMaterial2.prototype;
  _proto.setIsTransparent = function setIsTransparent(passIndex, isTransparent) {
    var renderStates = this.renderStates;
    if (renderStates.length < passIndex) {
      throw "Pass should less than pass count.";
    }
    var renderState = renderStates[passIndex];
    if (isTransparent) {
      renderState.blendState.targetBlendState.enabled = true;
      renderState.depthState.writeEnabled = false;
      renderState.renderQueueType = RenderQueueType.Transparent;
      this.shaderData.enableMacro(BaseMaterial2._transparentMacro);
    } else {
      renderState.blendState.targetBlendState.enabled = false;
      renderState.depthState.writeEnabled = true;
      renderState.renderQueueType = this.shaderData.getFloat(BaseMaterial2._alphaCutoffProp) ? RenderQueueType.AlphaTest : RenderQueueType.Opaque;
      this.shaderData.disableMacro(BaseMaterial2._transparentMacro);
    }
  };
  _proto.setBlendMode = function setBlendMode(passIndex, blendMode) {
    var renderStates = this.renderStates;
    if (renderStates.length < passIndex) {
      throw "Pass should less than pass count.";
    }
    var _renderStates_passIndex_blendState = renderStates[passIndex].blendState, target = _renderStates_passIndex_blendState.targetBlendState;
    switch (blendMode) {
      case BlendMode.Normal:
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
        break;
      case BlendMode.Additive:
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.One;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
        break;
    }
  };
  _proto.setRenderFace = function setRenderFace(passIndex, renderFace) {
    var renderStates = this.renderStates;
    if (renderStates.length < passIndex) {
      throw "Pass should less than pass count.";
    }
    switch (renderFace) {
      case RenderFace.Front:
        renderStates[passIndex].rasterState.cullMode = CullMode.Back;
        break;
      case RenderFace.Back:
        renderStates[passIndex].rasterState.cullMode = CullMode.Front;
        break;
      case RenderFace.Double:
        renderStates[passIndex].rasterState.cullMode = CullMode.Off;
        break;
    }
  };
  _proto.clone = function clone() {
    var dest = new BaseMaterial2(this._engine, this.shader);
    this.cloneTo(dest);
    return dest;
  };
  _proto.cloneTo = function cloneTo(target) {
    Material2.prototype.cloneTo.call(this, target);
    target._renderFace = this._renderFace;
    target._isTransparent = this._isTransparent;
    target._blendMode = this._blendMode;
  };
  _create_class$4(BaseMaterial2, [
    {
      key: "shader",
      get: function get3() {
        return this._shader;
      },
      set: function set(value) {
        this._shader = value;
        var renderStates = this._renderStates;
        var lastStatesCount = renderStates.length;
        var maxPassCount = 0;
        var subShaders = value.subShaders;
        for (var i = 0; i < subShaders.length; i++) {
          maxPassCount = Math.max(subShaders[i].passes.length, maxPassCount);
        }
        if (lastStatesCount < maxPassCount) {
          for (var i1 = lastStatesCount; i1 < maxPassCount; i1++) {
            renderStates.push(new RenderState());
            this.setBlendMode(i1, BlendMode.Normal);
          }
        } else {
          renderStates.length = maxPassCount;
        }
      }
    },
    {
      key: "isTransparent",
      get: function get3() {
        return this._isTransparent;
      },
      set: function set(value) {
        if (value !== this._isTransparent) {
          this.setIsTransparent(0, value);
          this._isTransparent = value;
        }
      }
    },
    {
      key: "blendMode",
      get: function get3() {
        return this._blendMode;
      },
      set: function set(value) {
        if (value !== this._blendMode) {
          this.setBlendMode(0, value);
          this._blendMode = value;
        }
      }
    },
    {
      key: "alphaCutoff",
      get: function get3() {
        return this.shaderData.getFloat(BaseMaterial2._alphaCutoffProp);
      },
      set: function set(value) {
        var shaderData = this.shaderData;
        if (shaderData.getFloat(BaseMaterial2._alphaCutoffProp) !== value) {
          if (value) {
            shaderData.enableMacro(BaseMaterial2._alphaCutoffMacro);
          } else {
            shaderData.disableMacro(BaseMaterial2._alphaCutoffMacro);
          }
          var renderStates = this.renderStates;
          for (var i = 0, n = renderStates.length; i < n; i++) {
            var renderState = renderStates[i];
            if (value > 0) {
              renderState.renderQueueType = renderState.blendState.targetBlendState.enabled ? RenderQueueType.Transparent : RenderQueueType.AlphaTest;
            } else {
              renderState.renderQueueType = renderState.blendState.targetBlendState.enabled ? RenderQueueType.Transparent : RenderQueueType.Opaque;
            }
          }
          shaderData.setFloat(BaseMaterial2._alphaCutoffProp, value);
        }
      }
    },
    {
      key: "renderFace",
      get: function get3() {
        return this._renderFace;
      },
      set: function set(value) {
        if (value !== this._renderFace) {
          this.setRenderFace(0, value);
          this._renderFace = value;
        }
      }
    }
  ]);
  return BaseMaterial2;
}(Material);
(function() {
  BaseMaterial._baseTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_BASETEXTURE");
})();
(function() {
  BaseMaterial._normalTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_NORMALTEXTURE");
})();
(function() {
  BaseMaterial._emissiveTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_EMISSIVETEXTURE");
})();
(function() {
  BaseMaterial._transparentMacro = ShaderMacro.getByName("MATERIAL_IS_TRANSPARENT");
})();
(function() {
  BaseMaterial._baseColorProp = ShaderProperty.getByName("material_BaseColor");
})();
(function() {
  BaseMaterial._baseTextureProp = ShaderProperty.getByName("material_BaseTexture");
})();
(function() {
  BaseMaterial._tilingOffsetProp = ShaderProperty.getByName("material_TilingOffset");
})();
(function() {
  BaseMaterial._normalTextureProp = ShaderProperty.getByName("material_NormalTexture");
})();
(function() {
  BaseMaterial._normalIntensityProp = ShaderProperty.getByName("material_NormalIntensity");
})();
(function() {
  BaseMaterial._emissiveColorProp = ShaderProperty.getByName("material_EmissiveColor");
})();
(function() {
  BaseMaterial._emissiveTextureProp = ShaderProperty.getByName("material_EmissiveTexture");
})();
(function() {
  BaseMaterial._alphaCutoffProp = ShaderProperty.getByName("material_AlphaCutoff");
})();
(function() {
  BaseMaterial._alphaCutoffMacro = ShaderMacro.getByName("MATERIAL_IS_ALPHA_CUTOFF");
})();
var BlinnPhongMaterial = /* @__PURE__ */ function(BaseMaterial2) {
  _inherits$2(BlinnPhongMaterial2, BaseMaterial2);
  function BlinnPhongMaterial2(engine) {
    var _this;
    _this = BaseMaterial2.call(this, engine, Shader.find("blinn-phong")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("MATERIAL_NEED_WORLD_POS");
    shaderData.enableMacro("MATERIAL_NEED_TILING_OFFSET");
    shaderData.setColor(BlinnPhongMaterial2._baseColorProp, new Color$1(1, 1, 1, 1));
    shaderData.setColor(BlinnPhongMaterial2._specularColorProp, new Color$1(1, 1, 1, 1));
    shaderData.setColor(BlinnPhongMaterial2._emissiveColorProp, new Color$1(0, 0, 0, 1));
    shaderData.setVector4(BlinnPhongMaterial2._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    shaderData.setFloat(BlinnPhongMaterial2._shininessProp, 16);
    shaderData.setFloat(BlinnPhongMaterial2._normalIntensityProp, 1);
    return _this;
  }
  var _proto = BlinnPhongMaterial2.prototype;
  _proto.clone = function clone() {
    var dest = new BlinnPhongMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _create_class$4(BlinnPhongMaterial2, [
    {
      key: "baseColor",
      get: function get3() {
        return this.shaderData.getColor(BlinnPhongMaterial2._baseColorProp);
      },
      set: function set(value) {
        var baseColor = this.shaderData.getColor(BlinnPhongMaterial2._baseColorProp);
        if (value !== baseColor) {
          baseColor.copyFrom(value);
        }
      }
    },
    {
      key: "baseTexture",
      get: function get3() {
        return this.shaderData.getTexture(BlinnPhongMaterial2._baseTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(BlinnPhongMaterial2._baseTextureProp, value);
        if (value) {
          this.shaderData.enableMacro(BlinnPhongMaterial2._baseTextureMacro);
        } else {
          this.shaderData.disableMacro(BlinnPhongMaterial2._baseTextureMacro);
        }
      }
    },
    {
      key: "specularColor",
      get: function get3() {
        return this.shaderData.getColor(BlinnPhongMaterial2._specularColorProp);
      },
      set: function set(value) {
        var specularColor = this.shaderData.getColor(BlinnPhongMaterial2._specularColorProp);
        if (value !== specularColor) {
          specularColor.copyFrom(value);
        }
      }
    },
    {
      key: "specularTexture",
      get: function get3() {
        return this.shaderData.getTexture(BlinnPhongMaterial2._specularTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(BlinnPhongMaterial2._specularTextureProp, value);
        if (value) {
          this.shaderData.enableMacro("MATERIAL_HAS_SPECULAR_TEXTURE");
        } else {
          this.shaderData.disableMacro("MATERIAL_HAS_SPECULAR_TEXTURE");
        }
      }
    },
    {
      key: "emissiveColor",
      get: function get3() {
        return this.shaderData.getColor(BlinnPhongMaterial2._emissiveColorProp);
      },
      set: function set(value) {
        var emissiveColor = this.shaderData.getColor(BlinnPhongMaterial2._emissiveColorProp);
        if (value !== emissiveColor) {
          emissiveColor.copyFrom(value);
        }
      }
    },
    {
      key: "emissiveTexture",
      get: function get3() {
        return this.shaderData.getTexture(BlinnPhongMaterial2._emissiveTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(BlinnPhongMaterial2._emissiveTextureProp, value);
        if (value) {
          this.shaderData.enableMacro(BlinnPhongMaterial2._emissiveTextureMacro);
        } else {
          this.shaderData.disableMacro(BlinnPhongMaterial2._emissiveTextureMacro);
        }
      }
    },
    {
      key: "normalTexture",
      get: function get3() {
        return this.shaderData.getTexture(BlinnPhongMaterial2._normalTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(BlinnPhongMaterial2._normalTextureProp, value);
        if (value) {
          this.shaderData.enableMacro(BlinnPhongMaterial2._normalTextureMacro);
        } else {
          this.shaderData.disableMacro(BlinnPhongMaterial2._normalTextureMacro);
        }
      }
    },
    {
      key: "normalIntensity",
      get: function get3() {
        return this.shaderData.getFloat(BlinnPhongMaterial2._normalIntensityProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(BlinnPhongMaterial2._normalIntensityProp, value);
      }
    },
    {
      key: "shininess",
      get: function get3() {
        return this.shaderData.getFloat(BlinnPhongMaterial2._shininessProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(BlinnPhongMaterial2._shininessProp, Math.max(value, 1e-4));
      }
    },
    {
      key: "tilingOffset",
      get: function get3() {
        return this.shaderData.getVector4(BlinnPhongMaterial2._tilingOffsetProp);
      },
      set: function set(value) {
        var tilingOffset = this.shaderData.getVector4(BlinnPhongMaterial2._tilingOffsetProp);
        if (value !== tilingOffset) {
          tilingOffset.copyFrom(value);
        }
      }
    }
  ]);
  return BlinnPhongMaterial2;
}(BaseMaterial);
(function() {
  BlinnPhongMaterial._specularColorProp = ShaderProperty.getByName("material_SpecularColor");
})();
(function() {
  BlinnPhongMaterial._shininessProp = ShaderProperty.getByName("material_Shininess");
})();
(function() {
  BlinnPhongMaterial._specularTextureProp = ShaderProperty.getByName("material_SpecularTexture");
})();
var TextureCoordinate;
(function(TextureCoordinate2) {
  TextureCoordinate2[TextureCoordinate2["UV0"] = 0] = "UV0";
  TextureCoordinate2[TextureCoordinate2["UV1"] = 1] = "UV1";
  TextureCoordinate2[TextureCoordinate2["UV2"] = 2] = "UV2";
  TextureCoordinate2[TextureCoordinate2["UV3"] = 3] = "UV3";
  TextureCoordinate2[TextureCoordinate2["UV4"] = 4] = "UV4";
  TextureCoordinate2[TextureCoordinate2["UV5"] = 5] = "UV5";
  TextureCoordinate2[TextureCoordinate2["UV6"] = 6] = "UV6";
  TextureCoordinate2[TextureCoordinate2["UV7"] = 7] = "UV7";
})(TextureCoordinate || (TextureCoordinate = {}));
var PBRBaseMaterial = /* @__PURE__ */ function(BaseMaterial2) {
  _inherits$2(PBRBaseMaterial2, BaseMaterial2);
  function PBRBaseMaterial2(engine, shader) {
    var _this;
    _this = BaseMaterial2.call(this, engine, shader) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("MATERIAL_NEED_WORLD_POS");
    shaderData.enableMacro("MATERIAL_NEED_TILING_OFFSET");
    shaderData.setColor(PBRBaseMaterial2._baseColorProp, new Color$1(1, 1, 1, 1));
    shaderData.setColor(PBRBaseMaterial2._emissiveColorProp, new Color$1(0, 0, 0, 1));
    shaderData.setVector4(PBRBaseMaterial2._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    shaderData.setFloat(PBRBaseMaterial2._normalIntensityProp, 1);
    shaderData.setFloat(PBRBaseMaterial2._occlusionTextureIntensityProp, 1);
    shaderData.setFloat(PBRBaseMaterial2._occlusionTextureCoordProp, TextureCoordinate.UV0);
    shaderData.setFloat(PBRBaseMaterial2._clearCoatProp, 0);
    shaderData.setFloat(PBRBaseMaterial2._clearCoatRoughnessProp, 0);
    return _this;
  }
  _create_class$4(PBRBaseMaterial2, [
    {
      key: "baseColor",
      get: function get3() {
        return this.shaderData.getColor(PBRBaseMaterial2._baseColorProp);
      },
      set: function set(value) {
        var baseColor = this.shaderData.getColor(PBRBaseMaterial2._baseColorProp);
        if (value !== baseColor) {
          baseColor.copyFrom(value);
        }
      }
    },
    {
      key: "baseTexture",
      get: function get3() {
        return this.shaderData.getTexture(PBRBaseMaterial2._baseTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(PBRBaseMaterial2._baseTextureProp, value);
        if (value) {
          this.shaderData.enableMacro(PBRBaseMaterial2._baseTextureMacro);
        } else {
          this.shaderData.disableMacro(PBRBaseMaterial2._baseTextureMacro);
        }
      }
    },
    {
      key: "normalTexture",
      get: function get3() {
        return this.shaderData.getTexture(PBRBaseMaterial2._normalTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(PBRBaseMaterial2._normalTextureProp, value);
        if (value) {
          this.shaderData.enableMacro(PBRBaseMaterial2._normalTextureMacro);
        } else {
          this.shaderData.disableMacro(PBRBaseMaterial2._normalTextureMacro);
        }
      }
    },
    {
      key: "normalTextureIntensity",
      get: function get3() {
        return this.shaderData.getFloat(PBRBaseMaterial2._normalIntensityProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(PBRBaseMaterial2._normalIntensityProp, value);
      }
    },
    {
      key: "emissiveColor",
      get: function get3() {
        return this.shaderData.getColor(PBRBaseMaterial2._emissiveColorProp);
      },
      set: function set(value) {
        var emissiveColor = this.shaderData.getColor(PBRBaseMaterial2._emissiveColorProp);
        if (value !== emissiveColor) {
          emissiveColor.copyFrom(value);
        }
      }
    },
    {
      key: "emissiveTexture",
      get: function get3() {
        return this.shaderData.getTexture(PBRBaseMaterial2._emissiveTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(PBRBaseMaterial2._emissiveTextureProp, value);
        if (value) {
          this.shaderData.enableMacro(PBRBaseMaterial2._emissiveTextureMacro);
        } else {
          this.shaderData.disableMacro(PBRBaseMaterial2._emissiveTextureMacro);
        }
      }
    },
    {
      key: "occlusionTexture",
      get: function get3() {
        return this.shaderData.getTexture(PBRBaseMaterial2._occlusionTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(PBRBaseMaterial2._occlusionTextureProp, value);
        if (value) {
          this.shaderData.enableMacro("MATERIAL_HAS_OCCLUSION_TEXTURE");
        } else {
          this.shaderData.disableMacro("MATERIAL_HAS_OCCLUSION_TEXTURE");
        }
      }
    },
    {
      key: "occlusionTextureIntensity",
      get: function get3() {
        return this.shaderData.getFloat(PBRBaseMaterial2._occlusionTextureIntensityProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(PBRBaseMaterial2._occlusionTextureIntensityProp, value);
      }
    },
    {
      key: "occlusionTextureCoord",
      get: function get3() {
        return this.shaderData.getFloat(PBRBaseMaterial2._occlusionTextureCoordProp);
      },
      set: function set(value) {
        if (value > TextureCoordinate.UV1) {
          Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
        }
        this.shaderData.setFloat(PBRBaseMaterial2._occlusionTextureCoordProp, value);
      }
    },
    {
      key: "tilingOffset",
      get: function get3() {
        return this.shaderData.getVector4(PBRBaseMaterial2._tilingOffsetProp);
      },
      set: function set(value) {
        var tilingOffset = this.shaderData.getVector4(PBRBaseMaterial2._tilingOffsetProp);
        if (value !== tilingOffset) {
          tilingOffset.copyFrom(value);
        }
      }
    },
    {
      key: "clearCoat",
      get: function get3() {
        return this.shaderData.getFloat(PBRBaseMaterial2._clearCoatProp);
      },
      set: function set(value) {
        if (!!this.shaderData.getFloat(PBRBaseMaterial2._clearCoatProp) !== !!value) {
          if (value === 0) {
            this.shaderData.disableMacro("MATERIAL_ENABLE_CLEAR_COAT");
          } else {
            this.shaderData.enableMacro("MATERIAL_ENABLE_CLEAR_COAT");
          }
        }
        this.shaderData.setFloat(PBRBaseMaterial2._clearCoatProp, value);
      }
    },
    {
      key: "clearCoatTexture",
      get: function get3() {
        return this.shaderData.getTexture(PBRBaseMaterial2._clearCoatTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(PBRBaseMaterial2._clearCoatTextureProp, value);
        if (value) {
          this.shaderData.enableMacro("MATERIAL_HAS_CLEAR_COAT_TEXTURE");
        } else {
          this.shaderData.disableMacro("MATERIAL_HAS_CLEAR_COAT_TEXTURE");
        }
      }
    },
    {
      key: "clearCoatRoughness",
      get: function get3() {
        return this.shaderData.getFloat(PBRBaseMaterial2._clearCoatRoughnessProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(PBRBaseMaterial2._clearCoatRoughnessProp, value);
      }
    },
    {
      key: "clearCoatRoughnessTexture",
      get: function get3() {
        return this.shaderData.getTexture(PBRBaseMaterial2._clearCoatRoughnessTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(PBRBaseMaterial2._clearCoatRoughnessTextureProp, value);
        if (value) {
          this.shaderData.enableMacro("MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE");
        } else {
          this.shaderData.disableMacro("MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE");
        }
      }
    },
    {
      key: "clearCoatNormalTexture",
      get: function get3() {
        return this.shaderData.getTexture(PBRBaseMaterial2._clearCoatNormalTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(PBRBaseMaterial2._clearCoatNormalTextureProp, value);
        if (value) {
          this.shaderData.enableMacro("MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE");
        } else {
          this.shaderData.disableMacro("MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE");
        }
      }
    }
  ]);
  return PBRBaseMaterial2;
}(BaseMaterial);
(function() {
  PBRBaseMaterial._occlusionTextureIntensityProp = ShaderProperty.getByName("material_OcclusionIntensity");
})();
(function() {
  PBRBaseMaterial._occlusionTextureCoordProp = ShaderProperty.getByName("material_OcclusionTextureCoord");
})();
(function() {
  PBRBaseMaterial._occlusionTextureProp = ShaderProperty.getByName("material_OcclusionTexture");
})();
(function() {
  PBRBaseMaterial._clearCoatProp = ShaderProperty.getByName("material_ClearCoat");
})();
(function() {
  PBRBaseMaterial._clearCoatTextureProp = ShaderProperty.getByName("material_ClearCoatTexture");
})();
(function() {
  PBRBaseMaterial._clearCoatRoughnessProp = ShaderProperty.getByName("material_ClearCoatRoughness");
})();
(function() {
  PBRBaseMaterial._clearCoatRoughnessTextureProp = ShaderProperty.getByName("material_ClearCoatRoughnessTexture");
})();
(function() {
  PBRBaseMaterial._clearCoatNormalTextureProp = ShaderProperty.getByName("material_ClearCoatNormalTexture");
})();
var PBRMaterial = /* @__PURE__ */ function(PBRBaseMaterial2) {
  _inherits$2(PBRMaterial2, PBRBaseMaterial2);
  function PBRMaterial2(engine) {
    var _this;
    _this = PBRBaseMaterial2.call(this, engine, Shader.find("pbr")) || this;
    _this.shaderData.setFloat(PBRMaterial2._metallicProp, 1);
    _this.shaderData.setFloat(PBRMaterial2._roughnessProp, 1);
    _this.shaderData.setFloat(PBRMaterial2._iorProp, 1.5);
    return _this;
  }
  var _proto = PBRMaterial2.prototype;
  _proto.clone = function clone() {
    var dest = new PBRMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _create_class$4(PBRMaterial2, [
    {
      key: "ior",
      get: function get3() {
        return this.shaderData.getFloat(PBRMaterial2._iorProp);
      },
      set: function set(v) {
        this.shaderData.setFloat(PBRMaterial2._iorProp, Math.max(v, 0));
      }
    },
    {
      key: "metallic",
      get: function get3() {
        return this.shaderData.getFloat(PBRMaterial2._metallicProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(PBRMaterial2._metallicProp, value);
      }
    },
    {
      key: "roughness",
      get: function get3() {
        return this.shaderData.getFloat(PBRMaterial2._roughnessProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(PBRMaterial2._roughnessProp, value);
      }
    },
    {
      key: "roughnessMetallicTexture",
      get: function get3() {
        return this.shaderData.getTexture(PBRMaterial2._roughnessMetallicTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(PBRMaterial2._roughnessMetallicTextureProp, value);
        if (value) {
          this.shaderData.enableMacro("MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE");
        } else {
          this.shaderData.disableMacro("MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE");
        }
      }
    }
  ]);
  return PBRMaterial2;
}(PBRBaseMaterial);
(function() {
  PBRMaterial._metallicProp = ShaderProperty.getByName("material_Metal");
})();
(function() {
  PBRMaterial._roughnessProp = ShaderProperty.getByName("material_Roughness");
})();
(function() {
  PBRMaterial._roughnessMetallicTextureProp = ShaderProperty.getByName("material_RoughnessMetallicTexture");
})();
(function() {
  PBRMaterial._iorProp = Shader.getPropertyByName("material_IOR");
})();
var PBRSpecularMaterial = /* @__PURE__ */ function(PBRBaseMaterial2) {
  _inherits$2(PBRSpecularMaterial2, PBRBaseMaterial2);
  function PBRSpecularMaterial2(engine) {
    var _this;
    _this = PBRBaseMaterial2.call(this, engine, Shader.find("pbr-specular")) || this;
    _this.shaderData.setColor(PBRSpecularMaterial2._specularColorProp, new Color$1(1, 1, 1, 1));
    _this.shaderData.setFloat(PBRSpecularMaterial2._glossinessProp, 1);
    return _this;
  }
  var _proto = PBRSpecularMaterial2.prototype;
  _proto.clone = function clone() {
    var dest = new PBRSpecularMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _create_class$4(PBRSpecularMaterial2, [
    {
      key: "specularColor",
      get: function get3() {
        return this.shaderData.getColor(PBRSpecularMaterial2._specularColorProp);
      },
      set: function set(value) {
        var specularColor = this.shaderData.getColor(PBRSpecularMaterial2._specularColorProp);
        if (value !== specularColor) {
          specularColor.copyFrom(value);
        }
      }
    },
    {
      key: "glossiness",
      get: function get3() {
        return this.shaderData.getFloat(PBRSpecularMaterial2._glossinessProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(PBRSpecularMaterial2._glossinessProp, value);
      }
    },
    {
      key: "specularGlossinessTexture",
      get: function get3() {
        return this.shaderData.getTexture(PBRSpecularMaterial2._specularGlossinessTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(PBRSpecularMaterial2._specularGlossinessTextureProp, value);
        if (value) {
          this.shaderData.enableMacro(PBRSpecularMaterial2._specularGlossinessTextureMacro);
        } else {
          this.shaderData.disableMacro(PBRSpecularMaterial2._specularGlossinessTextureMacro);
        }
      }
    }
  ]);
  return PBRSpecularMaterial2;
}(PBRBaseMaterial);
(function() {
  PBRSpecularMaterial._specularColorProp = ShaderProperty.getByName("material_PBRSpecularColor");
})();
(function() {
  PBRSpecularMaterial._glossinessProp = ShaderProperty.getByName("material_Glossiness");
})();
(function() {
  PBRSpecularMaterial._specularGlossinessTextureProp = ShaderProperty.getByName("material_SpecularGlossinessTexture");
})();
(function() {
  PBRSpecularMaterial._specularGlossinessTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE");
})();
var UnlitMaterial = /* @__PURE__ */ function(BaseMaterial2) {
  _inherits$2(UnlitMaterial2, BaseMaterial2);
  function UnlitMaterial2(engine) {
    var _this;
    _this = BaseMaterial2.call(this, engine, Shader.find("unlit")) || this;
    var shaderData = _this.shaderData;
    shaderData.enableMacro("MATERIAL_OMIT_NORMAL");
    shaderData.enableMacro("MATERIAL_NEED_TILING_OFFSET");
    shaderData.setColor(UnlitMaterial2._baseColorProp, new Color$1(1, 1, 1, 1));
    shaderData.setVector4(UnlitMaterial2._tilingOffsetProp, new Vector4(1, 1, 0, 0));
    return _this;
  }
  var _proto = UnlitMaterial2.prototype;
  _proto.clone = function clone() {
    var dest = new UnlitMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _create_class$4(UnlitMaterial2, [
    {
      key: "baseColor",
      get: function get3() {
        return this.shaderData.getColor(UnlitMaterial2._baseColorProp);
      },
      set: function set(value) {
        var baseColor = this.shaderData.getColor(UnlitMaterial2._baseColorProp);
        if (value !== baseColor) {
          baseColor.copyFrom(value);
        }
      }
    },
    {
      key: "baseTexture",
      get: function get3() {
        return this.shaderData.getTexture(UnlitMaterial2._baseTextureProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(UnlitMaterial2._baseTextureProp, value);
        if (value) {
          this.shaderData.enableMacro(UnlitMaterial2._baseTextureMacro);
        } else {
          this.shaderData.disableMacro(UnlitMaterial2._baseTextureMacro);
        }
      }
    },
    {
      key: "tilingOffset",
      get: function get3() {
        return this.shaderData.getVector4(UnlitMaterial2._tilingOffsetProp);
      },
      set: function set(value) {
        var tilingOffset = this.shaderData.getVector4(UnlitMaterial2._tilingOffsetProp);
        if (value !== tilingOffset) {
          tilingOffset.copyFrom(value);
        }
      }
    }
  ]);
  return UnlitMaterial2;
}(BaseMaterial);
var TextHorizontalAlignment;
(function(TextHorizontalAlignment2) {
  TextHorizontalAlignment2[TextHorizontalAlignment2["Left"] = 0] = "Left";
  TextHorizontalAlignment2[TextHorizontalAlignment2["Center"] = 1] = "Center";
  TextHorizontalAlignment2[TextHorizontalAlignment2["Right"] = 2] = "Right";
})(TextHorizontalAlignment || (TextHorizontalAlignment = {}));
var TextVerticalAlignment;
(function(TextVerticalAlignment2) {
  TextVerticalAlignment2[TextVerticalAlignment2["Top"] = 0] = "Top";
  TextVerticalAlignment2[TextVerticalAlignment2["Center"] = 1] = "Center";
  TextVerticalAlignment2[TextVerticalAlignment2["Bottom"] = 2] = "Bottom";
})(TextVerticalAlignment || (TextVerticalAlignment = {}));
var SpriteAtlas = /* @__PURE__ */ function(ReferResource2) {
  _inherits$2(SpriteAtlas2, ReferResource2);
  function SpriteAtlas2(engine) {
    var _this;
    _this = ReferResource2.call(this, engine) || this;
    _this._sprites = new Array();
    _this._spriteNamesToIndex = {};
    return _this;
  }
  var _proto = SpriteAtlas2.prototype;
  _proto.getSprite = function getSprite(name2) {
    var sprite = this._sprites[this._spriteNamesToIndex[name2]];
    if (!sprite) {
      console.warn("There is no sprite named " + name2 + " in the atlas.");
    }
    return sprite;
  };
  _proto.getSprites = function getSprites(name2, outSprites) {
    outSprites.length = 0;
    var i = this._spriteNamesToIndex[name2];
    if (i !== void 0) {
      var _sprites = this._sprites;
      for (; i >= 0; i--) {
        var sprite = _sprites[i];
        sprite.name === name2 && outSprites.push(sprite);
      }
    } else {
      console.warn("The name of the sprite you want to find is not exit in SpriteAtlas.");
    }
    return outSprites;
  };
  _proto._addSprite = function _addSprite(sprite) {
    this._spriteNamesToIndex[sprite.name] = this._sprites.push(sprite) - 1;
    sprite._atlas = this;
    sprite.isGCIgnored = true;
  };
  _proto._onDestroy = function _onDestroy() {
    ReferResource2.prototype._onDestroy.call(this);
    var _this = this, sprites = _this._sprites;
    for (var i = 0, n = sprites.length; i < n; i++) {
      sprites[i].destroy();
    }
    sprites.length = 0;
    this._sprites = null;
    this._spriteNamesToIndex = null;
  };
  _create_class$4(SpriteAtlas2, [
    {
      key: "sprites",
      get: function get3() {
        return this._sprites;
      }
    }
  ]);
  return SpriteAtlas2;
}(ReferResource);
var SpriteDrawMode;
(function(SpriteDrawMode2) {
  SpriteDrawMode2[SpriteDrawMode2["Simple"] = 0] = "Simple";
  SpriteDrawMode2[SpriteDrawMode2["Sliced"] = 1] = "Sliced";
  SpriteDrawMode2[SpriteDrawMode2["Tiled"] = 2] = "Tiled";
})(SpriteDrawMode || (SpriteDrawMode = {}));
var SpriteTileMode;
(function(SpriteTileMode2) {
  SpriteTileMode2[SpriteTileMode2["Continuous"] = 0] = "Continuous";
  SpriteTileMode2[SpriteTileMode2["Adaptive"] = 1] = "Adaptive";
})(SpriteTileMode || (SpriteTileMode = {}));
var Sprite = /* @__PURE__ */ function(ReferResource2) {
  _inherits$2(Sprite2, ReferResource2);
  function Sprite2(engine, texture, region, pivot, border, name2) {
    if (texture === void 0)
      texture = null;
    if (region === void 0)
      region = null;
    if (pivot === void 0)
      pivot = null;
    if (border === void 0)
      border = null;
    if (name2 === void 0)
      name2 = null;
    var _this;
    _this = ReferResource2.call(this, engine) || this;
    _this._automaticWidth = 0;
    _this._automaticHeight = 0;
    _this._customWidth = void 0;
    _this._customHeight = void 0;
    _this._positions = [
      new Vector2(),
      new Vector2(),
      new Vector2(),
      new Vector2()
    ];
    _this._uvs = [
      new Vector2(),
      new Vector2(),
      new Vector2(),
      new Vector2()
    ];
    _this._bounds = new BoundingBox();
    _this._texture = null;
    _this._atlasRotated = false;
    _this._atlasRegion = new Rect(0, 0, 1, 1);
    _this._atlasRegionOffset = new Vector4(0, 0, 0, 0);
    _this._region = new Rect(0, 0, 1, 1);
    _this._pivot = new Vector2(0.5, 0.5);
    _this._border = new Vector4(0, 0, 0, 0);
    _this._dirtyUpdateFlag = 7;
    _this._updateFlagManager = new UpdateFlagManager();
    _this._texture = texture;
    _this._onRegionChange = _this._onRegionChange.bind(_assert_this_initialized(_this));
    _this._onPivotChange = _this._onPivotChange.bind(_assert_this_initialized(_this));
    _this._onBorderChange = _this._onBorderChange.bind(_assert_this_initialized(_this));
    _this._region._onValueChanged = _this._onRegionChange;
    _this._pivot._onValueChanged = _this._onPivotChange;
    _this._border._onValueChanged = _this._onBorderChange;
    region && _this._region.copyFrom(region);
    pivot && _this._pivot.copyFrom(pivot);
    border && _this._border.copyFrom(border);
    _this.name = name2;
    return _this;
  }
  var _proto = Sprite2.prototype;
  _proto.clone = function clone() {
    var cloneSprite = new Sprite2(this._engine, this._texture, this._region, this._pivot, this._border, this.name);
    cloneSprite._atlasRotated = this._atlasRotated;
    cloneSprite._atlasRegion.copyFrom(this._atlasRegion);
    cloneSprite._atlasRegionOffset.copyFrom(this._atlasRegionOffset);
    return cloneSprite;
  };
  _proto._getPositions = function _getPositions() {
    this._dirtyUpdateFlag & 1 && this._updatePositions();
    return this._positions;
  };
  _proto._getUVs = function _getUVs() {
    this._dirtyUpdateFlag & 2 && this._updateUVs();
    return this._uvs;
  };
  _proto._getBounds = function _getBounds() {
    this._dirtyUpdateFlag & 1 && this._updatePositions();
    return this._bounds;
  };
  _proto._addReferCount = function _addReferCount(value) {
    var _this__atlas;
    ReferResource2.prototype._addReferCount.call(this, value);
    (_this__atlas = this._atlas) == null ? void 0 : _this__atlas._addReferCount(value);
  };
  _proto._onDestroy = function _onDestroy() {
    ReferResource2.prototype._onDestroy.call(this);
    this._positions.length = 0;
    this._positions = null;
    this._uvs.length = 0;
    this._uvs = null;
    this._atlasRegion = null;
    this._atlasRegionOffset = null;
    this._region = null;
    this._pivot = null;
    this._border = null;
    this._bounds = null;
    this._atlas = null;
    this._texture = null;
    this._updateFlagManager = null;
  };
  _proto._calDefaultSize = function _calDefaultSize() {
    if (this._texture) {
      var _this = this, _texture = _this._texture, _atlasRegion = _this._atlasRegion, _atlasRegionOffset = _this._atlasRegionOffset, _region = _this._region;
      var pixelsPerUnitReciprocal = 1 / Engine._pixelsPerUnit;
      this._automaticWidth = _texture.width * _atlasRegion.width / (1 - _atlasRegionOffset.x - _atlasRegionOffset.z) * _region.width * pixelsPerUnitReciprocal;
      this._automaticHeight = _texture.height * _atlasRegion.height / (1 - _atlasRegionOffset.y - _atlasRegionOffset.w) * _region.height * pixelsPerUnitReciprocal;
    } else {
      this._automaticWidth = this._automaticHeight = 0;
    }
    this._dirtyUpdateFlag &= ~4;
  };
  _proto._updatePositions = function _updatePositions() {
    var blank = this._atlasRegionOffset;
    var _this__region = this._region, regionX = _this__region.x, regionY = _this__region.y, regionW = _this__region.width, regionH = _this__region.height;
    var regionRight = 1 - regionX - regionW;
    var regionBottom = 1 - regionY - regionH;
    var left = Math.max(blank.x - regionX, 0) / regionW;
    var bottom = Math.max(blank.w - regionY, 0) / regionH;
    var right = 1 - Math.max(blank.z - regionRight, 0) / regionW;
    var top = 1 - Math.max(blank.y - regionBottom, 0) / regionH;
    var positions = this._positions;
    positions[0].set(left, bottom);
    positions[1].set(right, bottom);
    positions[2].set(left, top);
    positions[3].set(right, top);
    var _this__bounds = this._bounds, min = _this__bounds.min, max = _this__bounds.max;
    min.set(left, bottom, 0);
    max.set(right, top, 0);
    this._dirtyUpdateFlag &= ~1;
  };
  _proto._updateUVs = function _updateUVs() {
    var _this = this, uv = _this._uvs, atlasRegionOffset = _this._atlasRegionOffset;
    var _this__region = this._region, regionX = _this__region.x, regionY = _this__region.y, regionW = _this__region.width, regionH = _this__region.height;
    var regionRight = 1 - regionX - regionW;
    var regionBottom = 1 - regionY - regionH;
    var _this__atlasRegion = this._atlasRegion, atlasRegionX = _this__atlasRegion.x, atlasRegionY = _this__atlasRegion.y, atlasRegionW = _this__atlasRegion.width, atlasRegionH = _this__atlasRegion.height;
    var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
    var realWidth = atlasRegionW / (1 - offsetLeft - offsetRight);
    var realHeight = atlasRegionH / (1 - offsetTop - offsetBottom);
    var left = Math.max(regionX - offsetLeft, 0) * realWidth + atlasRegionX;
    var top = Math.max(regionBottom - offsetTop, 0) * realHeight + atlasRegionY;
    var right = atlasRegionW + atlasRegionX - Math.max(regionRight - offsetRight, 0) * realWidth;
    var bottom = atlasRegionH + atlasRegionY - Math.max(regionY - offsetBottom, 0) * realHeight;
    var _this__border = this._border, borderLeft = _this__border.x, borderBottom = _this__border.y, borderRight = _this__border.z, borderTop = _this__border.w;
    uv[0].set(left, bottom);
    uv[1].set((regionX - offsetLeft + borderLeft * regionW) * realWidth + atlasRegionX, atlasRegionH + atlasRegionY - (regionY - offsetBottom + borderBottom * regionH) * realHeight);
    uv[2].set(atlasRegionW + atlasRegionX - (regionRight - offsetRight + borderRight * regionW) * realWidth, (regionBottom - offsetTop + borderTop * regionH) * realHeight + atlasRegionY);
    uv[3].set(right, top);
    this._dirtyUpdateFlag &= ~2;
  };
  _proto._dispatchSpriteChange = function _dispatchSpriteChange(type) {
    switch (type) {
      case SpriteModifyFlags.texture:
        this._dirtyUpdateFlag |= 4;
        break;
      case SpriteModifyFlags.atlasRegionOffset:
      case SpriteModifyFlags.region:
        this._dirtyUpdateFlag |= 7;
        break;
      case SpriteModifyFlags.atlasRegion:
        this._dirtyUpdateFlag |= 4 | 2;
        break;
      case SpriteModifyFlags.border:
        this._dirtyUpdateFlag |= 2;
        break;
    }
    this._updateFlagManager.dispatch(type);
  };
  _proto._onRegionChange = function _onRegionChange() {
    var _this = this, region = _this._region;
    region._onValueChanged = null;
    var x = MathUtil$1.clamp(region.x, 0, 1);
    var y = MathUtil$1.clamp(region.y, 0, 1);
    region.set(x, y, MathUtil$1.clamp(region.width, 0, 1 - x), MathUtil$1.clamp(region.height, 0, 1 - y));
    this._dispatchSpriteChange(SpriteModifyFlags.region);
    if (this._customWidth === void 0 || this._customHeight === void 0) {
      this._dispatchSpriteChange(SpriteModifyFlags.size);
    }
    region._onValueChanged = this._onRegionChange;
  };
  _proto._onPivotChange = function _onPivotChange() {
    this._dispatchSpriteChange(SpriteModifyFlags.pivot);
  };
  _proto._onBorderChange = function _onBorderChange() {
    var _this = this, border = _this._border;
    border._onValueChanged = null;
    var x = MathUtil$1.clamp(border.x, 0, 1);
    var y = MathUtil$1.clamp(border.y, 0, 1);
    border.set(x, y, MathUtil$1.clamp(border.z, 0, 1 - x), MathUtil$1.clamp(border.w, 0, 1 - y));
    this._dispatchSpriteChange(SpriteModifyFlags.border);
    border._onValueChanged = this._onBorderChange;
  };
  _create_class$4(Sprite2, [
    {
      key: "texture",
      get: function get3() {
        return this._texture;
      },
      set: function set(value) {
        if (this._texture !== value) {
          this._texture = value;
          this._dispatchSpriteChange(SpriteModifyFlags.texture);
          if (this._customWidth === void 0 || this._customHeight === void 0) {
            this._dispatchSpriteChange(SpriteModifyFlags.size);
          }
        }
      }
    },
    {
      key: "width",
      get: function get3() {
        if (this._customWidth !== void 0) {
          return this._customWidth;
        } else {
          this._dirtyUpdateFlag & 4 && this._calDefaultSize();
          return this._automaticWidth;
        }
      },
      set: function set(value) {
        if (this._customWidth !== value) {
          this._customWidth = value;
          this._dispatchSpriteChange(SpriteModifyFlags.size);
        }
      }
    },
    {
      key: "height",
      get: function get3() {
        if (this._customHeight !== void 0) {
          return this._customHeight;
        } else {
          this._dirtyUpdateFlag & 4 && this._calDefaultSize();
          return this._automaticHeight;
        }
      },
      set: function set(value) {
        if (this._customHeight !== value) {
          this._customHeight = value;
          this._dispatchSpriteChange(SpriteModifyFlags.size);
        }
      }
    },
    {
      key: "atlasRotated",
      get: function get3() {
        return this._atlasRotated;
      },
      set: function set(value) {
        if (this._atlasRotated != value) {
          this._atlasRotated = value;
        }
      }
    },
    {
      key: "atlasRegion",
      get: function get3() {
        return this._atlasRegion;
      },
      set: function set(value) {
        var x = MathUtil$1.clamp(value.x, 0, 1);
        var y = MathUtil$1.clamp(value.y, 0, 1);
        this._atlasRegion.set(x, y, MathUtil$1.clamp(value.width, 0, 1 - x), MathUtil$1.clamp(value.height, 0, 1 - y));
        this._dispatchSpriteChange(SpriteModifyFlags.atlasRegion);
        if (this._customWidth === void 0 || this._customHeight === void 0) {
          this._dispatchSpriteChange(SpriteModifyFlags.size);
        }
      }
    },
    {
      key: "atlasRegionOffset",
      get: function get3() {
        return this._atlasRegionOffset;
      },
      set: function set(value) {
        var x = MathUtil$1.clamp(value.x, 0, 1);
        var y = MathUtil$1.clamp(value.y, 0, 1);
        this._atlasRegionOffset.set(x, y, MathUtil$1.clamp(value.z, 0, 1 - x), MathUtil$1.clamp(value.w, 0, 1 - y));
        this._dispatchSpriteChange(SpriteModifyFlags.atlasRegionOffset);
        if (this._customWidth === void 0 || this._customHeight === void 0) {
          this._dispatchSpriteChange(SpriteModifyFlags.size);
        }
      }
    },
    {
      key: "region",
      get: function get3() {
        return this._region;
      },
      set: function set(value) {
        this._region !== value && this._region.copyFrom(value);
      }
    },
    {
      key: "pivot",
      get: function get3() {
        return this._pivot;
      },
      set: function set(value) {
        this._pivot !== value && this._pivot.copyFrom(value);
      }
    },
    {
      key: "border",
      get: function get3() {
        return this._border;
      },
      set: function set(value) {
        this._border !== value && this._border.copyFrom(value);
      }
    }
  ]);
  return Sprite2;
}(ReferResource);
var SpriteUpdateFlags;
(function(SpriteUpdateFlags2) {
  SpriteUpdateFlags2[SpriteUpdateFlags2["positions"] = 1] = "positions";
  SpriteUpdateFlags2[SpriteUpdateFlags2["uvs"] = 2] = "uvs";
  SpriteUpdateFlags2[SpriteUpdateFlags2["automaticSize"] = 4] = "automaticSize";
  SpriteUpdateFlags2[SpriteUpdateFlags2["all"] = 7] = "all";
})(SpriteUpdateFlags || (SpriteUpdateFlags = {}));
var _SlicedSpriteAssembler;
var SlicedSpriteAssembler = (_SlicedSpriteAssembler = /* @__PURE__ */ function() {
  function SlicedSpriteAssembler1() {
  }
  SlicedSpriteAssembler1.resetData = function resetData(renderer) {
    var verticesData = renderer._verticesData;
    var positions = verticesData.positions, uvs = verticesData.uvs;
    if (positions.length < 16) {
      for (var i = positions.length; i < 16; i++) {
        positions.push(new Vector3());
        uvs.push(new Vector2());
      }
    }
    verticesData.triangles = [];
  };
  SlicedSpriteAssembler1.updatePositions = function updatePositions(renderer) {
    var width = renderer.width, height = renderer.height, sprite = renderer.sprite;
    var _renderer__verticesData = renderer._verticesData, positions = _renderer__verticesData.positions, uvs = _renderer__verticesData.uvs, triangles = _renderer__verticesData.triangles;
    var border = sprite.border;
    var spriteUVs = sprite._getUVs();
    var spritePositions = sprite._getPositions();
    var _spritePositions_ = spritePositions[0], left = _spritePositions_.x, bottom = _spritePositions_.y;
    var _spritePositions_1 = spritePositions[3], right = _spritePositions_1.x, top = _spritePositions_1.y;
    var expectWidth = sprite.width, expectHeight = sprite.height;
    var fixedLeft = expectWidth * border.x;
    var fixedBottom = expectHeight * border.y;
    var fixedRight = expectWidth * border.z;
    var fixedTop = expectHeight * border.w;
    var row, column;
    if (fixedLeft + fixedRight > width) {
      var widthScale = width / (fixedLeft + fixedRight);
      row = [
        expectWidth * left * widthScale,
        fixedLeft * widthScale,
        fixedLeft * widthScale,
        width - expectWidth * (1 - right) * widthScale
      ];
    } else {
      row = [
        expectWidth * left,
        fixedLeft,
        width - fixedRight,
        width - expectWidth * (1 - right)
      ];
    }
    if (fixedTop + fixedBottom > height) {
      var heightScale = height / (fixedTop + fixedBottom);
      column = [
        expectHeight * bottom * heightScale,
        fixedBottom * heightScale,
        fixedBottom * heightScale,
        height - expectHeight * (1 - top) * heightScale
      ];
    } else {
      column = [
        expectHeight * bottom,
        fixedBottom,
        height - fixedTop,
        height - expectHeight * (1 - top)
      ];
    }
    var _renderer_sprite_pivot = renderer.sprite.pivot, pivotX = _renderer_sprite_pivot.x, pivotY = _renderer_sprite_pivot.y;
    var localTransX = renderer.width * pivotX;
    var localTransY = renderer.height * pivotY;
    var worldMatrix = SlicedSpriteAssembler._worldMatrix;
    var wE = worldMatrix.elements;
    var _renderer_entity_transform_worldMatrix = renderer.entity.transform.worldMatrix, pWE = _renderer_entity_transform_worldMatrix.elements;
    var sx = renderer.flipX ? -1 : 1;
    var sy = renderer.flipY ? -1 : 1;
    wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
    wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
    wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
    wE[12] = pWE[12] - localTransX * wE[0] - localTransY * wE[4];
    wE[13] = pWE[13] - localTransX * wE[1] - localTransY * wE[5];
    wE[14] = pWE[14] - localTransX * wE[2] - localTransY * wE[6];
    var vertexCount = 0;
    var realICount = 0;
    for (var i = 0; i < 4; i++) {
      var rowValue = row[i];
      var rowU = spriteUVs[i].x;
      for (var j2 = 0; j2 < 4; j2++) {
        var columnValue = column[j2];
        positions[vertexCount].set(wE[0] * rowValue + wE[4] * columnValue + wE[12], wE[1] * rowValue + wE[5] * columnValue + wE[13], wE[2] * rowValue + wE[6] * columnValue + wE[14]);
        uvs[vertexCount].set(rowU, spriteUVs[j2].y);
        ++vertexCount;
      }
      ++realICount;
    }
    var realJCount = vertexCount / realICount;
    var indexOffset = 0;
    for (var i1 = 0; i1 < realICount - 1; ++i1) {
      for (var j1 = 0; j1 < realJCount - 1; ++j1) {
        var start = i1 * realJCount + j1;
        triangles[indexOffset++] = start;
        triangles[indexOffset++] = start + 1;
        triangles[indexOffset++] = start + realJCount;
        triangles[indexOffset++] = start + 1;
        triangles[indexOffset++] = start + realJCount + 1;
        triangles[indexOffset++] = start + realJCount;
      }
    }
    renderer._verticesData.vertexCount = realICount * realJCount;
    triangles.length = (realICount - 1) * (realJCount - 1) * 6;
    var _renderer__bounds = renderer._bounds, min = _renderer__bounds.min, max = _renderer__bounds.max;
    min.set(row[0], column[0], 0);
    max.set(row[3], column[3], 0);
    renderer._bounds.transform(worldMatrix);
  };
  SlicedSpriteAssembler1.updateUVs = function updateUVs(renderer) {
  };
  return SlicedSpriteAssembler1;
}(), function() {
  _SlicedSpriteAssembler._worldMatrix = new Matrix();
}(), _SlicedSpriteAssembler);
SlicedSpriteAssembler = __decorate$2([
  StaticInterfaceImplement$1()
], SlicedSpriteAssembler);
var _TiledSpriteAssembler;
var TiledSpriteAssembler = (_TiledSpriteAssembler = /* @__PURE__ */ function() {
  function TiledSpriteAssembler1() {
  }
  TiledSpriteAssembler1.resetData = function resetData(renderer) {
    var _renderer__verticesData;
    (_renderer__verticesData = renderer._verticesData).triangles || (_renderer__verticesData.triangles = []);
  };
  TiledSpriteAssembler1.updatePositions = function updatePositions(renderer) {
    var width = renderer.width, height = renderer.height, sprite = renderer.sprite, tileMode = renderer.tileMode, threshold = renderer.tiledAdaptiveThreshold;
    var _renderer__verticesData = renderer._verticesData, positions = _renderer__verticesData.positions, uvs = _renderer__verticesData.uvs, triangles = _renderer__verticesData.triangles;
    var _this = this, posRow = _this._posRow, posColumn = _this._posColumn, uvRow = _this._uvRow, uvColumn = _this._uvColumn;
    posRow.length = posColumn.length = uvRow.length = uvColumn.length = 0;
    tileMode === SpriteTileMode.Adaptive ? this._calculateAdaptiveDividing(sprite, width, height, threshold, posRow, posColumn, uvRow, uvColumn) : this._calculateContinuousDividing(sprite, width, height, posRow, posColumn, uvRow, uvColumn);
    var _renderer_sprite_pivot = renderer.sprite.pivot, pivotX = _renderer_sprite_pivot.x, pivotY = _renderer_sprite_pivot.y;
    var localTransX = renderer.width * pivotX;
    var localTransY = renderer.height * pivotY;
    var worldMatrix = TiledSpriteAssembler._worldMatrix;
    var wE = worldMatrix.elements;
    var _renderer_entity_transform_worldMatrix = renderer.entity.transform.worldMatrix, pWE = _renderer_entity_transform_worldMatrix.elements;
    var sx = renderer.flipX ? -1 : 1;
    var sy = renderer.flipY ? -1 : 1;
    var wE0, wE1, wE2;
    var wE4, wE5, wE6;
    wE0 = wE[0] = pWE[0] * sx, wE1 = wE[1] = pWE[1] * sx, wE2 = wE[2] = pWE[2] * sx;
    wE4 = wE[4] = pWE[4] * sy, wE5 = wE[5] = pWE[5] * sy, wE6 = wE[6] = pWE[6] * sy;
    wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
    var wE12 = wE[12] = pWE[12] - localTransX * wE[0] - localTransY * wE[4];
    var wE13 = wE[13] = pWE[13] - localTransX * wE[1] - localTransY * wE[5];
    var wE14 = wE[14] = pWE[14] - localTransX * wE[2] - localTransY * wE[6];
    var rowLength = posRow.length - 1;
    var columnLength = posColumn.length - 1;
    var count = 0;
    var trianglesOffset = 0;
    for (var j2 = 0; j2 < columnLength; j2++) {
      var doubleJ = 2 * j2;
      for (var i = 0; i < rowLength; i++) {
        var uvL = uvRow.get(2 * i);
        var uvB = uvColumn.get(doubleJ);
        var uvR = uvRow.get(2 * i + 1);
        var uvT = uvColumn.get(doubleJ + 1);
        if (isNaN(uvL) || isNaN(uvL) || isNaN(uvR) || isNaN(uvT)) {
          continue;
        }
        triangles[trianglesOffset++] = count;
        triangles[trianglesOffset++] = count + 1;
        triangles[trianglesOffset++] = count + 2;
        triangles[trianglesOffset++] = count + 2;
        triangles[trianglesOffset++] = count + 1;
        triangles[trianglesOffset++] = count + 3;
        var l = posRow.get(i);
        var b = posColumn.get(j2);
        var r = posRow.get(i + 1);
        var t = posColumn.get(j2 + 1);
        uvs[count] ? uvs[count].set(uvL, uvB) : uvs[count] = new Vector2(uvL, uvB);
        var pos = positions[count];
        if (pos) {
          pos.set(wE0 * l + wE4 * b + wE12, wE1 * l + wE5 * b + wE13, wE2 * l + wE6 * b + wE14);
        } else {
          positions[count] = new Vector3(wE0 * l + wE4 * b + wE12, wE1 * l + wE5 * b + wE13, wE2 * l + wE6 * b + wE14);
        }
        count++;
        uvs[count] ? uvs[count].set(uvR, uvB) : uvs[count] = new Vector2(uvR, uvB);
        pos = positions[count];
        if (pos) {
          pos.set(wE0 * r + wE4 * b + wE12, wE1 * r + wE5 * b + wE13, wE2 * r + wE6 * b + wE14);
        } else {
          positions[count] = new Vector3(wE0 * r + wE4 * b + wE12, wE1 * r + wE5 * b + wE13, wE2 * r + wE6 * b + wE14);
        }
        count++;
        uvs[count] ? uvs[count].set(uvL, uvT) : uvs[count] = new Vector2(uvL, uvT);
        pos = positions[count];
        if (pos) {
          pos.set(wE0 * l + wE4 * t + wE12, wE1 * l + wE5 * t + wE13, wE2 * l + wE6 * t + wE14);
        } else {
          positions[count] = new Vector3(wE0 * l + wE4 * t + wE12, wE1 * l + wE5 * t + wE13, wE2 * l + wE6 * t + wE14);
        }
        count++;
        uvs[count] ? uvs[count].set(uvR, uvT) : uvs[count] = new Vector2(uvR, uvT);
        pos = positions[count];
        if (pos) {
          pos.set(wE0 * r + wE4 * t + wE12, wE1 * r + wE5 * t + wE13, wE2 * r + wE6 * t + wE14);
        } else {
          positions[count] = new Vector3(wE0 * r + wE4 * t + wE12, wE1 * r + wE5 * t + wE13, wE2 * r + wE6 * t + wE14);
        }
        count++;
      }
    }
    renderer._verticesData.vertexCount = count;
    triangles.length = trianglesOffset;
    var _renderer__bounds = renderer._bounds, min = _renderer__bounds.min, max = _renderer__bounds.max;
    min.set(posRow.get(0), posColumn.get(0), 0);
    max.set(posRow.get(rowLength), posColumn.get(columnLength), 0);
    renderer._bounds.transform(worldMatrix);
  };
  TiledSpriteAssembler1.updateUVs = function updateUVs(renderer) {
  };
  TiledSpriteAssembler1._calculateAdaptiveDividing = function _calculateAdaptiveDividing(sprite, width, height, threshold, posRow, posColumn, uvRow, uvColumn) {
    var border = sprite.border;
    var spritePositions = sprite._getPositions();
    var _spritePositions_ = spritePositions[0], left = _spritePositions_.x, bottom = _spritePositions_.y;
    var _spritePositions_1 = spritePositions[3], right = _spritePositions_1.x, top = _spritePositions_1.y;
    var _sprite__getUVs = sprite._getUVs(), spriteUV0 = _sprite__getUVs[0], spriteUV1 = _sprite__getUVs[1], spriteUV2 = _sprite__getUVs[2], spriteUV3 = _sprite__getUVs[3];
    var expectWidth = sprite.width, expectHeight = sprite.height;
    var fixedL = expectWidth * border.x;
    var fixedR = expectWidth * border.z;
    var fixedLR = fixedL + fixedR;
    var fixedCW = expectWidth - fixedLR;
    var fixedT = expectHeight * border.w;
    var fixedB = expectHeight * border.y;
    var fixedTB = fixedT + fixedB;
    var fixedCH = expectHeight - fixedTB;
    var scale;
    var rType, cType;
    var rVertCount, cVertCount;
    var rRepeatCount, cRepeatCount;
    if (fixedLR >= width) {
      rVertCount = 3;
      rType = 0;
    } else {
      if (fixedCW > MathUtil$1.zeroTolerance) {
        rRepeatCount = (width - fixedLR) / fixedCW;
        rRepeatCount = rRepeatCount % 1 >= threshold ? Math.ceil(rRepeatCount) : Math.floor(rRepeatCount);
        rVertCount = 4 + rRepeatCount - 1;
        rType = 2;
      } else {
        rVertCount = 4;
        rType = 1;
      }
    }
    if (fixedTB >= height) {
      cVertCount = 3;
      cType = 0;
    } else {
      if (fixedCH > MathUtil$1.zeroTolerance) {
        cRepeatCount = (height - fixedTB) / fixedCH;
        cRepeatCount = cRepeatCount % 1 >= threshold ? Math.ceil(cRepeatCount) : Math.floor(cRepeatCount);
        cVertCount = 4 + cRepeatCount - 1;
        cType = 2;
      } else {
        cVertCount = 4;
        cType = 1;
      }
    }
    if ((rVertCount - 1) * (cVertCount - 1) * 4 > Basic2DBatcher.MAX_VERTEX_COUNT) {
      posRow.add(width * left), posRow.add(width * right);
      posColumn.add(height * bottom), posColumn.add(height * top);
      uvRow.add(spriteUV0.x), uvRow.add(spriteUV3.x);
      uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV3.y);
      Logger.warn("The number of vertices exceeds the upper limit(" + Basic2DBatcher.MAX_VERTEX_COUNT + ").");
      return;
    }
    switch (rType) {
      case 0:
        scale = width / fixedLR;
        posRow.add(expectWidth * left * scale), posRow.add(fixedL * scale);
        posRow.add(width - expectWidth * (1 - right) * scale);
        uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
        break;
      case 1:
        posRow.add(expectWidth * left), posRow.add(fixedL), posRow.add(width - fixedR);
        posRow.add(width - expectWidth * (1 - right));
        uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(NaN), uvRow.add(NaN);
        uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
        break;
      case 2:
        scale = width / (fixedLR + rRepeatCount * fixedCW);
        posRow.add(expectWidth * left * scale), posRow.add(fixedL * scale);
        uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(spriteUV1.x);
        for (var i = 0, l = rRepeatCount - 1; i < l; i++) {
          posRow.add(fixedL + (i + 1) * fixedCW * scale);
          uvRow.add(spriteUV2.x), uvRow.add(spriteUV1.x);
        }
        posRow.add(width - fixedR * scale), posRow.add(width - expectWidth * (1 - right) * scale);
        uvRow.add(spriteUV2.x), uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
        break;
    }
    switch (cType) {
      case 0:
        scale = height / fixedTB;
        posColumn.add(expectHeight * bottom * scale), posColumn.add(fixedB * scale);
        posColumn.add(height - expectHeight * (1 - top) * scale);
        uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
        break;
      case 1:
        posColumn.add(expectHeight * bottom), posColumn.add(fixedB), posColumn.add(height - fixedT);
        posColumn.add(height - expectHeight * (1 - top));
        uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(NaN), uvColumn.add(NaN);
        uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
        break;
      case 2:
        scale = height / (fixedTB + cRepeatCount * fixedCH);
        posColumn.add(expectHeight * bottom * scale), posColumn.add(fixedB * scale);
        uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(spriteUV1.y);
        for (var i1 = 0, l1 = cRepeatCount - 1; i1 < l1; i1++) {
          posColumn.add(fixedB + (i1 + 1) * fixedCH * scale);
          uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV1.y);
        }
        posColumn.add(height - fixedT * scale), posColumn.add(height - expectHeight * (1 - top) * scale);
        uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
        break;
    }
  };
  TiledSpriteAssembler1._calculateContinuousDividing = function _calculateContinuousDividing(sprite, width, height, posRow, posColumn, uvRow, uvColumn) {
    var border = sprite.border;
    var spritePositions = sprite._getPositions();
    var _spritePositions_ = spritePositions[0], left = _spritePositions_.x, bottom = _spritePositions_.y;
    var _spritePositions_1 = spritePositions[3], right = _spritePositions_1.x, top = _spritePositions_1.y;
    var _sprite__getUVs = sprite._getUVs(), spriteUV0 = _sprite__getUVs[0], spriteUV1 = _sprite__getUVs[1], spriteUV2 = _sprite__getUVs[2], spriteUV3 = _sprite__getUVs[3];
    var expectWidth = sprite.width, expectHeight = sprite.height;
    var fixedL = expectWidth * border.x;
    var fixedR = expectWidth * border.z;
    var fixedLR = fixedL + fixedR;
    var fixedCW = expectWidth - fixedLR;
    var fixedT = expectHeight * border.w;
    var fixedB = expectHeight * border.y;
    var fixedTB = fixedT + fixedB;
    var fixedCH = expectHeight - fixedTB;
    var rType, cType;
    var rVertCount, cVertCount;
    var rRepeatCount, cRepeatCount;
    if (fixedLR >= width) {
      rVertCount = 3;
      rType = 0;
    } else {
      if (fixedCW > MathUtil$1.zeroTolerance) {
        rRepeatCount = (width - fixedLR) / fixedCW;
        rVertCount = 4 + (rRepeatCount | 0);
        rType = 2;
      } else {
        rVertCount = 4;
        rType = 1;
      }
    }
    if (fixedTB >= height) {
      cVertCount = 3;
      cType = 0;
    } else {
      if (fixedCH > MathUtil$1.zeroTolerance) {
        cRepeatCount = (height - fixedTB) / fixedCH;
        cVertCount = 4 + (cRepeatCount | 0);
        cType = 2;
      } else {
        cVertCount = 4;
        cType = 1;
      }
    }
    if ((rVertCount - 1) * (cVertCount - 1) * 4 > Basic2DBatcher.MAX_VERTEX_COUNT) {
      posRow.add(width * left), posRow.add(width * right);
      posColumn.add(height * bottom), posColumn.add(height * top);
      uvRow.add(spriteUV0.x), uvRow.add(spriteUV3.x);
      uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV3.y);
      Logger.warn("The number of vertices exceeds the upper limit(" + Basic2DBatcher.MAX_VERTEX_COUNT + ").");
      return;
    }
    switch (rType) {
      case 0:
        var scale = width / fixedLR;
        posRow.add(expectWidth * left * scale), posRow.add(fixedL * scale);
        posRow.add(width - expectWidth * (1 - right) * scale);
        uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
        break;
      case 1:
        posRow.add(expectWidth * left), posRow.add(fixedL), posRow.add(width - fixedR);
        posRow.add(width - expectWidth * (1 - right));
        uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(NaN), uvRow.add(NaN);
        uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
        break;
      case 2:
        posRow.add(expectWidth * left), posRow.add(fixedL);
        uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(spriteUV1.x);
        var countInteger = rRepeatCount | 0;
        for (var i = 0; i < countInteger; i++) {
          posRow.add(fixedL + (i + 1) * fixedCW);
          uvRow.add(spriteUV2.x), uvRow.add(spriteUV1.x);
        }
        posRow.add(width - fixedR), posRow.add(width - expectWidth * (1 - right));
        uvRow.add((spriteUV2.x - spriteUV1.x) * (rRepeatCount - countInteger) + spriteUV1.x);
        uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
        break;
    }
    switch (cType) {
      case 0:
        var scale1 = height / fixedTB;
        posColumn.add(expectHeight * bottom * scale1), posColumn.add(fixedB * scale1);
        posColumn.add(height - expectHeight * (1 - top) * scale1);
        uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
        break;
      case 1:
        posColumn.add(expectHeight * bottom), posColumn.add(fixedB), posColumn.add(height - fixedT);
        posColumn.add(height - expectHeight * (1 - top));
        uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(NaN), uvColumn.add(NaN);
        uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
        break;
      case 2:
        posColumn.add(expectHeight * bottom), posColumn.add(fixedB);
        uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(spriteUV1.y);
        var countInteger1 = cRepeatCount | 0;
        for (var i1 = 0; i1 < countInteger1; i1++) {
          posColumn.add(fixedB + (i1 + 1) * fixedCH);
          uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV1.y);
        }
        posColumn.add(height - fixedT), posColumn.add(height - expectHeight * (1 - top));
        uvColumn.add((spriteUV2.y - spriteUV1.y) * (cRepeatCount - countInteger1) + spriteUV1.y);
        uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
        break;
    }
  };
  return TiledSpriteAssembler1;
}(), function() {
  _TiledSpriteAssembler._worldMatrix = new Matrix();
}(), function() {
  _TiledSpriteAssembler._posRow = new DisorderedArray();
}(), function() {
  _TiledSpriteAssembler._posColumn = new DisorderedArray();
}(), function() {
  _TiledSpriteAssembler._uvRow = new DisorderedArray();
}(), function() {
  _TiledSpriteAssembler._uvColumn = new DisorderedArray();
}(), _TiledSpriteAssembler);
TiledSpriteAssembler = __decorate$2([
  StaticInterfaceImplement$1()
], TiledSpriteAssembler);
var TiledType;
(function(TiledType2) {
  TiledType2[TiledType2["Compressed"] = 0] = "Compressed";
  TiledType2[TiledType2["WithoutTiled"] = 1] = "WithoutTiled";
  TiledType2[TiledType2["WithTiled"] = 2] = "WithTiled";
})(TiledType || (TiledType = {}));
var SpriteRenderer = /* @__PURE__ */ function(Renderer2) {
  _inherits$2(SpriteRenderer2, Renderer2);
  function SpriteRenderer2(entity) {
    var _this;
    _this = Renderer2.call(this, entity) || this;
    _this._tileMode = SpriteTileMode.Continuous;
    _this._tiledAdaptiveThreshold = 0.5;
    _this._color = new Color$1(1, 1, 1, 1);
    _this._sprite = null;
    _this._automaticWidth = 0;
    _this._automaticHeight = 0;
    _this._customWidth = void 0;
    _this._customHeight = void 0;
    _this._flipX = false;
    _this._flipY = false;
    _this._maskLayer = SpriteMaskLayer.Layer0;
    _this._maskInteraction = SpriteMaskInteraction.None;
    _this._verticesData = new VertexData2D(4, [], [], null, _this._color);
    _this.drawMode = SpriteDrawMode.Simple;
    _this.setMaterial(_this._engine._spriteDefaultMaterial);
    _this._onSpriteChange = _this._onSpriteChange.bind(_assert_this_initialized(_this));
    return _this;
  }
  var _proto = SpriteRenderer2.prototype;
  _proto._cloneTo = function _cloneTo(target) {
    Renderer2.prototype._cloneTo.call(this, target);
    target._assembler.resetData(target);
    target.sprite = this._sprite;
    target.drawMode = this._drawMode;
  };
  _proto._updateShaderData = function _updateShaderData(context) {
    this._updateTransformShaderData(context, Matrix._identity);
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    if (this.sprite) {
      this._assembler.updatePositions(this);
    } else {
      worldBounds.min.set(0, 0, 0);
      worldBounds.max.set(0, 0, 0);
    }
  };
  _proto._render = function _render(context) {
    var _this_sprite;
    if (!((_this_sprite = this.sprite) == null ? void 0 : _this_sprite.texture) || !this.width || !this.height) {
      return;
    }
    if (this._dirtyUpdateFlag & RendererUpdateFlags.WorldVolume) {
      this._assembler.updatePositions(this);
      this._dirtyUpdateFlag &= ~RendererUpdateFlags.WorldVolume;
    }
    if (this._dirtyUpdateFlag & 2) {
      this._assembler.updateUVs(this);
      this._dirtyUpdateFlag &= ~2;
    }
    var material = this.getMaterial();
    var texture = this.sprite.texture;
    var renderData = this._engine._spriteRenderDataPool.getFromPool();
    renderData.set(this, material, this._verticesData, texture);
    context.camera._renderPipeline.pushRenderData(context, renderData);
  };
  _proto._onDestroy = function _onDestroy() {
    Renderer2.prototype._onDestroy.call(this);
    var sprite = this._sprite;
    if (sprite) {
      sprite._addReferCount(-1);
      sprite._updateFlagManager.removeListener(this._onSpriteChange);
    }
    this._entity = null;
    this._color = null;
    this._sprite = null;
    this._assembler = null;
    this._verticesData = null;
  };
  _proto._calDefaultSize = function _calDefaultSize() {
    var sprite = this._sprite;
    if (sprite) {
      this._automaticWidth = sprite.width;
      this._automaticHeight = sprite.height;
    } else {
      this._automaticWidth = this._automaticHeight = 0;
    }
    this._dirtyUpdateFlag &= ~4;
  };
  _proto._updateStencilState = function _updateStencilState() {
    var material = this.getInstanceMaterial();
    var stencilState = material.renderState.stencilState;
    var maskInteraction = this._maskInteraction;
    if (maskInteraction === SpriteMaskInteraction.None) {
      stencilState.enabled = false;
      stencilState.writeMask = 255;
      stencilState.referenceValue = 0;
      stencilState.compareFunctionFront = stencilState.compareFunctionBack = CompareFunction.Always;
    } else {
      stencilState.enabled = true;
      stencilState.writeMask = 0;
      stencilState.referenceValue = 1;
      var compare = maskInteraction === SpriteMaskInteraction.VisibleInsideMask ? CompareFunction.LessEqual : CompareFunction.Greater;
      stencilState.compareFunctionFront = compare;
      stencilState.compareFunctionBack = compare;
    }
  };
  _proto._onSpriteChange = function _onSpriteChange(type) {
    switch (type) {
      case SpriteModifyFlags.texture:
        this.shaderData.setTexture(SpriteRenderer2._textureProperty, this.sprite.texture);
        break;
      case SpriteModifyFlags.size:
        var _this = this, drawMode = _this._drawMode;
        this._dirtyUpdateFlag |= 4;
        if (this._drawMode === SpriteDrawMode.Sliced) {
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        } else if (drawMode === SpriteDrawMode.Tiled) {
          this._dirtyUpdateFlag |= 3;
        } else {
          if (this._customWidth === void 0 || this._customHeight === void 0) {
            this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
          }
        }
        break;
      case SpriteModifyFlags.border:
        this._drawMode === SpriteDrawMode.Sliced && (this._dirtyUpdateFlag |= 3);
        break;
      case SpriteModifyFlags.region:
      case SpriteModifyFlags.atlasRegionOffset:
        this._dirtyUpdateFlag |= 3;
        break;
      case SpriteModifyFlags.atlasRegion:
        this._dirtyUpdateFlag |= 2;
        break;
      case SpriteModifyFlags.pivot:
        this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        break;
    }
  };
  _create_class$4(SpriteRenderer2, [
    {
      key: "drawMode",
      get: function get3() {
        return this._drawMode;
      },
      set: function set(value) {
        if (this._drawMode !== value) {
          this._drawMode = value;
          switch (value) {
            case SpriteDrawMode.Simple:
              this._assembler = SimpleSpriteAssembler;
              break;
            case SpriteDrawMode.Sliced:
              this._assembler = SlicedSpriteAssembler;
              break;
            case SpriteDrawMode.Tiled:
              this._assembler = TiledSpriteAssembler;
              break;
          }
          this._assembler.resetData(this);
          this._dirtyUpdateFlag |= 3;
        }
      }
    },
    {
      key: "tileMode",
      get: function get3() {
        return this._tileMode;
      },
      set: function set(value) {
        if (this._tileMode !== value) {
          this._tileMode = value;
          if (this.drawMode === SpriteDrawMode.Tiled) {
            this._dirtyUpdateFlag |= 3;
          }
        }
      }
    },
    {
      key: "tiledAdaptiveThreshold",
      get: function get3() {
        return this._tiledAdaptiveThreshold;
      },
      set: function set(value) {
        if (value !== this._tiledAdaptiveThreshold) {
          value = MathUtil$1.clamp(value, 0, 1);
          this._tiledAdaptiveThreshold = value;
          if (this.drawMode === SpriteDrawMode.Tiled) {
            this._dirtyUpdateFlag |= 3;
          }
        }
      }
    },
    {
      key: "sprite",
      get: function get3() {
        return this._sprite;
      },
      set: function set(value) {
        var lastSprite = this._sprite;
        if (lastSprite !== value) {
          if (lastSprite) {
            lastSprite._addReferCount(-1);
            lastSprite._updateFlagManager.removeListener(this._onSpriteChange);
          }
          this._dirtyUpdateFlag |= 7;
          if (value) {
            value._addReferCount(1);
            value._updateFlagManager.addListener(this._onSpriteChange);
            this.shaderData.setTexture(SpriteRenderer2._textureProperty, value.texture);
          } else {
            this.shaderData.setTexture(SpriteRenderer2._textureProperty, null);
          }
          this._sprite = value;
        }
      }
    },
    {
      key: "color",
      get: function get3() {
        return this._color;
      },
      set: function set(value) {
        if (this._color !== value) {
          this._color.copyFrom(value);
        }
      }
    },
    {
      key: "width",
      get: function get3() {
        if (this._customWidth !== void 0) {
          return this._customWidth;
        } else {
          this._dirtyUpdateFlag & 4 && this._calDefaultSize();
          return this._automaticWidth;
        }
      },
      set: function set(value) {
        if (this._customWidth !== value) {
          this._customWidth = value;
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        }
      }
    },
    {
      key: "height",
      get: function get3() {
        if (this._customHeight !== void 0) {
          return this._customHeight;
        } else {
          this._dirtyUpdateFlag & 4 && this._calDefaultSize();
          return this._automaticHeight;
        }
      },
      set: function set(value) {
        if (this._customHeight !== value) {
          this._customHeight = value;
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        }
      }
    },
    {
      key: "flipX",
      get: function get3() {
        return this._flipX;
      },
      set: function set(value) {
        if (this._flipX !== value) {
          this._flipX = value;
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        }
      }
    },
    {
      key: "flipY",
      get: function get3() {
        return this._flipY;
      },
      set: function set(value) {
        if (this._flipY !== value) {
          this._flipY = value;
          this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
        }
      }
    },
    {
      key: "maskLayer",
      get: function get3() {
        return this._maskLayer;
      },
      set: function set(value) {
        this._maskLayer = value;
      }
    },
    {
      key: "maskInteraction",
      get: function get3() {
        return this._maskInteraction;
      },
      set: function set(value) {
        if (this._maskInteraction !== value) {
          this._maskInteraction = value;
          this._updateStencilState();
        }
      }
    }
  ]);
  return SpriteRenderer2;
}(Renderer);
(function() {
  SpriteRenderer._textureProperty = ShaderProperty.getByName("renderer_SpriteTexture");
})();
__decorate$2([
  ignoreClone
], SpriteRenderer.prototype, "_verticesData", void 0);
__decorate$2([
  ignoreClone
], SpriteRenderer.prototype, "_drawMode", void 0);
__decorate$2([
  assignmentClone
], SpriteRenderer.prototype, "_assembler", void 0);
__decorate$2([
  assignmentClone
], SpriteRenderer.prototype, "_tileMode", void 0);
__decorate$2([
  assignmentClone
], SpriteRenderer.prototype, "_tiledAdaptiveThreshold", void 0);
__decorate$2([
  deepClone
], SpriteRenderer.prototype, "_color", void 0);
__decorate$2([
  ignoreClone
], SpriteRenderer.prototype, "_sprite", void 0);
__decorate$2([
  ignoreClone
], SpriteRenderer.prototype, "_automaticWidth", void 0);
__decorate$2([
  ignoreClone
], SpriteRenderer.prototype, "_automaticHeight", void 0);
__decorate$2([
  assignmentClone
], SpriteRenderer.prototype, "_customWidth", void 0);
__decorate$2([
  assignmentClone
], SpriteRenderer.prototype, "_customHeight", void 0);
__decorate$2([
  assignmentClone
], SpriteRenderer.prototype, "_flipX", void 0);
__decorate$2([
  assignmentClone
], SpriteRenderer.prototype, "_flipY", void 0);
__decorate$2([
  assignmentClone
], SpriteRenderer.prototype, "_maskLayer", void 0);
__decorate$2([
  assignmentClone
], SpriteRenderer.prototype, "_maskInteraction", void 0);
__decorate$2([
  ignoreClone
], SpriteRenderer.prototype, "_onSpriteChange", null);
var SpriteRendererUpdateFlags;
(function(SpriteRendererUpdateFlags2) {
  SpriteRendererUpdateFlags2[SpriteRendererUpdateFlags2["UV"] = 2] = "UV";
  SpriteRendererUpdateFlags2[SpriteRendererUpdateFlags2["RenderData"] = 3] = "RenderData";
  SpriteRendererUpdateFlags2[SpriteRendererUpdateFlags2["AutomaticSize"] = 4] = "AutomaticSize";
  SpriteRendererUpdateFlags2[SpriteRendererUpdateFlags2["All"] = 7] = "All";
})(SpriteRendererUpdateFlags || (SpriteRendererUpdateFlags = {}));
var CharRenderData = function CharRenderData2() {
  this.localPositions = new Vector4();
  var positions = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3()
  ];
  this.renderData = new VertexData2D(4, positions, null, CharRenderData2.triangles, null);
};
(function() {
  CharRenderData.triangles = [
    0,
    2,
    1,
    2,
    0,
    3
  ];
})();
var CharRenderDataPool = /* @__PURE__ */ function() {
  function CharRenderDataPool2(type, length2) {
    this._elements = [];
    this._type = type;
    var elements = this._elements;
    for (var i = 0; i < length2; ++i) {
      elements[i] = new type();
    }
  }
  var _proto = CharRenderDataPool2.prototype;
  _proto.get = function get3() {
    if (this._elements.length > 0) {
      return this._elements.pop();
    }
    return new this._type();
  };
  _proto.put = function put(data) {
    this._elements.push(data);
  };
  return CharRenderDataPool2;
}();
var TextRenderer = /* @__PURE__ */ function(Renderer2) {
  _inherits$2(TextRenderer2, Renderer2);
  function TextRenderer2(entity) {
    var _this;
    _this = Renderer2.call(this, entity) || this;
    _this._subFont = null;
    _this._charRenderDatas = [];
    _this._dirtyFlag = 15;
    _this._color = new Color$1(1, 1, 1, 1);
    _this._text = "";
    _this._width = 0;
    _this._height = 0;
    _this._localBounds = new BoundingBox();
    _this._font = null;
    _this._fontSize = 24;
    _this._fontStyle = FontStyle.None;
    _this._lineSpacing = 0;
    _this._horizontalAlignment = TextHorizontalAlignment.Center;
    _this._verticalAlignment = TextVerticalAlignment.Center;
    _this._enableWrapping = false;
    _this._overflowMode = OverflowMode.Overflow;
    _this._maskInteraction = SpriteMaskInteraction.None;
    _this._maskLayer = SpriteMaskLayer.Layer0;
    _this._init();
    return _this;
  }
  var _proto = TextRenderer2.prototype;
  _proto._init = function _init() {
    var engine = this.engine;
    this._font = engine._textDefaultFont;
    this._font._addReferCount(1);
    this.setMaterial(engine._spriteDefaultMaterial);
  };
  _proto._onDestroy = function _onDestroy() {
    Renderer2.prototype._onDestroy.call(this);
    var charRenderDatas = this._charRenderDatas;
    for (var i = 0, n = charRenderDatas.length; i < n; ++i) {
      TextRenderer2._charRenderDataPool.put(charRenderDatas[i]);
    }
    charRenderDatas.length = 0;
    if (this._font) {
      this._font._addReferCount(-1);
      this._font = null;
    }
    this._subFont && (this._subFont = null);
  };
  _proto._cloneTo = function _cloneTo(target) {
    Renderer2.prototype._cloneTo.call(this, target);
    target.font = this._font;
    target._subFont = this._subFont;
  };
  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };
  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };
  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  };
  _proto._updateShaderData = function _updateShaderData(context) {
    this._updateTransformShaderData(context, Matrix._identity);
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    BoundingBox.transform(this._localBounds, this._entity.transform.worldMatrix, worldBounds);
  };
  _proto._render = function _render(context) {
    if (this._text === "" || this.enableWrapping && this.width <= 0 || this.overflowMode === OverflowMode.Truncate && this.height <= 0) {
      return;
    }
    if (this._isContainDirtyFlag(16)) {
      this._updateStencilState();
      this._setDirtyFlagFalse(16);
    }
    if (this._isContainDirtyFlag(1)) {
      this._resetSubFont();
      this._setDirtyFlagFalse(1);
    }
    if (this._isContainDirtyFlag(2)) {
      this._updateLocalData();
      this._setDirtyFlagFalse(2);
    }
    if (this._isContainDirtyFlag(4)) {
      this._updatePosition();
      this._setDirtyFlagFalse(4);
    }
    var spriteRenderDataPool = this._engine._spriteRenderDataPool;
    var textData = this._engine._textRenderDataPool.getFromPool();
    var charsData = textData.charsData;
    var material = this.getMaterial();
    var charRenderDatas = this._charRenderDatas;
    var charCount = charRenderDatas.length;
    textData.component = this;
    textData.material = material;
    charsData.length = charCount;
    for (var i = 0; i < charCount; ++i) {
      var charRenderData = charRenderDatas[i];
      var spriteRenderData = spriteRenderDataPool.getFromPool();
      spriteRenderData.set(this, material, charRenderData.renderData, charRenderData.texture, i);
      charsData[i] = spriteRenderData;
    }
    context.camera._renderPipeline.pushRenderData(context, textData);
  };
  _proto._updateStencilState = function _updateStencilState() {
    var material = this.getInstanceMaterial();
    var stencilState = material.renderState.stencilState;
    var maskInteraction = this._maskInteraction;
    if (maskInteraction === SpriteMaskInteraction.None) {
      stencilState.enabled = false;
      stencilState.writeMask = 255;
      stencilState.referenceValue = 0;
      stencilState.compareFunctionFront = stencilState.compareFunctionBack = CompareFunction.Always;
    } else {
      stencilState.enabled = true;
      stencilState.writeMask = 0;
      stencilState.referenceValue = 1;
      var compare = maskInteraction === SpriteMaskInteraction.VisibleInsideMask ? CompareFunction.LessEqual : CompareFunction.Greater;
      stencilState.compareFunctionFront = compare;
      stencilState.compareFunctionBack = compare;
    }
  };
  _proto._resetSubFont = function _resetSubFont() {
    var font = this._font;
    this._subFont = font._getSubFont(this.fontSize, this.fontStyle);
    this._subFont.nativeFontString = TextUtils.getNativeFontString(font.name, this.fontSize, this.fontStyle);
  };
  _proto._updatePosition = function _updatePosition() {
    var transform = this.entity.transform;
    var e = transform.worldMatrix.elements;
    var charRenderDatas = this._charRenderDatas;
    var e0 = e[0], e1 = e[1], e2 = e[2], e4 = e[4], e5 = e[5], e6 = e[6], e12 = e[12], e13 = e[13], e14 = e[14];
    var up = TextRenderer2._tempVec31.set(e4, e5, e6);
    var right = TextRenderer2._tempVec30.set(e0, e1, e2);
    for (var i = 0, n = charRenderDatas.length; i < n; ++i) {
      var charRenderData = charRenderDatas[i];
      var localPositions = charRenderData.localPositions;
      var positions = charRenderData.renderData.positions;
      var topLeftX = localPositions.x, topLeftY = localPositions.y;
      var worldPosition0 = positions[0];
      worldPosition0.x = topLeftX * e0 + topLeftY * e4 + e12;
      worldPosition0.y = topLeftX * e1 + topLeftY * e5 + e13;
      worldPosition0.z = topLeftX * e2 + topLeftY * e6 + e14;
      var worldPosition1 = positions[1];
      Vector3.scale(right, localPositions.z - topLeftX, worldPosition1);
      Vector3.add(worldPosition0, worldPosition1, worldPosition1);
      var worldPosition2 = positions[2];
      Vector3.scale(up, localPositions.w - topLeftY, worldPosition2);
      Vector3.add(worldPosition0, worldPosition2, positions[3]);
      Vector3.add(worldPosition1, worldPosition2, worldPosition2);
    }
  };
  _proto._updateLocalData = function _updateLocalData() {
    var _this = this, color = _this.color, charRenderDatas = _this._charRenderDatas, charFont = _this._subFont;
    var _this__localBounds = this._localBounds, min = _this__localBounds.min, max = _this__localBounds.max;
    var textMetrics = this.enableWrapping ? TextUtils.measureTextWithWrap(this) : TextUtils.measureTextWithoutWrap(this);
    var height = textMetrics.height, lines = textMetrics.lines, lineWidths = textMetrics.lineWidths, lineHeight = textMetrics.lineHeight, lineMaxSizes = textMetrics.lineMaxSizes;
    var charRenderDataPool = TextRenderer2._charRenderDataPool;
    var linesLen = lines.length;
    var renderDataCount = 0;
    if (linesLen > 0) {
      var _pixelsPerUnit = Engine._pixelsPerUnit;
      var horizontalAlignment = this.horizontalAlignment;
      var pixelsPerUnitReciprocal = 1 / _pixelsPerUnit;
      var rendererWidth = this.width * _pixelsPerUnit;
      var halfRendererWidth = rendererWidth * 0.5;
      var rendererHeight = this.height * _pixelsPerUnit;
      var halfLineHeight = lineHeight * 0.5;
      var startY = 0;
      var topDiff = lineHeight * 0.5 - lineMaxSizes[0].ascent;
      var bottomDiff = lineHeight * 0.5 - lineMaxSizes[linesLen - 1].descent - 1;
      switch (this.verticalAlignment) {
        case TextVerticalAlignment.Top:
          startY = rendererHeight * 0.5 - halfLineHeight + topDiff;
          break;
        case TextVerticalAlignment.Center:
          startY = height * 0.5 - halfLineHeight - (bottomDiff - topDiff) * 0.5;
          break;
        case TextVerticalAlignment.Bottom:
          startY = height - rendererHeight * 0.5 - halfLineHeight - bottomDiff;
          break;
      }
      var firstLine = -1;
      var minX = Number.MAX_SAFE_INTEGER;
      var minY = Number.MAX_SAFE_INTEGER;
      var maxX = Number.MIN_SAFE_INTEGER;
      var maxY = Number.MIN_SAFE_INTEGER;
      for (var i = 0; i < linesLen; ++i) {
        var lineWidth = lineWidths[i];
        if (lineWidth > 0) {
          var line = lines[i];
          var startX = 0;
          var firstRow = -1;
          if (firstLine < 0) {
            firstLine = i;
          }
          switch (horizontalAlignment) {
            case TextHorizontalAlignment.Left:
              startX = -halfRendererWidth;
              break;
            case TextHorizontalAlignment.Center:
              startX = -lineWidth * 0.5;
              break;
            case TextHorizontalAlignment.Right:
              startX = halfRendererWidth - lineWidth;
              break;
          }
          for (var j2 = 0, n = line.length; j2 < n; ++j2) {
            var char = line[j2];
            var charInfo = charFont._getCharInfo(char);
            if (charInfo.h > 0) {
              var _charRenderDatas, _ref;
              firstRow < 0 && (firstRow = j2);
              var charRenderData = (_charRenderDatas = charRenderDatas)[_ref = renderDataCount++] || (_charRenderDatas[_ref] = charRenderDataPool.get());
              var renderData = charRenderData.renderData, localPositions = charRenderData.localPositions;
              charRenderData.texture = charFont._getTextureByIndex(charInfo.index);
              renderData.color = color;
              renderData.uvs = charInfo.uvs;
              var w = charInfo.w, ascent = charInfo.ascent, descent = charInfo.descent;
              var left = startX * pixelsPerUnitReciprocal;
              var right = (startX + w) * pixelsPerUnitReciprocal;
              var top = (startY + ascent) * pixelsPerUnitReciprocal;
              var bottom = (startY - descent + 1) * pixelsPerUnitReciprocal;
              localPositions.set(left, top, right, bottom);
              i === firstLine && (maxY = Math.max(maxY, top));
              minY = Math.min(minY, bottom);
              j2 === firstRow && (minX = Math.min(minX, left));
              maxX = Math.max(maxX, right);
            }
            startX += charInfo.xAdvance;
          }
        }
        startY -= lineHeight;
      }
      if (firstLine < 0) {
        min.set(0, 0, 0);
        max.set(0, 0, 0);
      } else {
        min.set(minX, minY, 0);
        max.set(maxX, maxY, 0);
      }
    } else {
      min.set(0, 0, 0);
      max.set(0, 0, 0);
    }
    var lastRenderDataCount = charRenderDatas.length;
    if (lastRenderDataCount > renderDataCount) {
      for (var i1 = renderDataCount; i1 < lastRenderDataCount; ++i1) {
        charRenderDataPool.put(charRenderDatas[i1]);
      }
      charRenderDatas.length = renderDataCount;
    }
    charFont._getLastIndex() > 0 && charRenderDatas.sort(function(a, b) {
      return a.texture.instanceId - b.texture.instanceId;
    });
  };
  _proto._onTransformChanged = function _onTransformChanged(bit) {
    Renderer2.prototype._onTransformChanged.call(this, bit);
    this._setDirtyFlagTrue(4 | 8);
  };
  _create_class$4(TextRenderer2, [
    {
      key: "color",
      get: function get3() {
        return this._color;
      },
      set: function set(value) {
        if (this._color !== value) {
          this._color.copyFrom(value);
        }
      }
    },
    {
      key: "text",
      get: function get3() {
        return this._text;
      },
      set: function set(value) {
        value = value || "";
        if (this._text !== value) {
          this._text = value;
          this._setDirtyFlagTrue(14);
        }
      }
    },
    {
      key: "width",
      get: function get3() {
        return this._width;
      },
      set: function set(value) {
        if (this._width !== value) {
          this._width = value;
          this._setDirtyFlagTrue(14);
        }
      }
    },
    {
      key: "height",
      get: function get3() {
        return this._height;
      },
      set: function set(value) {
        if (this._height !== value) {
          this._height = value;
          this._setDirtyFlagTrue(14);
        }
      }
    },
    {
      key: "font",
      get: function get3() {
        return this._font;
      },
      set: function set(value) {
        var lastFont = this._font;
        if (lastFont !== value) {
          lastFont && lastFont._addReferCount(-1);
          value && value._addReferCount(1);
          this._font = value;
          this._setDirtyFlagTrue(15);
        }
      }
    },
    {
      key: "fontSize",
      get: function get3() {
        return this._fontSize;
      },
      set: function set(value) {
        if (this._fontSize !== value) {
          this._fontSize = value;
          this._setDirtyFlagTrue(15);
        }
      }
    },
    {
      key: "fontStyle",
      get: function get3() {
        return this._fontStyle;
      },
      set: function set(value) {
        if (this.fontStyle !== value) {
          this._fontStyle = value;
          this._setDirtyFlagTrue(15);
        }
      }
    },
    {
      key: "lineSpacing",
      get: function get3() {
        return this._lineSpacing;
      },
      set: function set(value) {
        if (this._lineSpacing !== value) {
          this._lineSpacing = value;
          this._setDirtyFlagTrue(14);
        }
      }
    },
    {
      key: "horizontalAlignment",
      get: function get3() {
        return this._horizontalAlignment;
      },
      set: function set(value) {
        if (this._horizontalAlignment !== value) {
          this._horizontalAlignment = value;
          this._setDirtyFlagTrue(14);
        }
      }
    },
    {
      key: "verticalAlignment",
      get: function get3() {
        return this._verticalAlignment;
      },
      set: function set(value) {
        if (this._verticalAlignment !== value) {
          this._verticalAlignment = value;
          this._setDirtyFlagTrue(14);
        }
      }
    },
    {
      key: "enableWrapping",
      get: function get3() {
        return this._enableWrapping;
      },
      set: function set(value) {
        if (this._enableWrapping !== value) {
          this._enableWrapping = value;
          this._setDirtyFlagTrue(14);
        }
      }
    },
    {
      key: "overflowMode",
      get: function get3() {
        return this._overflowMode;
      },
      set: function set(value) {
        if (this._overflowMode !== value) {
          this._overflowMode = value;
          this._setDirtyFlagTrue(14);
        }
      }
    },
    {
      key: "maskInteraction",
      get: function get3() {
        return this._maskInteraction;
      },
      set: function set(value) {
        if (this._maskInteraction !== value) {
          this._maskInteraction = value;
          this._setDirtyFlagTrue(16);
        }
      }
    },
    {
      key: "maskLayer",
      get: function get3() {
        return this._maskLayer;
      },
      set: function set(value) {
        this._maskLayer = value;
      }
    },
    {
      key: "bounds",
      get: function get3() {
        this._isContainDirtyFlag(1) && this._resetSubFont();
        this._isContainDirtyFlag(2) && this._updateLocalData();
        this._isContainDirtyFlag(4) && this._updatePosition();
        this._isContainDirtyFlag(8) && this._updateBounds(this._bounds);
        this._setDirtyFlagFalse(15);
        return this._bounds;
      }
    }
  ]);
  return TextRenderer2;
}(Renderer);
(function() {
  TextRenderer._charRenderDataPool = new CharRenderDataPool(CharRenderData, 50);
})();
(function() {
  TextRenderer._tempVec30 = new Vector3();
})();
(function() {
  TextRenderer._tempVec31 = new Vector3();
})();
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_subFont", void 0);
__decorate$2([
  ignoreClone
], TextRenderer.prototype, "_charRenderDatas", void 0);
__decorate$2([
  ignoreClone
], TextRenderer.prototype, "_dirtyFlag", void 0);
__decorate$2([
  deepClone
], TextRenderer.prototype, "_color", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_text", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_width", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_height", void 0);
__decorate$2([
  ignoreClone
], TextRenderer.prototype, "_localBounds", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_font", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_fontSize", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_fontStyle", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_lineSpacing", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_horizontalAlignment", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_verticalAlignment", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_enableWrapping", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_overflowMode", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_maskInteraction", void 0);
__decorate$2([
  assignmentClone
], TextRenderer.prototype, "_maskLayer", void 0);
var DirtyFlag;
(function(DirtyFlag2) {
  DirtyFlag2[DirtyFlag2["SubFont"] = 1] = "SubFont";
  DirtyFlag2[DirtyFlag2["LocalPositionBounds"] = 2] = "LocalPositionBounds";
  DirtyFlag2[DirtyFlag2["WorldPosition"] = 4] = "WorldPosition";
  DirtyFlag2[DirtyFlag2["WorldBounds"] = 8] = "WorldBounds";
  DirtyFlag2[DirtyFlag2["MaskInteraction"] = 16] = "MaskInteraction";
  DirtyFlag2[DirtyFlag2["Position"] = 14] = "Position";
  DirtyFlag2[DirtyFlag2["Font"] = 15] = "Font";
})(DirtyFlag || (DirtyFlag = {}));
var UniversalAnimationCurveOwnerAssembler = /* @__PURE__ */ function() {
  function UniversalAnimationCurveOwnerAssembler2() {
  }
  var _proto = UniversalAnimationCurveOwnerAssembler2.prototype;
  _proto.initialize = function initialize(owner) {
    var mounted = owner.component;
    var properties = owner.property.split(".");
    var endIndex = properties.length - 1;
    for (var i = 0; i < endIndex; i++) {
      mounted = mounted[properties[i]];
    }
    this._mounted = mounted;
    this._propertyName = properties[endIndex];
  };
  _proto.getTargetValue = function getTargetValue() {
    return this._mounted[this._propertyName];
  };
  _proto.setTargetValue = function setTargetValue(value) {
    this._mounted[this._propertyName] = value;
  };
  return UniversalAnimationCurveOwnerAssembler2;
}();
var AnimationCurveOwner = /* @__PURE__ */ function() {
  function AnimationCurveOwner2(target, type, property, cureType) {
    this.baseEvaluateData = {
      curKeyframeIndex: 0,
      value: null
    };
    this.crossEvaluateData = {
      curKeyframeIndex: 0,
      value: null
    };
    this.updateMark = 0;
    this.target = target;
    this.type = type;
    this.property = property;
    this.component = target.getComponent(type);
    this.cureType = cureType;
    var assemblerType = AnimationCurveOwner2.getAssemblerType(type, property);
    this._assembler = new assemblerType();
    this._assembler.initialize(this);
    if (cureType._isReferenceType) {
      this.referenceTargetValue = this._assembler.getTargetValue();
    }
  }
  var _proto = AnimationCurveOwner2.prototype;
  _proto.evaluateValue = function evaluateValue(curve, time, additive) {
    return additive ? curve._evaluateAdditive(time, this.baseEvaluateData) : curve._evaluate(time, this.baseEvaluateData);
  };
  _proto.evaluateCrossFadeValue = function evaluateCrossFadeValue(srcCurve, destCurve, srcTime, destTime, crossWeight, additive) {
    var srcValue = srcCurve && srcCurve.keys.length ? additive ? srcCurve._evaluateAdditive(srcTime, this.baseEvaluateData) : srcCurve._evaluate(srcTime, this.baseEvaluateData) : additive ? this.cureType._getZeroValue(this.baseEvaluateData.value) : this.defaultValue;
    var destValue = destCurve && destCurve.keys.length ? additive ? destCurve._evaluateAdditive(destTime, this.crossEvaluateData) : destCurve._evaluate(destTime, this.crossEvaluateData) : additive ? this.cureType._getZeroValue(this.crossEvaluateData.value) : this.defaultValue;
    return this._lerpValue(srcValue, destValue, crossWeight);
  };
  _proto.crossFadeFromPoseAndApplyValue = function crossFadeFromPoseAndApplyValue(destCurve, destTime, crossWeight, additive) {
    var srcValue = additive ? this.cureType._subtractValue(this.fixedPoseValue, this.defaultValue, this.baseEvaluateData.value) : this.fixedPoseValue;
    var destValue = destCurve && destCurve.keys.length ? additive ? destCurve._evaluateAdditive(destTime, this.crossEvaluateData) : destCurve._evaluate(destTime, this.crossEvaluateData) : additive ? this.cureType._getZeroValue(this.crossEvaluateData.value) : this.defaultValue;
    return this._lerpValue(srcValue, destValue, crossWeight);
  };
  _proto.revertDefaultValue = function revertDefaultValue() {
    this._assembler.setTargetValue(this.defaultValue);
  };
  _proto.getEvaluateValue = function getEvaluateValue(out) {
    if (this.cureType._isReferenceType) {
      this.cureType._copyValue(this.baseEvaluateData.value, out);
      return out;
    } else {
      return this.baseEvaluateData.value;
    }
  };
  _proto.saveDefaultValue = function saveDefaultValue() {
    if (this.cureType._isReferenceType) {
      this.cureType._copyValue(this.referenceTargetValue, this.defaultValue);
    } else {
      this.defaultValue = this._assembler.getTargetValue();
    }
  };
  _proto.saveFixedPoseValue = function saveFixedPoseValue() {
    if (this.cureType._isReferenceType) {
      this.cureType._copyValue(this.referenceTargetValue, this.fixedPoseValue);
    } else {
      this.fixedPoseValue = this._assembler.getTargetValue();
    }
  };
  _proto.applyValue = function applyValue(value, weight, additive) {
    var cureType = this.cureType;
    if (additive) {
      if (cureType._isReferenceType) {
        cureType._additiveValue(value, weight, this.referenceTargetValue);
      } else {
        var assembler = this._assembler;
        var originValue = assembler.getTargetValue();
        var additiveValue = cureType._additiveValue(value, weight, originValue);
        assembler.setTargetValue(additiveValue);
      }
    } else {
      if (weight === 1) {
        if (cureType._isReferenceType) {
          cureType._copyValue(value, this.referenceTargetValue);
        } else {
          this._assembler.setTargetValue(value);
        }
      } else {
        if (cureType._isReferenceType) {
          var targetValue = this.referenceTargetValue;
          cureType._lerpValue(targetValue, value, weight, targetValue);
        } else {
          var originValue1 = this._assembler.getTargetValue();
          var lerpValue = cureType._lerpValue(originValue1, value, weight);
          this._assembler.setTargetValue(lerpValue);
        }
      }
    }
  };
  _proto._lerpValue = function _lerpValue(srcValue, destValue, crossWeight) {
    if (this.cureType._isReferenceType) {
      return this.cureType._lerpValue(srcValue, destValue, crossWeight, this.baseEvaluateData.value);
    } else {
      this.baseEvaluateData.value = this.cureType._lerpValue(srcValue, destValue, crossWeight);
      return this.baseEvaluateData.value;
    }
  };
  AnimationCurveOwner2.registerAssembler = function registerAssembler(componentType, property, assemblerType) {
    var subMap = AnimationCurveOwner2._assemblerMap.get(componentType);
    if (!subMap) {
      subMap = {};
      AnimationCurveOwner2._assemblerMap.set(componentType, subMap);
    }
    subMap[property] = assemblerType;
  };
  AnimationCurveOwner2.getAssemblerType = function getAssemblerType(componentType, property) {
    var subMap = AnimationCurveOwner2._assemblerMap.get(componentType);
    var assemblerType = subMap ? subMap[property] : void 0;
    return assemblerType != null ? assemblerType : UniversalAnimationCurveOwnerAssembler;
  };
  return AnimationCurveOwner2;
}();
(function() {
  AnimationCurveOwner._assemblerMap = /* @__PURE__ */ new Map();
})();
var PositionAnimationCurveOwnerAssembler = /* @__PURE__ */ function() {
  function PositionAnimationCurveOwnerAssembler2() {
  }
  var _proto = PositionAnimationCurveOwnerAssembler2.prototype;
  _proto.initialize = function initialize(owner) {
    this._transform = owner.target.transform;
  };
  _proto.getTargetValue = function getTargetValue() {
    return this._transform.position;
  };
  _proto.setTargetValue = function setTargetValue(value) {
    this._transform.position = value;
  };
  return PositionAnimationCurveOwnerAssembler2;
}();
AnimationCurveOwner.registerAssembler(Transform, "position", PositionAnimationCurveOwnerAssembler);
var RotationAnimationCurveOwnerAssembler = /* @__PURE__ */ function() {
  function RotationAnimationCurveOwnerAssembler2() {
  }
  var _proto = RotationAnimationCurveOwnerAssembler2.prototype;
  _proto.initialize = function initialize(owner) {
    this._transform = owner.target.transform;
  };
  _proto.getTargetValue = function getTargetValue() {
    return this._transform.rotationQuaternion;
  };
  _proto.setTargetValue = function setTargetValue(value) {
    this._transform.rotationQuaternion = value;
  };
  return RotationAnimationCurveOwnerAssembler2;
}();
AnimationCurveOwner.registerAssembler(Transform, "rotationQuaternion", RotationAnimationCurveOwnerAssembler);
var ScaleAnimationCurveOwnerAssembler = /* @__PURE__ */ function() {
  function ScaleAnimationCurveOwnerAssembler2() {
  }
  var _proto = ScaleAnimationCurveOwnerAssembler2.prototype;
  _proto.initialize = function initialize(owner) {
    this._transform = owner.target.transform;
  };
  _proto.getTargetValue = function getTargetValue() {
    return this._transform.scale;
  };
  _proto.setTargetValue = function setTargetValue(value) {
    this._transform.scale = value;
  };
  return ScaleAnimationCurveOwnerAssembler2;
}();
AnimationCurveOwner.registerAssembler(Transform, "scale", ScaleAnimationCurveOwnerAssembler);
var BlendShapeWeightsAnimationCurveOwnerAssembler = /* @__PURE__ */ function() {
  function BlendShapeWeightsAnimationCurveOwnerAssembler2() {
  }
  var _proto = BlendShapeWeightsAnimationCurveOwnerAssembler2.prototype;
  _proto.initialize = function initialize(owner) {
    this._skinnedMeshRenderer = owner.target.getComponent(SkinnedMeshRenderer);
  };
  _proto.getTargetValue = function getTargetValue() {
    return this._skinnedMeshRenderer.blendShapeWeights;
  };
  _proto.setTargetValue = function setTargetValue(value) {
    this._skinnedMeshRenderer.blendShapeWeights = value;
  };
  return BlendShapeWeightsAnimationCurveOwnerAssembler2;
}();
AnimationCurveOwner.registerAssembler(SkinnedMeshRenderer, "blendShapeWeights", BlendShapeWeightsAnimationCurveOwnerAssembler);
var AnimationCurveLayerOwner = /* @__PURE__ */ function() {
  function AnimationCurveLayerOwner2() {
    this.crossCurveMark = 0;
  }
  var _proto = AnimationCurveLayerOwner2.prototype;
  _proto.initFinalValue = function initFinalValue() {
    var _this_curveOwner = this.curveOwner, cureType = _this_curveOwner.cureType, defaultValue = _this_curveOwner.defaultValue;
    if (cureType._isReferenceType) {
      cureType._copyValue(defaultValue, this.finalValue);
    } else {
      this.finalValue = defaultValue;
    }
  };
  _proto.saveFinalValue = function saveFinalValue() {
    this.finalValue = this.curveOwner.getEvaluateValue(this.finalValue);
  };
  return AnimationCurveLayerOwner2;
}();
var AnimationClipCurveBinding = /* @__PURE__ */ function() {
  function AnimationClipCurveBinding2() {
    this._tempCurveOwner = {};
  }
  var _proto = AnimationClipCurveBinding2.prototype;
  _proto._createCurveOwner = function _createCurveOwner(entity) {
    var curveType = this.curve.constructor;
    var owner = new AnimationCurveOwner(entity, this.type, this.property, curveType);
    curveType._initializeOwner(owner);
    owner.saveDefaultValue();
    return owner;
  };
  _proto._createCurveLayerOwner = function _createCurveLayerOwner(owner) {
    var curveType = this.curve.constructor;
    var layerOwner = new AnimationCurveLayerOwner();
    layerOwner.curveOwner = owner;
    curveType._initializeLayerOwner(layerOwner);
    layerOwner.initFinalValue();
    return layerOwner;
  };
  _proto._getTempCurveOwner = function _getTempCurveOwner(entity) {
    var instanceId = entity.instanceId;
    if (!this._tempCurveOwner[instanceId]) {
      this._tempCurveOwner[instanceId] = this._createCurveOwner(entity);
    }
    return this._tempCurveOwner[instanceId];
  };
  return AnimationClipCurveBinding2;
}();
var AnimationEvent = function AnimationEvent2() {
};
var AnimationClip = /* @__PURE__ */ function(EngineObject2) {
  _inherits$2(AnimationClip2, EngineObject2);
  function AnimationClip2(name2) {
    var _this;
    _this = EngineObject2.call(this, null) || this;
    _this.name = name2;
    _this._curveBindings = [];
    _this._length = 0;
    _this._events = [];
    return _this;
  }
  var _proto = AnimationClip2.prototype;
  _proto.addEvent = function addEvent(param, time, parameter) {
    var newEvent;
    if (typeof param === "string") {
      var event = new AnimationEvent();
      event.functionName = param;
      event.time = time;
      event.parameter = parameter;
      newEvent = event;
    } else {
      newEvent = param;
    }
    var events = this._events;
    var count = events.length;
    var eventTime = newEvent.time;
    var maxEventTime = count ? events[count - 1].time : 0;
    if (eventTime >= maxEventTime) {
      events.push(newEvent);
    } else {
      var index = count;
      while (--index >= 0 && eventTime < events[index].time)
        ;
      events.splice(index + 1, 0, newEvent);
    }
  };
  _proto.clearEvents = function clearEvents() {
    this._events.length = 0;
  };
  _proto.addCurveBinding = function addCurveBinding(relativePath, type, propertyName, curve) {
    var curveBinding = new AnimationClipCurveBinding();
    curveBinding.relativePath = relativePath;
    curveBinding.type = type;
    curveBinding.property = propertyName;
    curveBinding.curve = curve;
    if (curve.length > this._length) {
      this._length = curve.length;
    }
    this._curveBindings.push(curveBinding);
  };
  _proto.clearCurveBindings = function clearCurveBindings() {
    this._curveBindings.length = 0;
    this._length = 0;
  };
  _proto._sampleAnimation = function _sampleAnimation(entity, time) {
    var _this = this, curveBindings = _this._curveBindings;
    for (var i = curveBindings.length - 1; i >= 0; i--) {
      var curveData = curveBindings[i];
      var targetEntity = entity.findByPath(curveData.relativePath);
      if (targetEntity) {
        var curveOwner = curveData._getTempCurveOwner(targetEntity);
        var value = curveOwner.evaluateValue(curveData.curve, time, false);
        curveOwner.applyValue(value, 1, false);
      }
    }
  };
  _create_class$4(AnimationClip2, [
    {
      key: "events",
      get: function get3() {
        return this._events;
      }
    },
    {
      key: "curveBindings",
      get: function get3() {
        return this._curveBindings;
      }
    },
    {
      key: "length",
      get: function get3() {
        return this._length;
      }
    }
  ]);
  return AnimationClip2;
}(EngineObject);
var InterpolationType;
(function(InterpolationType2) {
  InterpolationType2[InterpolationType2["Linear"] = 0] = "Linear";
  InterpolationType2[InterpolationType2["CubicSpine"] = 1] = "CubicSpine";
  InterpolationType2[InterpolationType2["Step"] = 2] = "Step";
  InterpolationType2[InterpolationType2["Hermite"] = 3] = "Hermite";
})(InterpolationType || (InterpolationType = {}));
var AnimationCurve = /* @__PURE__ */ function() {
  function AnimationCurve2() {
    this.keys = [];
    this._evaluateData = {
      curKeyframeIndex: 0,
      value: null
    };
    this._length = 0;
    var type = this.constructor;
    this._interpolation = type._isInterpolationType ? InterpolationType.Linear : InterpolationType.Step;
    this._type = type;
  }
  var _proto = AnimationCurve2.prototype;
  _proto.addKey = function addKey(key) {
    var time = key.time;
    var keys = this.keys;
    if (time >= this._length) {
      keys.push(key);
      this._length = time;
    } else {
      var index = keys.length;
      while (--index >= 0 && time < keys[index].time)
        ;
      keys.splice(index + 1, 0, key);
    }
  };
  _proto.evaluate = function evaluate(time) {
    return this._evaluate(time, this._evaluateData);
  };
  _proto.removeKey = function removeKey(index) {
    this.keys.splice(index, 1);
    var keys = this.keys;
    var newLength = 0;
    for (var i = keys.length - 1; i >= 0; i--) {
      var key = keys[i];
      if (key.time > length) {
        newLength = key.time;
      }
    }
    this._length = newLength;
  };
  _proto._evaluate = function _evaluate(time, evaluateData) {
    var length1 = this.keys.length;
    if (!length1) {
      console.warn("This curve don't have any keyframes: ", this);
      return;
    }
    var _this = this, keys = _this.keys, interpolation = _this.interpolation;
    var curIndex = evaluateData.curKeyframeIndex;
    if (curIndex !== -1 && (curIndex >= length1 || time < keys[curIndex].time)) {
      curIndex = -1;
    }
    var nextIndex = curIndex + 1;
    while (nextIndex < length1) {
      if (time < keys[nextIndex].time) {
        break;
      }
      curIndex++;
      nextIndex++;
    }
    evaluateData.curKeyframeIndex = curIndex;
    var value;
    if (curIndex === -1) {
      value = this._type._copyValue(keys[0].value, evaluateData.value);
    } else if (nextIndex === length1) {
      value = this._type._copyValue(keys[curIndex].value, evaluateData.value);
    } else {
      var curFrame = keys[curIndex];
      var nextFrame = keys[nextIndex];
      var curFrameTime = curFrame.time;
      var duration = nextFrame.time - curFrameTime;
      var t = (time - curFrameTime) / duration;
      switch (interpolation) {
        case InterpolationType.Linear:
          value = this._type._lerpValue(curFrame.value, nextFrame.value, t, evaluateData.value);
          break;
        case InterpolationType.Step:
          value = this._type._copyValue(curFrame.value, evaluateData.value);
          break;
        case InterpolationType.CubicSpine:
        case InterpolationType.Hermite:
          value = this._type._hermiteInterpolationValue(curFrame, nextFrame, t, duration, evaluateData.value);
          break;
      }
    }
    evaluateData.value = value;
    return value;
  };
  _proto._evaluateAdditive = function _evaluateAdditive(time, evaluateData) {
    var result2 = this._evaluate(time, evaluateData);
    return this._type._subtractValue(result2, this.keys[0].value, evaluateData.value);
  };
  _create_class$4(AnimationCurve2, [
    {
      key: "interpolation",
      get: function get3() {
        return this._interpolation;
      },
      set: function set(value) {
        if (!this._type._isInterpolationType && value !== InterpolationType.Step) {
          this._interpolation = InterpolationType.Step;
          console.warn("The interpolation type must be `InterpolationType.Step`.");
        } else {
          this._interpolation = value;
        }
      }
    },
    {
      key: "length",
      get: function get3() {
        return this._length;
      }
    }
  ]);
  return AnimationCurve2;
}();
var _AnimationArrayCurve;
var AnimationArrayCurve = (_AnimationArrayCurve = /* @__PURE__ */ function(AnimationCurve2) {
  _inherits$2(AnimationArrayCurve2, AnimationCurve2);
  function AnimationArrayCurve2() {
    var _this;
    _this = AnimationCurve2.call(this) || this;
    _this._evaluateData.value = [];
    return _this;
  }
  AnimationArrayCurve2._initializeOwner = function _initializeOwner(owner) {
    owner.defaultValue = [];
    owner.fixedPoseValue = [];
    owner.baseEvaluateData.value = [];
    owner.crossEvaluateData.value = [];
  };
  AnimationArrayCurve2._initializeLayerOwner = function _initializeLayerOwner(owner) {
    owner.finalValue = [];
  };
  AnimationArrayCurve2._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
    for (var i = 0, n = out.length; i < n; ++i) {
      var src = srcValue[i];
      out[i] = src + (destValue[i] - src) * weight;
    }
    return out;
  };
  AnimationArrayCurve2._subtractValue = function _subtractValue(src, base, out) {
    for (var i = 0, n = src.length; i < n; i++) {
      out[i] = src[i] - base[i];
    }
    return out;
  };
  AnimationArrayCurve2._getZeroValue = function _getZeroValue(out) {
    for (var i = 0, n = out.length; i < n; i++) {
      out[i] = 0;
    }
    return out;
  };
  AnimationArrayCurve2._additiveValue = function _additiveValue(value, weight, out) {
    for (var i = 0, n = out.length; i < n; ++i) {
      out[i] += value[i] * weight;
    }
    return out;
  };
  AnimationArrayCurve2._copyValue = function _copyValue(source, out) {
    for (var i = 0, n = out.length; i < n; ++i) {
      out[i] = source[i];
    }
    return out;
  };
  AnimationArrayCurve2._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, duration, out) {
    var t0 = frame.outTangent;
    var t1 = nextFrame.inTangent;
    var p0 = frame.value;
    var p1 = nextFrame.value;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    for (var i = 0, n = p0.length; i < n; ++i) {
      if (Number.isFinite(t0[i]) && Number.isFinite(t1[i])) {
        out[i] = a * p0[i] + b * t0[i] * duration + c * t1[i] * duration + d * p1[i];
      } else {
        out[i] = frame.value[i];
      }
    }
    return out;
  };
  return AnimationArrayCurve2;
}(AnimationCurve), function() {
  _AnimationArrayCurve._isReferenceType = true;
}(), function() {
  _AnimationArrayCurve._isInterpolationType = true;
}(), _AnimationArrayCurve);
AnimationArrayCurve = __decorate$2([
  StaticInterfaceImplement$1()
], AnimationArrayCurve);
var _AnimationBoolCurve;
var AnimationBoolCurve = (_AnimationBoolCurve = /* @__PURE__ */ function(AnimationCurve2) {
  _inherits$2(AnimationBoolCurve2, AnimationCurve2);
  function AnimationBoolCurve2() {
    var _this;
    _this = AnimationCurve2.call(this) || this;
    _this._evaluateData.value = false;
    return _this;
  }
  AnimationBoolCurve2._initializeOwner = function _initializeOwner(owner) {
    owner.defaultValue = false;
    owner.fixedPoseValue = false;
    owner.baseEvaluateData.value = false;
    owner.crossEvaluateData.value = false;
  };
  AnimationBoolCurve2._initializeLayerOwner = function _initializeLayerOwner(owner) {
    owner.finalValue = false;
  };
  AnimationBoolCurve2._lerpValue = function _lerpValue(srcValue, destValue) {
    return destValue;
  };
  AnimationBoolCurve2._subtractValue = function _subtractValue(src, base, out) {
    return src;
  };
  AnimationBoolCurve2._getZeroValue = function _getZeroValue() {
    return false;
  };
  AnimationBoolCurve2._additiveValue = function _additiveValue(value, weight, source) {
    return value;
  };
  AnimationBoolCurve2._copyValue = function _copyValue(value) {
    return value;
  };
  AnimationBoolCurve2._hermiteInterpolationValue = function _hermiteInterpolationValue(frame) {
    return frame.value;
  };
  return AnimationBoolCurve2;
}(AnimationCurve), function() {
  _AnimationBoolCurve._isReferenceType = false;
}(), function() {
  _AnimationBoolCurve._isInterpolationType = false;
}(), _AnimationBoolCurve);
AnimationBoolCurve = __decorate$2([
  StaticInterfaceImplement$1()
], AnimationBoolCurve);
var _AnimationColorCurve;
var AnimationColorCurve = (_AnimationColorCurve = /* @__PURE__ */ function(AnimationCurve2) {
  _inherits$2(AnimationColorCurve2, AnimationCurve2);
  function AnimationColorCurve2() {
    var _this;
    _this = AnimationCurve2.call(this) || this;
    _this._evaluateData.value = new Color$1();
    return _this;
  }
  AnimationColorCurve2._initializeOwner = function _initializeOwner(owner) {
    owner.defaultValue = new Color$1();
    owner.fixedPoseValue = new Color$1();
    owner.baseEvaluateData.value = new Color$1();
    owner.crossEvaluateData.value = new Color$1();
  };
  AnimationColorCurve2._initializeLayerOwner = function _initializeLayerOwner(owner) {
    owner.finalValue = new Color$1();
  };
  AnimationColorCurve2._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
    Color$1.lerp(srcValue, destValue, weight, out);
    return out;
  };
  AnimationColorCurve2._subtractValue = function _subtractValue(src, base, out) {
    Color$1.subtract(src, base, out);
    return out;
  };
  AnimationColorCurve2._getZeroValue = function _getZeroValue(out) {
    out.set(0, 0, 0, 0);
    return out;
  };
  AnimationColorCurve2._additiveValue = function _additiveValue(value, weight, out) {
    Color$1.scale(value, weight, value);
    Color$1.add(out, value, out);
    return out;
  };
  AnimationColorCurve2._copyValue = function _copyValue(source, out) {
    out.copyFrom(source);
    return out;
  };
  AnimationColorCurve2._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
    var p0 = frame.value;
    var tan0 = frame.outTangent;
    var p1 = nextFrame.value;
    var tan1 = nextFrame.inTangent;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    var t0 = tan0.x, t1 = tan1.x;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.r = a * p0.r + b * t0 * dur + c * t1 * dur + d * p1.r;
    } else {
      out.r = p0.r;
    }
    t0 = tan0.y, t1 = tan1.y;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.g = a * p0.g + b * t0 * dur + c * t1 * dur + d * p1.g;
    } else {
      out.g = p0.g;
    }
    t0 = tan0.z, t1 = tan1.z;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.b = a * p0.b + b * t0 * dur + c * t1 * dur + d * p1.b;
    } else {
      out.b = p0.b;
    }
    t0 = tan0.w, t1 = tan1.w;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.a = a * p0.a + b * t0 * dur + c * t1 * dur + d * p1.a;
    } else {
      out.a = p0.a;
    }
    return out;
  };
  return AnimationColorCurve2;
}(AnimationCurve), function() {
  _AnimationColorCurve._isReferenceType = true;
}(), function() {
  _AnimationColorCurve._isInterpolationType = true;
}(), _AnimationColorCurve);
AnimationColorCurve = __decorate$2([
  StaticInterfaceImplement$1()
], AnimationColorCurve);
var _AnimationFloatArrayCurve;
var AnimationFloatArrayCurve = (_AnimationFloatArrayCurve = /* @__PURE__ */ function(AnimationCurve2) {
  _inherits$2(AnimationFloatArrayCurve2, AnimationCurve2);
  function AnimationFloatArrayCurve2() {
    return AnimationCurve2.apply(this, arguments);
  }
  var _proto = AnimationFloatArrayCurve2.prototype;
  _proto.addKey = function addKey(key) {
    AnimationCurve2.prototype.addKey.call(this, key);
    var evaluateData = this._evaluateData;
    if (!evaluateData.value || evaluateData.value.length !== key.value.length) {
      var size = key.value.length;
      evaluateData.value = new Float32Array(size);
    }
  };
  AnimationFloatArrayCurve2._initializeOwner = function _initializeOwner(owner) {
    var size = owner.referenceTargetValue.length;
    owner.defaultValue = new Float32Array(size);
    owner.fixedPoseValue = new Float32Array(size);
    owner.baseEvaluateData.value = new Float32Array(size);
    owner.crossEvaluateData.value = new Float32Array(size);
  };
  AnimationFloatArrayCurve2._initializeLayerOwner = function _initializeLayerOwner(owner) {
    var size = owner.curveOwner.referenceTargetValue.length;
    owner.finalValue = new Float32Array(size);
  };
  AnimationFloatArrayCurve2._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
    for (var i = 0, n = out.length; i < n; ++i) {
      var src = srcValue[i];
      out[i] = src + (destValue[i] - src) * weight;
    }
    return out;
  };
  AnimationFloatArrayCurve2._subtractValue = function _subtractValue(src, base, out) {
    for (var i = 0, n = src.length; i < n; i++) {
      out[i] = src[i] - base[i];
    }
    return out;
  };
  AnimationFloatArrayCurve2._getZeroValue = function _getZeroValue(out) {
    for (var i = 0, n = out.length; i < n; i++) {
      out[i] = 0;
    }
    return out;
  };
  AnimationFloatArrayCurve2._additiveValue = function _additiveValue(value, weight, out) {
    for (var i = 0, n = out.length; i < n; ++i) {
      out[i] += value[i] * weight;
    }
    return out;
  };
  AnimationFloatArrayCurve2._copyValue = function _copyValue(source, out) {
    for (var i = 0, n = out.length; i < n; ++i) {
      out[i] = source[i];
    }
    return out;
  };
  AnimationFloatArrayCurve2._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
    var t0 = frame.outTangent;
    var t1 = nextFrame.inTangent;
    var p0 = frame.value;
    var p1 = nextFrame.value;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    for (var i = 0, n = p0.length; i < n; ++i) {
      if (Number.isFinite(t0[i]) && Number.isFinite(t1[i])) {
        out[i] = a * p0[i] + b * t0[i] * dur + c * t1[i] * dur + d * p1[i];
      } else {
        out[i] = frame.value[i];
      }
    }
    return out;
  };
  return AnimationFloatArrayCurve2;
}(AnimationCurve), function() {
  _AnimationFloatArrayCurve._isReferenceType = true;
}(), function() {
  _AnimationFloatArrayCurve._isInterpolationType = true;
}(), _AnimationFloatArrayCurve);
AnimationFloatArrayCurve = __decorate$2([
  StaticInterfaceImplement$1()
], AnimationFloatArrayCurve);
var _AnimationFloatCurve;
var AnimationFloatCurve = (_AnimationFloatCurve = /* @__PURE__ */ function(AnimationCurve2) {
  _inherits$2(AnimationFloatCurve2, AnimationCurve2);
  function AnimationFloatCurve2() {
    var _this;
    _this = AnimationCurve2.call(this) || this;
    _this._evaluateData.value = 0;
    return _this;
  }
  AnimationFloatCurve2._initializeOwner = function _initializeOwner(owner) {
    owner.defaultValue = 0;
    owner.fixedPoseValue = 0;
    owner.baseEvaluateData.value = 0;
    owner.crossEvaluateData.value = 0;
  };
  AnimationFloatCurve2._initializeLayerOwner = function _initializeLayerOwner(owner) {
    owner.finalValue = 0;
  };
  AnimationFloatCurve2._lerpValue = function _lerpValue(srcValue, destValue, crossWeight) {
    return srcValue + (destValue - srcValue) * crossWeight;
  };
  AnimationFloatCurve2._additiveValue = function _additiveValue(value, weight, scource) {
    return scource += value * weight;
  };
  AnimationFloatCurve2._subtractValue = function _subtractValue(src, base) {
    return src - base;
  };
  AnimationFloatCurve2._getZeroValue = function _getZeroValue() {
    return 0;
  };
  AnimationFloatCurve2._copyValue = function _copyValue(source) {
    return source;
  };
  AnimationFloatCurve2._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur) {
    var t0 = frame.outTangent;
    var t1 = nextFrame.inTangent;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      var t2 = t * t;
      var t3 = t2 * t;
      var a = 2 * t3 - 3 * t2 + 1;
      var b = t3 - 2 * t2 + t;
      var c = t3 - t2;
      var d = -2 * t3 + 3 * t2;
      return a * frame.value + b * t0 * dur + c * t1 * dur + d * nextFrame.value;
    } else {
      return frame.value;
    }
  };
  return AnimationFloatCurve2;
}(AnimationCurve), function() {
  _AnimationFloatCurve._isReferenceType = false;
}(), function() {
  _AnimationFloatCurve._isInterpolationType = true;
}(), _AnimationFloatCurve);
AnimationFloatCurve = __decorate$2([
  StaticInterfaceImplement$1()
], AnimationFloatCurve);
var _AnimationQuaternionCurve;
var AnimationQuaternionCurve = (_AnimationQuaternionCurve = /* @__PURE__ */ function(AnimationCurve2) {
  _inherits$2(AnimationQuaternionCurve1, AnimationCurve2);
  function AnimationQuaternionCurve1() {
    var _this;
    _this = AnimationCurve2.call(this) || this;
    _this._evaluateData.value = new Quaternion();
    return _this;
  }
  AnimationQuaternionCurve1._initializeOwner = function _initializeOwner(owner) {
    owner.defaultValue = new Quaternion();
    owner.fixedPoseValue = new Quaternion();
    owner.baseEvaluateData.value = new Quaternion();
    owner.crossEvaluateData.value = new Quaternion();
  };
  AnimationQuaternionCurve1._initializeLayerOwner = function _initializeLayerOwner(owner) {
    owner.finalValue = new Quaternion();
  };
  AnimationQuaternionCurve1._lerpValue = function _lerpValue(src, dest, weight, out) {
    Quaternion.slerp(src, dest, weight, out);
    return out;
  };
  AnimationQuaternionCurve1._additiveValue = function _additiveValue(value, weight, out) {
    value.x = value.x * weight;
    value.y = value.y * weight;
    value.z = value.z * weight;
    value.normalize();
    out.multiply(value);
    return out;
  };
  AnimationQuaternionCurve1._subtractValue = function _subtractValue(src, base, out) {
    var conjugate = AnimationQuaternionCurve._tempConjugateQuat;
    Quaternion.conjugate(base, conjugate);
    Quaternion.multiply(conjugate, src, out);
    return out;
  };
  AnimationQuaternionCurve1._getZeroValue = function _getZeroValue(out) {
    out.set(0, 0, 0, 1);
    return out;
  };
  AnimationQuaternionCurve1._copyValue = function _copyValue(source, out) {
    out.copyFrom(source);
    return out;
  };
  AnimationQuaternionCurve1._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
    var p0 = frame.value;
    var tan0 = frame.outTangent;
    var p1 = nextFrame.value;
    var tan1 = nextFrame.inTangent;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    var t0 = tan0.x, t1 = tan1.x;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
    } else {
      out.x = p0.x;
    }
    t0 = tan0.y, t1 = tan1.y;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
    } else {
      out.y = p0.y;
    }
    t0 = tan0.z, t1 = tan1.z;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
    } else {
      out.z = p0.z;
    }
    t0 = tan0.w, t1 = tan1.w;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
    } else {
      out.w = p0.w;
    }
    return out;
  };
  return AnimationQuaternionCurve1;
}(AnimationCurve), function() {
  _AnimationQuaternionCurve._isInterpolationType = true;
}(), function() {
  _AnimationQuaternionCurve._isReferenceType = true;
}(), function() {
  _AnimationQuaternionCurve._tempConjugateQuat = new Quaternion();
}(), _AnimationQuaternionCurve);
AnimationQuaternionCurve = __decorate$2([
  StaticInterfaceImplement$1()
], AnimationQuaternionCurve);
var _AnimationVector2Curve;
var AnimationVector2Curve = (_AnimationVector2Curve = /* @__PURE__ */ function(AnimationCurve2) {
  _inherits$2(AnimationVector2Curve2, AnimationCurve2);
  function AnimationVector2Curve2() {
    var _this;
    _this = AnimationCurve2.call(this) || this;
    _this._evaluateData.value = new Vector2();
    return _this;
  }
  AnimationVector2Curve2._initializeOwner = function _initializeOwner(owner) {
    owner.defaultValue = new Vector2();
    owner.fixedPoseValue = new Vector2();
    owner.baseEvaluateData.value = new Vector2();
    owner.crossEvaluateData.value = new Vector2();
  };
  AnimationVector2Curve2._initializeLayerOwner = function _initializeLayerOwner(owner) {
    owner.finalValue = new Vector2();
  };
  AnimationVector2Curve2._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
    Vector2.lerp(srcValue, destValue, weight, out);
    return out;
  };
  AnimationVector2Curve2._additiveValue = function _additiveValue(value, weight, out) {
    Vector2.scale(value, weight, value);
    Vector2.add(out, value, out);
    return out;
  };
  AnimationVector2Curve2._subtractValue = function _subtractValue(src, base, out) {
    Vector2.subtract(src, base, out);
    return out;
  };
  AnimationVector2Curve2._getZeroValue = function _getZeroValue(out) {
    out.set(0, 0);
    return out;
  };
  AnimationVector2Curve2._copyValue = function _copyValue(source, out) {
    out.copyFrom(source);
    return out;
  };
  AnimationVector2Curve2._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
    var p0 = frame.value;
    var tan0 = frame.outTangent;
    var p1 = nextFrame.value;
    var tan1 = nextFrame.inTangent;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    var t0 = tan0.x, t1 = tan1.x;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
    } else {
      out.x = p0.x;
    }
    t0 = tan0.y, t1 = tan1.y;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
    } else {
      out.y = p0.y;
    }
    return out;
  };
  return AnimationVector2Curve2;
}(AnimationCurve), function() {
  _AnimationVector2Curve._isReferenceType = true;
}(), function() {
  _AnimationVector2Curve._isInterpolationType = true;
}(), _AnimationVector2Curve);
AnimationVector2Curve = __decorate$2([
  StaticInterfaceImplement$1()
], AnimationVector2Curve);
var _AnimationVector3Curve;
var AnimationVector3Curve = (_AnimationVector3Curve = /* @__PURE__ */ function(AnimationCurve2) {
  _inherits$2(AnimationVector3Curve2, AnimationCurve2);
  function AnimationVector3Curve2() {
    var _this;
    _this = AnimationCurve2.call(this) || this;
    _this._evaluateData.value = new Vector3();
    return _this;
  }
  AnimationVector3Curve2._initializeOwner = function _initializeOwner(owner) {
    owner.defaultValue = new Vector3();
    owner.fixedPoseValue = new Vector3();
    owner.baseEvaluateData.value = new Vector3();
    owner.crossEvaluateData.value = new Vector3();
  };
  AnimationVector3Curve2._initializeLayerOwner = function _initializeLayerOwner(owner) {
    owner.finalValue = new Vector3();
  };
  AnimationVector3Curve2._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
    Vector3.lerp(srcValue, destValue, weight, out);
    return out;
  };
  AnimationVector3Curve2._relativeBaseValue = function _relativeBaseValue(base, out) {
    Vector3.subtract(out, base, out);
    return out;
  };
  AnimationVector3Curve2._additiveValue = function _additiveValue(value, weight, out) {
    Vector3.scale(value, weight, value);
    Vector3.add(out, value, out);
    return out;
  };
  AnimationVector3Curve2._subtractValue = function _subtractValue(src, base, out) {
    Vector3.subtract(src, base, out);
    return out;
  };
  AnimationVector3Curve2._getZeroValue = function _getZeroValue(out) {
    out.set(0, 0, 0);
    return out;
  };
  AnimationVector3Curve2._copyValue = function _copyValue(source, out) {
    out.copyFrom(source);
    return out;
  };
  AnimationVector3Curve2._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
    var p0 = frame.value;
    var tan0 = frame.outTangent;
    var p1 = nextFrame.value;
    var tan1 = nextFrame.inTangent;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    var t0 = tan0.x, t1 = tan1.x;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
    } else {
      out.x = p0.x;
    }
    t0 = tan0.y, t1 = tan1.y;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
    } else {
      out.y = p0.y;
    }
    t0 = tan0.z, t1 = tan1.z;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
    } else {
      out.z = p0.z;
    }
    return out;
  };
  return AnimationVector3Curve2;
}(AnimationCurve), function() {
  _AnimationVector3Curve._isReferenceType = true;
}(), function() {
  _AnimationVector3Curve._isInterpolationType = true;
}(), _AnimationVector3Curve);
AnimationVector3Curve = __decorate$2([
  StaticInterfaceImplement$1()
], AnimationVector3Curve);
var _AnimationVector4Curve;
var AnimationVector4Curve = (_AnimationVector4Curve = /* @__PURE__ */ function(AnimationCurve2) {
  _inherits$2(AnimationVector4Curve2, AnimationCurve2);
  function AnimationVector4Curve2() {
    var _this;
    _this = AnimationCurve2.call(this) || this;
    _this._evaluateData.value = new Vector4();
    return _this;
  }
  AnimationVector4Curve2._initializeOwner = function _initializeOwner(owner) {
    owner.defaultValue = new Vector4();
    owner.fixedPoseValue = new Vector4();
    owner.baseEvaluateData.value = new Vector4();
    owner.crossEvaluateData.value = new Vector4();
  };
  AnimationVector4Curve2._initializeLayerOwner = function _initializeLayerOwner(owner) {
    owner.finalValue = new Vector4();
  };
  AnimationVector4Curve2._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
    Vector4.lerp(srcValue, destValue, weight, out);
    return out;
  };
  AnimationVector4Curve2._additiveValue = function _additiveValue(value, weight, out) {
    Vector4.scale(value, weight, value);
    Vector4.add(out, value, out);
    return out;
  };
  AnimationVector4Curve2._subtractValue = function _subtractValue(src, base, out) {
    Vector4.subtract(src, base, out);
    return out;
  };
  AnimationVector4Curve2._getZeroValue = function _getZeroValue(out) {
    out.set(0, 0, 0, 0);
    return out;
  };
  AnimationVector4Curve2._copyValue = function _copyValue(source, out) {
    out.copyFrom(source);
    return out;
  };
  AnimationVector4Curve2._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
    var p0 = frame.value;
    var tan0 = frame.outTangent;
    var p1 = nextFrame.value;
    var tan1 = nextFrame.inTangent;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    var t0 = tan0.x, t1 = tan1.x;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
    } else {
      out.x = p0.x;
    }
    t0 = tan0.y, t1 = tan1.y;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
    } else {
      out.y = p0.y;
    }
    t0 = tan0.z, t1 = tan1.z;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
    } else {
      out.z = p0.z;
    }
    t0 = tan0.w, t1 = tan1.w;
    if (Number.isFinite(t0) && Number.isFinite(t1)) {
      out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
    } else {
      out.w = p0.w;
    }
    return out;
  };
  return AnimationVector4Curve2;
}(AnimationCurve), function() {
  _AnimationVector4Curve._isReferenceType = true;
}(), function() {
  _AnimationVector4Curve._isInterpolationType = true;
}(), _AnimationVector4Curve);
AnimationVector4Curve = __decorate$2([
  StaticInterfaceImplement$1()
], AnimationVector4Curve);
var AnimatorCullingMode;
(function(AnimatorCullingMode2) {
  AnimatorCullingMode2[AnimatorCullingMode2["None"] = 0] = "None";
  AnimatorCullingMode2[AnimatorCullingMode2["Complete"] = 1] = "Complete";
})(AnimatorCullingMode || (AnimatorCullingMode = {}));
var AnimatorLayerBlendingMode;
(function(AnimatorLayerBlendingMode2) {
  AnimatorLayerBlendingMode2[AnimatorLayerBlendingMode2["Override"] = 0] = "Override";
  AnimatorLayerBlendingMode2[AnimatorLayerBlendingMode2["Additive"] = 1] = "Additive";
})(AnimatorLayerBlendingMode || (AnimatorLayerBlendingMode = {}));
var AnimatorStatePlayState;
(function(AnimatorStatePlayState2) {
  AnimatorStatePlayState2[AnimatorStatePlayState2["UnStarted"] = 0] = "UnStarted";
  AnimatorStatePlayState2[AnimatorStatePlayState2["Playing"] = 1] = "Playing";
  AnimatorStatePlayState2[AnimatorStatePlayState2["Finished"] = 2] = "Finished";
})(AnimatorStatePlayState || (AnimatorStatePlayState = {}));
var LayerState;
(function(LayerState2) {
  LayerState2[LayerState2["Standby"] = 0] = "Standby";
  LayerState2[LayerState2["Playing"] = 1] = "Playing";
  LayerState2[LayerState2["CrossFading"] = 2] = "CrossFading";
  LayerState2[LayerState2["FixedCrossFading"] = 3] = "FixedCrossFading";
  LayerState2[LayerState2["Finished"] = 4] = "Finished";
})(LayerState || (LayerState = {}));
var AnimationEventHandler = /* @__PURE__ */ function() {
  function AnimationEventHandler2() {
    this.handlers = [];
  }
  var _proto = AnimationEventHandler2.prototype;
  _proto.dispose = function dispose() {
  };
  return AnimationEventHandler2;
}();
var AnimatorStateTransition = function AnimatorStateTransition2() {
  this.duration = 0;
  this.offset = 0;
  this.exitTime = 1;
};
var WrapMode;
(function(WrapMode2) {
  WrapMode2[WrapMode2["Once"] = 0] = "Once";
  WrapMode2[WrapMode2["Loop"] = 1] = "Loop";
})(WrapMode || (WrapMode = {}));
var AnimatorStatePlayData = /* @__PURE__ */ function() {
  function AnimatorStatePlayData2() {
  }
  var _proto = AnimatorStatePlayData2.prototype;
  _proto.reset = function reset(state, stateData, offsetFrameTime) {
    this.state = state;
    this.frameTime = offsetFrameTime;
    this.stateData = stateData;
    this.playState = AnimatorStatePlayState.UnStarted;
    this.clipTime = state.clipStartTime * state.clip.length;
    this.currentEventIndex = 0;
    this.currentTransitionIndex = 0;
  };
  _proto.update = function update(isBackwards) {
    var state = this.state;
    var time = this.frameTime;
    var duration = state._getDuration();
    this.playState = AnimatorStatePlayState.Playing;
    if (state.wrapMode === WrapMode.Loop) {
      time = duration ? time % duration : 0;
    } else {
      if (Math.abs(time) > duration) {
        time = time < 0 ? -duration : duration;
        this.playState = AnimatorStatePlayState.Finished;
      }
    }
    if (isBackwards && time === 0) {
      this.clipTime = state.clipEndTime * state.clip.length;
    } else {
      time < 0 && (time += duration);
      this.clipTime = time + state.clipStartTime * state.clip.length;
    }
  };
  return AnimatorStatePlayData2;
}();
var AnimatorLayerData = /* @__PURE__ */ function() {
  function AnimatorLayerData2() {
    this.curveOwnerPool = /* @__PURE__ */ Object.create(null);
    this.animatorStateDataMap = {};
    this.srcPlayData = new AnimatorStatePlayData();
    this.destPlayData = new AnimatorStatePlayData();
    this.layerState = LayerState.Standby;
    this.crossCurveMark = 0;
    this.manuallyTransition = new AnimatorStateTransition();
    this.crossLayerOwnerCollection = [];
  }
  var _proto = AnimatorLayerData2.prototype;
  _proto.switchPlayData = function switchPlayData() {
    var srcPlayData = this.destPlayData;
    var switchTemp = this.srcPlayData;
    this.srcPlayData = srcPlayData;
    this.destPlayData = switchTemp;
  };
  return AnimatorLayerData2;
}();
var AnimatorStateData = function AnimatorStateData2() {
  this.curveLayerOwner = [];
  this.eventHandlers = [];
};
var Animator = /* @__PURE__ */ function(Component2) {
  _inherits$2(Animator2, Component2);
  function Animator2(entity) {
    var _this;
    _this = Component2.call(this, entity) || this;
    _this.cullingMode = AnimatorCullingMode.None;
    _this.speed = 1;
    _this._onUpdateIndex = -1;
    _this._updateMark = 0;
    _this._animatorLayersData = [];
    _this._curveOwnerPool = /* @__PURE__ */ Object.create(null);
    _this._animationEventHandlerPool = new ClassPool(AnimationEventHandler);
    _this._tempAnimatorStateInfo = {
      layerIndex: -1,
      state: null
    };
    _this._controlledRenderers = [];
    return _this;
  }
  var _proto = Animator2.prototype;
  _proto.play = function play(stateName, layerIndex, normalizedTimeOffset) {
    if (layerIndex === void 0)
      layerIndex = -1;
    if (normalizedTimeOffset === void 0)
      normalizedTimeOffset = 0;
    var _this__controllerUpdateFlag;
    if ((_this__controllerUpdateFlag = this._controllerUpdateFlag) == null ? void 0 : _this__controllerUpdateFlag.flag) {
      this._reset();
    }
    this._playFrameCount = this.engine.time.frameCount;
    var stateInfo = this._getAnimatorStateInfo(stateName, layerIndex);
    var state = stateInfo.state, playLayerIndex = stateInfo.layerIndex;
    if (!state) {
      return;
    }
    if (!state.clip) {
      Logger.warn("The state named " + stateName + " has no AnimationClip data.");
      return;
    }
    var animatorLayerData = this._getAnimatorLayerData(playLayerIndex);
    var animatorStateData = this._getAnimatorStateData(stateName, state, animatorLayerData, playLayerIndex);
    this._preparePlay(animatorLayerData, state);
    animatorLayerData.layerState = LayerState.Playing;
    animatorLayerData.srcPlayData.reset(state, animatorStateData, state._getDuration() * normalizedTimeOffset);
    this.update(0);
  };
  _proto.crossFade = function crossFade(stateName, normalizedTransitionDuration, layerIndex, normalizedTimeOffset) {
    if (layerIndex === void 0)
      layerIndex = -1;
    if (normalizedTimeOffset === void 0)
      normalizedTimeOffset = 0;
    var _this__controllerUpdateFlag;
    if ((_this__controllerUpdateFlag = this._controllerUpdateFlag) == null ? void 0 : _this__controllerUpdateFlag.flag) {
      this._reset();
    }
    this._playFrameCount = this.engine.time.frameCount;
    var _this__getAnimatorStateInfo = this._getAnimatorStateInfo(stateName, layerIndex), state = _this__getAnimatorStateInfo.state, playLayerIndex = _this__getAnimatorStateInfo.layerIndex;
    var manuallyTransition = this._getAnimatorLayerData(playLayerIndex).manuallyTransition;
    manuallyTransition.duration = normalizedTransitionDuration;
    manuallyTransition.offset = normalizedTimeOffset;
    manuallyTransition.destinationState = state;
    if (this._crossFadeByTransition(manuallyTransition, playLayerIndex)) {
      this.update(0);
    }
  };
  _proto.update = function update(deltaTime) {
    var _this__controllerUpdateFlag;
    var animationUpdate;
    if (this.cullingMode === AnimatorCullingMode.Complete) {
      animationUpdate = false;
      var controlledRenderers = this._controlledRenderers;
      for (var i = 0, n = controlledRenderers.length; i < n; i++) {
        if (!controlledRenderers[i].isCulled) {
          animationUpdate = true;
          break;
        }
      }
    } else {
      animationUpdate = true;
    }
    var _this = this, animatorController = _this._animatorController;
    if (!animatorController) {
      return;
    }
    if ((_this__controllerUpdateFlag = this._controllerUpdateFlag) == null ? void 0 : _this__controllerUpdateFlag.flag) {
      this._checkAutoPlay();
      return;
    }
    this._updateMark++;
    for (var i1 = 0, n1 = animatorController.layers.length; i1 < n1; i1++) {
      var animatorLayerData = this._getAnimatorLayerData(i1);
      if (animatorLayerData.layerState === LayerState.Standby) {
        continue;
      }
      this._updateLayer(i1, i1 === 0, deltaTime, animationUpdate);
    }
  };
  _proto.getCurrentAnimatorState = function getCurrentAnimatorState(layerIndex) {
    var _this__animatorLayersData_layerIndex, _this__animatorLayersData_layerIndex_srcPlayData;
    return (_this__animatorLayersData_layerIndex = this._animatorLayersData[layerIndex]) == null ? void 0 : (_this__animatorLayersData_layerIndex_srcPlayData = _this__animatorLayersData_layerIndex.srcPlayData) == null ? void 0 : _this__animatorLayersData_layerIndex_srcPlayData.state;
  };
  _proto.findAnimatorState = function findAnimatorState(stateName, layerIndex) {
    if (layerIndex === void 0)
      layerIndex = -1;
    return this._getAnimatorStateInfo(stateName, layerIndex).state;
  };
  _proto._onEnable = function _onEnable() {
    this.engine._componentsManager.addOnUpdateAnimations(this);
    this.animatorController && this._checkAutoPlay();
    this._entity.getComponentsIncludeChildren(Renderer, this._controlledRenderers);
  };
  _proto._onDisable = function _onDisable() {
    this.engine._componentsManager.removeOnUpdateAnimations(this);
  };
  _proto._reset = function _reset() {
    var _this = this, animationCurveOwners = _this._curveOwnerPool;
    for (var instanceId in animationCurveOwners) {
      var propertyOwners = animationCurveOwners[instanceId];
      for (var property in propertyOwners) {
        var owner = propertyOwners[property];
        owner.revertDefaultValue();
      }
    }
    this._animatorLayersData.length = 0;
    this._curveOwnerPool = {};
    this._animationEventHandlerPool.resetPool();
    if (this._controllerUpdateFlag) {
      this._controllerUpdateFlag.flag = false;
    }
  };
  _proto._getAnimatorStateInfo = function _getAnimatorStateInfo(stateName, layerIndex) {
    var _this = this, animatorController = _this._animatorController, stateInfo = _this._tempAnimatorStateInfo;
    var state = null;
    if (animatorController) {
      var layers = animatorController.layers;
      if (layerIndex === -1) {
        for (var i = 0, n = layers.length; i < n; i++) {
          state = layers[i].stateMachine.findStateByName(stateName);
          if (state) {
            layerIndex = i;
            break;
          }
        }
      } else {
        state = layers[layerIndex].stateMachine.findStateByName(stateName);
      }
    }
    stateInfo.layerIndex = layerIndex;
    stateInfo.state = state;
    return stateInfo;
  };
  _proto._getAnimatorStateData = function _getAnimatorStateData(stateName, animatorState, animatorLayerData, layerIndex) {
    var animatorStateDataMap = animatorLayerData.animatorStateDataMap;
    var animatorStateData = animatorStateDataMap[stateName];
    if (!animatorStateData) {
      animatorStateData = new AnimatorStateData();
      animatorStateDataMap[stateName] = animatorStateData;
      this._saveAnimatorStateData(animatorState, animatorStateData, animatorLayerData, layerIndex);
      this._saveAnimatorEventHandlers(animatorState, animatorStateData);
    }
    return animatorStateData;
  };
  _proto._saveAnimatorStateData = function _saveAnimatorStateData(animatorState, animatorStateData, animatorLayerData, layerIndex) {
    var _this = this, entity = _this.entity, curveOwnerPool = _this._curveOwnerPool;
    var curveLayerOwner = animatorStateData.curveLayerOwner;
    var _animatorState_clip = animatorState.clip, curves = _animatorState_clip._curveBindings;
    var layerCurveOwnerPool = animatorLayerData.curveOwnerPool;
    for (var i = curves.length - 1; i >= 0; i--) {
      var curve = curves[i];
      var targetEntity = curve.relativePath === "" ? entity : entity.findByPath(curve.relativePath);
      if (targetEntity) {
        var _curveOwnerPool, _instanceId, _propertyOwners, _property, _layerCurveOwnerPool, _instanceId1, _layerPropertyOwners, _property1;
        var property = curve.property;
        var instanceId = targetEntity.instanceId;
        var propertyOwners = (_curveOwnerPool = curveOwnerPool)[_instanceId = instanceId] || (_curveOwnerPool[_instanceId] = /* @__PURE__ */ Object.create(null));
        var owner = (_propertyOwners = propertyOwners)[_property = property] || (_propertyOwners[_property] = curve._createCurveOwner(targetEntity));
        var layerPropertyOwners = (_layerCurveOwnerPool = layerCurveOwnerPool)[_instanceId1 = instanceId] || (_layerCurveOwnerPool[_instanceId1] = /* @__PURE__ */ Object.create(null));
        var layerOwner = (_layerPropertyOwners = layerPropertyOwners)[_property1 = property] || (_layerPropertyOwners[_property1] = curve._createCurveLayerOwner(owner));
        curveLayerOwner[i] = layerOwner;
      } else {
        curveLayerOwner[i] = null;
        Logger.warn("The entity don't have the child entity which path is " + curve.relativePath + ".");
      }
    }
  };
  _proto._saveAnimatorEventHandlers = function _saveAnimatorEventHandlers(state, animatorStateData) {
    var eventHandlerPool = this._animationEventHandlerPool;
    var scripts = [];
    this._entity.getComponents(Script, scripts);
    var scriptCount = scripts.length;
    var eventHandlers = animatorStateData.eventHandlers;
    var events = state.clip.events;
    eventHandlers.length = 0;
    for (var i = 0, n = events.length; i < n; i++) {
      var event = events[i];
      var eventHandler = eventHandlerPool.getFromPool();
      var funcName = event.functionName;
      var handlers = eventHandler.handlers;
      eventHandler.event = event;
      handlers.length = 0;
      for (var j2 = scriptCount - 1; j2 >= 0; j2--) {
        var handler = scripts[j2][funcName];
        handler && handlers.push(handler);
      }
      eventHandlers.push(eventHandler);
    }
  };
  _proto._clearCrossData = function _clearCrossData(animatorLayerData) {
    animatorLayerData.crossCurveMark++;
    animatorLayerData.crossLayerOwnerCollection.length = 0;
  };
  _proto._addCrossOwner = function _addCrossOwner(animatorLayerData, layerOwner, curCurveIndex, nextCurveIndex) {
    layerOwner.crossSrcCurveIndex = curCurveIndex;
    layerOwner.crossDestCurveIndex = nextCurveIndex;
    animatorLayerData.crossLayerOwnerCollection.push(layerOwner);
  };
  _proto._prepareCrossFading = function _prepareCrossFading(animatorLayerData) {
    this._prepareSrcCrossData(animatorLayerData, false);
    this._prepareDestCrossData(animatorLayerData, false);
  };
  _proto._prepareStandbyCrossFading = function _prepareStandbyCrossFading(animatorLayerData) {
    animatorLayerData.srcPlayData.state && this._prepareSrcCrossData(animatorLayerData, true);
    this._prepareDestCrossData(animatorLayerData, true);
  };
  _proto._prepareFixedPoseCrossFading = function _prepareFixedPoseCrossFading(animatorLayerData) {
    var crossLayerOwnerCollection = animatorLayerData.crossLayerOwnerCollection;
    for (var i = crossLayerOwnerCollection.length - 1; i >= 0; i--) {
      var layerOwner = crossLayerOwnerCollection[i];
      if (!layerOwner)
        continue;
      layerOwner.curveOwner.saveFixedPoseValue();
      layerOwner.crossDestCurveIndex = -1;
    }
    this._prepareDestCrossData(animatorLayerData, true);
  };
  _proto._prepareSrcCrossData = function _prepareSrcCrossData(animatorLayerData, saveFixed) {
    var curveLayerOwner = animatorLayerData.srcPlayData.stateData.curveLayerOwner;
    for (var i = curveLayerOwner.length - 1; i >= 0; i--) {
      var layerOwner = curveLayerOwner[i];
      if (!layerOwner)
        continue;
      layerOwner.crossCurveMark = animatorLayerData.crossCurveMark;
      saveFixed && layerOwner.curveOwner.saveFixedPoseValue();
      this._addCrossOwner(animatorLayerData, layerOwner, i, -1);
    }
  };
  _proto._prepareDestCrossData = function _prepareDestCrossData(animatorLayerData, saveFixed) {
    var curveLayerOwner = animatorLayerData.destPlayData.stateData.curveLayerOwner;
    for (var i = curveLayerOwner.length - 1; i >= 0; i--) {
      var layerOwner = curveLayerOwner[i];
      if (!layerOwner)
        continue;
      if (layerOwner.crossCurveMark === animatorLayerData.crossCurveMark) {
        layerOwner.crossDestCurveIndex = i;
      } else {
        var owner = layerOwner.curveOwner;
        saveFixed && owner.saveFixedPoseValue();
        layerOwner.crossCurveMark = animatorLayerData.crossCurveMark;
        this._addCrossOwner(animatorLayerData, layerOwner, -1, i);
      }
    }
  };
  _proto._getAnimatorLayerData = function _getAnimatorLayerData(layerIndex) {
    var animatorLayerData = this._animatorLayersData[layerIndex];
    animatorLayerData || (this._animatorLayersData[layerIndex] = animatorLayerData = new AnimatorLayerData());
    return animatorLayerData;
  };
  _proto._updateLayer = function _updateLayer(layerIndex, firstLayer, deltaTime, aniUpdate) {
    var _this__animatorController_layers_layerIndex = this._animatorController.layers[layerIndex], blendingMode = _this__animatorController_layers_layerIndex.blendingMode, weight = _this__animatorController_layers_layerIndex.weight;
    var layerData = this._animatorLayersData[layerIndex];
    var srcPlayData = layerData.srcPlayData, destPlayData = layerData.destPlayData;
    var additive = blendingMode === AnimatorLayerBlendingMode.Additive;
    firstLayer && (weight = 1);
    switch (layerData.layerState) {
      case LayerState.Playing:
        this._updatePlayingState(srcPlayData, layerData, layerIndex, weight, deltaTime, additive, aniUpdate);
        break;
      case LayerState.FixedCrossFading:
        this._updateCrossFadeFromPose(destPlayData, layerData, layerIndex, weight, deltaTime, additive, aniUpdate);
        break;
      case LayerState.CrossFading:
        this._updateCrossFade(srcPlayData, destPlayData, layerData, layerIndex, weight, deltaTime, additive, aniUpdate);
        break;
      case LayerState.Finished:
        this._updateFinishedState(srcPlayData, weight, additive, aniUpdate);
        break;
    }
  };
  _proto._updatePlayingState = function _updatePlayingState(playData, layerData, layerIndex, weight, delta, additive, aniUpdate) {
    var _playData_stateData = playData.stateData, curveLayerOwner = _playData_stateData.curveLayerOwner, eventHandlers = _playData_stateData.eventHandlers;
    var state = playData.state, lastPlayState = playData.playState, lastClipTime = playData.clipTime;
    var transitions = state.transitions;
    var _state_clip = state.clip, curveBindings = _state_clip._curveBindings;
    var speed = state.speed * this.speed;
    playData.frameTime += speed * delta;
    playData.update(speed < 0);
    var clipTime = playData.clipTime, playState = playData.playState;
    var finished = playState === AnimatorStatePlayState.Finished;
    if (aniUpdate || finished) {
      for (var i = curveBindings.length - 1; i >= 0; i--) {
        var layerOwner = curveLayerOwner[i];
        var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
        if (!owner)
          continue;
        var curve = curveBindings[i].curve;
        if (curve.keys.length) {
          this._checkRevertOwner(owner, additive);
          var value = owner.evaluateValue(curve, clipTime, additive);
          aniUpdate && owner.applyValue(value, weight, additive);
          finished && layerOwner.saveFinalValue();
        }
      }
    }
    if (playState === AnimatorStatePlayState.Finished) {
      layerData.layerState = LayerState.Finished;
    }
    eventHandlers.length && this._fireAnimationEvents(playData, eventHandlers, lastClipTime, clipTime);
    if (lastPlayState === AnimatorStatePlayState.UnStarted) {
      this._callAnimatorScriptOnEnter(state, layerIndex);
    }
    if (playState === AnimatorStatePlayState.Finished) {
      this._callAnimatorScriptOnExit(state, layerIndex);
    } else {
      this._callAnimatorScriptOnUpdate(state, layerIndex);
    }
    if (transitions.length) {
      var layerState = layerData.layerState;
      if (layerState !== LayerState.CrossFading && layerState !== LayerState.FixedCrossFading) {
        this._checkTransition(playData, transitions, layerIndex, lastClipTime, clipTime);
      }
    }
  };
  _proto._updateCrossFade = function _updateCrossFade(srcPlayData, destPlayData, layerData, layerIndex, weight, delta, additive, aniUpdate) {
    var speed = this.speed;
    var crossLayerOwnerCollection = layerData.crossLayerOwnerCollection;
    var _srcPlayData_state_clip = srcPlayData.state.clip, srcCurves = _srcPlayData_state_clip._curveBindings;
    var srcState = srcPlayData.state, srcStateData = srcPlayData.stateData, lastSrcPlayState = srcPlayData.playState;
    var srcEventHandlers = srcStateData.eventHandlers;
    var destState = destPlayData.state, destStateData = destPlayData.stateData, lastDstPlayState = destPlayData.playState;
    var destEventHandlers = destStateData.eventHandlers;
    var _destState_clip = destState.clip, destCurves = _destState_clip._curveBindings;
    var lastSrcClipTime = srcPlayData.clipTime;
    var lastDestClipTime = destPlayData.clipTime;
    var duration = destState._getDuration() * layerData.crossFadeTransition.duration;
    var crossWeight = Math.abs(destPlayData.frameTime) / duration;
    (crossWeight >= 1 || duration === 0) && (crossWeight = 1);
    var srcSpeed = srcState.speed * speed;
    var destSpeed = destState.speed * speed;
    srcPlayData.frameTime += srcSpeed * delta;
    destPlayData.frameTime += destSpeed * delta;
    srcPlayData.update(srcSpeed < 0);
    destPlayData.update(destSpeed < 0);
    var srcClipTime = srcPlayData.clipTime, srcPlayState = srcPlayData.playState;
    var destClipTime = destPlayData.clipTime, destPlayState = destPlayData.playState;
    var finished = destPlayData.playState === AnimatorStatePlayState.Finished;
    if (aniUpdate || finished) {
      for (var i = crossLayerOwnerCollection.length - 1; i >= 0; i--) {
        var layerOwner = crossLayerOwnerCollection[i];
        var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
        if (!owner)
          continue;
        var srcCurveIndex = layerOwner.crossSrcCurveIndex;
        var destCurveIndex = layerOwner.crossDestCurveIndex;
        this._checkRevertOwner(owner, additive);
        var value = owner.evaluateCrossFadeValue(srcCurveIndex >= 0 ? srcCurves[srcCurveIndex].curve : null, destCurveIndex >= 0 ? destCurves[destCurveIndex].curve : null, srcClipTime, destClipTime, crossWeight, additive);
        aniUpdate && owner.applyValue(value, weight, additive);
        finished && layerOwner.saveFinalValue();
      }
    }
    this._updateCrossFadeData(layerData, crossWeight);
    srcEventHandlers.length && this._fireAnimationEvents(srcPlayData, srcEventHandlers, lastSrcClipTime, srcClipTime);
    destEventHandlers.length && this._fireAnimationEvents(destPlayData, destEventHandlers, lastDestClipTime, destClipTime);
    if (lastSrcPlayState === AnimatorStatePlayState.UnStarted) {
      this._callAnimatorScriptOnEnter(srcState, layerIndex);
    }
    if (crossWeight === 1 || srcPlayState === AnimatorStatePlayState.Finished) {
      this._callAnimatorScriptOnExit(srcState, layerIndex);
    } else {
      this._callAnimatorScriptOnUpdate(srcState, layerIndex);
    }
    if (lastDstPlayState === AnimatorStatePlayState.UnStarted) {
      this._callAnimatorScriptOnEnter(destState, layerIndex);
    }
    if (destPlayState === AnimatorStatePlayState.Finished) {
      this._callAnimatorScriptOnExit(destState, layerIndex);
    } else {
      this._callAnimatorScriptOnUpdate(destState, layerIndex);
    }
  };
  _proto._updateCrossFadeFromPose = function _updateCrossFadeFromPose(destPlayData, layerData, layerIndex, weight, delta, additive, aniUpdate) {
    var crossLayerOwnerCollection = layerData.crossLayerOwnerCollection;
    var state = destPlayData.state, stateData = destPlayData.stateData, lastPlayState = destPlayData.playState;
    var eventHandlers = stateData.eventHandlers;
    var _state_clip = state.clip, curveBindings = _state_clip._curveBindings;
    var lastDestClipTime = destPlayData.clipTime;
    var duration = state._getDuration() * layerData.crossFadeTransition.duration;
    var crossWeight = Math.abs(destPlayData.frameTime) / duration;
    (crossWeight >= 1 || duration === 0) && (crossWeight = 1);
    var speed = state.speed * this.speed;
    destPlayData.frameTime += speed * delta;
    destPlayData.update(speed < 0);
    var destClipTime = destPlayData.clipTime, playState = destPlayData.playState;
    var finished = playState === AnimatorStatePlayState.Finished;
    if (aniUpdate || finished) {
      for (var i = crossLayerOwnerCollection.length - 1; i >= 0; i--) {
        var layerOwner = crossLayerOwnerCollection[i];
        var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
        if (!owner)
          continue;
        var curveIndex = layerOwner.crossDestCurveIndex;
        this._checkRevertOwner(owner, additive);
        var value = layerOwner.curveOwner.crossFadeFromPoseAndApplyValue(curveIndex >= 0 ? curveBindings[curveIndex].curve : null, destClipTime, crossWeight, additive);
        aniUpdate && owner.applyValue(value, weight, additive);
        finished && layerOwner.saveFinalValue();
      }
    }
    this._updateCrossFadeData(layerData, crossWeight);
    eventHandlers.length && this._fireAnimationEvents(destPlayData, eventHandlers, lastDestClipTime, destClipTime);
    if (lastPlayState === AnimatorStatePlayState.UnStarted) {
      this._callAnimatorScriptOnEnter(state, layerIndex);
    }
    if (playState === AnimatorStatePlayState.Finished) {
      this._callAnimatorScriptOnExit(state, layerIndex);
    } else {
      this._callAnimatorScriptOnUpdate(state, layerIndex);
    }
  };
  _proto._updateFinishedState = function _updateFinishedState(playData, weight, additive, aniUpdate) {
    if (!aniUpdate) {
      return;
    }
    var curveLayerOwner = playData.stateData.curveLayerOwner;
    var _playData_state_clip = playData.state.clip, curveBindings = _playData_state_clip._curveBindings;
    for (var i = curveBindings.length - 1; i >= 0; i--) {
      var layerOwner = curveLayerOwner[i];
      var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
      if (!owner)
        continue;
      this._checkRevertOwner(owner, additive);
      owner.applyValue(layerOwner.finalValue, weight, additive);
    }
  };
  _proto._updateCrossFadeData = function _updateCrossFadeData(layerData, crossWeight) {
    var destPlayData = layerData.destPlayData;
    if (crossWeight === 1) {
      if (destPlayData.playState === AnimatorStatePlayState.Finished) {
        layerData.layerState = LayerState.Finished;
      } else {
        layerData.layerState = LayerState.Playing;
      }
      layerData.switchPlayData();
      layerData.crossFadeTransition = null;
    }
  };
  _proto._preparePlay = function _preparePlay(layerData, playState) {
    if (layerData.layerState === LayerState.Playing) {
      var srcPlayData = layerData.srcPlayData;
      if (srcPlayData.state !== playState) {
        var curveLayerOwner = srcPlayData.stateData.curveLayerOwner;
        for (var i = curveLayerOwner.length - 1; i >= 0; i--) {
          var _curveLayerOwner_i;
          (_curveLayerOwner_i = curveLayerOwner[i]) == null ? void 0 : _curveLayerOwner_i.curveOwner.revertDefaultValue();
        }
      }
    } else {
      var crossLayerOwnerCollection = layerData.crossLayerOwnerCollection;
      for (var i1 = crossLayerOwnerCollection.length - 1; i1 >= 0; i1--) {
        crossLayerOwnerCollection[i1].curveOwner.revertDefaultValue();
      }
    }
  };
  _proto._checkTransition = function _checkTransition(playState, transitions, layerIndex, lastClipTime, clipTime) {
    var state = playState.state;
    var clipDuration = state.clip.length;
    if (this.speed * state.speed >= 0) {
      if (clipTime < lastClipTime) {
        this._checkSubTransition(playState, transitions, layerIndex, lastClipTime, state.clipEndTime * clipDuration);
        playState.currentTransitionIndex = 0;
        this._checkSubTransition(playState, transitions, layerIndex, state.clipStartTime * clipDuration, clipTime);
      } else {
        this._checkSubTransition(playState, transitions, layerIndex, lastClipTime, clipTime);
      }
    } else {
      if (clipTime > lastClipTime) {
        this._checkBackwardsSubTransition(playState, transitions, layerIndex, lastClipTime, state.clipStartTime * clipDuration);
        playState.currentTransitionIndex = transitions.length - 1;
        this._checkBackwardsSubTransition(playState, transitions, layerIndex, clipTime, state.clipEndTime * clipDuration);
      } else {
        this._checkBackwardsSubTransition(playState, transitions, layerIndex, lastClipTime, clipTime);
      }
    }
  };
  _proto._checkSubTransition = function _checkSubTransition(playState, transitions, layerIndex, lastClipTime, curClipTime) {
    var transitionIndex = playState.currentTransitionIndex;
    var duration = playState.state._getDuration();
    for (var n = transitions.length; transitionIndex < n; transitionIndex++) {
      var transition = transitions[transitionIndex];
      var exitTime = transition.exitTime * duration;
      if (exitTime > curClipTime) {
        break;
      }
      if (exitTime >= lastClipTime) {
        this._crossFadeByTransition(transition, layerIndex);
        playState.currentTransitionIndex = Math.min(transitionIndex + 1, n - 1);
      }
    }
  };
  _proto._checkBackwardsSubTransition = function _checkBackwardsSubTransition(playState, transitions, layerIndex, lastClipTime, curClipTime) {
    var transitionIndex = playState.currentTransitionIndex;
    var duration = playState.state._getDuration();
    for (; transitionIndex >= 0; transitionIndex--) {
      var transition = transitions[transitionIndex];
      var exitTime = transition.exitTime * duration;
      if (exitTime < curClipTime) {
        break;
      }
      if (exitTime <= lastClipTime) {
        this._crossFadeByTransition(transition, layerIndex);
        playState.currentTransitionIndex = Math.max(transitionIndex - 1, 0);
      }
    }
  };
  _proto._crossFadeByTransition = function _crossFadeByTransition(transition, layerIndex) {
    var crossState = transition.destinationState;
    if (!crossState) {
      return false;
    }
    if (!crossState.clip) {
      Logger.warn("The state named " + name + " has no AnimationClip data.");
      return false;
    }
    var animatorLayerData = this._getAnimatorLayerData(layerIndex);
    var layerState = animatorLayerData.layerState;
    var destPlayData = animatorLayerData.destPlayData;
    var animatorStateData = this._getAnimatorStateData(crossState.name, crossState, animatorLayerData, layerIndex);
    var duration = crossState._getDuration();
    var offset = duration * transition.offset;
    destPlayData.reset(crossState, animatorStateData, offset);
    switch (layerState) {
      case LayerState.Standby:
      case LayerState.Finished:
        animatorLayerData.layerState = LayerState.FixedCrossFading;
        this._clearCrossData(animatorLayerData);
        this._prepareStandbyCrossFading(animatorLayerData);
        break;
      case LayerState.Playing:
        animatorLayerData.layerState = LayerState.CrossFading;
        this._clearCrossData(animatorLayerData);
        this._prepareCrossFading(animatorLayerData);
        break;
      case LayerState.CrossFading:
        animatorLayerData.layerState = LayerState.FixedCrossFading;
        this._prepareFixedPoseCrossFading(animatorLayerData);
        break;
      case LayerState.FixedCrossFading:
        this._prepareFixedPoseCrossFading(animatorLayerData);
        break;
    }
    animatorLayerData.crossFadeTransition = transition;
    return true;
  };
  _proto._fireAnimationEvents = function _fireAnimationEvents(playState, eventHandlers, lastClipTime, clipTime) {
    var state = playState.state;
    var clipDuration = state.clip.length;
    if (this.speed * state.speed >= 0) {
      if (clipTime < lastClipTime) {
        this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, state.clipEndTime * clipDuration);
        playState.currentEventIndex = 0;
        this._fireSubAnimationEvents(playState, eventHandlers, state.clipStartTime * clipDuration, clipTime);
      } else {
        this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
      }
    } else {
      if (clipTime > lastClipTime) {
        this._fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, state.clipStartTime * clipDuration);
        playState.currentEventIndex = eventHandlers.length - 1;
        this._fireBackwardSubAnimationEvents(playState, eventHandlers, state.clipEndTime * clipDuration, clipTime);
      } else {
        this._fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
      }
    }
  };
  _proto._fireSubAnimationEvents = function _fireSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
    var eventIndex = playState.currentEventIndex;
    for (var n = eventHandlers.length; eventIndex < n; eventIndex++) {
      var eventHandler = eventHandlers[eventIndex];
      var _eventHandler_event = eventHandler.event, time = _eventHandler_event.time, parameter = _eventHandler_event.parameter;
      if (time > curClipTime) {
        break;
      }
      var handlers = eventHandler.handlers;
      if (time >= lastClipTime) {
        for (var j2 = handlers.length - 1; j2 >= 0; j2--) {
          handlers[j2](parameter);
        }
        playState.currentEventIndex = Math.min(eventIndex + 1, n - 1);
      }
    }
  };
  _proto._fireBackwardSubAnimationEvents = function _fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
    var eventIndex = playState.currentEventIndex;
    for (; eventIndex >= 0; eventIndex--) {
      var eventHandler = eventHandlers[eventIndex];
      var _eventHandler_event = eventHandler.event, time = _eventHandler_event.time, parameter = _eventHandler_event.parameter;
      if (time < curClipTime) {
        break;
      }
      if (time <= lastClipTime) {
        var handlers = eventHandler.handlers;
        for (var j2 = handlers.length - 1; j2 >= 0; j2--) {
          handlers[j2](parameter);
        }
        playState.currentEventIndex = Math.max(eventIndex - 1, 0);
      }
    }
  };
  _proto._callAnimatorScriptOnEnter = function _callAnimatorScriptOnEnter(state, layerIndex) {
    var scripts = state._onStateEnterScripts;
    for (var i = 0, n = scripts.length; i < n; i++) {
      scripts[i].onStateEnter(this, state, layerIndex);
    }
  };
  _proto._callAnimatorScriptOnUpdate = function _callAnimatorScriptOnUpdate(state, layerIndex) {
    var scripts = state._onStateUpdateScripts;
    for (var i = 0, n = scripts.length; i < n; i++) {
      scripts[i].onStateUpdate(this, state, layerIndex);
    }
  };
  _proto._callAnimatorScriptOnExit = function _callAnimatorScriptOnExit(state, layerIndex) {
    var scripts = state._onStateExitScripts;
    for (var i = 0, n = scripts.length; i < n; i++) {
      scripts[i].onStateExit(this, state, layerIndex);
    }
  };
  _proto._checkAutoPlay = function _checkAutoPlay() {
    var layers = this._animatorController.layers;
    for (var i = 0, n = layers.length; i < n; ++i) {
      var stateMachine = layers[i].stateMachine;
      if (stateMachine == null ? void 0 : stateMachine.defaultState) {
        this.play(stateMachine.defaultState.name, i);
      }
    }
  };
  _proto._checkRevertOwner = function _checkRevertOwner(owner, additive) {
    if (additive && owner.updateMark !== this._updateMark) {
      owner.revertDefaultValue();
    }
    owner.updateMark = this._updateMark;
  };
  _create_class$4(Animator2, [
    {
      key: "animatorController",
      get: function get3() {
        return this._animatorController;
      },
      set: function set(animatorController) {
        if (animatorController !== this._animatorController) {
          this._reset();
          this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();
          this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
          this._animatorController = animatorController;
        }
      }
    }
  ]);
  return Animator2;
}(Component);
__decorate$2([
  assignmentClone
], Animator.prototype, "speed", void 0);
__decorate$2([
  ignoreClone
], Animator.prototype, "_controllerUpdateFlag", void 0);
__decorate$2([
  ignoreClone
], Animator.prototype, "_updateMark", void 0);
__decorate$2([
  ignoreClone
], Animator.prototype, "_animatorLayersData", void 0);
__decorate$2([
  ignoreClone
], Animator.prototype, "_curveOwnerPool", void 0);
__decorate$2([
  ignoreClone
], Animator.prototype, "_animationEventHandlerPool", void 0);
__decorate$2([
  ignoreClone
], Animator.prototype, "_tempAnimatorStateInfo", void 0);
__decorate$2([
  ignoreClone
], Animator.prototype, "_controlledRenderers", void 0);
var AnimatorController = /* @__PURE__ */ function() {
  function AnimatorController2() {
    this._updateFlagManager = new UpdateFlagManager();
    this._layers = [];
    this._layersMap = {};
  }
  var _proto = AnimatorController2.prototype;
  _proto.findLayerByName = function findLayerByName(name2) {
    return this._layersMap[name2];
  };
  _proto.addLayer = function addLayer(layer) {
    this._layers.push(layer);
    this._layersMap[layer.name] = layer;
    this._updateFlagManager.dispatch();
  };
  _proto.removeLayer = function removeLayer(layerIndex) {
    var theLayer = this.layers[layerIndex];
    this._layers.splice(layerIndex, 1);
    delete this._layersMap[theLayer.name];
    this._updateFlagManager.dispatch();
  };
  _proto.clearLayers = function clearLayers() {
    this._layers.length = 0;
    for (var name2 in this._layersMap) {
      delete this._layersMap[name2];
    }
    this._updateFlagManager.dispatch();
  };
  _proto._registerChangeFlag = function _registerChangeFlag() {
    return this._updateFlagManager.createFlag(BoolUpdateFlag);
  };
  _create_class$4(AnimatorController2, [
    {
      key: "layers",
      get: function get3() {
        return this._layers;
      }
    }
  ]);
  return AnimatorController2;
}();
var AnimatorControllerLayer = function AnimatorControllerLayer2(name2) {
  this.name = name2;
  this.weight = 1;
  this.blendingMode = AnimatorLayerBlendingMode.Override;
};
var StateMachineScript = /* @__PURE__ */ function() {
  function StateMachineScript2() {
    this._destroyed = false;
  }
  var _proto = StateMachineScript2.prototype;
  _proto.onStateEnter = function onStateEnter(animator, animatorState, layerIndex) {
  };
  _proto.onStateUpdate = function onStateUpdate(animator, animatorState, layerIndex) {
  };
  _proto.onStateExit = function onStateExit(animator, animatorState, layerIndex) {
  };
  _proto.destroy = function destroy2() {
    if (this._destroyed) {
      return;
    }
    this._state._removeStateMachineScript(this);
    this._destroyed = true;
  };
  return StateMachineScript2;
}();
var AnimatorState = /* @__PURE__ */ function() {
  function AnimatorState2(name2) {
    this.name = name2;
    this.speed = 1;
    this.wrapMode = WrapMode.Loop;
    this._onStateEnterScripts = [];
    this._onStateUpdateScripts = [];
    this._onStateExitScripts = [];
    this._clipStartTime = 0;
    this._clipEndTime = 1;
    this._transitions = [];
  }
  var _proto = AnimatorState2.prototype;
  _proto.addTransition = function addTransition(transition) {
    var transitions = this._transitions;
    var count = transitions.length;
    var time = transition.exitTime;
    var maxExitTime = count ? transitions[count - 1].exitTime : 0;
    if (time >= maxExitTime) {
      transitions.push(transition);
    } else {
      var index = count;
      while (--index >= 0 && time < transitions[index].exitTime)
        ;
      transitions.splice(index + 1, 0, transition);
    }
  };
  _proto.removeTransition = function removeTransition(transition) {
    var index = this._transitions.indexOf(transition);
    index !== -1 && this._transitions.splice(index, 1);
  };
  _proto.addStateMachineScript = function addStateMachineScript(scriptType) {
    var script = new scriptType();
    script._state = this;
    var prototype = StateMachineScript.prototype;
    if (script.onStateEnter !== prototype.onStateEnter) {
      this._onStateEnterScripts.push(script);
    }
    if (script.onStateUpdate !== prototype.onStateUpdate) {
      this._onStateUpdateScripts.push(script);
    }
    if (script.onStateExit !== prototype.onStateExit) {
      this._onStateExitScripts.push(script);
    }
    return script;
  };
  _proto.clearTransitions = function clearTransitions() {
    this._transitions.length = 0;
  };
  _proto._getDuration = function _getDuration() {
    if (this.clip) {
      return (this._clipEndTime - this._clipStartTime) * this.clip.length;
    }
    return null;
  };
  _proto._removeStateMachineScript = function _removeStateMachineScript(script) {
    var prototype = StateMachineScript.prototype;
    if (script.onStateEnter !== prototype.onStateEnter) {
      var index = this._onStateEnterScripts.indexOf(script);
      index !== -1 && this._onStateEnterScripts.splice(index, 1);
    }
    if (script.onStateUpdate !== prototype.onStateUpdate) {
      var index1 = this._onStateUpdateScripts.indexOf(script);
      index1 !== -1 && this._onStateUpdateScripts.splice(index1, 1);
    }
    if (script.onStateExit !== prototype.onStateExit) {
      var index2 = this._onStateExitScripts.indexOf(script);
      index2 !== -1 && this._onStateExitScripts.splice(index2, 1);
    }
  };
  _create_class$4(AnimatorState2, [
    {
      key: "transitions",
      get: function get3() {
        return this._transitions;
      }
    },
    {
      key: "clip",
      get: function get3() {
        return this._clip;
      },
      set: function set(clip) {
        this._clip = clip;
        this._clipEndTime = Math.min(this._clipEndTime, 1);
      }
    },
    {
      key: "clipStartTime",
      get: function get3() {
        return this._clipStartTime;
      },
      set: function set(time) {
        this._clipStartTime = Math.max(time, 0);
      }
    },
    {
      key: "clipEndTime",
      get: function get3() {
        return this._clipEndTime;
      },
      set: function set(time) {
        this._clipEndTime = Math.min(time, 1);
      }
    }
  ]);
  return AnimatorState2;
}();
var AnimatorStateMachine = /* @__PURE__ */ function() {
  function AnimatorStateMachine2() {
    this.states = [];
    this._statesMap = {};
  }
  var _proto = AnimatorStateMachine2.prototype;
  _proto.addState = function addState(name2) {
    var state = this.findStateByName(name2);
    if (!state) {
      state = new AnimatorState(name2);
      this.states.push(state);
      this._statesMap[name2] = state;
    } else {
      console.warn("The state named " + name2 + " has existed.");
    }
    return state;
  };
  _proto.removeState = function removeState(state) {
    var name2 = state.name;
    var index = this.states.indexOf(state);
    if (index > -1) {
      this.states.splice(index, 1);
    }
    delete this._statesMap[name2];
  };
  _proto.findStateByName = function findStateByName(name2) {
    return this._statesMap[name2];
  };
  _proto.makeUniqueStateName = function makeUniqueStateName(name2) {
    var _statesMap = this._statesMap;
    var originName = name2;
    var index = 0;
    while (_statesMap[name2]) {
      name2 = originName + " " + index;
      index++;
    }
    return name2;
  };
  return AnimatorStateMachine2;
}();
var AnimatorConditionMode;
(function(AnimatorConditionMode2) {
  AnimatorConditionMode2[AnimatorConditionMode2["If"] = 0] = "If";
  AnimatorConditionMode2[AnimatorConditionMode2["IfNot"] = 1] = "IfNot";
  AnimatorConditionMode2[AnimatorConditionMode2["Greater"] = 2] = "Greater";
  AnimatorConditionMode2[AnimatorConditionMode2["Less"] = 3] = "Less";
  AnimatorConditionMode2[AnimatorConditionMode2["Equals"] = 4] = "Equals";
  AnimatorConditionMode2[AnimatorConditionMode2["NotEquals"] = 5] = "NotEquals";
})(AnimatorConditionMode || (AnimatorConditionMode = {}));
var Keyframe = function Keyframe2() {
};
var SkyBoxMaterial = /* @__PURE__ */ function(Material2) {
  _inherits$2(SkyBoxMaterial2, Material2);
  function SkyBoxMaterial2(engine) {
    var _this;
    _this = Material2.call(this, engine, Shader.find("skybox")) || this;
    _this._textureDecodeRGBM = false;
    _this._tintColor = new Color$1(1, 1, 1, 1);
    _this.renderState.rasterState.cullMode = CullMode.Off;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this.shaderData.setFloat(SkyBoxMaterial2._rotationProp, 0);
    _this.shaderData.setFloat(SkyBoxMaterial2._exposureProp, 1);
    _this.shaderData.setColor(SkyBoxMaterial2._tintColorProp, _this._tintColor);
    return _this;
  }
  var _proto = SkyBoxMaterial2.prototype;
  _proto.clone = function clone() {
    var dest = new SkyBoxMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _create_class$4(SkyBoxMaterial2, [
    {
      key: "textureDecodeRGBM",
      get: function get3() {
        return this._textureDecodeRGBM;
      },
      set: function set(value) {
        this._textureDecodeRGBM = value;
        if (value) {
          this.shaderData.enableMacro(SkyBoxMaterial2._decodeSkyRGBMMacro);
        } else {
          this.shaderData.disableMacro(SkyBoxMaterial2._decodeSkyRGBMMacro);
        }
      }
    },
    {
      key: "texture",
      get: function get3() {
        return this.shaderData.getTexture(SkyBoxMaterial2._textureCubeProp);
      },
      set: function set(value) {
        this.shaderData.setTexture(SkyBoxMaterial2._textureCubeProp, value);
      }
    },
    {
      key: "rotation",
      get: function get3() {
        return this.shaderData.getFloat(SkyBoxMaterial2._rotationProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(SkyBoxMaterial2._rotationProp, value);
      }
    },
    {
      key: "exposure",
      get: function get3() {
        return this.shaderData.getFloat(SkyBoxMaterial2._exposureProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(SkyBoxMaterial2._exposureProp, value);
      }
    },
    {
      key: "tintColor",
      get: function get3() {
        return this._tintColor;
      },
      set: function set(value) {
        if (this._tintColor != value) {
          this._tintColor.copyFrom(value);
        }
      }
    }
  ]);
  return SkyBoxMaterial2;
}(Material);
(function() {
  SkyBoxMaterial._tintColorProp = ShaderProperty.getByName("material_TintColor");
})();
(function() {
  SkyBoxMaterial._textureCubeProp = ShaderProperty.getByName("material_CubeTexture");
})();
(function() {
  SkyBoxMaterial._rotationProp = ShaderProperty.getByName("material_Rotation");
})();
(function() {
  SkyBoxMaterial._exposureProp = ShaderProperty.getByName("material_Exposure");
})();
(function() {
  SkyBoxMaterial._decodeSkyRGBMMacro = ShaderMacro.getByName("MATERIAL_IS_DECODE_SKY_RGBM");
})();
var SunMode;
(function(SunMode2) {
  SunMode2[SunMode2["None"] = 0] = "None";
  SunMode2[SunMode2["Simple"] = 1] = "Simple";
  SunMode2[SunMode2["HighQuality"] = 2] = "HighQuality";
})(SunMode || (SunMode = {}));
var SkyProceduralMaterial = /* @__PURE__ */ function(Material2) {
  _inherits$2(SkyProceduralMaterial2, Material2);
  function SkyProceduralMaterial2(engine) {
    var _this;
    _this = Material2.call(this, engine, Shader.find("SkyProcedural")) || this;
    _this.sunMode = 2;
    _this.sunSize = 0.04;
    _this.sunSizeConvergence = 5;
    _this.atmosphereThickness = 1;
    _this.skyTint = new Color$1(0.5, 0.5, 0.5, 1);
    _this.groundTint = new Color$1(0.369, 0.349, 0.341, 1);
    _this.exposure = 1.3;
    _this.renderState.rasterState.cullMode = CullMode.Off;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    return _this;
  }
  var _proto = SkyProceduralMaterial2.prototype;
  _proto.clone = function clone() {
    var dest = new SkyProceduralMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _create_class$4(SkyProceduralMaterial2, [
    {
      key: "sunMode",
      get: function get3() {
        return this._sunDisk;
      },
      set: function set(value) {
        var shaderData = this.shaderData;
        switch (value) {
          case 2:
            shaderData.disableMacro(SkyProceduralMaterial2._sunSimpleMacro);
            shaderData.enableMacro(SkyProceduralMaterial2._sunHighQualityMacro);
            break;
          case 1:
            shaderData.disableMacro(SkyProceduralMaterial2._sunHighQualityMacro);
            shaderData.enableMacro(SkyProceduralMaterial2._sunSimpleMacro);
            break;
          case 0:
            shaderData.disableMacro(SkyProceduralMaterial2._sunHighQualityMacro);
            shaderData.disableMacro(SkyProceduralMaterial2._sunSimpleMacro);
            break;
          default:
            throw "SkyBoxProceduralMaterial: unknown sun value.";
        }
        this._sunDisk = value;
      }
    },
    {
      key: "sunSize",
      get: function get3() {
        return this.shaderData.getFloat(SkyProceduralMaterial2._sunSizeProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(SkyProceduralMaterial2._sunSizeProp, Math.min(Math.max(0, value), 1));
      }
    },
    {
      key: "sunSizeConvergence",
      get: function get3() {
        return this.shaderData.getFloat(SkyProceduralMaterial2._sunSizeConvergenceProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(SkyProceduralMaterial2._sunSizeConvergenceProp, Math.min(Math.max(0, value), 20));
      }
    },
    {
      key: "atmosphereThickness",
      get: function get3() {
        return this.shaderData.getFloat(SkyProceduralMaterial2._atmosphereThicknessProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(SkyProceduralMaterial2._atmosphereThicknessProp, Math.min(Math.max(0, value), 5));
      }
    },
    {
      key: "skyTint",
      get: function get3() {
        return this.shaderData.getColor(SkyProceduralMaterial2._skyTintProp);
      },
      set: function set(value) {
        this.shaderData.setColor(SkyProceduralMaterial2._skyTintProp, value);
      }
    },
    {
      key: "groundTint",
      get: function get3() {
        return this.shaderData.getColor(SkyProceduralMaterial2._groundTintProp);
      },
      set: function set(value) {
        this.shaderData.setColor(SkyProceduralMaterial2._groundTintProp, value);
      }
    },
    {
      key: "exposure",
      get: function get3() {
        return this.shaderData.getFloat(SkyProceduralMaterial2._exposureProp);
      },
      set: function set(value) {
        this.shaderData.setFloat(SkyProceduralMaterial2._exposureProp, Math.min(Math.max(0, value), 8));
      }
    }
  ]);
  return SkyProceduralMaterial2;
}(Material);
(function() {
  SkyProceduralMaterial._sunSizeProp = ShaderProperty.getByName("material_SunSize");
})();
(function() {
  SkyProceduralMaterial._sunSizeConvergenceProp = ShaderProperty.getByName("material_SunSizeConvergence");
})();
(function() {
  SkyProceduralMaterial._atmosphereThicknessProp = ShaderProperty.getByName("material_AtmosphereThickness");
})();
(function() {
  SkyProceduralMaterial._skyTintProp = ShaderProperty.getByName("material_SkyTint");
})();
(function() {
  SkyProceduralMaterial._groundTintProp = ShaderProperty.getByName("material_GroundTint");
})();
(function() {
  SkyProceduralMaterial._exposureProp = ShaderProperty.getByName("material_Exposure");
})();
(function() {
  SkyProceduralMaterial._sunHighQualityMacro = ShaderMacro.getByName("MATERIAL_SUN_HIGH_QUALITY");
})();
(function() {
  SkyProceduralMaterial._sunSimpleMacro = ShaderMacro.getByName("MATERIAL_SUN_SIMPLE");
})();
var DirtyFlagType;
(function(DirtyFlagType2) {
  DirtyFlagType2[DirtyFlagType2["Position"] = 1] = "Position";
  DirtyFlagType2[DirtyFlagType2["Velocity"] = 2] = "Velocity";
  DirtyFlagType2[DirtyFlagType2["Acceleration"] = 4] = "Acceleration";
  DirtyFlagType2[DirtyFlagType2["Color"] = 8] = "Color";
  DirtyFlagType2[DirtyFlagType2["Alpha"] = 16] = "Alpha";
  DirtyFlagType2[DirtyFlagType2["Size"] = 32] = "Size";
  DirtyFlagType2[DirtyFlagType2["StartAngle"] = 64] = "StartAngle";
  DirtyFlagType2[DirtyFlagType2["StartTime"] = 128] = "StartTime";
  DirtyFlagType2[DirtyFlagType2["LifeTime"] = 256] = "LifeTime";
  DirtyFlagType2[DirtyFlagType2["RotateVelocity"] = 512] = "RotateVelocity";
  DirtyFlagType2[DirtyFlagType2["Scale"] = 1024] = "Scale";
  DirtyFlagType2[DirtyFlagType2["Everything"] = 4294967295] = "Everything";
})(DirtyFlagType || (DirtyFlagType = {}));
var ParticleRendererBlendMode;
(function(ParticleRendererBlendMode2) {
  ParticleRendererBlendMode2[ParticleRendererBlendMode2["Transparent"] = 0] = "Transparent";
  ParticleRendererBlendMode2[ParticleRendererBlendMode2["Additive"] = 1] = "Additive";
})(ParticleRendererBlendMode || (ParticleRendererBlendMode = {}));
var ParticleRenderer = /* @__PURE__ */ function(MeshRenderer2) {
  _inherits$2(ParticleRenderer2, MeshRenderer2);
  function ParticleRenderer2(props) {
    var _this;
    _this = MeshRenderer2.call(this, props) || this;
    _this._maxCount = 1e3;
    _this._position = new Vector3();
    _this._positionRandomness = new Vector3();
    _this._velocity = new Vector3();
    _this._velocityRandomness = new Vector3();
    _this._acceleration = new Vector3();
    _this._accelerationRandomness = new Vector3();
    _this._color = new Color$1(1, 1, 1, 1);
    _this._colorRandomness = 0;
    _this._size = 1;
    _this._sizeRandomness = 0;
    _this._alpha = 1;
    _this._alphaRandomness = 0;
    _this._startAngle = 0;
    _this._startAngleRandomness = 0;
    _this._rotateVelocity = 0;
    _this._rotateVelocityRandomness = 0;
    _this._lifetime = 5;
    _this._startTimeRandomness = 0;
    _this._scale = 1;
    _this._isOnce = false;
    _this._onceTime = 0;
    _this._time = 0;
    _this._isInit = false;
    _this._isStart = false;
    _this._updateDirtyFlag = 4294967295;
    _this._isRotateToVelocity = false;
    _this._isUseOriginColor = false;
    _this._isScaleByLifetime = false;
    _this._is2d = true;
    _this._isFadeIn = false;
    _this._isFadeOut = false;
    _this._playOnEnable = true;
    _this._blendMode = 0;
    _this._onColorChanged = _this._onColorChanged.bind(_assert_this_initialized(_this));
    _this._color._onValueChanged = _this._onColorChanged;
    _this.setMaterial(_this._createMaterial());
    return _this;
  }
  var _proto = ParticleRenderer2.prototype;
  _proto.update = function update(deltaTime) {
    if (!this._isInit || !this._isStart) {
      return;
    }
    if (this._isOnce && this._time > this._onceTime) {
      return this.stop();
    }
    if (this._updateDirtyFlag) {
      this._updateBuffer();
      this._updateDirtyFlag = 0;
    }
    this._time += deltaTime;
    this.shaderData.setFloat("u_time", this._time);
  };
  _proto._onEnable = function _onEnable() {
    MeshRenderer2.prototype._onEnable.call(this);
    if (this._playOnEnable) {
      this.start();
    }
  };
  _proto.start = function start() {
    this._isStart = true;
    this._time = 0;
  };
  _proto.stop = function stop() {
    this._isStart = false;
  };
  _proto._createMaterial = function _createMaterial() {
    var material = new Material(this.engine, Shader.find("particle-shader"));
    var renderState = material.renderState;
    var target = renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.sourceAlphaBlendFactor = BlendFactor.One;
    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    renderState.depthState.writeEnabled = false;
    material.renderState.renderQueueType = RenderQueueType.Transparent;
    this.isUseOriginColor = true;
    this.is2d = true;
    this.isFadeOut = true;
    return material;
  };
  _proto._createMesh = function _createMesh() {
    var mesh = new BufferMesh(this._entity.engine, "particleMesh");
    var vertexStride = 96;
    var vertexCount = this._maxCount * 4;
    var vertexFloatCount = vertexCount * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var indices = null;
    var useUint32 = false;
    if (vertexCount > ParticleRenderer2._uint16VertexLimit) {
      if (this.engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
        useUint32 = true;
        indices = new Uint32Array(6 * this._maxCount);
      } else {
        throw Error("The vertex count is over limit.");
      }
    } else {
      indices = new Uint16Array(6 * this._maxCount);
    }
    for (var i = 0, idx = 0; i < this._maxCount; ++i) {
      var startIndex = i * 4;
      indices[idx++] = startIndex;
      indices[idx++] = startIndex + 1;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex + 3;
    }
    var vertexElements = [
      new VertexElement("a_position", 0, VertexElementFormat.Vector3, 0),
      new VertexElement("a_velocity", 12, VertexElementFormat.Vector3, 0),
      new VertexElement("a_acceleration", 24, VertexElementFormat.Vector3, 0),
      new VertexElement("a_color", 36, VertexElementFormat.Vector4, 0),
      new VertexElement("a_lifeAndSize", 52, VertexElementFormat.Vector4, 0),
      new VertexElement("a_rotation", 68, VertexElementFormat.Vector2, 0),
      new VertexElement("a_uv", 76, VertexElementFormat.Vector3, 0),
      new VertexElement("a_normalizedUv", 88, VertexElementFormat.Vector2, 0)
    ];
    var vertexBuffer = new Buffer(this.engine, BufferBindFlag.VertexBuffer, vertexFloatCount * 4, BufferUsage.Dynamic);
    var indexBuffer = new Buffer(this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
    mesh.setIndexBufferBinding(indexBuffer, useUint32 ? IndexFormat.UInt32 : IndexFormat.UInt16);
    mesh.setVertexElements(vertexElements);
    mesh.addSubMesh(0, indices.length);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride / 4;
    this._vertices = vertices;
    var bounds = mesh.bounds;
    var minValue = Number.MIN_SAFE_INTEGER;
    var maxValue = Number.MAX_SAFE_INTEGER;
    bounds.min.set(minValue, minValue, minValue);
    bounds.max.set(maxValue, maxValue, maxValue);
    return mesh;
  };
  _proto._updateBuffer = function _updateBuffer() {
    for (var x = 0; x < this._maxCount; x++) {
      this._updateSingleBuffer(x);
    }
    this._vertexBuffer.setData(this._vertices);
  };
  _proto._updateSingleBuffer = function _updateSingleBuffer(i) {
    var _this = this, _updateDirtyFlag = _this._updateDirtyFlag, vertices = _this._vertices, vertexStride = _this._vertexStride;
    var getRandom = ParticleRenderer2._getRandom;
    var offset = i * 4;
    var k0 = offset * vertexStride;
    var k1 = (offset + 1) * vertexStride;
    var k2 = (offset + 2) * vertexStride;
    var k3 = (offset + 3) * vertexStride;
    if (_updateDirtyFlag & 1) {
      var _this__position = this._position, x = _this__position.x, y = _this__position.y, z2 = _this__position.z;
      var _this1 = this, _positionArray = _this1._positionArray, _positionRandomness = _this1._positionRandomness;
      if (_positionArray) {
        if (_positionArray.length !== this._maxCount) {
          throw Error("The length of positionArray must be equal to maxCount.");
        }
        var pos = _positionArray[i];
        x += pos.x;
        y += pos.y;
        z2 += pos.z;
      } else {
        x += getRandom() * _positionRandomness.x;
        y += getRandom() * _positionRandomness.y;
        z2 += getRandom() * _positionRandomness.z;
      }
      vertices[k0] = vertices[k1] = vertices[k2] = vertices[k3] = x;
      vertices[k0 + 1] = vertices[k1 + 1] = vertices[k2 + 1] = vertices[k3 + 1] = y;
      vertices[k0 + 2] = vertices[k1 + 2] = vertices[k2 + 2] = vertices[k3 + 2] = z2;
    }
    if (_updateDirtyFlag & 2) {
      var _this2 = this, _velocity = _this2._velocity, _velocityRandomness = _this2._velocityRandomness;
      vertices[k0 + 3] = vertices[k1 + 3] = vertices[k2 + 3] = vertices[k3 + 3] = _velocity.x + getRandom() * _velocityRandomness.x;
      vertices[k0 + 4] = vertices[k1 + 4] = vertices[k2 + 4] = vertices[k3 + 4] = _velocity.y + getRandom() * _velocityRandomness.y;
      vertices[k0 + 5] = vertices[k1 + 5] = vertices[k2 + 5] = vertices[k3 + 5] = _velocity.z + getRandom() * _velocityRandomness.z;
    }
    if (_updateDirtyFlag & 4) {
      var _this3 = this, _acceleration = _this3._acceleration, _accelerationRandomness = _this3._accelerationRandomness;
      vertices[k0 + 6] = vertices[k1 + 6] = vertices[k2 + 6] = vertices[k3 + 6] = _acceleration.x + getRandom() * _accelerationRandomness.x;
      vertices[k0 + 7] = vertices[k1 + 7] = vertices[k2 + 7] = vertices[k3 + 7] = _acceleration.y + getRandom() * _accelerationRandomness.y;
      vertices[k0 + 8] = vertices[k1 + 8] = vertices[k2 + 8] = vertices[k3 + 8] = _acceleration.z + getRandom() * _accelerationRandomness.z;
    }
    if (_updateDirtyFlag & 8) {
      var _this4 = this, _color = _this4._color, _colorRandomness = _this4._colorRandomness;
      vertices[k0 + 9] = vertices[k1 + 9] = vertices[k2 + 9] = vertices[k3 + 9] = MathUtil$1.clamp(_color.r + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 10] = vertices[k1 + 10] = vertices[k2 + 10] = vertices[k3 + 10] = MathUtil$1.clamp(_color.g + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 11] = vertices[k1 + 11] = vertices[k2 + 11] = vertices[k3 + 11] = MathUtil$1.clamp(_color.b + getRandom() * _colorRandomness, 0, 1);
    }
    if (_updateDirtyFlag & 16) {
      vertices[k0 + 12] = vertices[k1 + 12] = vertices[k2 + 12] = vertices[k3 + 12] = MathUtil$1.clamp(this._alpha + getRandom() * this._alphaRandomness, 0, 1);
    }
    if (_updateDirtyFlag & 128) {
      vertices[k0 + 13] = vertices[k1 + 13] = vertices[k2 + 13] = vertices[k3 + 13] = Math.random() * this._startTimeRandomness;
    }
    if (_updateDirtyFlag & 256) {
      var _lifetime = this._lifetime;
      vertices[k0 + 14] = vertices[k1 + 14] = vertices[k2 + 14] = vertices[k3 + 14] = _lifetime + getRandom() * _lifetime;
    }
    if (_updateDirtyFlag & 128 || _updateDirtyFlag & 256) {
      this._onceTime = Math.max(this._onceTime, vertices[k0 + 13] + vertices[k0 + 14]);
    }
    if (_updateDirtyFlag & 32) {
      var _size = this._size;
      vertices[k0 + 15] = vertices[k1 + 15] = vertices[k2 + 15] = vertices[k3 + 15] = Math.max(_size + getRandom() * this._sizeRandomness * _size * 2, 0);
    }
    if (_updateDirtyFlag & 1024) {
      vertices[k0 + 16] = vertices[k1 + 16] = vertices[k2 + 16] = vertices[k3 + 16] = this._scale;
    }
    if (_updateDirtyFlag & 64) {
      vertices[k0 + 17] = vertices[k1 + 17] = vertices[k2 + 17] = vertices[k3 + 17] = this._startAngle + getRandom() * Math.PI * this._startAngleRandomness * 2;
    }
    if (_updateDirtyFlag & 512) {
      vertices[k0 + 18] = vertices[k1 + 18] = vertices[k2 + 18] = vertices[k3 + 18] = this._rotateVelocity + getRandom() * this._rotateVelocityRandomness;
    }
    this._updateSingleUv(i, k0, k1, k2, k3);
  };
  _proto._updateSingleUv = function _updateSingleUv(i, k0, k1, k2, k3) {
    var spriteSheet = this.spriteSheet;
    var texture = this.getMaterial().shaderData.getTexture("u_texture");
    var vertices = this._vertices;
    if (texture) {
      var width = texture.width;
      var height = texture.height;
      if (spriteSheet) {
        var _spriteSheet_ = spriteSheet[i % spriteSheet.length], x = _spriteSheet_.x, y = _spriteSheet_.y, w = _spriteSheet_.w, h = _spriteSheet_.h;
        var u = x / width;
        var v = y / height;
        var p = u + w / width;
        var q2 = v + h / height;
        var ratio = h / w;
        vertices[k0 + 19] = u;
        vertices[k0 + 20] = q2;
        vertices[k0 + 21] = ratio;
        vertices[k1 + 19] = p;
        vertices[k1 + 20] = q2;
        vertices[k1 + 21] = ratio;
        vertices[k2 + 19] = p;
        vertices[k2 + 20] = v;
        vertices[k2 + 21] = ratio;
        vertices[k3 + 19] = u;
        vertices[k3 + 20] = v;
        vertices[k3 + 21] = ratio;
      } else {
        var ratio1 = height / width;
        vertices[k0 + 19] = 0;
        vertices[k0 + 20] = 1;
        vertices[k0 + 21] = ratio1;
        vertices[k1 + 19] = 1;
        vertices[k1 + 20] = 1;
        vertices[k1 + 21] = ratio1;
        vertices[k2 + 19] = 1;
        vertices[k2 + 20] = 0;
        vertices[k2 + 21] = ratio1;
        vertices[k3 + 19] = 0;
        vertices[k3 + 20] = 0;
        vertices[k3 + 21] = ratio1;
      }
    } else {
      vertices[k0 + 19] = 0;
      vertices[k0 + 20] = 0;
      vertices[k0 + 21] = 1;
      vertices[k1 + 19] = 1;
      vertices[k1 + 20] = 0;
      vertices[k1 + 21] = 1;
      vertices[k2 + 19] = 1;
      vertices[k2 + 20] = 1;
      vertices[k2 + 21] = 1;
      vertices[k3 + 19] = 0;
      vertices[k3 + 20] = 1;
      vertices[k3 + 21] = 1;
    }
    vertices[k0 + 22] = -0.5;
    vertices[k0 + 23] = -0.5;
    vertices[k1 + 22] = 0.5;
    vertices[k1 + 23] = -0.5;
    vertices[k2 + 22] = 0.5;
    vertices[k2 + 23] = 0.5;
    vertices[k3 + 22] = -0.5;
    vertices[k3 + 23] = 0.5;
  };
  _proto._onColorChanged = function _onColorChanged() {
    this._updateDirtyFlag |= 8;
  };
  ParticleRenderer2._getRandom = function _getRandom() {
    return Math.random() - 0.5;
  };
  _create_class$4(ParticleRenderer2, [
    {
      key: "texture",
      get: function get3() {
        return this.getMaterial().shaderData.getTexture("u_texture");
      },
      set: function set(texture) {
        if (texture) {
          this.shaderData.enableMacro("particleTexture");
          this.getMaterial().shaderData.setTexture("u_texture", texture);
        } else {
          this.shaderData.disableMacro("particleTexture");
        }
      }
    },
    {
      key: "position",
      get: function get3() {
        return this._position;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 1;
        this._position = value;
      }
    },
    {
      key: "positionRandomness",
      get: function get3() {
        return this._positionRandomness;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 1;
        this._positionRandomness = value;
      }
    },
    {
      key: "positionArray",
      get: function get3() {
        return this._positionArray;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 1;
        this._positionArray = value;
      }
    },
    {
      key: "velocity",
      get: function get3() {
        return this._velocity;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 2;
        this._velocity = value;
      }
    },
    {
      key: "velocityRandomness",
      get: function get3() {
        return this._velocityRandomness;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 2;
        this._velocityRandomness = value;
      }
    },
    {
      key: "acceleration",
      get: function get3() {
        return this._acceleration;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 4;
        this._acceleration = value;
      }
    },
    {
      key: "accelerationRandomness",
      get: function get3() {
        return this._accelerationRandomness;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 4;
        this._accelerationRandomness = value;
      }
    },
    {
      key: "color",
      get: function get3() {
        return this._color;
      },
      set: function set(value) {
        this._color.copyFrom(value);
      }
    },
    {
      key: "colorRandomness",
      get: function get3() {
        return this._colorRandomness;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 8;
        this._colorRandomness = value;
      }
    },
    {
      key: "size",
      get: function get3() {
        return this._size;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 32;
        this._size = value;
      }
    },
    {
      key: "sizeRandomness",
      get: function get3() {
        return this._sizeRandomness;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 32;
        this._sizeRandomness = value;
      }
    },
    {
      key: "alpha",
      get: function get3() {
        return this._alpha;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 16;
        this._alpha = value;
      }
    },
    {
      key: "alphaRandomness",
      get: function get3() {
        return this._alphaRandomness;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 16;
        this._alphaRandomness = value;
      }
    },
    {
      key: "angle",
      get: function get3() {
        return this._startAngle;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 64;
        this._startAngle = value;
      }
    },
    {
      key: "angleRandomness",
      get: function get3() {
        return this._startAngleRandomness;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 64;
        this._startAngleRandomness = value;
      }
    },
    {
      key: "rotateVelocity",
      get: function get3() {
        return this._rotateVelocity;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 512;
        this._rotateVelocity = value;
      }
    },
    {
      key: "rotateVelocityRandomness",
      get: function get3() {
        return this._rotateVelocityRandomness;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 512;
        this._rotateVelocityRandomness = value;
      }
    },
    {
      key: "lifetime",
      get: function get3() {
        return this._lifetime;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 256;
        this._lifetime = value;
        this._onceTime = 0;
      }
    },
    {
      key: "startTimeRandomness",
      get: function get3() {
        return this._startTimeRandomness;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 128;
        this._startTimeRandomness = value;
        this._onceTime = 0;
      }
    },
    {
      key: "scale",
      get: function get3() {
        return this._scale;
      },
      set: function set(value) {
        this._updateDirtyFlag |= 1024;
        this._scale = value;
      }
    },
    {
      key: "maxCount",
      get: function get3() {
        return this._maxCount;
      },
      set: function set(value) {
        this._isStart = false;
        this._isInit = false;
        this._maxCount = value;
        this._updateDirtyFlag = 4294967295;
        this.mesh = this._createMesh();
        this._updateBuffer();
        this._isInit = true;
        this.shaderData.setFloat("u_time", 0);
      }
    },
    {
      key: "isOnce",
      get: function get3() {
        return this._isOnce;
      },
      set: function set(value) {
        this._time = 0;
        this.shaderData.setInt("u_once", value ? 1 : 0);
        this._isOnce = value;
      }
    },
    {
      key: "isRotateToVelocity",
      get: function get3() {
        return this._isRotateToVelocity;
      },
      set: function set(value) {
        if (value) {
          this.shaderData.enableMacro("rotateToVelocity");
        } else {
          this.shaderData.disableMacro("rotateToVelocity");
        }
        this._isRotateToVelocity = value;
      }
    },
    {
      key: "isUseOriginColor",
      get: function get3() {
        return this._isUseOriginColor;
      },
      set: function set(value) {
        if (value) {
          this.shaderData.enableMacro("useOriginColor");
        } else {
          this.shaderData.disableMacro("useOriginColor");
        }
        this._isUseOriginColor = value;
      }
    },
    {
      key: "isScaleByLifetime",
      get: function get3() {
        return this._isScaleByLifetime;
      },
      set: function set(value) {
        if (value) {
          this.shaderData.enableMacro("isScaleByLifetime");
        } else {
          this.shaderData.disableMacro("isScaleByLifetime");
        }
        this._isScaleByLifetime = value;
      }
    },
    {
      key: "is2d",
      get: function get3() {
        return this._is2d;
      },
      set: function set(value) {
        if (value) {
          this.shaderData.enableMacro("is2d");
        } else {
          this.shaderData.disableMacro("is2d");
          this.getMaterial().renderState.rasterState.cullMode = CullMode.Off;
        }
        this._is2d = value;
      }
    },
    {
      key: "isFadeIn",
      get: function get3() {
        return this._isFadeIn;
      },
      set: function set(value) {
        if (value) {
          this.shaderData.enableMacro("fadeIn");
        } else {
          this.shaderData.disableMacro("fadeIn");
        }
        this._isFadeIn = value;
      }
    },
    {
      key: "isFadeOut",
      get: function get3() {
        return this._isFadeOut;
      },
      set: function set(value) {
        if (value) {
          this.shaderData.enableMacro("fadeOut");
        } else {
          this.shaderData.disableMacro("fadeOut");
        }
        this._isFadeOut = value;
      }
    },
    {
      key: "playOnEnable",
      get: function get3() {
        return this._playOnEnable;
      },
      set: function set(value) {
        this._playOnEnable = value;
        if (value) {
          this.start();
        } else {
          this.stop();
        }
      }
    },
    {
      key: "blendMode",
      get: function get3() {
        return this._blendMode;
      },
      set: function set(value) {
        var blendState = this.getMaterial().renderState.blendState;
        var target = blendState.targetBlendState;
        if (value === 0) {
          target.enabled = true;
          target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
          target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
          target.sourceAlphaBlendFactor = BlendFactor.One;
          target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
        } else if (value === 1) {
          target.enabled = true;
          target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
          target.destinationColorBlendFactor = BlendFactor.One;
          target.sourceAlphaBlendFactor = BlendFactor.One;
          target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
        }
        this._blendMode = value;
      }
    }
  ]);
  return ParticleRenderer2;
}(MeshRenderer);
(function() {
  ParticleRenderer._uint16VertexLimit = 65535;
})();
__decorate$2([
  ignoreClone
], ParticleRenderer.prototype, "_onColorChanged", null);
var FRAG_SHADER = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;void main(void){gl_FragColor=texture2D(u_texture,v_uv);}";
var VERT_SHADER = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;uniform mat4 camera_ProjMat;uniform mat4 camera_ViewMat;void main(){gl_Position=camera_ProjMat*camera_ViewMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
Shader.create("trail", VERT_SHADER, FRAG_SHADER);
var TrailMaterial = /* @__PURE__ */ function(Material2) {
  _inherits$2(TrailMaterial2, Material2);
  function TrailMaterial2(engine) {
    var _this;
    _this = Material2.call(this, engine, Shader.find("trail")) || this;
    var target = _this.renderState.blendState.targetBlendState;
    target.enabled = true;
    target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.One;
    _this.renderState.depthState.writeEnabled = false;
    return _this;
  }
  return TrailMaterial2;
}(Material);
var _tempVector3 = new Vector3();
var TrailRenderer = /* @__PURE__ */ function(MeshRenderer2) {
  _inherits$2(TrailRenderer2, MeshRenderer2);
  function TrailRenderer2(entity, props) {
    var _this;
    _this = MeshRenderer2.call(this, entity) || this;
    _this._stroke = props.stroke || 0.2;
    _this._minSeg = props.minSeg || 0.02;
    _this._lifetime = props.lifetime || 1e3;
    _this._maxPointNum = _this._lifetime / 1e3 * entity.engine.targetFrameRate;
    _this._points = [];
    _this._pointStates = [];
    _this._strapPoints = [];
    for (var i = 0; i < _this._maxPointNum; i++) {
      _this._points.push(new Vector3());
      _this._pointStates.push(_this._lifetime);
      _this._strapPoints.push(new Vector3());
      _this._strapPoints.push(new Vector3());
    }
    _this._curPointNum = 0;
    var mtl = props.material || new TrailMaterial(_this.engine);
    _this.setMaterial(mtl);
    _this.setTexture(props.texture);
    _this._initGeometry();
    return _this;
  }
  var _proto = TrailRenderer2.prototype;
  _proto.update = function update(deltaTime) {
    var mov = 0, newIdx = 0;
    for (var i = 0; i < this._curPointNum; i++) {
      this._pointStates[i] -= deltaTime;
      if (this._pointStates[i] < 0) {
        mov++;
      } else if (mov > 0) {
        newIdx = i - mov;
        this._pointStates[newIdx] = this._pointStates[i];
        this._points[newIdx].copyFrom(this._points[i]);
      }
    }
    this._curPointNum -= mov;
    var appendNewPoint = true;
    if (this._curPointNum === this._maxPointNum) {
      appendNewPoint = false;
    } else if (this._curPointNum > 0) {
      var lastPoint = this._points[this._points.length - 1];
      if (Vector3.distance(this.entity.transform.worldPosition, lastPoint) < this._minSeg) {
        appendNewPoint = false;
      }
    }
    if (appendNewPoint) {
      this._pointStates[this._curPointNum] = this._lifetime;
      this._points[this._curPointNum].copyFrom(this.entity.transform.worldPosition);
      this._curPointNum++;
    }
  };
  _proto.setTexture = function setTexture(texture) {
    if (texture) {
      this.getMaterial().shaderData.setTexture("u_texture", texture);
    }
  };
  _proto._render = function _render(context) {
    this._updateStrapVertices(context.camera, this._points);
    this._updateStrapCoords();
    this._vertexBuffer.setData(this._vertices);
    MeshRenderer2.prototype._render.call(this, context);
  };
  _proto._initGeometry = function _initGeometry() {
    var mesh = new BufferMesh(this._entity.engine);
    var vertexStride = 20;
    var vertexCount = this._maxPointNum * 2;
    var vertexFloatCount = vertexCount * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var vertexElements = [
      new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0),
      new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)
    ];
    var vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);
    mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
    mesh.setVertexElements(vertexElements);
    mesh.addSubMesh(0, vertexCount, MeshTopology.TriangleStrip);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride;
    this._vertices = vertices;
    this.mesh = mesh;
  };
  _proto._updateStrapVertices = function _updateStrapVertices(camera, points) {
    var m = camera.viewMatrix;
    var e = m.elements;
    var vx = new Vector3(e[0], e[4], e[8]);
    var vy = new Vector3(e[1], e[5], e[9]);
    var vz = new Vector3(e[2], e[6], e[10]);
    var s = this._stroke;
    vy.scale(s);
    var up = new Vector3();
    var down = new Vector3();
    var rotation = new Quaternion();
    Vector3.transformByQuat(vx, rotation, vx);
    Vector3.transformByQuat(vy, rotation, vy);
    var dy = new Vector3();
    var cross = new Vector3();
    var perpVector = new Vector3();
    vx.normalize();
    var vertices = this._vertices;
    for (var i = 0; i < this._maxPointNum; i++) {
      if (i < this._curPointNum) {
        var p = points[i];
        if (i === this._curPointNum - 1 && i !== 0) {
          Vector3.subtract(p, points[i - 1], perpVector);
        } else {
          Vector3.subtract(points[i + 1], p, perpVector);
        }
        this._projectOnPlane(perpVector, vz, perpVector);
        perpVector.normalize();
        var angle = Math.acos(Vector3.dot(vx, perpVector));
        Vector3.cross(vx, perpVector, cross);
        if (Vector3.dot(cross, vz) <= 0) {
          angle = Math.PI * 2 - angle;
        }
        Quaternion.rotationAxisAngle(vz, angle, rotation);
        Vector3.transformByQuat(vy, rotation, dy);
        Vector3.add(p, dy, up);
        Vector3.subtract(p, dy, down);
      }
      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertices[p0] = up.x;
      vertices[p0 + 1] = up.y;
      vertices[p0 + 2] = up.z;
      vertices[p1] = down.x;
      vertices[p1 + 1] = down.y;
      vertices[p1 + 2] = down.z;
    }
  };
  _proto._updateStrapCoords = function _updateStrapCoords() {
    if (this._prePointsNum === this._curPointNum) {
      return;
    }
    this._prePointsNum = this._curPointNum;
    var count = this._curPointNum;
    var texDelta = 1 / count;
    var vertices = this._vertices;
    for (var i = 0; i < count; i++) {
      var d = 1 - i * texDelta;
      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertices[p0] = 0;
      vertices[p0 + 1] = d;
      vertices[p1] = 1;
      vertices[p1 + 1] = d;
    }
  };
  _proto._projectOnVector = function _projectOnVector(a, p, out) {
    var n_p = p.clone();
    Vector3.normalize(n_p, n_p);
    var cosine = Vector3.dot(a, n_p);
    out.x = n_p.x * cosine;
    out.y = n_p.y * cosine;
    out.z = n_p.z * cosine;
  };
  _proto._projectOnPlane = function _projectOnPlane(a, n, out) {
    this._projectOnVector(a, n, _tempVector3);
    Vector3.subtract(a, _tempVector3, out);
  };
  return TrailRenderer2;
}(MeshRenderer);
var Probe = /* @__PURE__ */ function(Script2) {
  _inherits$2(Probe2, Script2);
  function Probe2() {
    var _this;
    _this = Script2.apply(this, arguments) || this;
    _this.probeLayer = Layer.Everything;
    _this.width = 1024;
    _this.height = 1024;
    _this.antiAliasing = 1;
    _this._isCube = false;
    return _this;
  }
  var _proto = Probe2.prototype;
  _proto.onTextureChange = function onTextureChange(renderColorTexture) {
  };
  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled)
      return;
    this._camera = camera;
    this._oriCameraCullingMask = camera.cullingMask;
    camera.cullingMask = this.probeLayer;
    if (!this._activeRenderTarget || this._activeRenderTarget.width !== this.width || this._activeRenderTarget.height !== this.height || this._activeRenderTarget.antiAliasing !== this.antiAliasing) {
      this._renderTarget = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._renderTargetSwap = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._activeRenderTarget = this._renderTarget;
    }
    this._oriCameraRenderTarget = camera.renderTarget;
    camera.renderTarget = this._activeRenderTarget;
  };
  _proto.onEndRender = function onEndRender(camera) {
    if (!this.enabled)
      return;
    this.onTextureChange && this.onTextureChange(this._texture);
    this._activeRenderTarget = this._activeRenderTarget === this._renderTarget ? this._renderTargetSwap : this._renderTarget;
  };
  _proto._reset = function _reset() {
    if (!this.enabled)
      return;
    this._camera.renderTarget = this._oriCameraRenderTarget;
    this._camera.cullingMask = this._oriCameraCullingMask;
  };
  _create_class$4(Probe2, [
    {
      key: "_texture",
      get: function get3() {
        var _this__activeRenderTarget;
        return (_this__activeRenderTarget = this._activeRenderTarget) == null ? void 0 : _this__activeRenderTarget.getColorTexture();
      }
    }
  ]);
  return Probe2;
}(Script);
var cacheTarget = new Vector3();
var cacheUp = new Vector3();
var cacheDir = new Vector3();
var CubeProbe = /* @__PURE__ */ function(Probe2) {
  _inherits$2(CubeProbe2, Probe2);
  function CubeProbe2() {
    var _this;
    _this = Probe2.apply(this, arguments) || this;
    _this.position = new Vector3(0, 0, 0);
    _this._isCube = true;
    _this.oriViewMatrix = new Matrix();
    return _this;
  }
  var _proto = CubeProbe2.prototype;
  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled)
      return;
    Probe2.prototype.onBeginRender.call(this, camera);
    this._storeCamera(camera);
    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
      this._setCamera(faceIndex, camera);
      camera.render(TextureCubeFace.PositiveX + faceIndex);
    }
    this._restoreCamera(camera);
    Probe2.prototype._reset.call(this);
  };
  _proto._storeCamera = function _storeCamera(camera) {
    this.oriViewMatrix.copyFrom(camera.viewMatrix);
    this._oriFieldOfView = camera.fieldOfView;
  };
  _proto._restoreCamera = function _restoreCamera(camera) {
    camera.viewMatrix.copyFrom(this.oriViewMatrix);
    camera.fieldOfView = this._oriFieldOfView;
  };
  _proto._setCamera = function _setCamera(faceIndex, camera) {
    switch (faceIndex) {
      case 0:
        cacheUp.set(0, -1, 0);
        cacheDir.set(1, 0, 0);
        break;
      case 1:
        cacheUp.set(0, -1, 0);
        cacheDir.set(-1, 0, 0);
        break;
      case 2:
        cacheUp.set(0, 0, 1);
        cacheDir.set(0, 1, 0);
        break;
      case 3:
        cacheUp.set(0, 0, -1);
        cacheDir.set(0, -1, 0);
        break;
      case 4:
        cacheUp.set(0, -1, 0);
        cacheDir.set(0, 0, 1);
        break;
      case 5:
        cacheUp.set(0, -1, 0);
        cacheDir.set(0, 0, -1);
        break;
    }
    Vector3.add(this.position, cacheDir, cacheTarget);
    Matrix.lookAt(this.position, cacheTarget, cacheUp, camera.viewMatrix);
    camera.fieldOfView = 90;
  };
  return CubeProbe2;
}(Probe);
var CoreObjects = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AmbientLight,
  get AnimationArrayCurve() {
    return AnimationArrayCurve;
  },
  get AnimationBoolCurve() {
    return AnimationBoolCurve;
  },
  AnimationClip,
  AnimationClipCurveBinding,
  get AnimationColorCurve() {
    return AnimationColorCurve;
  },
  AnimationCurve,
  AnimationEvent,
  get AnimationFloatArrayCurve() {
    return AnimationFloatArrayCurve;
  },
  get AnimationFloatCurve() {
    return AnimationFloatCurve;
  },
  get AnimationQuaternionCurve() {
    return AnimationQuaternionCurve;
  },
  get AnimationVector2Curve() {
    return AnimationVector2Curve;
  },
  get AnimationVector3Curve() {
    return AnimationVector3Curve;
  },
  get AnimationVector4Curve() {
    return AnimationVector4Curve;
  },
  Animator,
  get AnimatorConditionMode() {
    return AnimatorConditionMode;
  },
  AnimatorController,
  AnimatorControllerLayer,
  get AnimatorCullingMode() {
    return AnimatorCullingMode;
  },
  get AnimatorLayerBlendingMode() {
    return AnimatorLayerBlendingMode;
  },
  AnimatorState,
  AnimatorStateMachine,
  AnimatorStateTransition,
  AssetPromise,
  get AssetType() {
    return AssetType;
  },
  Background,
  get BackgroundMode() {
    return BackgroundMode;
  },
  get BackgroundTextureFillMode() {
    return BackgroundTextureFillMode;
  },
  BaseMaterial,
  Basic2DBatcher,
  BasicRenderPipeline,
  get BlendFactor() {
    return BlendFactor;
  },
  get BlendMode() {
    return BlendMode;
  },
  get BlendOperation() {
    return BlendOperation;
  },
  BlendShape,
  BlendShapeFrame,
  BlendState,
  BlinnPhongMaterial,
  BoolUpdateFlag,
  BoxColliderShape,
  Buffer,
  get BufferBindFlag() {
    return BufferBindFlag;
  },
  BufferMesh,
  get BufferUsage() {
    return BufferUsage;
  },
  BufferUtil,
  get Camera() {
    return Camera;
  },
  get CameraClearFlags() {
    return CameraClearFlags;
  },
  CapsuleColliderShape,
  CharacterController,
  CloneManager,
  get Collider() {
    return Collider;
  },
  ColliderShape,
  get ColliderShapeUpAxis() {
    return ColliderShapeUpAxis;
  },
  get CollisionDetectionMode() {
    return CollisionDetectionMode;
  },
  get ColorSpace() {
    return ColorSpace;
  },
  get ColorWriteMask() {
    return ColorWriteMask;
  },
  get CompareFunction() {
    return CompareFunction;
  },
  Component,
  ContentRestorer,
  get ControllerCollisionFlag() {
    return ControllerCollisionFlag;
  },
  get ControllerNonWalkableMode() {
    return ControllerNonWalkableMode;
  },
  CubeProbe,
  get CullMode() {
    return CullMode;
  },
  get DataType() {
    return DataType;
  },
  get DependentMode() {
    return DependentMode;
  },
  DepthState,
  get DiffuseMode() {
    return DiffuseMode;
  },
  DirectLight,
  DynamicCollider,
  get DynamicColliderConstraints() {
    return DynamicColliderConstraints;
  },
  Engine,
  EngineObject,
  Entity,
  EventDispatcher,
  FixedJoint,
  get FogMode() {
    return FogMode;
  },
  Font,
  get FontStyle() {
    return FontStyle;
  },
  get GLCapabilityType() {
    return GLCapabilityType;
  },
  HingeJoint,
  HitResult,
  IndexBufferBinding,
  get IndexFormat() {
    return IndexFormat;
  },
  InputManager,
  get InterpolationType() {
    return InterpolationType;
  },
  get Joint() {
    return Joint;
  },
  JointLimits,
  JointMotor,
  Keyframe,
  get Keys() {
    return Keys;
  },
  get Layer() {
    return Layer;
  },
  Light,
  Loader,
  Logger,
  Material,
  Mesh,
  MeshRenderer,
  get MeshTopology() {
    return MeshTopology;
  },
  ModelMesh,
  get OverflowMode() {
    return OverflowMode;
  },
  PBRBaseMaterial,
  PBRMaterial,
  PBRSpecularMaterial,
  ParticleRenderer,
  get ParticleRendererBlendMode() {
    return ParticleRendererBlendMode;
  },
  PhysicsManager,
  PhysicsMaterial,
  get PhysicsMaterialCombineMode() {
    return PhysicsMaterialCombineMode;
  },
  get PipelineStage() {
    return PipelineStage;
  },
  PlaneColliderShape,
  get Platform() {
    return Platform;
  },
  PointLight,
  Pointer,
  get PointerButton() {
    return PointerButton;
  },
  get PointerPhase() {
    return PointerPhase;
  },
  PrimitiveMesh,
  Probe,
  RasterState,
  ReferResource,
  get RenderBufferDepthFormat() {
    return RenderBufferDepthFormat;
  },
  get RenderFace() {
    return RenderFace;
  },
  RenderPass,
  RenderQueue,
  get RenderQueueType() {
    return RenderQueueType;
  },
  RenderState,
  RenderTarget,
  RenderTargetBlendState,
  get Renderer() {
    return Renderer;
  },
  ResourceManager,
  Scene: Scene$1,
  SceneManager,
  Script,
  get SetDataOptions() {
    return SetDataOptions;
  },
  Shader,
  ShaderData,
  ShaderFactory,
  ShaderMacro,
  ShaderMacroCollection,
  ShaderPass,
  ShaderProperty,
  get ShaderPropertyType() {
    return ShaderPropertyType;
  },
  ShaderTagKey,
  get ShadowCascadesMode() {
    return ShadowCascadesMode;
  },
  get ShadowResolution() {
    return ShadowResolution;
  },
  get ShadowType() {
    return ShadowType;
  },
  Skin,
  SkinnedMeshRenderer,
  Sky,
  SkyBoxMaterial,
  SkyProceduralMaterial,
  SphereColliderShape,
  SpotLight,
  SpringJoint,
  Sprite,
  SpriteAtlas,
  get SpriteDrawMode() {
    return SpriteDrawMode;
  },
  SpriteMask,
  get SpriteMaskInteraction() {
    return SpriteMaskInteraction;
  },
  get SpriteMaskLayer() {
    return SpriteMaskLayer;
  },
  SpriteRenderer,
  get SpriteTileMode() {
    return SpriteTileMode;
  },
  StateMachineScript,
  StaticCollider,
  get StencilOperation() {
    return StencilOperation;
  },
  StencilState,
  SubMesh,
  SubShader,
  get SunMode() {
    return SunMode;
  },
  SystemInfo,
  get TextHorizontalAlignment() {
    return TextHorizontalAlignment;
  },
  TextRenderer,
  TextUtils,
  get TextVerticalAlignment() {
    return TextVerticalAlignment;
  },
  Texture,
  Texture2D,
  Texture2DArray,
  get TextureCoordinate() {
    return TextureCoordinate;
  },
  TextureCube,
  get TextureCubeFace() {
    return TextureCubeFace;
  },
  get TextureDepthCompareFunction() {
    return TextureDepthCompareFunction;
  },
  get TextureFilterMode() {
    return TextureFilterMode;
  },
  get TextureFormat() {
    return TextureFormat;
  },
  get TextureUsage() {
    return TextureUsage;
  },
  get TextureWrapMode() {
    return TextureWrapMode$1;
  },
  Time,
  TrailMaterial,
  TrailRenderer,
  Transform,
  UnlitMaterial,
  Utils,
  VertexBufferBinding,
  VertexElement,
  get VertexElementFormat() {
    return VertexElementFormat;
  },
  get WrapMode() {
    return WrapMode;
  },
  assignmentClone,
  deepClone,
  dependentComponents,
  ignoreClone,
  request,
  resourceLoader,
  shallowClone
}, Symbol.toStringTag, { value: "Module" }));
var GLCompressedTextureInternalFormat;
(function(GLCompressedTextureInternalFormat2) {
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["R11_EAC"] = 37488] = "R11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RG11_EAC"] = 37490] = "RG11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
})(GLCompressedTextureInternalFormat || (GLCompressedTextureInternalFormat = {}));
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
function _instanceof$1(left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return !!right[Symbol.hasInstance](left);
  } else
    return left instanceof right;
}
var WebCanvas = /* @__PURE__ */ function() {
  function WebCanvas2(webCanvas) {
    this._scale = new Vector2();
    var width = webCanvas.width;
    var height = webCanvas.height;
    this._webCanvas = webCanvas;
    this._width = width;
    this._height = height;
  }
  var _proto = WebCanvas2.prototype;
  _proto.resizeByClientSize = function resizeByClientSize(pixelRatio) {
    if (pixelRatio === void 0)
      pixelRatio = window.devicePixelRatio;
    var webCanvas = this._webCanvas;
    if (typeof OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, OffscreenCanvas)) {
      this.width = webCanvas.clientWidth * pixelRatio;
      this.height = webCanvas.clientHeight * pixelRatio;
    }
  };
  _proto.setScale = function setScale(x, y) {
    this._scale.set(x, y);
    this.scale = this._scale;
  };
  _create_class$3(WebCanvas2, [
    {
      key: "width",
      get: function get3() {
        return this._width;
      },
      set: function set(value) {
        if (this._width !== value) {
          this._webCanvas.width = value;
          this._width = value;
        }
      }
    },
    {
      key: "height",
      get: function get3() {
        return this._height;
      },
      set: function set(value) {
        if (this._height !== value) {
          this._webCanvas.height = value;
          this._height = value;
        }
      }
    },
    {
      key: "scale",
      get: function get3() {
        var webCanvas = this._webCanvas;
        if (typeof OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, OffscreenCanvas)) {
          this._scale.set(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
        }
        return this._scale;
      },
      set: function set(value) {
        var webCanvas = this._webCanvas;
        if (typeof OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, OffscreenCanvas)) {
          webCanvas.style.transformOrigin = "left top";
          webCanvas.style.transform = "scale(" + value.x + ", " + value.y + ")";
        }
      }
    }
  ]);
  return WebCanvas2;
}();
function _set_prototype_of$1(o, p) {
  _set_prototype_of$1 = Object.setPrototypeOf || function setPrototypeOf(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _set_prototype_of$1(o, p);
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _set_prototype_of$1(subClass, superClass);
}
var WebGLEngine = /* @__PURE__ */ function(Engine2) {
  _inherits$1(WebGLEngine2, Engine2);
  function WebGLEngine2() {
    return Engine2.apply(this, arguments);
  }
  WebGLEngine2.create = function create(configuration) {
    var canvas = configuration.canvas;
    var webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
    var webGLGraphicDevice = new WebGLGraphicDevice(configuration.graphicDeviceOptions);
    var engine = new WebGLEngine2(webCanvas, webGLGraphicDevice, configuration);
    return engine._initialize(configuration);
  };
  _create_class$3(WebGLEngine2, [
    {
      key: "canvas",
      get: function get3() {
        return this._canvas;
      }
    }
  ]);
  return WebGLEngine2;
}(Engine);
function _extends$1() {
  _extends$1 = Object.assign || function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        if (Object.prototype.hasOwnProperty.call(source, key))
          target[key] = source[key];
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var GLBuffer = /* @__PURE__ */ function() {
  function GLBuffer2(rhi, type, byteLength, bufferUsage, data) {
    if (bufferUsage === void 0)
      bufferUsage = BufferUsage.Static;
    var gl = rhi.gl;
    var glBuffer = gl.createBuffer();
    var glBufferUsage = this._getGLBufferUsage(gl, bufferUsage);
    var glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
    this._gl = gl;
    this._glBuffer = glBuffer;
    this._glBufferUsage = glBufferUsage;
    this._glBindTarget = glBindTarget;
    this._isWebGL2 = rhi.isWebGL2;
    this.bind();
    if (data) {
      gl.bufferData(glBindTarget, data, glBufferUsage);
    } else {
      gl.bufferData(glBindTarget, byteLength, glBufferUsage);
    }
    gl.bindBuffer(glBindTarget, null);
  }
  var _proto = GLBuffer2.prototype;
  _proto.bind = function bind2() {
    this._gl.bindBuffer(this._glBindTarget, this._glBuffer);
  };
  _proto.setData = function setData(byteLength, data, bufferByteOffset, dataOffset, dataLength, options) {
    var gl = this._gl;
    var glBindTarget = this._glBindTarget;
    this.bind();
    if (options === SetDataOptions.Discard) {
      gl.bufferData(glBindTarget, byteLength, this._glBufferUsage);
    }
    var byteSize = data.BYTES_PER_ELEMENT || 1;
    var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;
    if (dataOffset !== 0 || dataByteLength < data.byteLength) {
      var isArrayBufferView = data.byteOffset !== void 0;
      if (this._isWebGL2 && isArrayBufferView) {
        gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
      } else {
        var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
        gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
      }
    } else {
      gl.bufferSubData(glBindTarget, bufferByteOffset, data);
    }
    gl.bindBuffer(glBindTarget, null);
  };
  _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
    if (this._isWebGL2) {
      var gl = this._gl;
      this.bind();
      gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
    } else {
      throw "Buffer is write-only on WebGL1.0 platforms.";
    }
  };
  _proto.resize = function resize(byteLength) {
    this.bind();
    this._gl.bufferData(this._glBindTarget, byteLength, this._glBufferUsage);
  };
  _proto.destroy = function destroy2() {
    this._gl.deleteBuffer(this._glBuffer);
    this._gl = null;
    this._glBuffer = null;
  };
  _proto._getGLBufferUsage = function _getGLBufferUsage(gl, bufferUsage) {
    switch (bufferUsage) {
      case BufferUsage.Static:
        return gl.STATIC_DRAW;
      case BufferUsage.Dynamic:
        return gl.DYNAMIC_DRAW;
      case BufferUsage.Stream:
        return gl.STREAM_DRAW;
    }
  };
  return GLBuffer2;
}();
var GLCapability = /* @__PURE__ */ function() {
  function GLCapability2(rhi) {
    this._rhi = rhi;
    this.capabilityList = /* @__PURE__ */ new Map();
    this._init();
    this._compatibleAllInterface();
  }
  var _proto = GLCapability2.prototype;
  _proto.canIUse = function canIUse(capabilityType) {
    return this.capabilityList.get(capabilityType);
  };
  _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(internalType) {
    var RGBA_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR, RGBA_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR, SRGB8_ALPHA8_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR, SRGB8_ALPHA8_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR, RGB_ETC1_WEBGL = GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL, R11_EAC = GLCompressedTextureInternalFormat.R11_EAC, SRGB8_ALPHA8_ETC2_EAC = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC, RGB_PVRTC_4BPPV1_IMG = GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG, RGBA_PVRTC_2BPPV1_IMG = GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG, RGB_S3TC_DXT1_EXT = GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT, RGBA_S3TC_DXT5_EXT = GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;
    if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
      return this.canIUse(GLCapabilityType.astc);
    } else if (internalType === RGB_ETC1_WEBGL) {
      return this.canIUse(GLCapabilityType.etc1);
    } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
      return this.canIUse(GLCapabilityType.etc);
    } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
      return this.canIUse(GLCapabilityType.pvrtc);
    } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
      return this.canIUse(GLCapabilityType.s3tc);
    }
    return false;
  };
  _proto._init = function _init() {
    var cap = this.capabilityList;
    var isWebGL2 = this.rhi.isWebGL2;
    var requireExtension = this.rhi.requireExtension.bind(this.rhi);
    var shaderVertexID = GLCapabilityType.shaderVertexID, standardDerivatives = GLCapabilityType.standardDerivatives, shaderTextureLod = GLCapabilityType.shaderTextureLod, elementIndexUint = GLCapabilityType.elementIndexUint, depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, multipleSample = GLCapabilityType.multipleSample, drawBuffers = GLCapabilityType.drawBuffers, astc = GLCapabilityType.astc, astc_webkit = GLCapabilityType.astc_webkit, etc = GLCapabilityType.etc, etc_webkit = GLCapabilityType.etc_webkit, etc1 = GLCapabilityType.etc1, etc1_webkit = GLCapabilityType.etc1_webkit, pvrtc = GLCapabilityType.pvrtc, pvrtc_webkit = GLCapabilityType.pvrtc_webkit, s3tc = GLCapabilityType.s3tc, s3tc_webkit = GLCapabilityType.s3tc_webkit, textureFloat = GLCapabilityType.textureFloat, textureHalfFloat = GLCapabilityType.textureHalfFloat, textureFloatLinear = GLCapabilityType.textureFloatLinear, textureHalfFloatLinear = GLCapabilityType.textureHalfFloatLinear, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat, colorBufferFloat = GLCapabilityType.colorBufferFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic;
    cap.set(shaderVertexID, isWebGL2);
    cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
    cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
    cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
    cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
    cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
    cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
    cap.set(multipleSample, isWebGL2);
    cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
    cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
    cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
    cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
    cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
    cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
    cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
    cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
    cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
    cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
    cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
    cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
    cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
  };
  _proto._compatibleInterface = function _compatibleInterface(capabilityType, flatItem) {
    var rhi = this.rhi;
    var gl = rhi.gl;
    var ext = null;
    if (ext = rhi.requireExtension(capabilityType)) {
      for (var glKey in flatItem) {
        var extensionKey = flatItem[glKey];
        var extensionVal = ext[extensionKey];
        if (extensionVal == null ? void 0 : extensionVal.bind) {
          gl[glKey] = extensionVal.bind(ext);
        } else {
          gl[glKey] = extensionVal;
        }
      }
    }
  };
  _proto._compatibleAllInterface = function _compatibleAllInterface() {
    var depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, drawBuffers = GLCapabilityType.drawBuffers, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic, textureHalfFloat = GLCapabilityType.textureHalfFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat;
    var isWebGL2 = this.rhi.isWebGL2;
    if (!isWebGL2) {
      this._compatibleInterface(depthTexture, {
        UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
      });
      this._compatibleInterface(vertexArrayObject, {
        createVertexArray: "createVertexArrayOES",
        deleteVertexArray: "deleteVertexArrayOES",
        isVertexArray: "isVertexArrayOES",
        bindVertexArray: "bindVertexArrayOES"
      });
      this._compatibleInterface(instancedArrays, {
        drawArraysInstanced: "drawArraysInstancedANGLE",
        drawElementsInstanced: "drawElementsInstancedANGLE",
        vertexAttribDivisor: "vertexAttribDivisorANGLE"
      });
      this._compatibleInterface(drawBuffers, {
        MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
      });
      var items = {};
      if (this.canIUse(GLCapabilityType.drawBuffers)) {
        var maxDrawBuffers = this.maxDrawBuffers;
        for (var i = 0; i < maxDrawBuffers; i++) {
          i != 0 && (items["COLOR_ATTACHMENT" + i] = "COLOR_ATTACHMENT" + i + "_WEBGL");
          items["DRAW_BUFFER" + i] = "DRAW_BUFFER" + i + "_WEBGL";
        }
        this._compatibleInterface(drawBuffers, _extends$1({
          drawBuffers: "drawBuffersWEBGL"
        }, items));
      }
      this._compatibleInterface(textureHalfFloat, {
        HALF_FLOAT: "HALF_FLOAT_OES"
      });
      this._compatibleInterface(colorBufferHalfFloat, {
        RGBA16F: "RBGA16F_EXT"
      });
      this._compatibleInterface(WEBGL_colorBufferFloat, {
        RGBA32F: "RBGA32F_EXT"
      });
    }
    this._compatibleInterface(textureFilterAnisotropic, {
      TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
    });
  };
  _create_class$3(GLCapability2, [
    {
      key: "maxTextureSize",
      get: function get3() {
        return this.rhi.renderStates.getParameter(this.rhi.gl.MAX_TEXTURE_SIZE);
      }
    },
    {
      key: "canUseFloatTextureBlendShape",
      get: function get3() {
        return this.canIUse(GLCapabilityType.shaderVertexID) && this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
      }
    },
    {
      key: "canIUseMoreJoints",
      get: function get3() {
        return this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
      }
    },
    {
      key: "maxDrawBuffers",
      get: function get3() {
        if (!this._maxDrawBuffers) {
          if (this.canIUse(GLCapabilityType.drawBuffers)) {
            this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
          } else {
            this._maxDrawBuffers = 1;
          }
        }
        return this._maxDrawBuffers;
      }
    },
    {
      key: "maxAnisoLevel",
      get: function get3() {
        if (!this._maxAnisoLevel) {
          var ext = this._rhi.requireExtension(GLCapabilityType.textureFilterAnisotropic);
          this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
        }
        return this._maxAnisoLevel;
      }
    },
    {
      key: "maxAntiAliasing",
      get: function get3() {
        if (!this._maxAntiAliasing) {
          var gl = this._rhi.gl;
          var canMSAA = this.canIUse(GLCapabilityType.multipleSample);
          this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
        }
        return this._maxAntiAliasing;
      }
    },
    {
      key: "rhi",
      get: function get3() {
        return this._rhi;
      }
    }
  ]);
  return GLCapability2;
}();
var GLExtensions = /* @__PURE__ */ function() {
  function GLExtensions2(rhi) {
    this.rhi = rhi;
    this._requireResult = {};
  }
  var _proto = GLExtensions2.prototype;
  _proto.requireExtension = function requireExtension(ext) {
    if (this._requireResult[ext] !== void 0) {
      return this._requireResult[ext];
    }
    this._requireResult[ext] = this.rhi.gl.getExtension(ext);
    return this._requireResult[ext];
  };
  return GLExtensions2;
}();
var GLPrimitive = /* @__PURE__ */ function() {
  function GLPrimitive2(rhi, primitive) {
    this._attribLocArray = [];
    this._vaoMap = /* @__PURE__ */ new Map();
    this._primitive = primitive;
    this._canUseInstancedArrays = rhi.canIUse(GLCapabilityType.instancedArrays);
    this._useVao = rhi.canIUse(GLCapabilityType.vertexArrayObject);
    this._gl = rhi.gl;
  }
  var _proto = GLPrimitive2.prototype;
  _proto.draw = function draw(shaderProgram, subMesh) {
    var gl = this._gl;
    var primitive = this._primitive;
    var useVao = this._useVao && primitive._enableVAO;
    if (useVao) {
      if (primitive._bufferStructChanged) {
        this._clearVAO();
      }
      if (!this._vaoMap.has(shaderProgram.id)) {
        this._registerVAO(shaderProgram);
      }
      var vao = this._vaoMap.get(shaderProgram.id);
      gl.bindVertexArray(vao);
    } else {
      this._bindBufferAndAttrib(shaderProgram);
    }
    var _indexBufferBinding = primitive._indexBufferBinding, _instanceCount = primitive._instanceCount, _glIndexType = primitive._glIndexType, _glIndexByteCount = primitive._glIndexByteCount;
    var topology = subMesh.topology, start = subMesh.start, count = subMesh.count;
    if (!_instanceCount) {
      if (_indexBufferBinding) {
        if (useVao) {
          gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
        } else {
          var _glBuffer = _indexBufferBinding.buffer._platformBuffer._glBuffer;
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _glBuffer);
          gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
      } else {
        gl.drawArrays(topology, start, count);
      }
    } else {
      if (this._canUseInstancedArrays) {
        if (_indexBufferBinding) {
          if (useVao) {
            gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
          } else {
            var _glBuffer1 = _indexBufferBinding.buffer._platformBuffer._glBuffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _glBuffer1);
            gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
        } else {
          gl.drawArraysInstanced(topology, start, count, _instanceCount);
        }
      } else {
        Logger.error("ANGLE_instanced_arrays extension is not supported");
      }
    }
    if (useVao) {
      gl.bindVertexArray(null);
    } else {
      this._disableAttrib();
    }
  };
  _proto.destroy = function destroy2() {
    this._useVao && this._clearVAO();
  };
  _proto._bindBufferAndAttrib = function _bindBufferAndAttrib(shaderProgram) {
    var gl = this._gl;
    var primitive = this._primitive;
    var vertexBufferBindings = primitive._vertexBufferBindings;
    this._attribLocArray.length = 0;
    var attributeLocation = shaderProgram.attributeLocation;
    var attributes = primitive._vertexElementMap;
    var vbo;
    var lastBoundVbo;
    for (var name2 in attributeLocation) {
      var loc = attributeLocation[name2];
      if (loc === -1)
        continue;
      var element = attributes[name2];
      if (element) {
        var _vertexBufferBindings_element_bindingIndex = vertexBufferBindings[element.bindingIndex], buffer = _vertexBufferBindings_element_bindingIndex.buffer, stride = _vertexBufferBindings_element_bindingIndex.stride;
        vbo = buffer._platformBuffer._glBuffer;
        if (lastBoundVbo !== vbo) {
          lastBoundVbo = vbo;
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        }
        gl.enableVertexAttribArray(loc);
        var elementInfo = element._glElementInfo;
        gl.vertexAttribPointer(loc, elementInfo.size, elementInfo.type, elementInfo.normalized, stride, element.offset);
        if (this._canUseInstancedArrays) {
          gl.vertexAttribDivisor(loc, element.instanceStepRate);
        }
        this._attribLocArray.push(loc);
      } else {
        Logger.warn("vertex attribute not found: " + name2);
      }
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  };
  _proto._disableAttrib = function _disableAttrib() {
    var gl = this._gl;
    for (var i = 0, l = this._attribLocArray.length; i < l; i++) {
      gl.disableVertexAttribArray(this._attribLocArray[i]);
    }
  };
  _proto._registerVAO = function _registerVAO(shaderProgram) {
    var gl = this._gl;
    var vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    var _indexBufferBinding = this._primitive._indexBufferBinding;
    if (_indexBufferBinding) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBufferBinding.buffer._platformBuffer._glBuffer);
    }
    this._bindBufferAndAttrib(shaderProgram);
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    this._disableAttrib();
    this._vaoMap.set(shaderProgram.id, vao);
  };
  _proto._clearVAO = function _clearVAO() {
    var gl = this._gl;
    this._vaoMap.forEach(function(vao) {
      gl.deleteVertexArray(vao);
    });
    this._vaoMap.clear();
  };
  return GLPrimitive2;
}();
var GLRenderStates = /* @__PURE__ */ function() {
  function GLRenderStates2(gl) {
    this._parameters = {};
    this._gl = gl;
    this._parameters = {};
    this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.MAX_TEXTURE_SIZE] = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    gl.colorMask(true, true, true, true);
    gl.blendColor(0, 0, 0, 0);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.depthMask(true);
    gl.disable(gl.STENCIL_TEST);
    gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 255);
    gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 255);
    gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(255);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.polygonOffset(0, 0);
  }
  var _proto = GLRenderStates2.prototype;
  _proto.getParameter = function getParameter(pname) {
    return this._parameters[pname];
  };
  return GLRenderStates2;
}();
var GLTexture = /* @__PURE__ */ function() {
  function GLTexture2(rhi, texture, target) {
    this._texture = texture;
    this._rhi = rhi;
    this._gl = rhi.gl;
    this._isWebGL2 = rhi.isWebGL2;
    this._target = target;
    this._glTexture = this._gl.createTexture();
  }
  var _proto = GLTexture2.prototype;
  _proto.destroy = function destroy2() {
    this._gl.deleteTexture(this._glTexture);
    this._texture = null;
    this._glTexture = null;
    this._formatDetail = null;
  };
  _proto.setUseDepthCompareMode = function setUseDepthCompareMode(value) {
    var gl = this._gl;
    gl.texParameteri(this._target, gl.TEXTURE_COMPARE_MODE, value ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
  };
  _proto.generateMipmaps = function generateMipmaps() {
    if (this._texture.width !== 1 || this._texture.height !== 1) {
      this._bind();
      this._gl.generateMipmap(this._target);
    }
  };
  _proto._bind = function _bind() {
    this._rhi.bindTexture(this);
  };
  _proto._init = function _init(isCube) {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
    var _this__texture = this._texture, mipmapCount = _this__texture.mipmapCount, width = _this__texture.width, height = _this__texture.height, usage = _this__texture.usage, _isDepthTexture = _this__texture._isDepthTexture;
    this._bind();
    if (isWebGL2 && !(baseFormat === gl.LUMINANCE_ALPHA || baseFormat === gl.ALPHA) && usage !== TextureUsage.Dynamic) {
      gl.texStorage2D(this._target, mipmapCount, internalFormat, width, height);
    } else {
      if (!isCube) {
        if (_isDepthTexture) {
          gl.texImage2D(this._target, 0, internalFormat, width, height, 0, baseFormat, dataType, null);
        } else {
          for (var i = 0; i < mipmapCount; i++) {
            var mipWidth = Math.max(1, width >> i);
            var mipHeight = Math.max(1, height >> i);
            gl.texImage2D(this._target, i, internalFormat, mipWidth, mipHeight, 0, baseFormat, dataType, null);
          }
        }
      } else {
        for (var i1 = 0; i1 < mipmapCount; i1++) {
          var size = Math.max(1, width >> i1);
          for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, i1, internalFormat, size, size, 0, baseFormat, dataType, null);
          }
        }
      }
    }
  };
  _proto._getPixelBuffer = function _getPixelBuffer(face, x, y, width, height, mipLevel, out) {
    var gl = this._gl;
    var _this__formatDetail = this._formatDetail, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
    if (mipLevel > 0 && !this._isWebGL2) {
      mipLevel = 0;
      Logger.error("mipLevel only take effect in WebGL2.0");
    }
    if (face != null) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, mipLevel);
    } else {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, mipLevel);
    }
    gl.readPixels(x, y, width, height, baseFormat, dataType, out);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };
  _proto._setWrapMode = function _setWrapMode(value, pname) {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var target = this._target;
    var _this__texture = this._texture, width = _this__texture.width, height = _this__texture.height;
    if (!isWebGL2 && value !== TextureWrapMode$1.Clamp && (!GLTexture2._isPowerOf2(width) || !GLTexture2._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
      value = TextureWrapMode$1.Clamp;
    }
    switch (value) {
      case TextureWrapMode$1.Clamp:
        gl.texParameteri(target, pname, gl.CLAMP_TO_EDGE);
        break;
      case TextureWrapMode$1.Repeat:
        gl.texParameteri(target, pname, gl.REPEAT);
        break;
      case TextureWrapMode$1.Mirror:
        gl.texParameteri(target, pname, gl.MIRRORED_REPEAT);
        break;
    }
  };
  _proto._getReadFrameBuffer = function _getReadFrameBuffer() {
    var frameBuffer = this._rhi._readFrameBuffer;
    if (!frameBuffer) {
      this._rhi._readFrameBuffer = frameBuffer = this._gl.createFramebuffer();
    }
    return frameBuffer;
  };
  GLTexture2._isPowerOf2 = function _isPowerOf2(v) {
    return (v & v - 1) === 0;
  };
  GLTexture2._getFormatDetail = function _getFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case TextureFormat.R8G8B8:
        return {
          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R8G8B8A8:
        return {
          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R4G4B4A4:
        return {
          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_4_4_4_4,
          isCompressed: false
        };
      case TextureFormat.R5G5B5A1:
        return {
          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_5_5_5_1,
          isCompressed: false
        };
      case TextureFormat.R5G6B5:
        return {
          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_SHORT_5_6_5,
          isCompressed: false
        };
      case TextureFormat.Alpha8:
        return {
          internalFormat: gl.ALPHA,
          baseFormat: gl.ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.LuminanceAlpha:
        return {
          internalFormat: gl.LUMINANCE_ALPHA,
          baseFormat: gl.LUMINANCE_ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R16G16B16A16:
        return {
          internalFormat: isWebGL2 ? gl.RGBA16F : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.HALF_FLOAT,
          isCompressed: false
        };
      case TextureFormat.R32G32B32A32:
        return {
          internalFormat: isWebGL2 ? gl.RGBA32F : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.FLOAT,
          isCompressed: false
        };
      case TextureFormat.DXT1:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
          isCompressed: true
        };
      case TextureFormat.DXT5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
          isCompressed: true
        };
      case TextureFormat.ETC1_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_ETC2,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGBA5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGBA8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGB2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGBA2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGB4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGBA4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.ASTC_4x4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_5x5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_6x6:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_8x8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_10x10:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_12x12:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
          isCompressed: true
        };
      case TextureFormat.Depth:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_SHORT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case TextureFormat.DepthStencil:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH32F_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: isWebGL2 ? gl.FLOAT_32_UNSIGNED_INT_24_8_REV : gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case TextureFormat.Depth16:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_SHORT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case TextureFormat.Depth24Stencil8:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case TextureFormat.Depth24:
        return {
          internalFormat: gl.DEPTH_COMPONENT24,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case TextureFormat.Depth32:
        return {
          internalFormat: gl.DEPTH_COMPONENT32F,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.FLOAT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case TextureFormat.Depth32Stencil8:
        return {
          internalFormat: gl.DEPTH32F_STENCIL8,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      default:
        throw new Error("this TextureFormat is not supported in Galacean Engine: " + format);
    }
  };
  GLTexture2._getRenderBufferDepthFormatDetail = function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case RenderBufferDepthFormat.Depth:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_SHORT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.DepthStencil:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH32F_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: isWebGL2 ? gl.FLOAT_32_UNSIGNED_INT_24_8_REV : gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Stencil:
        return {
          internalFormat: gl.STENCIL_INDEX8,
          baseFormat: gl.STENCIL_ATTACHMENT,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false,
          attachment: gl.STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth16:
        return {
          internalFormat: gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_SHORT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth24Stencil8:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth24:
        return {
          internalFormat: gl.DEPTH_COMPONENT24,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth32:
        return {
          internalFormat: gl.DEPTH_COMPONENT32F,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.FLOAT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth32Stencil8:
        return {
          internalFormat: gl.DEPTH32F_STENCIL8,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      default:
        throw new Error("this TextureFormat is not supported in Galacean Engine: " + format);
    }
  };
  GLTexture2._supportTextureFormat = function _supportTextureFormat(format, rhi) {
    switch (format) {
      case TextureFormat.R16G16B16A16:
        if (!rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
          return false;
        }
        break;
      case TextureFormat.R32G32B32A32:
        if (!rhi.canIUse(GLCapabilityType.textureFloat)) {
          return false;
        }
        break;
      case TextureFormat.Depth16:
      case TextureFormat.Depth24Stencil8:
      case TextureFormat.Depth:
      case TextureFormat.DepthStencil:
        if (!rhi.canIUse(GLCapabilityType.depthTexture)) {
          return false;
        }
        break;
      case TextureFormat.Depth24:
      case TextureFormat.Depth32:
      case TextureFormat.Depth32Stencil8:
        return rhi.isWebGL2;
    }
    return true;
  };
  GLTexture2._supportRenderBufferColorFormat = function _supportRenderBufferColorFormat(format, rhi) {
    var isSupported = true;
    switch (format) {
      case TextureFormat.R16G16B16A16:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
            isSupported = false;
          }
        }
        break;
      case TextureFormat.R32G32B32A32:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferFloat) || !rhi.canIUse(GLCapabilityType.textureFloat)) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  };
  GLTexture2._supportRenderBufferDepthFormat = function _supportRenderBufferDepthFormat(format, rhi) {
    if (!rhi.isWebGL2) {
      switch (format) {
        case RenderBufferDepthFormat.Depth24:
        case RenderBufferDepthFormat.Depth32:
        case RenderBufferDepthFormat.Depth32Stencil8:
          return false;
      }
    }
    return true;
  };
  _create_class$3(GLTexture2, [
    {
      key: "wrapModeU",
      set: function set(value) {
        this._bind();
        this._setWrapMode(value, this._gl.TEXTURE_WRAP_S);
      }
    },
    {
      key: "wrapModeV",
      set: function set(value) {
        this._bind();
        this._setWrapMode(value, this._gl.TEXTURE_WRAP_T);
      }
    },
    {
      key: "filterMode",
      set: function set(value) {
        var gl = this._gl;
        var target = this._target;
        var _mipmap = this._texture._mipmap;
        this._bind();
        switch (value) {
          case TextureFilterMode.Point:
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
            break;
          case TextureFilterMode.Bilinear:
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
            break;
          case TextureFilterMode.Trilinear:
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
            break;
        }
      }
    },
    {
      key: "anisoLevel",
      set: function set(value) {
        var gl = this._gl;
        this._bind();
        gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
      }
    },
    {
      key: "depthCompareFunction",
      set: function set(value) {
        this._bind();
        var gl = this._gl;
        switch (value) {
          case TextureDepthCompareFunction.Never:
            gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.NEVER);
            break;
          case TextureDepthCompareFunction.Less:
            gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.LESS);
            break;
          case TextureDepthCompareFunction.Equal:
            gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.EQUAL);
            break;
          case TextureDepthCompareFunction.LessEqual:
            gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);
            break;
          case TextureDepthCompareFunction.Greater:
            gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.GREATER);
            break;
          case TextureDepthCompareFunction.NotEqual:
            gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.NOTEQUAL);
            break;
          case TextureDepthCompareFunction.GreaterEqual:
            gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.GEQUAL);
            break;
          case TextureDepthCompareFunction.Always:
            gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.ALWAYS);
            break;
        }
      }
    }
  ]);
  return GLTexture2;
}();
var GLRenderTarget = /* @__PURE__ */ function() {
  function GLRenderTarget2(rhi, target) {
    this._MSAAColorRenderBuffers = [];
    this._curMipLevel = 0;
    this._gl = rhi.gl;
    this._isWebGL2 = rhi.isWebGL2;
    this._target = target;
    var _colorTextures = target._colorTextures, _depth = target._depth, width = target.width, height = target.height;
    var isDepthTexture = _instanceof$1(_depth, Texture);
    for (var i = 0, n = _colorTextures.length; i < n; i++) {
      var format = _colorTextures[i]._format;
      if (!GLTexture._supportRenderBufferColorFormat(format, rhi)) {
        throw new Error("TextureFormat is not supported:" + TextureFormat[format] + " in RenderTarget");
      }
    }
    if (!isDepthTexture && !GLTexture._supportRenderBufferDepthFormat(_depth, rhi)) {
      throw new Error("TextureFormat is not supported:" + TextureFormat[_depth] + " in RenderTarget");
    }
    if (_colorTextures.length > 1 && !rhi.canIUse(GLCapabilityType.drawBuffers)) {
      throw new Error("MRT is not supported");
    }
    if (_colorTextures.some(function(v) {
      return v.width !== width || v.height !== height;
    })) {
      throw new Error("ColorTexture's size must as same as RenderTarget");
    }
    if (isDepthTexture && (_depth.width !== width || _depth.height !== height)) {
      throw new Error("DepthTexture's size must as same as RenderTarget");
    }
    if (_colorTextures.length > 1 && _colorTextures.some(function(v) {
      return _instanceof$1(v, TextureCube);
    })) {
      throw new Error("MRT+Cube+[,MSAA] is not supported");
    }
    var maxAntiAliasing = rhi.capability.maxAntiAliasing;
    if (target.antiAliasing > maxAntiAliasing) {
      Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:" + maxAntiAliasing);
      target._antiAliasing = maxAntiAliasing;
    }
    this._frameBuffer = this._gl.createFramebuffer();
    this._bindMainFBO();
    if (target.antiAliasing > 1) {
      this._MSAAFrameBuffer = this._gl.createFramebuffer();
      this._bindMSAAFBO();
    }
  }
  var _proto = GLRenderTarget2.prototype;
  _proto.setRenderTargetInfo = function setRenderTargetInfo(faceIndex, mipLevel) {
    var _this = this, gl = _this._gl, target = _this._target;
    var depthTexture = target.depthTexture;
    var colorTexture = target.getColorTexture(0);
    var mipChanged = mipLevel !== this._curMipLevel;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    if (colorTexture) {
      var isCube = _instanceof$1(colorTexture, TextureCube);
      if (mipChanged || isCube) {
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          isCube ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D,
          colorTexture._platformTexture._glTexture,
          mipLevel
        );
      }
    }
    if (depthTexture) {
      var isCube1 = _instanceof$1(depthTexture, TextureCube);
      if (mipChanged || isCube1) {
        var platformTexture = depthTexture._platformTexture;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, platformTexture._formatDetail.attachment, isCube1 ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D, platformTexture._glTexture, mipLevel);
      }
    } else {
      if (mipChanged) {
        var internalFormat = GLTexture._getRenderBufferDepthFormatDetail(target._depth, gl, this._isWebGL2).internalFormat;
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, target.width >> mipLevel, target.height >> mipLevel);
      }
    }
    this._curMipLevel = mipLevel;
    this._activeRenderTarget();
  };
  _proto.blitRenderTarget = function blitRenderTarget() {
    if (!this._MSAAFrameBuffer)
      return;
    var gl = this._gl;
    var mask = gl.COLOR_BUFFER_BIT | (this._target.depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
    var _this__target = this._target, colorTextureCount = _this__target.colorTextureCount, width = _this__target.width, height = _this__target.height;
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
    for (var textureIndex = 0; textureIndex < colorTextureCount; textureIndex++) {
      var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
      this._blitDrawBuffers[textureIndex] = attachment;
      gl.readBuffer(attachment);
      gl.drawBuffers(this._blitDrawBuffers);
      gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
      this._blitDrawBuffers[textureIndex] = gl.NONE;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };
  _proto.destroy = function destroy2() {
    var gl = this._gl;
    this._frameBuffer && gl.deleteFramebuffer(this._frameBuffer);
    this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
    this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
    this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);
    for (var i = 0; i < this._MSAAColorRenderBuffers.length; i++) {
      gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);
    }
    this._frameBuffer = null;
    this._depthRenderBuffer = null;
    this._MSAAFrameBuffer = null;
    this._MSAAColorRenderBuffers.length = 0;
    this._MSAADepthRenderBuffer = null;
  };
  _proto._activeRenderTarget = function _activeRenderTarget() {
    var gl = this._gl;
    if (this._MSAAFrameBuffer) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    }
  };
  _proto._bindMainFBO = function _bindMainFBO() {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this__target = this._target, _depth = _this__target._depth, colorTextureCount = _this__target.colorTextureCount, width = _this__target.width, height = _this__target.height;
    var drawBuffers = new Array(colorTextureCount);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    for (var i = 0; i < colorTextureCount; i++) {
      var colorTexture = this._target.getColorTexture(i);
      var attachment = gl.COLOR_ATTACHMENT0 + i;
      drawBuffers[i] = attachment;
      if (!_instanceof$1(colorTexture, TextureCube)) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, colorTexture._platformTexture._glTexture, 0);
      }
    }
    if (colorTextureCount > 1) {
      gl.drawBuffers(drawBuffers);
    }
    this._oriDrawBuffers = drawBuffers;
    if (_depth !== null) {
      if (_instanceof$1(_depth, Texture) && !_instanceof$1(_depth, TextureCube)) {
        var platformTexture = _depth._platformTexture;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, platformTexture._formatDetail.attachment, gl.TEXTURE_2D, platformTexture._glTexture, 0);
      } else if (this._target.antiAliasing <= 1) {
        var _GLTexture__getRenderBufferDepthFormatDetail = GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _GLTexture__getRenderBufferDepthFormatDetail.internalFormat, attachment1 = _GLTexture__getRenderBufferDepthFormatDetail.attachment;
        var depthRenderBuffer = gl.createRenderbuffer();
        this._depthRenderBuffer = depthRenderBuffer;
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment1, gl.RENDERBUFFER, depthRenderBuffer);
      }
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  };
  _proto._bindMSAAFBO = function _bindMSAAFBO() {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var MSAADepthRenderBuffer = gl.createRenderbuffer();
    var _this__target = this._target, _depth = _this__target._depth, colorTextureCount = _this__target.colorTextureCount, antiAliasing = _this__target.antiAliasing, width = _this__target.width, height = _this__target.height;
    this._blitDrawBuffers = new Array(colorTextureCount);
    this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
    for (var i = 0; i < colorTextureCount; i++) {
      var MSAAColorRenderBuffer = gl.createRenderbuffer();
      this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
      this._blitDrawBuffers[i] = gl.NONE;
      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, this._target.getColorTexture(i)._platformTexture._formatDetail.internalFormat, width, height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
    }
    gl.drawBuffers(this._oriDrawBuffers);
    if (_depth !== null) {
      var _ref = _instanceof$1(_depth, Texture) ? _depth._platformTexture._formatDetail : GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _ref.internalFormat, attachment = _ref.attachment;
      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, internalFormat, width, height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
    }
    this._checkFrameBuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  };
  _proto._checkFrameBuffer = function _checkFrameBuffer() {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    switch (e) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        throw new Error("There is no attachment");
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        throw new Error(" Height and width of the attachment are not the same.");
      case gl.FRAMEBUFFER_UNSUPPORTED:
        throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
    }
    if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
      throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
    }
  };
  return GLRenderTarget2;
}();
var GLTexture2D = /* @__PURE__ */ function(GLTexture1) {
  _inherits$1(GLTexture2D2, GLTexture1);
  function GLTexture2D2(rhi, texture2D) {
    var _this;
    _this = GLTexture1.call(this, rhi, texture2D, rhi.gl.TEXTURE_2D) || this;
    _this._compressedMipFilled = 0;
    var format = texture2D.format, _mipmap = texture2D._mipmap, width = texture2D.width, height = texture2D.height;
    var isWebGL2 = _this._isWebGL2;
    if (!GLTexture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:" + TextureFormat[format]);
    }
    if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      texture2D._mipmap = false;
      texture2D._mipmapCount = texture2D._getMipmapCount();
    }
    _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
    _this._formatDetail.isCompressed && !isWebGL2 || _this._init(false);
    return _this;
  }
  var _proto = GLTexture2D2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0)
      mipLevel = 0;
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType, isCompressed = _this__formatDetail.isCompressed;
    var mipWidth = Math.max(1, this._texture.width >> mipLevel);
    var mipHeight = Math.max(1, this._texture.height >> mipLevel);
    width = width || mipWidth - x;
    height = height || mipHeight - y;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isCompressed) {
      var mipBit = 1 << mipLevel;
      if (isWebGL2 || this._compressedMipFilled & mipBit) {
        gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedMipFilled |= mipBit;
      }
    } else {
      gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
  };
  _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    var gl = this._gl;
    var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    if (this._texture.usage === TextureUsage.Dynamic) {
      gl.texImage2D(this._target, mipLevel, internalFormat, baseFormat, dataType, imageSource);
    } else {
      gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    }
  };
  _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, mipLevel, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }
    GLTexture1.prototype._getPixelBuffer.call(this, null, x, y, width, height, mipLevel, out);
  };
  return GLTexture2D2;
}(GLTexture);
var GLTexture2DArray = /* @__PURE__ */ function(GLTexture1) {
  _inherits$1(GLTexture2DArray2, GLTexture1);
  function GLTexture2DArray2(rhi, texture2DArray) {
    var _this;
    _this = GLTexture1.call(this, rhi, texture2DArray, rhi.gl.TEXTURE_2D_ARRAY) || this;
    var format = texture2DArray.format, width = texture2DArray.width, height = texture2DArray.height, length2 = texture2DArray.length, mipmapCount = texture2DArray.mipmapCount;
    if (!_this._isWebGL2) {
      throw new Error("Texture2D Array is not supported in WebGL1.0");
    }
    if (!GLTexture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:" + TextureFormat[format]);
    }
    _this._bind();
    _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, true);
    _this._gl.texStorage3D(_this._target, mipmapCount, _this._formatDetail.internalFormat, width, height, length2);
    return _this;
  }
  var _proto = GLTexture2DArray2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length2) {
    var _this = this, target = _this._target, gl = _this._gl;
    var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType, isCompressed = _this__formatDetail.isCompressed;
    width = width || Math.max(1, this._texture.width >> mipLevel) - x;
    height = height || Math.max(1, this._texture.height >> mipLevel) - y;
    length2 = length2 || this._texture.length;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isCompressed) {
      gl.compressedTexSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length2, internalFormat, colorBuffer);
    } else {
      gl.texSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length2, baseFormat, dataType, colorBuffer);
    }
  };
  _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    var gl = this._gl;
    var _this__formatDetail = this._formatDetail, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage3D(this._target, mipLevel, x, y, elementIndex, imageSource.width, imageSource.height, 1, baseFormat, dataType, imageSource);
  };
  _proto.getPixelBuffer = function getPixelBuffer(elementIndex, x, y, width, height, mipLevel, out) {
    var _this = this, gl = _this._gl, formatDetail = _this._formatDetail;
    if (formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
    gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this._glTexture, mipLevel, elementIndex);
    gl.readPixels(x, y, width, height, formatDetail.baseFormat, formatDetail.dataType, out);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };
  return GLTexture2DArray2;
}(GLTexture);
var GLTextureCube = /* @__PURE__ */ function(GLTexture1) {
  _inherits$1(GLTextureCube2, GLTexture1);
  function GLTextureCube2(rhi, textureCube) {
    var _this;
    _this = GLTexture1.call(this, rhi, textureCube, rhi.gl.TEXTURE_CUBE_MAP) || this;
    _this._compressedFaceFilled = [
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var format = textureCube.format, _mipmap = textureCube._mipmap, size = textureCube.width;
    var isWebGL2 = _this._isWebGL2;
    if (!GLTexture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:" + TextureFormat[format]);
    }
    if (_mipmap && !isWebGL2 && !GLTexture._isPowerOf2(size)) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      textureCube._mipmap = false;
      textureCube._mipmapCount = textureCube._getMipmapCount();
    }
    _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
    _this._formatDetail.isCompressed && !isWebGL2 || _this._init(true);
    return _this;
  }
  var _proto = GLTextureCube2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
    var gl = this._gl;
    var isWebGL2 = this._isWebGL2;
    var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType, isCompressed = _this__formatDetail.isCompressed;
    var mipSize = Math.max(1, this._texture.width >> mipLevel);
    width = width || mipSize - x;
    height = height || mipSize - y;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isCompressed) {
      var mipBit = 1 << mipLevel;
      if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
        gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedFaceFilled[face] |= mipBit;
      }
    } else {
      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
  };
  _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    var gl = this._gl;
    var _this__formatDetail = this._formatDetail, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
  };
  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, mipLevel, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }
    GLTexture1.prototype._getPixelBuffer.call(this, face, x, y, width, height, mipLevel, out);
  };
  return GLTextureCube2;
}(GLTexture);
var WebGLMode;
(function(WebGLMode2) {
  WebGLMode2[WebGLMode2["Auto"] = 0] = "Auto";
  WebGLMode2[WebGLMode2["WebGL2"] = 1] = "WebGL2";
  WebGLMode2[WebGLMode2["WebGL1"] = 2] = "WebGL1";
})(WebGLMode || (WebGLMode = {}));
var WebGLGraphicDevice = /* @__PURE__ */ function() {
  function WebGLGraphicDevice2(initializeOptions) {
    if (initializeOptions === void 0)
      initializeOptions = {};
    this._readFrameBuffer = null;
    this._enableGlobalDepthBias = false;
    this._activeTextures = new Array(32);
    this._lastViewport = new Vector4(null, null, null, null);
    this._lastScissor = new Vector4(null, null, null, null);
    this._lastClearColor = new Color$1(null, null, null, null);
    this._scissorEnable = false;
    var options = _extends$1({
      webGLMode: 0,
      stencil: true,
      _forceFlush: false,
      _maxAllowSkinUniformVectorCount: 256
    }, initializeOptions);
    if (SystemInfo.platform === Platform.IPhone || SystemInfo.platform === Platform.IPad) {
      var version2 = SystemInfo.operatingSystem.match(/(\d+).?(\d+)?.?(\d+)?/);
      if (version2) {
        var majorVersion = parseInt(version2[1]);
        var minorVersion = parseInt(version2[2]);
        if (majorVersion === 15 && minorVersion >= 0 && minorVersion <= 4) {
          options._forceFlush = true;
        }
      }
    }
    this._options = options;
    this._onWebGLContextLost = this._onWebGLContextLost.bind(this);
    this._onWebGLContextRestored = this._onWebGLContextRestored.bind(this);
  }
  var _proto = WebGLGraphicDevice2.prototype;
  _proto.init = function init(canvas, onDeviceLost, onDeviceRestored) {
    var options = this._options;
    var webCanvas = canvas._webCanvas;
    var webGLMode = options.webGLMode;
    this._onDeviceLost = onDeviceLost;
    this._onDeviceRestored = onDeviceRestored;
    webCanvas.addEventListener("webglcontextlost", this._onWebGLContextLost, false);
    webCanvas.addEventListener("webglcontextrestored", this._onWebGLContextRestored, false);
    webCanvas.addEventListener("webglcontextcreationerror", this._onContextCreationError, false);
    this._webCanvas = webCanvas;
    var gl;
    if (webGLMode == 0 || webGLMode == 1) {
      gl = webCanvas.getContext("webgl2", options);
      if (!gl && (typeof OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, OffscreenCanvas))) {
        gl = webCanvas.getContext("experimental-webgl2", options);
      }
      this._isWebGL2 = true;
      if (gl && !gl.deleteQuery) {
        this._isWebGL2 = false;
      }
    }
    if (!gl) {
      if (webGLMode == 0 || webGLMode == 2) {
        gl = webCanvas.getContext("webgl", options);
        if (!gl && (typeof OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, OffscreenCanvas))) {
          gl = webCanvas.getContext("experimental-webgl", options);
        }
        this._isWebGL2 = false;
      }
    }
    if (!gl) {
      throw new Error("Get GL Context FAILED.");
    }
    this._gl = gl;
    this._initGLState(gl);
  };
  _proto.createPlatformPrimitive = function createPlatformPrimitive(primitive) {
    return new GLPrimitive(this, primitive);
  };
  _proto.createPlatformTexture2D = function createPlatformTexture2D(texture2D) {
    return new GLTexture2D(this, texture2D);
  };
  _proto.createPlatformTexture2DArray = function createPlatformTexture2DArray(texture2D) {
    return new GLTexture2DArray(this, texture2D);
  };
  _proto.createPlatformTextureCube = function createPlatformTextureCube(textureCube) {
    return new GLTextureCube(this, textureCube);
  };
  _proto.createPlatformRenderTarget = function createPlatformRenderTarget(target) {
    return new GLRenderTarget(this, target);
  };
  _proto.createPlatformBuffer = function createPlatformBuffer(type, byteLength, bufferUsage, data) {
    if (bufferUsage === void 0)
      bufferUsage = BufferUsage.Static;
    return new GLBuffer(this, type, byteLength, bufferUsage, data);
  };
  _proto.requireExtension = function requireExtension(ext) {
    return this._extensions.requireExtension(ext);
  };
  _proto.canIUse = function canIUse(capabilityType) {
    return this.capability.canIUse(capabilityType);
  };
  _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(type) {
    return this.capability.canIUseCompressedTextureInternalFormat(type);
  };
  _proto.viewport = function viewport(x, y, width, height) {
    var _this = this, gl = _this._gl, lastViewport = _this._lastViewport;
    if (x !== lastViewport.x || y !== lastViewport.y || width !== lastViewport.z || height !== lastViewport.w) {
      gl.viewport(x, y, width, height);
      lastViewport.set(x, y, width, height);
    }
  };
  _proto.scissor = function scissor(x, y, width, height) {
    var _this = this, gl = _this._gl, lastScissor = _this._lastScissor;
    if (x !== lastScissor.x || y !== lastScissor.y || width !== lastScissor.z || height !== lastScissor.w) {
      var _this1 = this, webCanvas = _this1._webCanvas;
      if (x === 0 && y === 0 && width === webCanvas.width && height === webCanvas.height) {
        if (this._scissorEnable) {
          gl.disable(gl.SCISSOR_TEST);
          this._scissorEnable = false;
        }
      } else {
        if (!this._scissorEnable) {
          gl.enable(gl.SCISSOR_TEST);
          this._scissorEnable = true;
        }
        gl.scissor(x, y, width, height);
      }
      lastScissor.set(x, y, width, height);
    }
  };
  _proto.colorMask = function colorMask(r, g, b, a) {
    this._gl.colorMask(r, g, b, a);
  };
  _proto.clearRenderTarget = function clearRenderTarget(engine, clearFlags, clearColor) {
    var gl = this._gl;
    var _engine__lastRenderState = engine._lastRenderState, targetBlendState = _engine__lastRenderState.blendState.targetBlendState, depthState = _engine__lastRenderState.depthState, stencilState = _engine__lastRenderState.stencilState;
    var clearFlag = 0;
    if (clearFlags & CameraClearFlags.Color) {
      clearFlag |= gl.COLOR_BUFFER_BIT;
      var lc = this._lastClearColor;
      var r = clearColor.r, g = clearColor.g, b = clearColor.b, a = clearColor.a;
      if (clearColor && (r !== lc.r || g !== lc.g || b !== lc.b || a !== lc.a)) {
        gl.clearColor(r, g, b, a);
        lc.set(r, g, b, a);
      }
      if (targetBlendState.colorWriteMask !== ColorWriteMask.All) {
        gl.colorMask(true, true, true, true);
        targetBlendState.colorWriteMask = ColorWriteMask.All;
      }
    }
    if (clearFlags & CameraClearFlags.Depth) {
      clearFlag |= gl.DEPTH_BUFFER_BIT;
      if (depthState.writeEnabled !== true) {
        gl.depthMask(true);
        depthState.writeEnabled = true;
      }
    }
    if (clearFlags & CameraClearFlags.Stencil) {
      clearFlag |= gl.STENCIL_BUFFER_BIT;
      if (stencilState.writeMask !== 255) {
        gl.stencilMask(255);
        stencilState.writeMask = 255;
      }
    }
    gl.clear(clearFlag);
  };
  _proto.drawPrimitive = function drawPrimitive(primitive, subPrimitive, shaderProgram) {
    if (primitive) {
      primitive._draw(shaderProgram, subPrimitive);
    } else {
      Logger.error("draw primitive failed.");
    }
  };
  _proto.activeRenderTarget = function activeRenderTarget(renderTarget, viewport, mipLevel) {
    var gl = this._gl;
    var bufferWidth, bufferHeight;
    if (renderTarget) {
      var _renderTarget__platformRenderTarget;
      (_renderTarget__platformRenderTarget = renderTarget._platformRenderTarget) == null ? void 0 : _renderTarget__platformRenderTarget._activeRenderTarget();
      bufferWidth = renderTarget.width >> mipLevel;
      bufferHeight = renderTarget.height >> mipLevel;
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      bufferWidth = gl.drawingBufferWidth;
      bufferHeight = gl.drawingBufferHeight;
    }
    var width = bufferWidth * viewport.z;
    var height = bufferHeight * viewport.w;
    var x = viewport.x * bufferWidth;
    var y = bufferHeight - viewport.y * bufferHeight - height;
    this.viewport(x, y, width, height);
    this.scissor(x, y, width, height);
  };
  _proto.activeTexture = function activeTexture(textureID) {
    if (this._activeTextureID !== textureID) {
      this._gl.activeTexture(textureID);
      this._activeTextureID = textureID;
    }
  };
  _proto.bindTexture = function bindTexture(texture) {
    var index = this._activeTextureID - this._gl.TEXTURE0;
    if (this._activeTextures[index] !== texture) {
      this._gl.bindTexture(texture._target, texture._glTexture);
      this._activeTextures[index] = texture;
    }
  };
  _proto.setGlobalDepthBias = function setGlobalDepthBias(bias, slopeBias) {
    var gl = this._gl;
    var enable2 = bias !== 0 || slopeBias !== 0;
    if (enable2) {
      gl.enable(gl.POLYGON_OFFSET_FILL);
      gl.polygonOffset(slopeBias, bias);
    } else {
      gl.disable(gl.POLYGON_OFFSET_FILL);
    }
    this._enableGlobalDepthBias = enable2;
  };
  _proto.flush = function flush() {
    this._gl.flush();
  };
  _proto.forceLoseDevice = function forceLoseDevice() {
    var extension = this.requireExtension(GLCapabilityType.WEBGL_lose_context);
    extension.loseContext();
  };
  _proto.forceRestoreDevice = function forceRestoreDevice() {
    var extension = this.requireExtension(GLCapabilityType.WEBGL_lose_context);
    extension.restoreContext();
  };
  _proto.resetState = function resetState() {
    this._readFrameBuffer = null;
    this._enableGlobalDepthBias = false;
    this._currentBindShaderProgram = null;
    var activeTextures = this._activeTextures;
    for (var i = 0, n = activeTextures.length; i < n; i++) {
      activeTextures[i] = null;
    }
    this._lastViewport.set(null, null, null, null);
    this._lastScissor.set(null, null, null, null);
    this._lastClearColor.set(null, null, null, null);
    this._scissorEnable = false;
    this._initGLState(this._gl);
  };
  _proto._initGLState = function _initGLState(gl) {
    this._activeTextureID = gl.TEXTURE0;
    this._renderStates = new GLRenderStates(gl);
    this._extensions = new GLExtensions(this);
    this._capability = new GLCapability(this);
    gl.activeTexture(gl.TEXTURE0);
    var debugRenderInfo = gl.getExtension("WEBGL_debug_renderer_info");
    if (debugRenderInfo != null) {
      this._renderer = gl.getParameter(debugRenderInfo.UNMASKED_RENDERER_WEBGL);
    }
  };
  _proto.destroy = function destroy2() {
    var webCanvas = this._webCanvas;
    webCanvas.removeEventListener("webglcontextcreationerror", this._onContextCreationError, false);
    webCanvas.removeEventListener("webglcontextlost", this._onWebGLContextLost, false);
    webCanvas.removeEventListener("webglcontextrestored", this._onWebGLContextRestored, false);
  };
  _proto._onContextCreationError = function _onContextCreationError(event) {
    console.error("WebGLRenderer: WebGL context could not be created. Reason: ", event.statusMessage);
  };
  _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
    event.preventDefault();
    this._onDeviceLost();
  };
  _proto._onWebGLContextRestored = function _onWebGLContextRestored(event) {
    this._onDeviceRestored();
  };
  _create_class$3(WebGLGraphicDevice2, [
    {
      key: "isWebGL2",
      get: function get3() {
        return this._isWebGL2;
      }
    },
    {
      key: "renderer",
      get: function get3() {
        return this._renderer;
      }
    },
    {
      key: "gl",
      get: function get3() {
        return this._gl;
      }
    },
    {
      key: "renderStates",
      get: function get3() {
        return this._renderStates;
      }
    },
    {
      key: "capability",
      get: function get3() {
        return this._capability;
      }
    },
    {
      key: "canIUseMoreJoints",
      get: function get3() {
        return this.capability.canIUseMoreJoints;
      }
    }
  ]);
  return WebGLGraphicDevice2;
}();
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
var DRACOWorker = /* @__PURE__ */ function() {
  function DRACOWorker2(workerSourceURL, decoderWASMBinary) {
    var _this = this;
    this._costs = {};
    this._currentLoad = 0;
    this._callbacks = {};
    this._worker = new Worker(workerSourceURL);
    this._worker.onmessage = function(e) {
      var message = e.data;
      switch (message.type) {
        case "decode":
          _this._callbacks[message.id].resolve(message.geometry);
          break;
        case "error":
          _this._callbacks[message.id].reject(message);
          break;
        default:
          Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
      }
    };
    if (decoderWASMBinary) {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {
          wasmBinary: decoderWASMBinary
        }
      });
    } else {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {}
      });
    }
  }
  var _proto = DRACOWorker2.prototype;
  _proto.setCosts = function setCosts(taskId, cost) {
    this._costs[taskId] = cost;
  };
  _proto.addCurrentLoad = function addCurrentLoad(cost) {
    this._currentLoad += cost;
  };
  _proto.setCallback = function setCallback(taskId, resolve, reject) {
    this._callbacks[taskId] = {
      resolve,
      reject
    };
  };
  _proto.decode = function decode2(taskId, taskConfig, buffer) {
    this._worker.postMessage({
      type: "decode",
      id: taskId,
      taskConfig,
      buffer
    }, [
      buffer
    ]);
  };
  _proto.releaseTask = function releaseTask(taskId) {
    this._currentLoad -= this._costs[taskId];
    delete this._callbacks[taskId];
    delete this._costs[taskId];
  };
  _create_class$2(DRACOWorker2, [
    {
      key: "currentLoad",
      get: function get3() {
        return this._currentLoad;
      }
    }
  ]);
  return DRACOWorker2;
}();
var workerString = 'let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case "init":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case "decode":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: "decode", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: "error", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error("DRACODecoder worker: Unexpected geometry type.");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error("DRACODecoder worker: Decoding failed: " + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error("DRACODecoder: Unexpected index type.");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error("DRACODecoder: Unexpected attribute type.");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n';
var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
var JS_FILE = "draco_decoder_gltf.js";
var WASM_FILE = "draco_decoder_gltf.r3bin";
var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";
var DRACODecoder = /* @__PURE__ */ function() {
  function DRACODecoder2(config) {
    if (config === void 0)
      config = {
        type: "wasm",
        workerLimit: 4
      };
    this.pool = [];
    this.workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);
    this.currentTaskId = 1;
    this.taskCache = /* @__PURE__ */ new WeakMap();
    if (config.workerLimit > this.workerLimit) {
      Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
    } else {
      var _config_workerLimit;
      this.workerLimit = (_config_workerLimit = config.workerLimit) != null ? _config_workerLimit : 4;
    }
    this.useJS = typeof WebAssembly !== "object" || config.type === "js";
    this.loadLibPromise = this.preloadLib();
  }
  var _proto = DRACODecoder2.prototype;
  _proto.preloadLib = function preloadLib() {
    var _this = this;
    if (this.loadLibPromise) {
      return this.loadLibPromise;
    }
    return new Promise(function(resolve, reject) {
      if (_this.useJS) {
        request("" + LIB_PATH + JS_FILE, {
          type: "text"
        }).then(function(jsSource) {
          var body = [
            jsSource,
            workerString
          ].join("\n");
          var workerSourceURL = URL.createObjectURL(new Blob([
            body
          ]));
          resolve({
            workerSourceURL,
            decoderWASMBinary: null
          });
        }).catch(function(reason) {
          reject(reason);
        });
      } else {
        Promise.all([
          request("" + LIB_PATH + WASM_WRAPPER_FILE, {
            type: "text"
          }),
          request("" + LIB_PATH + WASM_FILE, {
            type: "arraybuffer"
          })
        ]).then(function(resources) {
          var wrapperSource = resources[0], decoderWASMBinary = resources[1];
          var body = [
            wrapperSource,
            workerString
          ].join("\n");
          var workerSourceURL = URL.createObjectURL(new Blob([
            body
          ]));
          resolve({
            workerSourceURL,
            decoderWASMBinary
          });
        }).catch(function(reason) {
          reject(reason);
        });
      }
    });
  };
  _proto.getWorker = function getWorker() {
    var _this = this;
    return this.preloadLib().then(function(worderResources) {
      if (_this.pool.length < _this.workerLimit) {
        var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);
        _this.pool.push(dracoWorker);
      } else {
        _this.pool.sort(function(a, b) {
          return a.currentLoad > b.currentLoad ? -1 : 1;
        });
      }
      return _this.pool[_this.pool.length - 1];
    });
  };
  _proto.decode = function decode2(buffer, taskConfig) {
    var _this = this;
    var taskKey = JSON.stringify(taskConfig);
    if (this.taskCache.has(buffer)) {
      var cachedTask = this.taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error("DRACODecoder: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
    }
    var taskId = this.currentTaskId++;
    var cost = buffer.byteLength;
    var taskWorker;
    var task = new Promise(function(resolve, reject) {
      _this.getWorker().then(function(worker) {
        taskWorker = worker;
        worker.setCosts(taskId, cost);
        worker.addCurrentLoad(cost);
        worker.setCallback(taskId, resolve, reject);
        worker.decode(taskId, taskConfig, buffer);
      }).catch(function(e) {
        reject(e);
      });
    });
    task.finally(function() {
      if (taskWorker && taskId) {
        taskWorker.releaseTask(taskId);
      }
    });
    this.taskCache.set(buffer, {
      key: taskKey,
      promise: task
    });
    return task;
  };
  return DRACODecoder2;
}();
function _extends() {
  _extends = Object.assign || function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        if (Object.prototype.hasOwnProperty.call(source, key))
          target[key] = source[key];
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _set_prototype_of(o, p) {
  _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _set_prototype_of(o, p);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _set_prototype_of(subClass, superClass);
}
function __decorate$1(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var AnimatorControllerLoader = /* @__PURE__ */ function(Loader1) {
  _inherits(AnimatorControllerLoader2, Loader1);
  function AnimatorControllerLoader2() {
    return Loader1.apply(this, arguments);
  }
  var _proto = AnimatorControllerLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _extends({}, item, {
        type: "json"
      })).then(function(data) {
        var animatorController = new AnimatorController();
        var layers = data.layers;
        var promises = [];
        layers.forEach(function(layerData, layerIndex) {
          var name2 = layerData.name, blendingMode = layerData.blendingMode, weight = layerData.weight, stateMachineData = layerData.stateMachine;
          var layer = new AnimatorControllerLayer(name2);
          layer.blendingMode = blendingMode;
          layer.weight = weight;
          if (stateMachineData) {
            var states = stateMachineData.states;
            var stateMachine = layer.stateMachine = new AnimatorStateMachine();
            states.forEach(function(stateData, stateIndex) {
              var name3 = stateData.name, speed = stateData.speed, wrapMode = stateData.wrapMode, clipStartNormalizedTime = stateData.clipStartNormalizedTime, clipEndNormalizedTime = stateData.clipEndNormalizedTime, isDefaultState = stateData.isDefaultState, clipData = stateData.clip, scripts = stateData.scripts;
              var state = stateMachine.addState(name3);
              isDefaultState && (stateMachine.defaultState = state);
              state.speed = speed;
              state.wrapMode = wrapMode;
              state.clipStartTime = clipStartNormalizedTime;
              state.clipEndTime = clipEndNormalizedTime;
              var scriptsObject = JSON.parse(scripts);
              scriptsObject == null ? void 0 : scriptsObject.forEach(function(script) {
                state.addStateMachineScript(Loader.getClass(script));
              });
              if (clipData) {
                promises.push(new Promise(function(resolve2) {
                  resourceManager.getResourceByRef(clipData).then(function(clip) {
                    resolve2({
                      layerIndex,
                      stateIndex,
                      clip
                    });
                  });
                }));
              }
            });
            states.forEach(function(stateData) {
              var name3 = stateData.name, transitions = stateData.transitions;
              transitions.forEach(function(transitionData) {
                var targetStateName = transitionData.targetStateName, duration = transitionData.duration, offset = transitionData.offset, exitTime = transitionData.exitTime;
                var sourceState = stateMachine.findStateByName(name3);
                var destState = stateMachine.findStateByName(targetStateName);
                var transition = new AnimatorStateTransition();
                transition.destinationState = destState;
                transition.duration = duration;
                transition.exitTime = exitTime;
                transition.offset = offset;
                sourceState.addTransition(transition);
              });
            });
          }
          animatorController.addLayer(layer);
        });
        Promise.all(promises).then(function(clipData) {
          clipData.forEach(function(data2) {
            var layerIndex = data2.layerIndex, stateIndex = data2.stateIndex, clip = data2.clip;
            animatorController.layers[layerIndex].stateMachine.states[stateIndex].clip = clip;
          });
          resolve(animatorController);
        });
      }).catch(reject);
    });
  };
  return AnimatorControllerLoader2;
}(Loader);
AnimatorControllerLoader = __decorate$1([
  resourceLoader(AssetType.AnimatorController, [
    "json"
  ], false)
], AnimatorControllerLoader);
function isBase64(url) {
  return /^data:(.+?);base64,/.test(url);
}
var BufferLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(BufferLoader2, Loader2);
  function BufferLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = BufferLoader2.prototype;
  _proto.load = function load2(item) {
    var url = item.url;
    if (isBase64(url)) {
      return new AssetPromise(function(resolve) {
        var base64Str = url.slice(13 + RegExp.$1.length);
        var result2 = Uint8Array.from(atob(base64Str), function(c) {
          return c.charCodeAt(0);
        });
        resolve(result2.buffer);
      });
    }
    return this.request(url, _extends({}, item, {
      type: "arraybuffer"
    }));
  };
  return BufferLoader2;
}(Loader);
BufferLoader = __decorate$1([
  resourceLoader(AssetType.Buffer, [
    "bin",
    "r3bin"
  ], false)
], BufferLoader);
var EnvLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(EnvLoader2, Loader2);
  function EnvLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = EnvLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, {
        type: "arraybuffer"
      }).then(function(arraybuffer) {
        var _ref;
        var shArray = new Float32Array(arraybuffer, 0, 27);
        var shByteLength = 27 * 4;
        var size = (_ref = new Uint16Array(arraybuffer, shByteLength, 1)) == null ? void 0 : _ref[0];
        var engine = resourceManager.engine;
        var texture = new TextureCube(engine, size);
        texture.filterMode = TextureFilterMode.Trilinear;
        var mipmapCount = texture.mipmapCount;
        var offset = shByteLength + 2;
        for (var mipLevel = 0; mipLevel < mipmapCount; mipLevel++) {
          var mipSize = size >> mipLevel;
          for (var face = 0; face < 6; face++) {
            var dataSize = mipSize * mipSize * 4;
            var data = new Uint8Array(arraybuffer, offset, dataSize);
            offset += dataSize;
            texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data, mipLevel);
          }
        }
        var ambientLight = new AmbientLight(engine);
        var sh = new SphericalHarmonics3();
        ambientLight.diffuseMode = DiffuseMode.SphericalHarmonics;
        sh.copyFromArray(shArray);
        ambientLight.diffuseSphericalHarmonics = sh;
        ambientLight.specularTexture = texture;
        ambientLight.specularTextureDecodeRGBM = true;
        resolve(ambientLight);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return EnvLoader2;
}(Loader);
EnvLoader = __decorate$1([
  resourceLoader(AssetType.Env, [
    "env"
  ])
], EnvLoader);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info2 = gen[key](arg);
    var value = info2.value;
  } catch (error2) {
    reject(error2);
    return;
  }
  if (info2.done)
    resolve(value);
  else
    Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var FontLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(FontLoader2, Loader2);
  function FontLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = FontLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, {
        type: "json"
      }).then(function(data) {
        var fontName = data.fontName, fontUrl = data.fontUrl;
        if (fontUrl) {
          _this._registerFont(fontName, fontUrl).then(function() {
            var font2 = new Font(resourceManager.engine, fontName);
            resolve(font2);
          }).catch(function(e) {
            reject("load font " + fontUrl + " fail");
          });
        } else {
          var font = new Font(resourceManager.engine, fontName);
          resolve(font);
        }
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  _proto._registerFont = function _registerFont(fontName, fontUrl) {
    return _async_to_generator(function() {
      var fontFace;
      return __generator(this, function(_state) {
        switch (_state.label) {
          case 0:
            fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
            return [
              4,
              fontFace.load()
            ];
          case 1:
            _state.sent();
            document.fonts.add(fontFace);
            return [
              2
            ];
        }
      });
    })();
  };
  return FontLoader2;
}(Loader);
FontLoader = __decorate$1([
  resourceLoader(AssetType.Font, [
    "font"
  ], false)
], FontLoader);
function _array_like_to_array(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _unsupported_iterable_to_array(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _array_like_to_array(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _array_like_to_array(o, minLen);
}
function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it2)
    return (it2 = it2.call(o)).next.bind(it2);
  if (Array.isArray(o) || (it2 = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it2)
      o = it2;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var GLTFContentRestorer = /* @__PURE__ */ function(ContentRestorer3) {
  _inherits(GLTFContentRestorer2, ContentRestorer3);
  function GLTFContentRestorer2() {
    var _this;
    _this = ContentRestorer3.apply(this, arguments) || this;
    _this.bufferRequests = [];
    _this.glbBufferSlices = [];
    _this.bufferTextures = [];
    _this.meshes = [];
    return _this;
  }
  var _proto = GLTFContentRestorer2.prototype;
  _proto.restoreContent = function restoreContent() {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      Promise.all(_this.bufferRequests.map(function(bufferRequestInfo) {
        return request(bufferRequestInfo.url, bufferRequestInfo.config);
      })).then(function(buffers) {
        if (_this.isGLB) {
          var glbBufferSlice = _this.glbBufferSlices;
          var bigBuffer = buffers[0];
          var bufferCount = glbBufferSlice.length;
          buffers.length = bufferCount;
          for (var i = 0; i < bufferCount; i++) {
            var slice = glbBufferSlice[i];
            buffers[i] = bigBuffer.slice(slice.x, slice.x + slice.y);
          }
        }
        AssetPromise.all(_this.bufferTextures.map(function(textureRestoreInfo) {
          var bufferView = textureRestoreInfo.bufferView;
          var buffer = buffers[bufferView.buffer];
          var _bufferView_byteOffset;
          var bufferData = new Uint8Array(buffer, (_bufferView_byteOffset = bufferView.byteOffset) != null ? _bufferView_byteOffset : 0, bufferView.byteLength);
          return GLTFUtils.loadImageBuffer(bufferData, textureRestoreInfo.mimeType).then(function(image) {
            textureRestoreInfo.texture.setImageSource(image);
            textureRestoreInfo.texture.generateMipmaps();
          });
        })).then(function() {
          for (var _iterator = _create_for_of_iterator_helper_loose(_this.meshes), _step; !(_step = _iterator()).done; ) {
            var meshInfo = _step.value;
            var mesh = meshInfo.mesh;
            for (var _iterator1 = _create_for_of_iterator_helper_loose(meshInfo.vertexBuffers), _step1; !(_step1 = _iterator1()).done; ) {
              var bufferRestoreInfo = _step1.value;
              var vertexData = _this._getBufferData(buffers, bufferRestoreInfo.data);
              bufferRestoreInfo.buffer.setData(vertexData);
            }
            if (meshInfo.indexBuffer) {
              var indexData = _this._getBufferData(buffers, meshInfo.indexBuffer);
              mesh.setIndices(indexData);
            }
            for (var _iterator2 = _create_for_of_iterator_helper_loose(meshInfo.blendShapes), _step2; !(_step2 = _iterator2()).done; ) {
              var restoreInfo = _step2.value;
              var frame = restoreInfo.blendShape.frames[0];
              var position = restoreInfo.position;
              var positionData = _this._getBufferData(buffers, position.buffer);
              frame.deltaPositions = GLTFUtils.bufferToVector3Array(positionData, position.stride, position.byteOffset, position.count);
              if (restoreInfo.normal) {
                var normal = restoreInfo.normal;
                var normalData = _this._getBufferData(buffers, normal.buffer);
                frame.deltaNormals = GLTFUtils.bufferToVector3Array(normalData, normal.stride, normal.byteOffset, normal.count);
              }
              if (restoreInfo.tangent) {
                var tangent = restoreInfo.tangent;
                var tangentData = _this._getBufferData(buffers, tangent.buffer);
                frame.deltaTangents = GLTFUtils.bufferToVector3Array(tangentData, tangent.stride, tangent.byteOffset, tangent.count);
              }
            }
            mesh.uploadData(true);
          }
          resolve(_this.resource);
        }).catch(reject);
      }).catch(reject);
    });
  };
  _proto._getBufferData = function _getBufferData(buffers, restoreInfo) {
    var main = restoreInfo.main;
    var buffer = buffers[main.bufferIndex];
    var data = new main.TypedArray(buffer, main.byteOffset, main.length);
    var sparseCount = restoreInfo.sparseCount;
    if (sparseCount) {
      var sparseIndex = restoreInfo.sparseIndices;
      var sparseIndexBuffer = buffers[sparseIndex.bufferIndex];
      var sparseIndexData = new sparseIndex.TypedArray(sparseIndexBuffer, sparseIndex.byteOffset, sparseIndex.length);
      var sparseValue = restoreInfo.sparseValues;
      var sparseValueBuffer = buffers[sparseValue.bufferIndex];
      var sparseValueData = new sparseValue.TypedArray(sparseValueBuffer, sparseValue.byteOffset, sparseValue.length);
      var typeSize = restoreInfo.typeSize;
      for (var i = 0; i < sparseCount; i++) {
        var replaceIndex = sparseIndexData[i];
        for (var j2 = 0; j2 < typeSize; j2++) {
          data[replaceIndex * typeSize + j2] = sparseValueData[i * typeSize + j2];
        }
      }
    }
    return data;
  };
  return GLTFContentRestorer2;
}(ContentRestorer);
var BufferRequestInfo = function BufferRequestInfo2(url, config) {
  this.url = url;
  this.config = config;
};
var BufferTextureRestoreInfo = function BufferTextureRestoreInfo2(texture, bufferView, mimeType2) {
  this.texture = texture;
  this.bufferView = bufferView;
  this.mimeType = mimeType2;
};
var ModelMeshRestoreInfo = function ModelMeshRestoreInfo2() {
  this.vertexBuffers = [];
  this.blendShapes = [];
};
var BufferRestoreInfo = function BufferRestoreInfo2(buffer, data) {
  this.buffer = buffer;
  this.data = data;
};
var BufferDataRestoreInfo = function BufferDataRestoreInfo2(main, typeSize, sparseCount, sparseIndices, sparseValues) {
  this.main = main;
  this.typeSize = typeSize;
  this.sparseCount = sparseCount;
  this.sparseIndices = sparseIndices;
  this.sparseValues = sparseValues;
};
var RestoreDataAccessor = function RestoreDataAccessor2(bufferIndex, TypedArray, byteOffset, length2) {
  this.bufferIndex = bufferIndex;
  this.TypedArray = TypedArray;
  this.byteOffset = byteOffset;
  this.length = length2;
};
var BlendShapeRestoreInfo = function BlendShapeRestoreInfo2(blendShape, position, normal, tangent) {
  this.blendShape = blendShape;
  this.position = position;
  this.normal = normal;
  this.tangent = tangent;
};
var BlendShapeDataRestoreInfo = function BlendShapeDataRestoreInfo2(buffer, stride, byteOffset, count) {
  this.buffer = buffer;
  this.stride = stride;
  this.byteOffset = byteOffset;
  this.count = count;
};
var AccessorComponentType;
(function(AccessorComponentType2) {
  AccessorComponentType2[AccessorComponentType2["BYTE"] = 5120] = "BYTE";
  AccessorComponentType2[AccessorComponentType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  AccessorComponentType2[AccessorComponentType2["SHORT"] = 5122] = "SHORT";
  AccessorComponentType2[AccessorComponentType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  AccessorComponentType2[AccessorComponentType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  AccessorComponentType2[AccessorComponentType2["FLOAT"] = 5126] = "FLOAT";
})(AccessorComponentType || (AccessorComponentType = {}));
var AccessorType;
(function(AccessorType2) {
  AccessorType2["SCALAR"] = "SCALAR";
  AccessorType2["VEC2"] = "VEC2";
  AccessorType2["VEC3"] = "VEC3";
  AccessorType2["VEC4"] = "VEC4";
  AccessorType2["MAT2"] = "MAT2";
  AccessorType2["MAT3"] = "MAT3";
  AccessorType2["MAT4"] = "MAT4";
})(AccessorType || (AccessorType = {}));
var AnimationChannelTargetPath;
(function(AnimationChannelTargetPath2) {
  AnimationChannelTargetPath2["TRANSLATION"] = "translation";
  AnimationChannelTargetPath2["ROTATION"] = "rotation";
  AnimationChannelTargetPath2["SCALE"] = "scale";
  AnimationChannelTargetPath2["WEIGHTS"] = "weights";
})(AnimationChannelTargetPath || (AnimationChannelTargetPath = {}));
var AnimationSamplerInterpolation;
(function(AnimationSamplerInterpolation2) {
  AnimationSamplerInterpolation2["Linear"] = "LINEAR";
  AnimationSamplerInterpolation2["Step"] = "STEP";
  AnimationSamplerInterpolation2["CubicSpine"] = "CUBICSPLINE";
})(AnimationSamplerInterpolation || (AnimationSamplerInterpolation = {}));
var CameraType;
(function(CameraType2) {
  CameraType2["PERSPECTIVE"] = "perspective";
  CameraType2["ORTHOGRAPHIC"] = "orthographic";
})(CameraType || (CameraType = {}));
var ImageMimeType;
(function(ImageMimeType2) {
  ImageMimeType2["JPEG"] = "image/jpeg";
  ImageMimeType2["PNG"] = "image/png";
})(ImageMimeType || (ImageMimeType = {}));
var MaterialAlphaMode;
(function(MaterialAlphaMode2) {
  MaterialAlphaMode2["OPAQUE"] = "OPAQUE";
  MaterialAlphaMode2["MASK"] = "MASK";
  MaterialAlphaMode2["BLEND"] = "BLEND";
})(MaterialAlphaMode || (MaterialAlphaMode = {}));
var TextureMagFilter;
(function(TextureMagFilter2) {
  TextureMagFilter2[TextureMagFilter2["NEAREST"] = 9728] = "NEAREST";
  TextureMagFilter2[TextureMagFilter2["LINEAR"] = 9729] = "LINEAR";
})(TextureMagFilter || (TextureMagFilter = {}));
var TextureMinFilter;
(function(TextureMinFilter2) {
  TextureMinFilter2[TextureMinFilter2["NEAREST"] = 9728] = "NEAREST";
  TextureMinFilter2[TextureMinFilter2["LINEAR"] = 9729] = "LINEAR";
  TextureMinFilter2[TextureMinFilter2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  TextureMinFilter2[TextureMinFilter2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  TextureMinFilter2[TextureMinFilter2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  TextureMinFilter2[TextureMinFilter2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(TextureMinFilter || (TextureMinFilter = {}));
var TextureWrapMode;
(function(TextureWrapMode2) {
  TextureWrapMode2[TextureWrapMode2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  TextureWrapMode2[TextureWrapMode2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  TextureWrapMode2[TextureWrapMode2["REPEAT"] = 10497] = "REPEAT";
})(TextureWrapMode || (TextureWrapMode = {}));
var GLTFParserContext = /* @__PURE__ */ function() {
  function GLTFParserContext2(url) {
    this.hasSkinned = false;
    this.chainPromises = [];
    this.accessorBufferCache = {};
    this.texturesPromiseInfo = new PromiseInfo();
    this.materialsPromiseInfo = new PromiseInfo();
    this.meshesPromiseInfo = new PromiseInfo();
    this.animationClipsPromiseInfo = new PromiseInfo();
    this.defaultSceneRootPromiseInfo = new PromiseInfo();
    this.masterPromiseInfo = new PromiseInfo();
    this.promiseMap = {};
    var promiseMap = this.promiseMap;
    promiseMap["" + url + "?q=textures"] = this._initPromiseInfo(this.texturesPromiseInfo);
    promiseMap["" + url + "?q=materials"] = this._initPromiseInfo(this.materialsPromiseInfo);
    promiseMap["" + url + "?q=meshes"] = this._initPromiseInfo(this.meshesPromiseInfo);
    promiseMap["" + url + "?q=animations"] = this._initPromiseInfo(this.animationClipsPromiseInfo);
    promiseMap["" + url + "?q=defaultSceneRoot"] = this._initPromiseInfo(this.defaultSceneRootPromiseInfo);
    promiseMap["" + url] = this._initPromiseInfo(this.masterPromiseInfo);
  }
  var _proto = GLTFParserContext2.prototype;
  _proto.getBuffers = function getBuffers() {
    return Promise.resolve(this._buffers);
  };
  _proto._initPromiseInfo = function _initPromiseInfo(promiseInfo) {
    var promise = new AssetPromise(function(resolve, reject, setProgress, onCancel) {
      promiseInfo.resolve = resolve;
      promiseInfo.reject = reject;
      promiseInfo.setProgress = setProgress;
      promiseInfo.onCancel = onCancel;
    });
    promiseInfo.promise = promise;
    return promise;
  };
  return GLTFParserContext2;
}();
var BufferInfo = function BufferInfo2(data, interleaved, stride) {
  this.data = data;
  this.interleaved = interleaved;
  this.stride = stride;
  this.vertexBindingInfos = {};
};
var PromiseInfo = function PromiseInfo2() {
};
var GLTFUtils = /* @__PURE__ */ function() {
  function GLTFUtils2() {
  }
  GLTFUtils2.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 2);
    for (var i = 0; i < bufferLen; i += 2) {
      array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);
    }
    return array;
  };
  GLTFUtils2.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 3);
    for (var i = 0; i < bufferLen; i += 3) {
      array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
    }
    return array;
  };
  GLTFUtils2.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
    var bufferLen = buffer.length;
    var array = new Array(bufferLen / 4);
    for (var i = 0; i < bufferLen; i += 4) {
      array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
    }
    return array;
  };
  GLTFUtils2.floatBufferToColorArray = function floatBufferToColorArray(buffer, isColor3) {
    var bufferLen = buffer.length;
    var colors = new Array(bufferLen / (isColor3 ? 3 : 4));
    if (isColor3) {
      for (var i = 0; i < bufferLen; i += 3) {
        colors[i / 3] = new Color$1(buffer[i], buffer[i + 1], buffer[i + 2], 1);
      }
    } else {
      for (var i1 = 0; i1 < bufferLen; i1 += 4) {
        colors[i1 / 4] = new Color$1(buffer[i1], buffer[i1 + 1], buffer[i1 + 2], buffer[i1 + 3]);
      }
    }
    return colors;
  };
  GLTFUtils2.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
    switch (accessorType) {
      case AccessorType.SCALAR:
        return 1;
      case AccessorType.VEC2:
        return 2;
      case AccessorType.VEC3:
        return 3;
      case AccessorType.VEC4:
        return 4;
      case AccessorType.MAT2:
        return 4;
      case AccessorType.MAT3:
        return 9;
      case AccessorType.MAT4:
        return 16;
    }
  };
  GLTFUtils2.getComponentType = function getComponentType(componentType) {
    switch (componentType) {
      case AccessorComponentType.BYTE:
        return Int8Array;
      case AccessorComponentType.UNSIGNED_BYTE:
        return Uint8Array;
      case AccessorComponentType.SHORT:
        return Int16Array;
      case AccessorComponentType.UNSIGNED_SHORT:
        return Uint16Array;
      case AccessorComponentType.UNSIGNED_INT:
        return Uint32Array;
      case AccessorComponentType.FLOAT:
        return Float32Array;
    }
  };
  GLTFUtils2.getNormalizedComponentScale = function getNormalizedComponentScale(componentType) {
    switch (componentType) {
      case AccessorComponentType.BYTE:
        return 1 / 127;
      case AccessorComponentType.UNSIGNED_BYTE:
        return 1 / 255;
      case AccessorComponentType.SHORT:
        return 1 / 32767;
      case AccessorComponentType.UNSIGNED_SHORT:
        return 1 / 65535;
      default:
        throw new Error("Galacean.GLTFLoader: Unsupported normalized accessor component type.");
    }
  };
  GLTFUtils2.getAccessorBuffer = function getAccessorBuffer(context, bufferViews, accessor) {
    var componentType = accessor.componentType;
    var bufferView = bufferViews[accessor.bufferView];
    return context.getBuffers().then(function(buffers) {
      var bufferIndex = bufferView.buffer;
      var buffer = buffers[bufferIndex];
      var _bufferView_byteOffset;
      var bufferByteOffset = (_bufferView_byteOffset = bufferView.byteOffset) != null ? _bufferView_byteOffset : 0;
      var _accessor_byteOffset;
      var byteOffset = (_accessor_byteOffset = accessor.byteOffset) != null ? _accessor_byteOffset : 0;
      var TypedArray = GLTFUtils2.getComponentType(componentType);
      var dataElementSize = GLTFUtils2.getAccessorTypeSize(accessor.type);
      var dataElementBytes = TypedArray.BYTES_PER_ELEMENT;
      var elementStride = dataElementSize * dataElementBytes;
      var accessorCount = accessor.count;
      var bufferStride = bufferView.byteStride;
      var bufferInfo;
      if (bufferStride !== void 0 && bufferStride !== elementStride) {
        var bufferSlice = Math.floor(byteOffset / bufferStride);
        var bufferCacheKey = accessor.bufferView + ":" + componentType + ":" + bufferSlice + ":" + accessorCount;
        var accessorBufferCache = context.accessorBufferCache;
        bufferInfo = accessorBufferCache[bufferCacheKey];
        if (!bufferInfo) {
          var offset = bufferByteOffset + bufferSlice * bufferStride;
          var count = accessorCount * (bufferStride / dataElementBytes);
          var data = new TypedArray(buffer, offset, count);
          accessorBufferCache[bufferCacheKey] = bufferInfo = new BufferInfo(data, true, bufferStride);
          bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(bufferIndex, TypedArray, offset, count));
        }
      } else {
        var offset1 = bufferByteOffset + byteOffset;
        var count1 = accessorCount * dataElementSize;
        var data1 = new TypedArray(buffer, offset1, count1);
        bufferInfo = new BufferInfo(data1, false, elementStride);
        bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(bufferIndex, TypedArray, offset1, count1));
      }
      if (accessor.sparse) {
        GLTFUtils2.processingSparseData(bufferViews, accessor, buffers, bufferInfo);
      }
      return bufferInfo;
    });
  };
  GLTFUtils2.bufferToVector3Array = function bufferToVector3Array(data, byteStride, accessorByteOffset, count) {
    var bytesPerElement = data.BYTES_PER_ELEMENT;
    var offset = accessorByteOffset % byteStride / bytesPerElement;
    var stride = byteStride / bytesPerElement;
    var vector3s = new Array(count);
    for (var i = 0; i < count; i++) {
      var index = offset + i * stride;
      vector3s[i] = new Vector3(data[index], data[index + 1], data[index + 2]);
    }
    return vector3s;
  };
  GLTFUtils2.getAccessorData = function getAccessorData(glTF, accessor, buffers) {
    var bufferViews = glTF.bufferViews;
    var bufferView = bufferViews[accessor.bufferView];
    var arrayBuffer = buffers[bufferView.buffer];
    var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
    var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
    var byteOffset = accessorByteOffset + bufferViewByteOffset;
    var accessorTypeSize = GLTFUtils2.getAccessorTypeSize(accessor.type);
    var length2 = accessorTypeSize * accessor.count;
    var _bufferView_byteStride;
    var byteStride = (_bufferView_byteStride = bufferView.byteStride) != null ? _bufferView_byteStride : 0;
    var arrayType = GLTFUtils2.getComponentType(accessor.componentType);
    var uint8Array;
    if (byteStride) {
      var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
      uint8Array = new Uint8Array(accessor.count * accessorByteSize);
      var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
      for (var i = 0; i < accessor.count; i++) {
        for (var j2 = 0; j2 < accessorByteSize; j2++) {
          uint8Array[i * accessorByteSize + j2] = originalBufferView[i * byteStride + accessorByteOffset + j2];
        }
      }
    } else {
      uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length2 * arrayType.BYTES_PER_ELEMENT));
    }
    var typedArray = new arrayType(uint8Array.buffer);
    if (accessor.sparse) {
      var _accessor_sparse = accessor.sparse, count = _accessor_sparse.count, indices = _accessor_sparse.indices, values = _accessor_sparse.values;
      var indicesBufferView = bufferViews[indices.bufferView];
      var valuesBufferView = bufferViews[values.bufferView];
      var indicesArrayBuffer = buffers[indicesBufferView.buffer];
      var valuesArrayBuffer = buffers[valuesBufferView.buffer];
      var _indices_byteOffset, _indicesBufferView_byteOffset;
      var indicesByteOffset = ((_indices_byteOffset = indices.byteOffset) != null ? _indices_byteOffset : 0) + ((_indicesBufferView_byteOffset = indicesBufferView.byteOffset) != null ? _indicesBufferView_byteOffset : 0);
      var indicesByteLength = indicesBufferView.byteLength;
      var _values_byteOffset, _valuesBufferView_byteOffset;
      var valuesByteOffset = ((_values_byteOffset = values.byteOffset) != null ? _values_byteOffset : 0) + ((_valuesBufferView_byteOffset = valuesBufferView.byteOffset) != null ? _valuesBufferView_byteOffset : 0);
      var valuesByteLength = valuesBufferView.byteLength;
      var indicesType = GLTFUtils2.getComponentType(indices.componentType);
      var indicesArray = new indicesType(indicesArrayBuffer, indicesByteOffset, indicesByteLength / indicesType.BYTES_PER_ELEMENT);
      var valuesArray = new arrayType(valuesArrayBuffer, valuesByteOffset, valuesByteLength / arrayType.BYTES_PER_ELEMENT);
      for (var i1 = 0; i1 < count; i1++) {
        var replaceIndex = indicesArray[i1];
        for (var j1 = 0; j1 < accessorTypeSize; j1++) {
          typedArray[replaceIndex * accessorTypeSize + j1] = valuesArray[i1 * accessorTypeSize + j1];
        }
      }
    }
    return typedArray;
  };
  GLTFUtils2.getBufferViewData = function getBufferViewData(bufferView, buffers) {
    var _bufferView_byteOffset = bufferView.byteOffset, byteOffset = _bufferView_byteOffset === void 0 ? 0 : _bufferView_byteOffset;
    var arrayBuffer = buffers[bufferView.buffer];
    return arrayBuffer.slice(byteOffset, byteOffset + bufferView.byteLength);
  };
  GLTFUtils2.processingSparseData = function processingSparseData(bufferViews, accessor, buffers, bufferInfo) {
    var restoreInfo = bufferInfo.restoreInfo;
    var accessorTypeSize = GLTFUtils2.getAccessorTypeSize(accessor.type);
    var TypedArray = GLTFUtils2.getComponentType(accessor.componentType);
    var data = bufferInfo.data.slice();
    var _accessor_sparse = accessor.sparse, count = _accessor_sparse.count, indices = _accessor_sparse.indices, values = _accessor_sparse.values;
    var indicesBufferView = bufferViews[indices.bufferView];
    var valuesBufferView = bufferViews[values.bufferView];
    var indicesBufferIndex = indicesBufferView.buffer;
    var valuesBufferIndex = valuesBufferView.buffer;
    var indicesArrayBuffer = buffers[indicesBufferIndex];
    var valuesArrayBuffer = buffers[valuesBufferIndex];
    var _indices_byteOffset, _indicesBufferView_byteOffset;
    var indicesByteOffset = ((_indices_byteOffset = indices.byteOffset) != null ? _indices_byteOffset : 0) + ((_indicesBufferView_byteOffset = indicesBufferView.byteOffset) != null ? _indicesBufferView_byteOffset : 0);
    var indicesByteLength = indicesBufferView.byteLength;
    var _values_byteOffset, _valuesBufferView_byteOffset;
    var valuesByteOffset = ((_values_byteOffset = values.byteOffset) != null ? _values_byteOffset : 0) + ((_valuesBufferView_byteOffset = valuesBufferView.byteOffset) != null ? _valuesBufferView_byteOffset : 0);
    var valuesByteLength = valuesBufferView.byteLength;
    restoreInfo.typeSize = accessorTypeSize;
    restoreInfo.sparseCount = count;
    var IndexTypeArray = GLTFUtils2.getComponentType(indices.componentType);
    var indexLength = indicesByteLength / IndexTypeArray.BYTES_PER_ELEMENT;
    var indicesArray = new IndexTypeArray(indicesArrayBuffer, indicesByteOffset, indexLength);
    restoreInfo.sparseIndices = new RestoreDataAccessor(indicesBufferIndex, IndexTypeArray, indicesByteOffset, indexLength);
    var valueLength = valuesByteLength / TypedArray.BYTES_PER_ELEMENT;
    var valuesArray = new TypedArray(valuesArrayBuffer, valuesByteOffset, valueLength);
    restoreInfo.sparseValues = new RestoreDataAccessor(valuesBufferIndex, TypedArray, valuesByteOffset, valueLength);
    for (var i = 0; i < count; i++) {
      var replaceIndex = indicesArray[i];
      for (var j2 = 0; j2 < accessorTypeSize; j2++) {
        data[replaceIndex * accessorTypeSize + j2] = valuesArray[i * accessorTypeSize + j2];
      }
    }
    bufferInfo.data = data;
  };
  GLTFUtils2.getIndexFormat = function getIndexFormat(type) {
    switch (type) {
      case AccessorComponentType.UNSIGNED_BYTE:
        return IndexFormat.UInt8;
      case AccessorComponentType.UNSIGNED_SHORT:
        return IndexFormat.UInt16;
      case AccessorComponentType.UNSIGNED_INT:
        return IndexFormat.UInt32;
    }
  };
  GLTFUtils2.getElementFormat = function getElementFormat(type, size, normalized) {
    if (normalized === void 0)
      normalized = false;
    if (type == AccessorComponentType.FLOAT) {
      switch (size) {
        case 1:
          return VertexElementFormat.Float;
        case 2:
          return VertexElementFormat.Vector2;
        case 3:
          return VertexElementFormat.Vector3;
        case 4:
          return VertexElementFormat.Vector4;
      }
    }
    if (type == AccessorComponentType.SHORT) {
      switch (size) {
        case 2:
          return normalized ? VertexElementFormat.NormalizedShort2 : VertexElementFormat.Short2;
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedShort4 : VertexElementFormat.Short4;
      }
    }
    if (type == AccessorComponentType.UNSIGNED_SHORT) {
      switch (size) {
        case 2:
          return normalized ? VertexElementFormat.NormalizedUShort2 : VertexElementFormat.UShort2;
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedUShort4 : VertexElementFormat.UShort4;
      }
    }
    if (type == AccessorComponentType.BYTE) {
      switch (size) {
        case 2:
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedByte4 : VertexElementFormat.Byte4;
      }
    }
    if (type == AccessorComponentType.UNSIGNED_BYTE) {
      switch (size) {
        case 2:
        case 3:
        case 4:
          return normalized ? VertexElementFormat.NormalizedUByte4 : VertexElementFormat.UByte4;
      }
    }
  };
  GLTFUtils2.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
    return new Promise(function(resolve, reject) {
      var blob = new window.Blob([
        imageBuffer
      ], {
        type
      });
      var img = new Image();
      img.onerror = function() {
        reject(new Error("Failed to load image buffer"));
      };
      img.onload = function() {
        requestAnimationFrame(function() {
          resolve(img);
          img.onload = null;
          img.onerror = null;
          img.onabort = null;
        });
      };
      img.crossOrigin = "anonymous";
      img.src = URL.createObjectURL(blob);
    });
  };
  GLTFUtils2.parseGLB = function parseGLB(context, glb) {
    var UINT32_LENGTH = 4;
    var GLB_HEADER_MAGIC = 1179937895;
    var GLB_HEADER_LENGTH = 12;
    var GLB_CHUNK_TYPES = {
      JSON: 1313821514,
      BIN: 5130562
    };
    var dataView = new DataView(glb);
    var header = {
      magic: dataView.getUint32(0, true),
      version: dataView.getUint32(UINT32_LENGTH, true),
      length: dataView.getUint32(2 * UINT32_LENGTH, true)
    };
    if (header.magic !== GLB_HEADER_MAGIC) {
      console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
      return null;
    }
    var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
    var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);
    if (chunkType !== GLB_CHUNK_TYPES.JSON) {
      console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
      return null;
    }
    var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
    var glTF = JSON.parse(Utils.decodeText(glTFData));
    var buffers = [];
    var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
    var restoreGLBBufferSlice = context.contentRestorer.glbBufferSlices;
    while (byteOffset < header.length) {
      chunkLength = dataView.getUint32(byteOffset, true);
      chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
      if (chunkType !== GLB_CHUNK_TYPES.BIN) {
        console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
        return null;
      }
      var currentOffset = byteOffset + 2 * UINT32_LENGTH;
      var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
      buffers.push(buffer);
      restoreGLBBufferSlice.push(new Vector2(currentOffset, chunkLength));
      byteOffset += chunkLength + 2 * UINT32_LENGTH;
    }
    return {
      glTF,
      buffers
    };
  };
  GLTFUtils2._formatRelativePath = function _formatRelativePath(path) {
    return path.split("/").filter(Boolean).reduce(function(acc, cur) {
      if (cur === "..")
        acc.pop();
      else if (cur !== ".")
        acc.push(cur);
      return acc;
    }, []).join("/");
  };
  return GLTFUtils2;
}();
function _array_without_holes(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array(arr);
}
function _iterable_to_array(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) {
    return Array.from(iter);
  }
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
var GLTFExtensionParser = /* @__PURE__ */ function() {
  function GLTFExtensionParser2() {
  }
  var _proto = GLTFExtensionParser2.prototype;
  _proto.initialize = function initialize() {
  };
  _proto.createAndParse = function createAndParse(context, extensionSchema, extensionOwnerSchema) {
    for (var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      extra[_key - 3] = arguments[_key];
    }
    throw "Not implemented.";
  };
  _proto.additiveParse = function additiveParse(context, parseResource, extensionSchema, extensionOwnerSchema) {
    for (var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
      extra[_key - 4] = arguments[_key];
    }
    throw "Not implemented.";
  };
  return GLTFExtensionParser2;
}();
var GLTFExtensionMode;
(function(GLTFExtensionMode2) {
  GLTFExtensionMode2[GLTFExtensionMode2["CreateAndParse"] = 0] = "CreateAndParse";
  GLTFExtensionMode2[GLTFExtensionMode2["AdditiveParse"] = 1] = "AdditiveParse";
})(GLTFExtensionMode || (GLTFExtensionMode = {}));
var GLTFParser = /* @__PURE__ */ function() {
  function GLTFParser2() {
  }
  GLTFParser2.executeExtensionsInitialize = function executeExtensionsInitialize(extensionName) {
    var parsers = GLTFParser2._extensionParsers[extensionName];
    var length2 = parsers == null ? void 0 : parsers.length;
    if (length2) {
      return parsers[length2 - 1].initialize();
    }
  };
  GLTFParser2.executeExtensionsCreateAndParse = function executeExtensionsCreateAndParse(extensions, context, ownerSchema) {
    if (extensions === void 0)
      extensions = {};
    for (var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      extra[_key - 3] = arguments[_key];
    }
    var resource = null;
    var extensionArray = Object.keys(extensions);
    for (var i = extensionArray.length - 1; i >= 0; --i) {
      var _GLTFParser;
      var extensionName = extensionArray[i];
      var extensionSchema = extensions[extensionName];
      resource = (_GLTFParser = GLTFParser2)._createAndParse.apply(_GLTFParser, [
        extensionName,
        context,
        extensionSchema,
        ownerSchema
      ].concat(_to_consumable_array(extra)));
      if (resource) {
        return resource;
      }
    }
  };
  GLTFParser2.executeExtensionsAdditiveAndParse = function executeExtensionsAdditiveAndParse(extensions, context, parseResource, ownerSchema) {
    for (var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
      extra[_key - 4] = arguments[_key];
    }
    for (var extensionName in extensions) {
      var _GLTFParser;
      var extensionSchema = extensions[extensionName];
      (_GLTFParser = GLTFParser2)._additiveParse.apply(_GLTFParser, [
        extensionName,
        context,
        parseResource,
        extensionSchema,
        ownerSchema
      ].concat(_to_consumable_array(extra)));
    }
  };
  GLTFParser2.hasExtensionParser = function hasExtensionParser(extensionName) {
    var _GLTFParser__extensionParsers_extensionName;
    return !!((_GLTFParser__extensionParsers_extensionName = GLTFParser2._extensionParsers[extensionName]) == null ? void 0 : _GLTFParser__extensionParsers_extensionName.length);
  };
  GLTFParser2.getExtensionParser = function getExtensionParser(extensionName, mode) {
    var parsers = GLTFParser2._extensionParsers[extensionName];
    var length2 = parsers == null ? void 0 : parsers.length;
    if (length2) {
      for (var i = length2 - 1; i >= 0; --i) {
        var currentParser = parsers[i];
        if (currentParser._mode === mode) {
          return currentParser;
        }
      }
    }
  };
  GLTFParser2._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
    if (!GLTFParser2._extensionParsers[extensionName]) {
      GLTFParser2._extensionParsers[extensionName] = [];
    }
    GLTFParser2._extensionParsers[extensionName].push(extensionParser);
  };
  GLTFParser2._createAndParse = function _createAndParse(extensionName, context, extensionSchema, ownerSchema) {
    for (var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
      extra[_key - 4] = arguments[_key];
    }
    var parser = GLTFParser2.getExtensionParser(extensionName, GLTFExtensionMode.CreateAndParse);
    if (parser) {
      var _parser;
      return (_parser = parser).createAndParse.apply(_parser, [
        context,
        extensionSchema,
        ownerSchema
      ].concat(_to_consumable_array(extra)));
    }
  };
  GLTFParser2._additiveParse = function _additiveParse(extensionName, context, parseResource, extensionSchema, ownerSchema) {
    for (var _len = arguments.length, extra = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      extra[_key - 5] = arguments[_key];
    }
    var parser = GLTFParser2.getExtensionParser(extensionName, GLTFExtensionMode.AdditiveParse);
    if (parser) {
      var _parser;
      (_parser = parser).additiveParse.apply(_parser, [
        context,
        parseResource,
        extensionSchema,
        ownerSchema
      ].concat(_to_consumable_array(extra)));
    }
  };
  return GLTFParser2;
}();
(function() {
  GLTFParser._extensionParsers = {};
})();
function registerGLTFExtension(extensionName, mode) {
  return function(parser) {
    var extensionParser = new parser();
    extensionParser._mode = mode;
    GLTFParser._addExtensionParser(extensionName, extensionParser);
  };
}
var GLTFAnimationParser = /* @__PURE__ */ function(GLTFParser1) {
  _inherits(GLTFAnimationParser2, GLTFParser1);
  function GLTFAnimationParser2() {
    return GLTFParser1.apply(this, arguments);
  }
  var _proto = GLTFAnimationParser2.prototype;
  _proto.parse = function parse2(context) {
    var glTF = context.glTF, glTFResource = context.glTFResource;
    glTFResource.entities;
    var animations = glTF.animations;
    glTF.accessors;
    glTF.bufferViews;
    if (!animations) {
      return;
    }
    var animationClipsPromiseInfo = context.animationClipsPromiseInfo;
    var animationClipCount = animations.length;
    var animationClipPromises = [];
    new Array(animationClipCount);
    var parseStandardPropertyPromises = new Array();
    for (var i = 0; i < animationClipCount; i++) {
      var animationInfo = animations[i];
      var _animationInfo_name = animationInfo.name, name2 = _animationInfo_name === void 0 ? "AnimationClip" + i : _animationInfo_name;
      var animationClip = GLTFParser.executeExtensionsCreateAndParse(animationInfo.extensions, context, animationInfo);
      if (!animationClip) {
        animationClip = new AnimationClip(name2);
        parseStandardPropertyPromises.push(GLTFAnimationParser2._parseStandardProperty(context, animationClip, animationInfo));
      }
      animationClipPromises.push(animationClip);
    }
    return AssetPromise.all(parseStandardPropertyPromises).then(function() {
      return AssetPromise.all(animationClipPromises).then(function(animationClips) {
        glTFResource.animations = animationClips;
        for (var i2 = 0; i2 < glTF.animations.length; i2++) {
          var animationInfo2 = glTF.animations[i2];
          GLTFParser.executeExtensionsAdditiveAndParse(animationInfo2.extensions, context, animationClips[i2], animationInfo2);
        }
        animationClipsPromiseInfo.resolve(animationClips);
        return animationClipsPromiseInfo.promise;
      });
    });
  };
  GLTFAnimationParser2._parseStandardProperty = function _parseStandardProperty(context, animationClip, animationInfo) {
    var _loop = function(j3, m2) {
      var gltfSampler = samplers[j3];
      var inputAccessor = accessors[gltfSampler.input];
      var outputAccessor = accessors[gltfSampler.output];
      var promise = Promise.all([
        GLTFUtils.getAccessorBuffer(context, bufferViews, inputAccessor),
        GLTFUtils.getAccessorBuffer(context, bufferViews, outputAccessor)
      ]).then(function(bufferInfos) {
        var input = bufferInfos[0].data;
        var output = bufferInfos[1].data;
        if (outputAccessor.normalized) {
          var scale = GLTFUtils.getNormalizedComponentScale(outputAccessor.componentType);
          var scaled = new Float32Array(output.length);
          for (var k2 = 0, v = output.length; k2 < v; k2++) {
            scaled[k2] = output[k2] * scale;
          }
          output = scaled;
        }
        var outputStride = output.length / input.length;
        var _gltfSampler_interpolation;
        var interpolation = (_gltfSampler_interpolation = gltfSampler.interpolation) != null ? _gltfSampler_interpolation : AnimationSamplerInterpolation.Linear;
        var samplerInterpolation;
        switch (interpolation) {
          case AnimationSamplerInterpolation.CubicSpine:
            samplerInterpolation = InterpolationType.CubicSpine;
            break;
          case AnimationSamplerInterpolation.Step:
            samplerInterpolation = InterpolationType.Step;
            break;
          case AnimationSamplerInterpolation.Linear:
            samplerInterpolation = InterpolationType.Linear;
            break;
        }
        input[input.length - 1];
        sampleDataCollection.push({
          type: outputAccessor.type,
          interpolation: samplerInterpolation,
          input,
          output,
          outputSize: outputStride
        });
      });
      promises.push(promise);
    };
    var _this = this;
    var glTF = context.glTF, glTFResource = context.glTFResource;
    var entities = glTFResource.entities;
    var accessors = glTF.accessors, bufferViews = glTF.bufferViews;
    var channels = animationInfo.channels, samplers = animationInfo.samplers;
    var sampleDataCollection = new Array();
    var promises = new Array();
    for (var j2 = 0, m = samplers.length; j2 < m; j2++)
      _loop(j2);
    return Promise.all(promises).then(function() {
      for (var j3 = 0, m2 = channels.length; j3 < m2; j3++) {
        var gltfChannel = channels[j3];
        var target = gltfChannel.target;
        var channelTargetEntity = entities[target.node];
        var relativePath = "";
        var entity = channelTargetEntity;
        while (entity.parent) {
          relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
          entity = entity.parent;
        }
        var ComponentType = void 0;
        var propertyName = void 0;
        switch (target.path) {
          case AnimationChannelTargetPath.TRANSLATION:
            ComponentType = Transform;
            propertyName = "position";
            break;
          case AnimationChannelTargetPath.ROTATION:
            ComponentType = Transform;
            propertyName = "rotationQuaternion";
            break;
          case AnimationChannelTargetPath.SCALE:
            ComponentType = Transform;
            propertyName = "scale";
            break;
          case AnimationChannelTargetPath.WEIGHTS:
            ComponentType = SkinnedMeshRenderer;
            propertyName = "blendShapeWeights";
            break;
        }
        var curve = _this._addCurve(target.path, gltfChannel, sampleDataCollection);
        animationClip.addCurveBinding(relativePath, ComponentType, propertyName, curve);
      }
    });
  };
  GLTFAnimationParser2._addCurve = function _addCurve(animationChannelTargetPath, gltfChannel, sampleDataCollection) {
    var sampleData = sampleDataCollection[gltfChannel.sampler];
    var input = sampleData.input, output = sampleData.output, outputSize = sampleData.outputSize;
    switch (animationChannelTargetPath) {
      case AnimationChannelTargetPath.TRANSLATION:
      case AnimationChannelTargetPath.SCALE: {
        var curve = new AnimationVector3Curve();
        var interpolation = curve.interpolation = sampleData.interpolation;
        var offset = 0;
        for (var i = 0, n = input.length; i < n; i++) {
          var keyframe = new Keyframe();
          keyframe.time = input[i];
          if (interpolation === InterpolationType.CubicSpine) {
            keyframe.inTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
            keyframe.outTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
          } else {
            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
          }
          curve.addKey(keyframe);
        }
        return curve;
      }
      case AnimationChannelTargetPath.ROTATION: {
        var curve1 = new AnimationQuaternionCurve();
        var interpolation1 = curve1.interpolation = sampleData.interpolation;
        var offset1 = 0;
        for (var i1 = 0, n1 = input.length; i1 < n1; i1++) {
          var keyframe1 = new Keyframe();
          keyframe1.time = input[i1];
          if (interpolation1 === InterpolationType.CubicSpine) {
            keyframe1.inTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
            keyframe1.outTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
          } else {
            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
          }
          curve1.addKey(keyframe1);
        }
        return curve1;
      }
      case AnimationChannelTargetPath.WEIGHTS: {
        var curve2 = new AnimationFloatArrayCurve();
        curve2.interpolation = sampleData.interpolation;
        var offset2 = 0;
        for (var i2 = 0, n2 = input.length; i2 < n2; i2++) {
          var keyframe2 = new Keyframe();
          keyframe2.time = input[i2];
          if (curve2.interpolation === InterpolationType.CubicSpine) {
            keyframe2.inTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
            offset2 += outputSize;
            keyframe2.value = output.subarray(offset2, offset2 + outputSize);
            offset2 += outputSize;
            keyframe2.outTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
            offset2 += outputSize;
          } else {
            keyframe2.value = output.subarray(offset2, offset2 + outputSize);
            offset2 += outputSize;
          }
          curve2.addKey(keyframe2);
        }
        return curve2;
      }
    }
  };
  return GLTFAnimationParser2;
}(GLTFParser);
var GLTFBufferParser = /* @__PURE__ */ function(GLTFParser2) {
  _inherits(GLTFBufferParser2, GLTFParser2);
  function GLTFBufferParser2() {
    return GLTFParser2.apply(this, arguments);
  }
  var _proto = GLTFBufferParser2.prototype;
  _proto.parse = function parse2(context) {
    var glTFResource = context.glTFResource, contentRestorer = context.contentRestorer;
    var url = glTFResource.url;
    var restoreBufferRequests = contentRestorer.bufferRequests;
    var requestConfig = {
      type: "arraybuffer"
    };
    var isGLB = this._isGLB(url);
    contentRestorer.isGLB = isGLB;
    if (isGLB) {
      return request(url, requestConfig).then(function(glb) {
        restoreBufferRequests.push(new BufferRequestInfo(url, requestConfig));
        return GLTFUtils.parseGLB(context, glb);
      }).then(function(param) {
        var glTF = param.glTF, buffers = param.buffers;
        context.glTF = glTF;
        context._buffers = buffers;
      });
    } else {
      return request(url, {
        type: "json"
      }).then(function(glTF) {
        context.glTF = glTF;
        context._buffers = Promise.all(glTF.buffers.map(function(buffer) {
          var absoluteUrl = Utils.resolveAbsoluteUrl(url, buffer.uri);
          restoreBufferRequests.push(new BufferRequestInfo(absoluteUrl, requestConfig));
          return request(absoluteUrl, requestConfig);
        }));
      });
    }
  };
  _proto._isGLB = function _isGLB(url) {
    var index = url.lastIndexOf(".");
    return url.substring(index + 1, index + 4) === "glb";
  };
  return GLTFBufferParser2;
}(GLTFParser);
var GLTFEntityParser = /* @__PURE__ */ function(GLTFParser2) {
  _inherits(GLTFEntityParser2, GLTFParser2);
  function GLTFEntityParser2() {
    return GLTFParser2.apply(this, arguments);
  }
  var _proto = GLTFEntityParser2.prototype;
  _proto.parse = function parse2(context) {
    var glTFResource = context.glTFResource, nodes = context.glTF.nodes;
    var engine = glTFResource.engine;
    if (!nodes)
      return;
    var entities = [];
    for (var i = 0; i < nodes.length; i++) {
      var gltfNode = nodes[i];
      var matrix = gltfNode.matrix, translation = gltfNode.translation, rotation = gltfNode.rotation, scale = gltfNode.scale;
      var entity = new Entity(engine, gltfNode.name || "" + GLTFEntityParser2._defaultName + i);
      var transform = entity.transform;
      if (matrix) {
        var localMatrix = transform.localMatrix;
        localMatrix.copyFromArray(matrix);
        transform.localMatrix = localMatrix;
      } else {
        if (translation) {
          transform.setPosition(translation[0], translation[1], translation[2]);
        }
        if (rotation) {
          transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
        }
        if (scale) {
          transform.setScale(scale[0], scale[1], scale[2]);
        }
      }
      entities[i] = entity;
    }
    glTFResource.entities = entities;
    this._buildEntityTree(context, glTFResource);
    this._createSceneRoots(context, glTFResource);
  };
  _proto._buildEntityTree = function _buildEntityTree(context, glTFResource) {
    var nodes = context.glTF.nodes;
    var entities = glTFResource.entities;
    for (var i = 0; i < nodes.length; i++) {
      var children = nodes[i].children;
      var entity = entities[i];
      if (children) {
        for (var j2 = 0; j2 < children.length; j2++) {
          var childEntity = entities[children[j2]];
          entity.addChild(childEntity);
        }
      }
    }
  };
  _proto._createSceneRoots = function _createSceneRoots(context, glTFResource) {
    var _context_glTF = context.glTF, tmp = _context_glTF.scene, sceneID = tmp === void 0 ? 0 : tmp, scenes = _context_glTF.scenes;
    var engine = glTFResource.engine, entities = glTFResource.entities;
    if (!scenes)
      return;
    var sceneRoots = [];
    for (var i = 0; i < scenes.length; i++) {
      var nodes = scenes[i].nodes;
      if (!nodes)
        continue;
      if (nodes.length === 1) {
        sceneRoots[i] = entities[nodes[0]];
      } else {
        var rootEntity = new Entity(engine, "GLTF_ROOT");
        for (var j2 = 0; j2 < nodes.length; j2++) {
          rootEntity.addChild(entities[nodes[j2]]);
        }
        sceneRoots[i] = rootEntity;
      }
      sceneRoots[i]._hookResource = glTFResource;
      glTFResource._addReferCount(1);
    }
    glTFResource.sceneRoots = sceneRoots;
    glTFResource.defaultSceneRoot = sceneRoots[sceneID];
  };
  return GLTFEntityParser2;
}(GLTFParser);
(function() {
  GLTFEntityParser._defaultName = "_GLTF_ENTITY_";
})();
var GLTFMaterialParser = /* @__PURE__ */ function(GLTFParser1) {
  _inherits(GLTFMaterialParser2, GLTFParser1);
  function GLTFMaterialParser2() {
    return GLTFParser1.apply(this, arguments);
  }
  var _proto = GLTFMaterialParser2.prototype;
  _proto.parse = function parse2(context) {
    var glTF = context.glTF, glTFResource = context.glTFResource, materialsPromiseInfo = context.materialsPromiseInfo;
    if (!glTF.materials)
      return;
    var engine = glTFResource.engine;
    var materialPromises = [];
    for (var i = 0; i < glTF.materials.length; i++) {
      var materialInfo = glTF.materials[i];
      var material = GLTFParser.executeExtensionsCreateAndParse(materialInfo.extensions, context, materialInfo);
      if (!material) {
        material = new PBRMaterial(engine);
        material.name = materialInfo.name;
        GLTFMaterialParser2._parseStandardProperty(context, material, materialInfo);
      }
      materialPromises.push(material);
    }
    return AssetPromise.all(materialPromises).then(function(materials) {
      glTFResource.materials = materials;
      for (var i2 = 0; i2 < glTF.materials.length; i2++) {
        var materialInfo2 = glTF.materials[i2];
        GLTFParser.executeExtensionsAdditiveAndParse(materialInfo2.extensions, context, materials[i2], materialInfo2);
      }
      materialsPromiseInfo.resolve(materials);
      return materialsPromiseInfo.promise;
    });
  };
  GLTFMaterialParser2._checkOtherTextureTransform = function _checkOtherTextureTransform(texture, textureName) {
    var _texture_extensions;
    if ((_texture_extensions = texture.extensions) == null ? void 0 : _texture_extensions.KHR_texture_transform) {
      Logger.warn("" + textureName + " texture always use the KHR_texture_transform of the base texture.");
    }
  };
  GLTFMaterialParser2._parseStandardProperty = function _parseStandardProperty(context, material, materialInfo) {
    var textures = context.glTFResource.textures;
    var pbrMetallicRoughness = materialInfo.pbrMetallicRoughness, normalTexture = materialInfo.normalTexture, occlusionTexture = materialInfo.occlusionTexture, emissiveTexture = materialInfo.emissiveTexture, emissiveFactor = materialInfo.emissiveFactor, alphaMode = materialInfo.alphaMode, alphaCutoff = materialInfo.alphaCutoff, doubleSided = materialInfo.doubleSided;
    if (pbrMetallicRoughness) {
      var baseColorFactor = pbrMetallicRoughness.baseColorFactor, baseColorTexture = pbrMetallicRoughness.baseColorTexture, metallicFactor = pbrMetallicRoughness.metallicFactor, roughnessFactor = pbrMetallicRoughness.roughnessFactor, metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
      if (baseColorFactor) {
        material.baseColor = new Color$1(Color$1.linearToGammaSpace(baseColorFactor[0]), Color$1.linearToGammaSpace(baseColorFactor[1]), Color$1.linearToGammaSpace(baseColorFactor[2]), baseColorFactor[3]);
      }
      if (baseColorTexture) {
        material.baseTexture = textures[baseColorTexture.index];
        GLTFParser.executeExtensionsAdditiveAndParse(baseColorTexture.extensions, context, material, baseColorTexture);
      }
      if (material.constructor === PBRMaterial) {
        material.metallic = metallicFactor != null ? metallicFactor : 1;
        material.roughness = roughnessFactor != null ? roughnessFactor : 1;
        if (metallicRoughnessTexture) {
          material.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];
          GLTFMaterialParser2._checkOtherTextureTransform(metallicRoughnessTexture, "Roughness metallic");
        }
      }
    }
    if (material.constructor === PBRMaterial || material.constructor === PBRSpecularMaterial) {
      if (emissiveTexture) {
        material.emissiveTexture = textures[emissiveTexture.index];
        GLTFMaterialParser2._checkOtherTextureTransform(emissiveTexture, "Emissive");
      }
      if (emissiveFactor) {
        material.emissiveColor = new Color$1(Color$1.linearToGammaSpace(emissiveFactor[0]), Color$1.linearToGammaSpace(emissiveFactor[1]), Color$1.linearToGammaSpace(emissiveFactor[2]));
      }
      if (normalTexture) {
        var index = normalTexture.index, scale = normalTexture.scale;
        material.normalTexture = textures[index];
        GLTFMaterialParser2._checkOtherTextureTransform(normalTexture, "Normal");
        if (scale !== void 0) {
          material.normalTextureIntensity = scale;
        }
      }
      if (occlusionTexture) {
        var index1 = occlusionTexture.index, strength = occlusionTexture.strength, texCoord = occlusionTexture.texCoord;
        material.occlusionTexture = textures[index1];
        GLTFMaterialParser2._checkOtherTextureTransform(occlusionTexture, "Occlusion");
        if (strength !== void 0) {
          material.occlusionTextureIntensity = strength;
        }
        if (texCoord === TextureCoordinate.UV1) {
          material.occlusionTextureCoord = TextureCoordinate.UV1;
        } else if (texCoord > TextureCoordinate.UV1) {
          Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
        }
      }
    }
    if (doubleSided) {
      material.renderFace = RenderFace.Double;
    } else {
      material.renderFace = RenderFace.Front;
    }
    switch (alphaMode) {
      case MaterialAlphaMode.OPAQUE:
        material.isTransparent = false;
        break;
      case MaterialAlphaMode.BLEND:
        material.isTransparent = true;
        break;
      case MaterialAlphaMode.MASK:
        material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
        break;
    }
  };
  return GLTFMaterialParser2;
}(GLTFParser);
function _instanceof(left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return !!right[Symbol.hasInstance](left);
  } else
    return left instanceof right;
}
var GLTFMeshParser = /* @__PURE__ */ function(GLTFParser1) {
  _inherits(GLTFMeshParser2, GLTFParser1);
  function GLTFMeshParser2() {
    return GLTFParser1.apply(this, arguments);
  }
  var _proto = GLTFMeshParser2.prototype;
  _proto.parse = function parse2(context) {
    var _loop = function(i2) {
      var _loop2 = function(j3) {
        var gltfPrimitive = gltfMesh.primitives[j3];
        primitivePromises[j3] = new Promise(function(resolve) {
          var mesh = GLTFParser.executeExtensionsCreateAndParse(gltfPrimitive.extensions, context, gltfPrimitive, gltfMesh);
          if (mesh) {
            if (_instanceof(mesh, ModelMesh)) {
              resolve(mesh);
            } else {
              mesh.then(function(mesh2) {
                return resolve(mesh2);
              });
            }
          } else {
            var mesh1 = new ModelMesh(engine, gltfMesh.name || j3 + "");
            var meshRestoreInfo = new ModelMeshRestoreInfo();
            meshRestoreInfo.mesh = mesh1;
            context.contentRestorer.meshes.push(meshRestoreInfo);
            GLTFMeshParser2._parseMeshFromGLTFPrimitive(context, mesh1, meshRestoreInfo, gltfMesh, gltfPrimitive, glTF, function(attributeSemantic) {
              return null;
            }, function(attributeName, shapeIndex) {
              var shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];
              var attributeAccessorIdx = shapeAccessorIdx[attributeName];
              if (attributeAccessorIdx) {
                var accessor = glTF.accessors[attributeAccessorIdx];
                return GLTFUtils.getAccessorBuffer(context, context.glTF.bufferViews, accessor);
              } else {
                return null;
              }
            }, function() {
              var indexAccessor = glTF.accessors[gltfPrimitive.indices];
              return context.getBuffers().then(function(buffers) {
                return GLTFUtils.getAccessorData(glTF, indexAccessor, buffers);
              });
            }, context.keepMeshData).then(resolve);
          }
        });
      };
      var gltfMesh = glTF.meshes[i2];
      var primitivePromises = [];
      for (var j2 = 0; j2 < gltfMesh.primitives.length; j2++)
        _loop2(j2);
      meshPromises[i2] = Promise.all(primitivePromises);
    };
    var glTF = context.glTF, glTFResource = context.glTFResource;
    var engine = glTFResource.engine;
    if (!glTF.meshes)
      return;
    var meshesPromiseInfo = context.meshesPromiseInfo;
    var meshPromises = [];
    for (var i = 0; i < glTF.meshes.length; i++)
      _loop(i);
    AssetPromise.all(meshPromises).then(function(meshes) {
      glTFResource.meshes = meshes;
      meshesPromiseInfo.resolve(meshes);
    }).catch(meshesPromiseInfo.reject);
    return meshesPromiseInfo.promise;
  };
  GLTFMeshParser2._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(context, mesh, meshRestoreInfo, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, keepMeshData) {
    var _loop = function(attribute2) {
      var accessor = accessors[attributes[attribute2]];
      var promise = GLTFUtils.getAccessorBuffer(context, gltf.bufferViews, accessor).then(function(accessorBuffer) {
        var dataElementSize = GLTFUtils.getAccessorTypeSize(accessor.type);
        var accessorCount = accessor.count;
        var vertices = accessorBuffer.data;
        var vertexElement;
        var meshId = mesh.instanceId;
        var vertexBindingInfos = accessorBuffer.vertexBindingInfos;
        var elementNormalized = accessor.normalized;
        var elementFormat = GLTFUtils.getElementFormat(accessor.componentType, dataElementSize, elementNormalized);
        var scaleFactor;
        elementNormalized && (scaleFactor = GLTFUtils.getNormalizedComponentScale(accessor.componentType));
        var elementOffset;
        if (accessorBuffer.interleaved) {
          var byteOffset = accessor.byteOffset || 0;
          var stride = accessorBuffer.stride;
          elementOffset = byteOffset % stride;
          if (vertexBindingInfos[meshId] === void 0) {
            vertexElement = new VertexElement(attribute2, elementOffset, elementFormat, bufferBindIndex);
            var vertexBuffer = accessorBuffer.vertexBuffer;
            if (!vertexBuffer) {
              vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices.byteLength, BufferUsage.Static);
              vertexBuffer.setData(vertices);
              accessorBuffer.vertexBuffer = vertexBuffer;
              meshRestoreInfo.vertexBuffers.push(new BufferRestoreInfo(vertexBuffer, accessorBuffer.restoreInfo));
            }
            mesh.setVertexBufferBinding(vertexBuffer, stride, bufferBindIndex);
            vertexBindingInfos[meshId] = bufferBindIndex++;
          } else {
            vertexElement = new VertexElement(attribute2, elementOffset, elementFormat, vertexBindingInfos[meshId]);
          }
        } else {
          elementOffset = 0;
          vertexElement = new VertexElement(attribute2, elementOffset, elementFormat, bufferBindIndex);
          var vertexBuffer1 = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices.byteLength, BufferUsage.Static);
          vertexBuffer1.setData(vertices);
          meshRestoreInfo.vertexBuffers.push(new BufferRestoreInfo(vertexBuffer1, accessorBuffer.restoreInfo));
          mesh.setVertexBufferBinding(vertexBuffer1, accessorBuffer.stride, bufferBindIndex);
          vertexBindingInfos[meshId] = bufferBindIndex++;
        }
        vertexElements.push(vertexElement);
        if (attribute2 === "POSITION") {
          vertexCount = accessorCount;
          var _mesh_bounds = mesh.bounds, min = _mesh_bounds.min, max = _mesh_bounds.max;
          if (accessor.min && accessor.max) {
            min.copyFromArray(accessor.min);
            max.copyFromArray(accessor.max);
            if (keepMeshData) {
              var baseOffset = elementOffset / vertices.BYTES_PER_ELEMENT;
              var stride1 = vertices.length / accessorCount;
              for (var j2 = 0; j2 < accessorCount; j2++) {
                var offset = baseOffset + j2 * stride1;
                var position = new Vector3(vertices[offset], vertices[offset + 1], vertices[offset + 2]);
                elementNormalized && position.scale(scaleFactor);
                positions[j2] = position;
              }
            }
          } else {
            var position1 = GLTFMeshParser2._tempVector3;
            min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            var baseOffset1 = elementOffset / vertices.BYTES_PER_ELEMENT;
            var stride2 = vertices.length / accessorCount;
            for (var j1 = 0; j1 < accessorCount; j1++) {
              var offset1 = baseOffset1 + j1 * stride2;
              position1.copyFromArray(vertices, offset1);
              Vector3.min(min, position1, min);
              Vector3.max(max, position1, max);
              if (keepMeshData) {
                var clonePosition = position1.clone();
                elementNormalized && clonePosition.scale(scaleFactor);
                positions[j1] = clonePosition;
              }
            }
          }
          if (elementNormalized) {
            min.scale(scaleFactor);
            max.scale(scaleFactor);
          }
        } else if (attribute2 === "JOINTS_0" && keepMeshData) {
          var baseOffset2 = elementOffset / vertices.BYTES_PER_ELEMENT;
          var stride3 = vertices.length / accessorCount;
          for (var j22 = 0; j22 < accessorCount; j22++) {
            var offset2 = baseOffset2 + j22 * stride3;
            var boneIndex = new Vector4(vertices[offset2], vertices[offset2 + 1], vertices[offset2 + 2], vertices[offset2 + 3]);
            elementNormalized && boneIndex.scale(scaleFactor);
            boneIndices[j22] = boneIndex;
          }
        } else if (attribute2 === "WEIGHTS_0" && keepMeshData) {
          var baseOffset3 = elementOffset / vertices.BYTES_PER_ELEMENT;
          var stride4 = vertices.length / accessorCount;
          for (var j3 = 0; j3 < accessorCount; j3++) {
            var offset3 = baseOffset3 + j3 * stride4;
            var boneWeight = new Vector4(vertices[offset3], vertices[offset3 + 1], vertices[offset3 + 2], vertices[offset3 + 3]);
            elementNormalized && boneWeight.scale(scaleFactor);
            boneWeights[j3] = boneWeight;
          }
        }
      });
      promises.push(promise);
    };
    var accessors = gltf.accessors;
    var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
    var engine = mesh.engine;
    var vertexElements = new Array();
    var vertexCount;
    var bufferBindIndex = 0;
    var positions;
    var boneIndices;
    var boneWeights;
    if (keepMeshData) {
      positions = new Array(vertexCount);
      boneIndices = new Array(vertexCount);
      boneWeights = new Array(vertexCount);
    }
    var promises = new Array();
    for (var attribute in attributes)
      _loop(attribute);
    return Promise.all(promises).then(function() {
      mesh.setVertexElements(vertexElements);
      if (indices !== void 0) {
        var indexAccessor = gltf.accessors[indices];
        var promise = GLTFUtils.getAccessorBuffer(context, gltf.bufferViews, indexAccessor).then(function(accessorBuffer) {
          mesh.setIndices(accessorBuffer.data);
          mesh.addSubMesh(0, indexAccessor.count, mode);
          meshRestoreInfo.indexBuffer = accessorBuffer.restoreInfo;
        });
        promises.push(promise);
      } else {
        mesh.addSubMesh(0, vertexCount, mode);
      }
      if (targets) {
        promises.push(GLTFMeshParser2._createBlendShape(mesh, meshRestoreInfo, gltfMesh, accessors, targets, getBlendShapeData));
      }
      return Promise.all(promises).then(function() {
        mesh.uploadData(!keepMeshData);
        mesh._positions = positions;
        mesh._boneIndices = boneIndices;
        mesh._boneWeights = boneWeights;
        return Promise.resolve(mesh);
      });
    });
  };
  GLTFMeshParser2._createBlendShape = function _createBlendShape(mesh, meshRestoreInfo, glTFMesh, accessors, glTFTargets, getBlendShapeData) {
    var _loop = function(i2, n2) {
      var name2 = blendShapeNames ? blendShapeNames[i2] : "blendShape" + i2;
      var promise = Promise.all([
        getBlendShapeData("POSITION", i2),
        getBlendShapeData("NORMAL", i2),
        getBlendShapeData("TANGENT", i2)
      ]).then(function(infos) {
        var posBufferInfo = infos[0];
        var norBufferInfo = infos[1];
        var tanBufferInfo = infos[2];
        var target = glTFTargets[i2];
        var posAccessor;
        var norAccessor;
        var tanAccessor;
        var positions = null;
        if (posBufferInfo) {
          posAccessor = accessors[target["POSITION"]];
          var _posAccessor_byteOffset;
          positions = GLTFUtils.bufferToVector3Array(posBufferInfo.data, posBufferInfo.stride, (_posAccessor_byteOffset = posAccessor.byteOffset) != null ? _posAccessor_byteOffset : 0, posAccessor.count);
        }
        var normals = null;
        if (norBufferInfo) {
          norAccessor = accessors[target["NORMAL"]];
          var _norAccessor_byteOffset;
          normals = GLTFUtils.bufferToVector3Array(norBufferInfo.data, norBufferInfo.stride, (_norAccessor_byteOffset = norAccessor.byteOffset) != null ? _norAccessor_byteOffset : 0, norAccessor.count);
        }
        var tangents = null;
        if (tanBufferInfo) {
          tanAccessor = accessors[target["NORMAL"]];
          var _tanAccessor_byteOffset;
          tangents = GLTFUtils.bufferToVector3Array(tanBufferInfo.data, tanBufferInfo.stride, (_tanAccessor_byteOffset = tanAccessor.byteOffset) != null ? _tanAccessor_byteOffset : 0, tanAccessor.count);
        }
        var blendShape = new BlendShape(name2);
        blendShape.addFrame(1, positions, normals, tangents);
        mesh.addBlendShape(blendShape);
        var _posAccessor_byteOffset1, _norAccessor_byteOffset1, _tanAccessor_byteOffset1;
        meshRestoreInfo.blendShapes.push(new BlendShapeRestoreInfo(blendShape, new BlendShapeDataRestoreInfo(posBufferInfo.restoreInfo, posBufferInfo.stride, (_posAccessor_byteOffset1 = posAccessor.byteOffset) != null ? _posAccessor_byteOffset1 : 0, posAccessor.count), norBufferInfo ? new BlendShapeDataRestoreInfo(norBufferInfo.restoreInfo, norBufferInfo.stride, (_norAccessor_byteOffset1 = norAccessor.byteOffset) != null ? _norAccessor_byteOffset1 : 0, norAccessor.count) : null, tanBufferInfo ? new BlendShapeDataRestoreInfo(tanBufferInfo.restoreInfo, tanBufferInfo.stride, (_tanAccessor_byteOffset1 = tanAccessor.byteOffset) != null ? _tanAccessor_byteOffset1 : 0, tanAccessor.count) : null));
      });
      promises.push(promise);
    };
    var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;
    var promises = new Array();
    for (var i = 0, n = glTFTargets.length; i < n; i++)
      _loop(i);
    return Promise.all(promises);
  };
  return GLTFMeshParser2;
}(GLTFParser);
(function() {
  GLTFMeshParser._tempVector3 = new Vector3();
})();
var GLTFSceneParser = /* @__PURE__ */ function(GLTFParser1) {
  _inherits(GLTFSceneParser2, GLTFParser1);
  function GLTFSceneParser2() {
    return GLTFParser1.apply(this, arguments);
  }
  var _proto = GLTFSceneParser2.prototype;
  _proto.parse = function parse2(context) {
    var glTFResource = context.glTFResource, glTF = context.glTF;
    var entities = glTFResource.entities;
    var nodes = glTF.nodes, cameras = glTF.cameras;
    if (!nodes)
      return;
    var defaultSceneRootPromiseInfo = context.defaultSceneRootPromiseInfo;
    for (var i = 0; i < nodes.length; i++) {
      var glTFNode = nodes[i];
      var cameraID = glTFNode.camera, meshID = glTFNode.mesh, extensions = glTFNode.extensions;
      var entity = entities[i];
      if (cameraID !== void 0) {
        this._createCamera(glTFResource, cameras[cameraID], entity);
      }
      if (meshID !== void 0) {
        this._createRenderer(context, glTFNode, entity);
      }
      GLTFParser.executeExtensionsAdditiveAndParse(extensions, context, entity, glTFNode);
    }
    if (glTFResource.defaultSceneRoot) {
      this._createAnimator(context);
    }
    defaultSceneRootPromiseInfo.resolve(glTFResource.defaultSceneRoot);
    return defaultSceneRootPromiseInfo.promise;
  };
  _proto._createCamera = function _createCamera(context, cameraSchema, entity) {
    var orthographic = cameraSchema.orthographic, perspective = cameraSchema.perspective, type = cameraSchema.type;
    var camera = entity.addComponent(Camera);
    if (type === CameraType.ORTHOGRAPHIC) {
      var xmag = orthographic.xmag, ymag = orthographic.ymag, zfar = orthographic.zfar, znear = orthographic.znear;
      camera.isOrthographic = true;
      if (znear !== void 0) {
        camera.nearClipPlane = znear;
      }
      if (zfar !== void 0) {
        camera.farClipPlane = zfar;
      }
      camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
    } else if (type === CameraType.PERSPECTIVE) {
      var aspectRatio = perspective.aspectRatio, yfov = perspective.yfov, zfar1 = perspective.zfar, znear1 = perspective.znear;
      if (aspectRatio !== void 0) {
        camera.aspectRatio = aspectRatio;
      }
      if (yfov !== void 0) {
        camera.fieldOfView = yfov * 180 / Math.PI;
      }
      if (zfar1 !== void 0) {
        camera.farClipPlane = zfar1;
      }
      if (znear1 !== void 0) {
        camera.nearClipPlane = znear1;
      }
    }
    if (!context.cameras)
      context.cameras = [];
    context.cameras.push(camera);
    camera.enabled = false;
  };
  _proto._createRenderer = function _createRenderer(context, glTFNode, entity) {
    var _loop = function(i2) {
      var gltfPrimitive = glTFMeshPrimitives[i2];
      var mesh = meshes[meshID][i2];
      var renderer = void 0;
      if (skinID !== void 0 || blendShapeWeights) {
        context.hasSkinned = true;
        var skinRenderer = entity.addComponent(SkinnedMeshRenderer);
        skinRenderer.mesh = mesh;
        if (skinID !== void 0) {
          skinRenderer.skin = skins[skinID];
        }
        if (blendShapeWeights) {
          skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
        }
        renderer = skinRenderer;
      } else {
        renderer = entity.addComponent(MeshRenderer);
        renderer.mesh = mesh;
      }
      var materialIndex = gltfPrimitive.material;
      var material = (materials == null ? void 0 : materials[materialIndex]) || GLTFSceneParser2._getDefaultMaterial(engine);
      renderer.setMaterial(material);
      mesh.vertexElements.forEach(function(element) {
        if (element.semantic === "COLOR_0") {
          renderer.enableVertexColor = true;
        }
      });
      GLTFParser.executeExtensionsAdditiveAndParse(gltfPrimitive.extensions, context, renderer, gltfPrimitive);
    };
    var glTFResource = context.glTFResource, glTF = context.glTF;
    var glTFMeshes = glTF.meshes;
    var engine = glTFResource.engine, meshes = glTFResource.meshes, materials = glTFResource.materials, skins = glTFResource.skins;
    var meshID = glTFNode.mesh, skinID = glTFNode.skin;
    var glTFMesh = glTFMeshes[meshID];
    var glTFMeshPrimitives = glTFMesh.primitives;
    var blendShapeWeights = glTFNode.weights || glTFMesh.weights;
    for (var i = 0; i < glTFMeshPrimitives.length; i++)
      _loop(i);
  };
  _proto._createAnimator = function _createAnimator(context) {
    if (!context.hasSkinned && !context.glTFResource.animations) {
      return;
    }
    var _context_glTFResource = context.glTFResource, defaultSceneRoot = _context_glTFResource.defaultSceneRoot, animations = _context_glTFResource.animations;
    var animator = defaultSceneRoot.addComponent(Animator);
    var animatorController = new AnimatorController();
    var layer = new AnimatorControllerLayer("layer");
    var animatorStateMachine = new AnimatorStateMachine();
    animatorController.addLayer(layer);
    animator.animatorController = animatorController;
    layer.stateMachine = animatorStateMachine;
    if (animations) {
      for (var i = 0; i < animations.length; i++) {
        var animationClip = animations[i];
        var name2 = animationClip.name;
        var uniqueName = animatorStateMachine.makeUniqueStateName(name2);
        if (uniqueName !== name2) {
          console.warn("AnimatorState name is existed, name: " + name2 + " reset to " + uniqueName);
        }
        var animatorState = animatorStateMachine.addState(uniqueName);
        animatorState.clip = animationClip;
      }
    }
  };
  GLTFSceneParser2._getDefaultMaterial = function _getDefaultMaterial(engine) {
    if (!GLTFSceneParser2._defaultMaterial) {
      GLTFSceneParser2._defaultMaterial = new BlinnPhongMaterial(engine);
    }
    return GLTFSceneParser2._defaultMaterial;
  };
  return GLTFSceneParser2;
}(GLTFParser);
var GLTFSkinParser = /* @__PURE__ */ function(GLTFParser2) {
  _inherits(GLTFSkinParser2, GLTFParser2);
  function GLTFSkinParser2() {
    return GLTFParser2.apply(this, arguments);
  }
  var _proto = GLTFSkinParser2.prototype;
  _proto.parse = function parse2(context) {
    var _loop = function(i2) {
      var _gltfSkins_i = gltfSkins[i2], inverseBindMatrices = _gltfSkins_i.inverseBindMatrices, skeleton = _gltfSkins_i.skeleton, joints = _gltfSkins_i.joints, _gltfSkins_i_name = _gltfSkins_i.name, name2 = _gltfSkins_i_name === void 0 ? "SKIN_" + i2 : _gltfSkins_i_name;
      var jointCount = joints.length;
      var skin = new Skin(name2);
      skin.inverseBindMatrices.length = jointCount;
      var accessor = glTF.accessors[inverseBindMatrices];
      var promise = GLTFUtils.getAccessorBuffer(context, glTF.bufferViews, accessor).then(function(bufferInfo) {
        var buffer = bufferInfo.data;
        for (var i3 = 0; i3 < jointCount; i3++) {
          var inverseBindMatrix = new Matrix();
          inverseBindMatrix.copyFromArray(buffer, i3 * 16);
          skin.inverseBindMatrices[i3] = inverseBindMatrix;
          for (var i1 = 0; i1 < jointCount; i1++) {
            var jointIndex = joints[i1];
            var jointName = entities[jointIndex].name;
            skin.joints[i1] = jointName;
            for (var j2 = entities.length - 1; j2 >= 0; j2--) {
              if (jointIndex !== j2 && entities[j2].name === jointName) {
                entities[j2].name = jointName + "_" + j2;
              }
            }
          }
          if (skeleton !== void 0) {
            skin.skeleton = entities[skeleton].name;
          } else {
            var rootBone = _this._findSkeletonRootBone(joints, entities);
            if (rootBone) {
              skin.skeleton = rootBone.name;
            } else {
              throw "Failed to find skeleton root bone.";
            }
          }
        }
        return skin;
      });
      promises.push(promise);
    };
    var _this = this;
    var glTFResource = context.glTFResource, glTF = context.glTF;
    var entities = glTFResource.entities;
    var gltfSkins = glTF.skins;
    if (!gltfSkins)
      return;
    var count = gltfSkins.length;
    var promises = new Array();
    for (var i = 0; i < count; i++)
      _loop(i);
    return AssetPromise.all(promises).then(function(skins) {
      glTFResource.skins = skins;
    });
  };
  _proto._findSkeletonRootBone = function _findSkeletonRootBone(joints, entities) {
    var paths = {};
    for (var _iterator = _create_for_of_iterator_helper_loose(joints), _step; !(_step = _iterator()).done; ) {
      var index = _step.value;
      var path = new Array();
      var entity = entities[index];
      while (entity) {
        path.unshift(entity);
        entity = entity.parent;
      }
      paths[index] = path;
    }
    var rootNode = null;
    for (var i = 0; ; i++) {
      var path1 = paths[joints[0]];
      if (i >= path1.length) {
        return rootNode;
      }
      var entity1 = path1[i];
      for (var j2 = 1, m = joints.length; j2 < m; j2++) {
        path1 = paths[joints[j2]];
        if (i >= path1.length || entity1 !== path1[i]) {
          return rootNode;
        }
      }
      rootNode = entity1;
    }
  };
  return GLTFSkinParser2;
}(GLTFParser);
var GLTFTextureParser = /* @__PURE__ */ function(GLTFParser2) {
  _inherits(GLTFTextureParser2, GLTFParser2);
  function GLTFTextureParser2() {
    return GLTFParser2.apply(this, arguments);
  }
  var _proto = GLTFTextureParser2.prototype;
  _proto.parse = function parse2(context) {
    var _this = this;
    var glTFResource = context.glTFResource, glTF = context.glTF;
    var engine = glTFResource.engine, url = glTFResource.url;
    if (glTF.textures) {
      var texturesPromiseInfo = context.texturesPromiseInfo;
      AssetPromise.all(glTF.textures.map(function(param, index) {
        var sampler = param.sampler, _param_source = param.source, source = _param_source === void 0 ? 0 : _param_source, textureName = param.name;
        var _glTF_images_source = glTF.images[source], uri = _glTF_images_source.uri, bufferViewIndex = _glTF_images_source.bufferView, mimeType2 = _glTF_images_source.mimeType, imageName = _glTF_images_source.name;
        var samplerInfo = sampler !== void 0 && _this._getSamplerInfo(glTF.samplers[sampler]);
        if (uri) {
          var index1 = uri.lastIndexOf(".");
          var ext = uri.substring(index1 + 1);
          var type = ext.startsWith("ktx") ? AssetType.KTX : AssetType.Texture2D;
          return engine.resourceManager.load({
            url: Utils.resolveAbsoluteUrl(url, uri),
            type,
            params: {
              mipmap: samplerInfo == null ? void 0 : samplerInfo.mipmap
            }
          }).then(function(texture) {
            texture.name = textureName || imageName || texture.name || "texture_" + index1;
            if (sampler !== void 0) {
              _this._parseSampler(texture, samplerInfo);
            }
            return texture;
          });
        } else {
          var bufferView = glTF.bufferViews[bufferViewIndex];
          return context.getBuffers().then(function(buffers) {
            var buffer = buffers[bufferView.buffer];
            var imageBuffer = new Uint8Array(buffer, bufferView.byteOffset, bufferView.byteLength);
            return GLTFUtils.loadImageBuffer(imageBuffer, mimeType2).then(function(image) {
              var texture = new Texture2D(engine, image.width, image.height, void 0, samplerInfo == null ? void 0 : samplerInfo.mipmap);
              texture.setImageSource(image);
              texture.generateMipmaps();
              texture.name = textureName || imageName || "texture_" + index;
              if (sampler !== void 0) {
                _this._parseSampler(texture, samplerInfo);
              }
              var bufferTextureRestoreInfo = new BufferTextureRestoreInfo(texture, bufferView, mimeType2);
              context.contentRestorer.bufferTextures.push(bufferTextureRestoreInfo);
              return texture;
            });
          });
        }
      })).then(function(textures) {
        glTFResource.textures = textures;
        texturesPromiseInfo.resolve(textures);
      }).catch(texturesPromiseInfo.reject);
      return texturesPromiseInfo.promise;
    }
  };
  _proto._getSamplerInfo = function _getSamplerInfo(sampler) {
    var minFilter = sampler.minFilter, magFilter = sampler.magFilter, wrapS = sampler.wrapS, wrapT = sampler.wrapT;
    var info2 = {};
    if (minFilter || magFilter) {
      info2.mipmap = minFilter >= TextureMinFilter.NEAREST_MIPMAP_NEAREST;
      if (magFilter === TextureMagFilter.NEAREST) {
        info2.filterMode = TextureFilterMode.Point;
      } else {
        if (minFilter <= TextureMinFilter.LINEAR_MIPMAP_NEAREST) {
          info2.filterMode = TextureFilterMode.Bilinear;
        } else {
          info2.filterMode = TextureFilterMode.Trilinear;
        }
      }
    }
    if (wrapS) {
      info2.wrapModeU = GLTFTextureParser2._wrapMap[wrapS];
    }
    if (wrapT) {
      info2.wrapModeV = GLTFTextureParser2._wrapMap[wrapT];
    }
    return info2;
  };
  _proto._parseSampler = function _parseSampler(texture, samplerInfo) {
    var filterMode = samplerInfo.filterMode, wrapModeU = samplerInfo.wrapModeU, wrapModeV = samplerInfo.wrapModeV;
    if (filterMode !== void 0) {
      texture.filterMode = filterMode;
    }
    if (wrapModeU !== void 0) {
      texture.wrapModeU = wrapModeU;
    }
    if (wrapModeV !== void 0) {
      texture.wrapModeV = wrapModeV;
    }
  };
  return GLTFTextureParser2;
}(GLTFParser);
(function() {
  var _obj;
  GLTFTextureParser._wrapMap = (_obj = {}, _obj[TextureWrapMode.CLAMP_TO_EDGE] = TextureWrapMode$1.Clamp, _obj[TextureWrapMode.MIRRORED_REPEAT] = TextureWrapMode$1.Mirror, _obj[TextureWrapMode.REPEAT] = TextureWrapMode$1.Repeat, _obj);
})();
var GLTFValidator = /* @__PURE__ */ function(GLTFParser1) {
  _inherits(GLTFValidator2, GLTFParser1);
  function GLTFValidator2() {
    return GLTFParser1.apply(this, arguments);
  }
  var _proto = GLTFValidator2.prototype;
  _proto.parse = function parse2(context) {
    var _context_glTF = context.glTF, version2 = _context_glTF.asset.version, extensionsUsed = _context_glTF.extensionsUsed, extensionsRequired = _context_glTF.extensionsRequired;
    var glTFVersion = Number(version2);
    if (!(glTFVersion >= 2 && glTFVersion < 3)) {
      throw "Only support glTF 2.x.";
    }
    var promises = [];
    if (extensionsUsed) {
      Logger.info("extensionsUsed: ", extensionsUsed);
      for (var i = 0; i < extensionsUsed.length; i++) {
        var extensionUsed = extensionsUsed[i];
        if (!GLTFParser.hasExtensionParser(extensionUsed)) {
          Logger.warn("Extension " + extensionUsed + " is not implemented, you can customize this extension in gltf.");
        }
      }
    }
    if (extensionsRequired) {
      Logger.info("extensionsRequired: " + extensionsRequired);
      for (var i1 = 0; i1 < extensionsRequired.length; i1++) {
        var extensionRequired = extensionsRequired[i1];
        if (!GLTFParser.hasExtensionParser(extensionRequired)) {
          Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
        } else {
          promises.push(GLTFParser.executeExtensionsInitialize(extensionRequired));
        }
      }
    }
    return AssetPromise.all(promises).then(null);
  };
  return GLTFValidator2;
}(GLTFParser);
var GLTFPipeline = /* @__PURE__ */ function() {
  function GLTFPipeline2() {
    for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {
      parsers[_key] = arguments[_key];
    }
    var _this = this;
    this._parsers = [];
    parsers.forEach(function(pipe, index) {
      _this._parsers[index] = new pipe();
    });
  }
  var _proto = GLTFPipeline2.prototype;
  _proto._parse = function _parse(context) {
    var _this = this;
    var glTFResource = context.glTFResource;
    var lastParser;
    return new AssetPromise(function(resolve, reject) {
      _this._parsers.forEach(function(parser) {
        if (lastParser) {
          lastParser = lastParser.then(function() {
            return parser.parse(context);
          });
          if (lastParser.cancel) {
            context.chainPromises.push(lastParser);
          }
        } else {
          lastParser = parser.parse(context);
        }
      });
      if (lastParser) {
        lastParser.then(function() {
          resolve(glTFResource);
        }).catch(reject);
      }
    });
  };
  return GLTFPipeline2;
}();
(function() {
  GLTFPipeline.defaultPipeline = new GLTFPipeline(GLTFBufferParser, GLTFValidator, GLTFTextureParser, GLTFMaterialParser, GLTFMeshParser, GLTFEntityParser, GLTFSkinParser, GLTFAnimationParser, GLTFSceneParser);
})();
var GLTFResource = /* @__PURE__ */ function(ReferResource2) {
  _inherits(GLTFResource2, ReferResource2);
  function GLTFResource2(engine, url) {
    var _this;
    _this = ReferResource2.call(this, engine) || this;
    _this.url = url;
    return _this;
  }
  return GLTFResource2;
}(ReferResource);
var GLTFLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(GLTFLoader2, Loader2);
  function GLTFLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = GLTFLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var url = item.url;
    var params = item.params;
    var context = new GLTFParserContext(url);
    var glTFResource = new GLTFResource(resourceManager.engine, url);
    var restorer = new GLTFContentRestorer(glTFResource);
    var masterPromiseInfo = context.masterPromiseInfo;
    context.contentRestorer = restorer;
    context.glTFResource = glTFResource;
    var _params_keepMeshData;
    context.keepMeshData = (_params_keepMeshData = params == null ? void 0 : params.keepMeshData) != null ? _params_keepMeshData : false;
    masterPromiseInfo.onCancel(function() {
      var chainPromises = context.chainPromises;
      for (var _iterator = _create_for_of_iterator_helper_loose(chainPromises), _step; !(_step = _iterator()).done; ) {
        var promise = _step.value;
        promise.cancel();
      }
    });
    ((params == null ? void 0 : params.pipeline) || GLTFPipeline.defaultPipeline)._parse(context).then(function(glTFResource2) {
      resourceManager.addContentRestorer(restorer);
      masterPromiseInfo.resolve(glTFResource2);
    }).catch(function(e) {
      var msg = "Error loading glTF model from " + url + " : " + e;
      Logger.error(msg);
      masterPromiseInfo.reject(msg);
      context.defaultSceneRootPromiseInfo.reject(e);
      context.texturesPromiseInfo.reject(e);
      context.materialsPromiseInfo.reject(e);
      context.meshesPromiseInfo.reject(e);
      context.animationClipsPromiseInfo.reject(e);
    });
    return context.promiseMap;
  };
  return GLTFLoader2;
}(Loader);
GLTFLoader = __decorate$1([
  resourceLoader(AssetType.GLTF, [
    "gltf",
    "glb"
  ])
], GLTFLoader);
var _HDRLoader;
var PI = Math.PI;
var HDRLoader = (_HDRLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(HDRLoader1, Loader2);
  function HDRLoader1() {
    return Loader2.apply(this, arguments);
  }
  var _proto = HDRLoader1.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      var engine = resourceManager.engine;
      _this.request(item.url, {
        type: "arraybuffer"
      }).then(function(buffer) {
        var uint8Array = new Uint8Array(buffer);
        var _HDRLoader__parseHeader = HDRLoader._parseHeader(uint8Array), width = _HDRLoader__parseHeader.width, height = _HDRLoader__parseHeader.height, dataPosition = _HDRLoader__parseHeader.dataPosition;
        var pixels = HDRLoader._readPixels(uint8Array.subarray(dataPosition), width, height);
        var cubeSize = height >> 1;
        var cubeMapData = HDRLoader._convertToCubemap(pixels, width, height, cubeSize);
        var texture = new TextureCube(engine, cubeSize);
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          texture.setPixelBuffer(TextureCubeFace.PositiveX + faceIndex, cubeMapData[faceIndex], 0);
        }
        texture.generateMipmaps();
        resolve(texture);
      }).catch(reject);
    });
  };
  HDRLoader1._convertToCubemap = function _convertToCubemap(pixels, inputWidth, inputHeight, size) {
    if (!pixels) {
      throw "ConvertPanoramaToCubemap: input cannot be null";
    }
    if (pixels.length != inputWidth * inputHeight * 4) {
      throw "ConvertPanoramaToCubemap: input size is wrong";
    }
    var textureRight = this._createCubemapData(size, this._faceRight, pixels, inputWidth, inputHeight);
    var textureLeft = this._createCubemapData(size, this._faceLeft, pixels, inputWidth, inputHeight);
    var textureUp = this._createCubemapData(size, this._faceUp, pixels, inputWidth, inputHeight);
    var textureDown = this._createCubemapData(size, this._faceBottom, pixels, inputWidth, inputHeight);
    var textureFront = this._createCubemapData(size, this._faceFront, pixels, inputWidth, inputHeight);
    var textureBack = this._createCubemapData(size, this._faceBack, pixels, inputWidth, inputHeight);
    return [
      textureRight,
      textureLeft,
      textureUp,
      textureDown,
      textureFront,
      textureBack
    ];
  };
  HDRLoader1._createCubemapData = function _createCubemapData(texSize, faceData, pixels, inputWidth, inputHeight) {
    var textureArray = new Uint8ClampedArray(texSize * texSize * 4);
    var rotDX1 = this._tempVector3.set(0, 0, 0).add(faceData[1]).subtract(faceData[0]).scale(1 / texSize);
    var rotDX2 = this._temp2Vector3.set(0, 0, 0).add(faceData[3]).subtract(faceData[2]).scale(1 / texSize);
    var dy = 1 / texSize;
    var fy = 0;
    for (var y = 0; y < texSize; y++) {
      var xv1 = this._temp3Vector3.set(0, 0, 0).add(faceData[0]);
      var xv2 = this._temp4Vector3.set(0, 0, 0).add(faceData[2]);
      for (var x = 0; x < texSize; x++) {
        var v = this._temp5Vector3.set(0, 0, 0).add(xv2).subtract(xv1).scale(fy).add(xv1);
        v.normalize();
        var color = this._calcProjectionSpherical(v, pixels, inputWidth, inputHeight);
        this._RGBEToLinear(color);
        this._linearToRGBM(color, 5);
        var index = y * texSize * 4 + x * 4;
        textureArray[index] = color.r;
        textureArray[index + 1] = color.g;
        textureArray[index + 2] = color.b;
        textureArray[index + 3] = color.a;
        xv1.add(rotDX1);
        xv2.add(rotDX2);
      }
      fy += dy;
    }
    return textureArray;
  };
  HDRLoader1._calcProjectionSpherical = function _calcProjectionSpherical(vDir, pixels, inputWidth, inputHeight) {
    var theta = Math.atan2(vDir.z, vDir.x);
    var phi = Math.acos(vDir.y);
    while (theta < -PI) {
      theta += 2 * PI;
    }
    while (theta > PI) {
      theta -= 2 * PI;
    }
    var dx = theta / PI;
    var dy = phi / PI;
    dx = dx * 0.5 + 0.5;
    var px = Math.round(dx * inputWidth);
    if (px < 0) {
      px = 0;
    } else if (px >= inputWidth) {
      px = inputWidth - 1;
    }
    var py = Math.round(dy * inputHeight);
    if (py < 0) {
      py = 0;
    } else if (py >= inputHeight) {
      py = inputHeight - 1;
    }
    var inputY = inputHeight - py - 1;
    var index = inputY * inputWidth * 4 + px * 4;
    var r = pixels[index];
    var g = pixels[index + 1];
    var b = pixels[index + 2];
    var a = pixels[index + 3];
    return new Color$1(r, g, b, a);
  };
  HDRLoader1._readStringLine = function _readStringLine(uint8array, startIndex) {
    var line = "";
    var character = "";
    for (var i = startIndex; i < uint8array.length - startIndex; i++) {
      character = String.fromCharCode(uint8array[i]);
      if (character == "\n") {
        break;
      }
      line += character;
    }
    return line;
  };
  HDRLoader1._parseHeader = function _parseHeader(uint8array) {
    var height = 0;
    var width = 0;
    var line = this._readStringLine(uint8array, 0);
    if (line[0] != "#" || line[1] != "?") {
      throw "Bad HDR Format.";
    }
    var endOfHeader = false;
    var findFormat = false;
    var lineIndex = 0;
    do {
      lineIndex += line.length + 1;
      line = this._readStringLine(uint8array, lineIndex);
      if (line == "FORMAT=32-bit_rle_rgbe") {
        findFormat = true;
      } else if (line.length == 0) {
        endOfHeader = true;
      }
    } while (!endOfHeader);
    if (!findFormat) {
      throw "HDR Bad header format, unsupported FORMAT";
    }
    lineIndex += line.length + 1;
    line = this._readStringLine(uint8array, lineIndex);
    var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
    var match = sizeRegexp.exec(line);
    if (!match || match.length < 3) {
      throw "HDR Bad header format, no size";
    }
    width = parseInt(match[2]);
    height = parseInt(match[1]);
    if (width < 8 || width > 32767) {
      throw "HDR Bad header format, unsupported size";
    }
    lineIndex += line.length + 1;
    return {
      height,
      width,
      dataPosition: lineIndex
    };
  };
  HDRLoader1._readPixels = function _readPixels(buffer, width, height) {
    var scanLineWidth = width;
    var byteLength = buffer.byteLength;
    var dataRGBA = new Uint8Array(4 * width * height);
    var offset = 0, pos = 0;
    var ptrEnd = 4 * scanLineWidth;
    var rgbeStart = new Uint8Array(4);
    var scanLineBuffer = new Uint8Array(ptrEnd);
    var numScanLines = height;
    while (numScanLines > 0 && pos < byteLength) {
      rgbeStart[0] = buffer[pos++];
      rgbeStart[1] = buffer[pos++];
      rgbeStart[2] = buffer[pos++];
      rgbeStart[3] = buffer[pos++];
      if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanLineWidth) {
        throw "HDR Bad header format, wrong scan line width";
      }
      var ptr = 0, count = void 0;
      while (ptr < ptrEnd && pos < byteLength) {
        count = buffer[pos++];
        var isEncodedRun = count > 128;
        if (isEncodedRun)
          count -= 128;
        if (0 === count || ptr + count > ptrEnd) {
          throw "HDR Bad Format, bad scanline data (run)";
        }
        if (isEncodedRun) {
          var byteValue = buffer[pos++];
          for (var i = 0; i < count; i++) {
            scanLineBuffer[ptr++] = byteValue;
          }
        } else {
          scanLineBuffer.set(buffer.subarray(pos, pos + count), ptr);
          ptr += count;
          pos += count;
        }
      }
      var l = scanLineWidth;
      for (var i1 = 0; i1 < l; i1++) {
        var off = 0;
        dataRGBA[offset] = scanLineBuffer[i1 + off];
        off += scanLineWidth;
        dataRGBA[offset + 1] = scanLineBuffer[i1 + off];
        off += scanLineWidth;
        dataRGBA[offset + 2] = scanLineBuffer[i1 + off];
        off += scanLineWidth;
        dataRGBA[offset + 3] = scanLineBuffer[i1 + off];
        offset += 4;
      }
      numScanLines--;
    }
    return dataRGBA;
  };
  HDRLoader1._RGBEToLinear = function _RGBEToLinear(color) {
    var scaleFactor = Math.pow(2, color.a - 128) / 255;
    color.r *= scaleFactor;
    color.g *= scaleFactor;
    color.b *= scaleFactor;
    color.a = 1;
  };
  HDRLoader1._linearToRGBM = function _linearToRGBM(color, maxRange) {
    var maxRGB = Math.max(color.r, Math.max(color.g, color.b));
    var M2 = Math.min(maxRGB / maxRange, 1);
    M2 = Math.ceil(M2 * 255);
    var scaleFactor = 65025 / (M2 * maxRange);
    color.r *= scaleFactor;
    color.g *= scaleFactor;
    color.b *= scaleFactor;
    color.a *= M2;
  };
  return HDRLoader1;
}(Loader), function() {
  _HDRLoader._rightBottomBack = new Vector3(1, -1, -1);
}(), function() {
  _HDRLoader._rightBottomFront = new Vector3(1, -1, 1);
}(), function() {
  _HDRLoader._rightUpBack = new Vector3(1, 1, -1);
}(), function() {
  _HDRLoader._rightUpFront = new Vector3(1, 1, 1);
}(), function() {
  _HDRLoader._leftBottomBack = new Vector3(-1, -1, -1);
}(), function() {
  _HDRLoader._leftBottomFront = new Vector3(-1, -1, 1);
}(), function() {
  _HDRLoader._leftUpBack = new Vector3(-1, 1, -1);
}(), function() {
  _HDRLoader._leftUpFront = new Vector3(-1, 1, 1);
}(), function() {
  _HDRLoader._faceRight = [
    _HDRLoader._rightBottomBack,
    _HDRLoader._rightBottomFront,
    _HDRLoader._rightUpBack,
    _HDRLoader._rightUpFront
  ];
}(), function() {
  _HDRLoader._faceLeft = [
    _HDRLoader._leftBottomFront,
    _HDRLoader._leftBottomBack,
    _HDRLoader._leftUpFront,
    _HDRLoader._leftUpBack
  ];
}(), function() {
  _HDRLoader._faceUp = [
    _HDRLoader._leftBottomFront,
    _HDRLoader._rightBottomFront,
    _HDRLoader._leftBottomBack,
    _HDRLoader._rightBottomBack
  ];
}(), function() {
  _HDRLoader._faceBottom = [
    _HDRLoader._leftUpBack,
    _HDRLoader._rightUpBack,
    _HDRLoader._leftUpFront,
    _HDRLoader._rightUpFront
  ];
}(), function() {
  _HDRLoader._faceFront = [
    _HDRLoader._leftBottomBack,
    _HDRLoader._rightBottomBack,
    _HDRLoader._leftUpBack,
    _HDRLoader._rightUpBack
  ];
}(), function() {
  _HDRLoader._faceBack = [
    _HDRLoader._rightBottomFront,
    _HDRLoader._leftBottomFront,
    _HDRLoader._rightUpFront,
    _HDRLoader._leftUpFront
  ];
}(), function() {
  _HDRLoader._tempVector3 = new Vector3();
}(), function() {
  _HDRLoader._temp2Vector3 = new Vector3();
}(), function() {
  _HDRLoader._temp3Vector3 = new Vector3();
}(), function() {
  _HDRLoader._temp4Vector3 = new Vector3();
}(), function() {
  _HDRLoader._temp5Vector3 = new Vector3();
}(), _HDRLoader);
HDRLoader = __decorate$1([
  resourceLoader(AssetType.HDR, [
    "hdr"
  ])
], HDRLoader);
var JSONLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(JSONLoader2, Loader2);
  function JSONLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = JSONLoader2.prototype;
  _proto.load = function load2(item) {
    return this.request(item.url, _extends({}, item, {
      type: "json"
    }));
  };
  return JSONLoader2;
}(Loader);
JSONLoader = __decorate$1([
  resourceLoader(AssetType.JSON, [
    "json"
  ], false)
], JSONLoader);
var HEADER_LEN = 12 + 13 * 4;
var COMPRESSED_2D = 0;
function getMipmaps(ktxContainer, loadMipmaps) {
  var mipmaps = [];
  var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
  var width = ktxContainer.pixelWidth;
  var height = ktxContainer.pixelHeight;
  var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
  for (var level = 0; level < mipmapCount; level++) {
    var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0];
    dataOffset += 4;
    for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
      var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
      mipmaps.push({
        data: byteArray,
        width,
        height
      });
      dataOffset += imageSize;
      dataOffset += 3 - (imageSize + 3) % 4;
    }
    width = Math.max(1, width * 0.5);
    height = Math.max(1, height * 0.5);
  }
  return mipmaps;
}
function isValid(data) {
  if (data.byteLength >= 12) {
    var identifier = new Uint8Array(data, 0, 12);
    if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
      return true;
    }
  }
  return false;
}
function getEngineFormat(internalFormat) {
  switch (internalFormat) {
    case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
      return TextureFormat.DXT1;
    case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
      return TextureFormat.DXT5;
    case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
      return TextureFormat.ETC1_RGB;
    case GLCompressedTextureInternalFormat.RGB8_ETC2:
      return TextureFormat.ETC2_RGB;
    case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return TextureFormat.ETC2_RGBA5;
    case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
      return TextureFormat.ETC2_RGBA8;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGB2;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA2;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGB4;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
      return TextureFormat.ASTC_4x4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
      return TextureFormat.ASTC_5x5;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
      return TextureFormat.ASTC_6x6;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
      return TextureFormat.ASTC_8x8;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
      return TextureFormat.ASTC_10x10;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
      return TextureFormat.ASTC_12x12;
    default:
      var formatName = GLCompressedTextureInternalFormat[internalFormat];
      throw new Error("this format is not supported in Galacean Engine: " + formatName);
  }
}
var khronosTextureContainerParser = {
  parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
    if (mapEngineFormat === void 0)
      mapEngineFormat = false;
    if (!isValid(buffer)) {
      throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
    }
    var dataSize = Uint32Array.BYTES_PER_ELEMENT;
    var headerDataView = new DataView(buffer, 12, 13 * dataSize);
    var endianness = headerDataView.getUint32(0, true);
    var littleEndian = endianness === 67305985;
    var parsedResult = {
      buffer,
      glType: headerDataView.getUint32(1 * dataSize, littleEndian),
      glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
      glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
      glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
      glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
      pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
      pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
      pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
      numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
      numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
      numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
      bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
      loadType: COMPRESSED_2D
    };
    if (parsedResult.glType !== 0) {
      throw new Error("only compressed formats currently supported");
    } else {
      parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
    }
    if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
      throw new Error("only 2D textures currently supported");
    }
    if (parsedResult.numberOfArrayElements !== 0) {
      throw new Error("texture arrays not currently supported");
    }
    if (parsedResult.numberOfFaces !== facesExpected) {
      throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
    }
    if (withMipmaps) {
      parsedResult.mipmaps = getMipmaps(parsedResult, true);
    }
    if (mapEngineFormat) {
      parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
    }
    return parsedResult;
  }
};
function parseSingleKTX(data) {
  var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
  return {
    mipmaps: ktx.mipmaps,
    engineFormat: ktx.engineFormat,
    internalFormat: ktx.glInternalFormat,
    width: ktx.pixelWidth,
    height: ktx.pixelHeight
  };
}
function parseCubeKTX(dataArray) {
  var mipmapsFaces = [];
  var internalFormat;
  var engineFormat;
  var width;
  var height;
  for (var i = 0; i < dataArray.length; i++) {
    var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
    mipmapsFaces.push(ktx.mipmaps);
    if (i === 0) {
      width = ktx.pixelWidth;
      height = ktx.pixelHeight;
      internalFormat = ktx.glInternalFormat;
      engineFormat = ktx.engineFormat;
    }
  }
  return {
    mipmapsFaces,
    engineFormat,
    internalFormat,
    width,
    height
  };
}
var KTXCubeLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(KTXCubeLoader2, Loader2);
  function KTXCubeLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = KTXCubeLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      Promise.all(item.urls.map(function(url) {
        return _this.request(url, _extends({}, item, {
          type: "arraybuffer"
        }));
      })).then(function(data) {
        var parsedData = parseCubeKTX(data);
        var width = parsedData.width, mipmapsFaces = parsedData.mipmapsFaces, engineFormat = parsedData.engineFormat;
        var mipmap = mipmapsFaces[0].length > 1;
        var texture = new TextureCube(resourceManager.engine, width, engineFormat, mipmap);
        for (var face = 0; face < 6; face++) {
          var length2 = mipmapsFaces[face].length;
          for (var miplevel = 0; miplevel < length2; miplevel++) {
            var _mipmapsFaces_face_miplevel = mipmapsFaces[face][miplevel], _$data = _mipmapsFaces_face_miplevel.data, width1 = _mipmapsFaces_face_miplevel.width, height = _mipmapsFaces_face_miplevel.height;
            texture.setPixelBuffer(TextureCubeFace.PositiveX + face, _$data, miplevel, 0, 0, width1, height);
          }
        }
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return KTXCubeLoader2;
}(Loader);
KTXCubeLoader = __decorate$1([
  resourceLoader(AssetType.KTXCube, [])
], KTXCubeLoader);
var KTXLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(KTXLoader2, Loader2);
  function KTXLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = KTXLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _extends({}, item, {
        type: "arraybuffer"
      })).then(function(bin) {
        var parsedData = parseSingleKTX(bin);
        var width = parsedData.width, height = parsedData.height, mipmaps = parsedData.mipmaps, engineFormat = parsedData.engineFormat;
        var mipmap = mipmaps.length > 1;
        var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
        for (var miplevel = 0; miplevel < mipmaps.length; miplevel++) {
          var _mipmaps_miplevel = mipmaps[miplevel], width1 = _mipmaps_miplevel.width, height1 = _mipmaps_miplevel.height, data = _mipmaps_miplevel.data;
          texture.setPixelBuffer(data, miplevel, 0, 0, width1, height1);
        }
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return KTXLoader2;
}(Loader);
KTXLoader = __decorate$1([
  resourceLoader(AssetType.KTX, [
    "ktx"
  ])
], KTXLoader);
function parseProperty(object, key, value) {
  if (typeof value === "object") {
    for (var subKey in value) {
      parseProperty(object[key], subKey, value[subKey]);
    }
  } else {
    object[key] = value;
  }
}
var MaterialLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(MaterialLoader2, Loader2);
  function MaterialLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = MaterialLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _extends({}, item, {
        type: "json"
      })).then(function(materialSchema) {
        var _loop = function(key2) {
          var _shaderData_key = shaderData[key2], type = _shaderData_key.type, value2 = _shaderData_key.value;
          switch (type) {
            case "Vector2":
              materialShaderData.setVector2(key2, new Vector2(value2.x, value2.y));
              break;
            case "Vector3":
              materialShaderData.setVector3(key2, new Vector3(value2.x, value2.y, value2.z));
              break;
            case "Vector4":
              materialShaderData.setVector4(key2, new Vector4(value2.x, value2.y, value2.z, value2.w));
              break;
            case "Color":
              materialShaderData.setColor(key2, new Color$1(value2.r, value2.g, value2.b, value2.a));
              break;
            case "Float":
              materialShaderData.setFloat(key2, value2);
              break;
            case "Texture":
              texturePromises.push(
                resourceManager.getResourceByRef(value2).then(function(texture) {
                  materialShaderData.setTexture(key2, texture);
                })
              );
              break;
          }
        };
        var engine = resourceManager.engine;
        var name2 = materialSchema.name, shader = materialSchema.shader, shaderData = materialSchema.shaderData, macros = materialSchema.macros, renderState = materialSchema.renderState;
        var material = new Material(engine, Shader.find(shader));
        material.name = name2;
        var texturePromises = new Array();
        var materialShaderData = material.shaderData;
        for (var key in shaderData)
          _loop(key);
        for (var i = 0, length2 = macros.length; i < length2; i++) {
          var _macros_i = macros[i], name1 = _macros_i.name, value = _macros_i.value;
          if (value == void 0) {
            materialShaderData.enableMacro(name1);
          } else {
            materialShaderData.enableMacro(name1, value);
          }
        }
        parseProperty(material, "renderState", renderState);
        return Promise.all(texturePromises).then(function() {
          resolve(material);
        });
      }).catch(reject);
    });
  };
  return MaterialLoader2;
}(Loader);
MaterialLoader = __decorate$1([
  resourceLoader(AssetType.Material, [
    "json"
  ])
], MaterialLoader);
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
var BufferReader = /* @__PURE__ */ function() {
  function BufferReader2(buffer, byteOffset, byteLength, littleEndian) {
    if (byteOffset === void 0)
      byteOffset = 0;
    if (littleEndian === void 0)
      littleEndian = true;
    this.buffer = buffer;
    this._dataView = new DataView(buffer);
    this._littleEndian = littleEndian;
    this._offset = byteOffset;
  }
  var _proto = BufferReader2.prototype;
  _proto.nextUint8 = function nextUint8() {
    var value = this._dataView.getUint8(this._offset);
    this._offset += 1;
    return value;
  };
  _proto.nextUint16 = function nextUint16() {
    var value = this._dataView.getUint16(this._offset, this._littleEndian);
    this._offset += 2;
    return value;
  };
  _proto.nextUint32 = function nextUint32() {
    var value = this._dataView.getUint32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  };
  _proto.nextInt32 = function nextInt32() {
    var value = this._dataView.getInt32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  };
  _proto.nextInt32Array = function nextInt32Array(len) {
    var value = new Int32Array(this.buffer, this._offset, len);
    this._offset += 4 * len;
    return value;
  };
  _proto.nextFloat32 = function nextFloat32() {
    var value = this._dataView.getFloat32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  };
  _proto.nextFloat32Array = function nextFloat32Array(len) {
    var value = new Float32Array(this.buffer, this._offset, len);
    this._offset += 4 * len;
    return value;
  };
  _proto.nextUint32Array = function nextUint32Array(len) {
    var value = new Uint32Array(this.buffer, this._offset, len);
    this._offset += 4 * len;
    return value;
  };
  _proto.nextUint8Array = function nextUint8Array(len) {
    var value = new Uint8Array(this.buffer, this._offset, len);
    this._offset += len;
    return value;
  };
  _proto.nextUint64 = function nextUint64() {
    var left = this._dataView.getUint32(this._offset, this._littleEndian);
    var right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
    var value = left + Math.pow(2, 32) * right;
    this._offset += 8;
    return value;
  };
  _proto.nextStr = function nextStr() {
    var strByteLength = this.nextUint16();
    var uint8Array = new Uint8Array(this.buffer, this._offset, strByteLength);
    this._offset += strByteLength;
    return Utils.decodeText(uint8Array);
  };
  _proto.nextImageData = function nextImageData(count) {
    return this.buffer.slice(this._offset);
  };
  _proto.nextImagesData = function nextImagesData(count) {
    var imagesLen = new Array(count);
    for (var i = 0; i < count; i++) {
      var len = this._dataView.getUint32(this._offset, this._littleEndian);
      imagesLen[i] = len;
      this._offset += 4;
    }
    var imagesData = [];
    for (var i1 = 0; i1 < count; i1++) {
      var len1 = imagesLen[i1];
      var buffer = this.buffer.slice(this._offset, this._offset + len1);
      this._offset += len1;
      imagesData.push(buffer);
    }
    return imagesData;
  };
  _proto.skip = function skip(bytes) {
    this._offset += bytes;
    return this;
  };
  _proto.scan = function scan(maxByteLength, term) {
    if (term === void 0)
      term = 0;
    var byteOffset = this._offset;
    var byteLength = 0;
    while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {
      byteLength++;
      this._offset++;
    }
    if (byteLength < maxByteLength)
      this._offset++;
    return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
  };
  _create_class$1(BufferReader2, [
    {
      key: "offset",
      get: function get3() {
        return this._offset;
      }
    }
  ]);
  return BufferReader2;
}();
(function() {
  BufferReader.imageMapping = {
    0: "image/png",
    1: "image/jpg",
    2: "image/webp",
    3: "ktx"
  };
})();
var decoderMap = {};
function decoder(type) {
  return function(target) {
    decoderMap[type] = target;
  };
}
var FileHeader = /* @__PURE__ */ function() {
  function FileHeader2() {
    this.totalLength = 0;
    this.version = 0;
    this.type = "";
    this.name = "";
    this.headerLength = 0;
  }
  FileHeader2.decode = function decode2(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var totalLen = dataView.getUint32(0, true);
    var fileVersion = dataView.getUint8(4);
    var typeLen = dataView.getUint16(5, true);
    var typeUint8Array = new Uint8Array(arrayBuffer, 7, typeLen);
    var nameLen = dataView.getUint16(7 + typeLen, true);
    var nameUint8Array = new Uint8Array(arrayBuffer, 9 + typeLen, nameLen);
    var name2 = Utils.decodeText(nameUint8Array);
    var type = Utils.decodeText(typeUint8Array);
    var header = new FileHeader2();
    header.totalLength = totalLen;
    header.name = name2;
    header.type = type;
    header.version = fileVersion;
    header.headerLength = nameUint8Array.byteLength + typeUint8Array.byteLength + 9;
    return header;
  };
  _create_class$1(FileHeader2, [
    {
      key: "dataLength",
      get: function get3() {
        return this.totalLength - this.headerLength;
      }
    }
  ]);
  return FileHeader2;
}();
var MeshDecoder = /* @__PURE__ */ function() {
  function MeshDecoder2() {
  }
  MeshDecoder2.decode = function decode2(engine, bufferReader) {
    return new Promise(function(resolve) {
      var modelMesh = new ModelMesh(engine);
      var jsonDataString = bufferReader.nextStr();
      var encodedMeshData = JSON.parse(jsonDataString);
      encodedMeshData.bounds && modelMesh.bounds.copyFrom(encodedMeshData.bounds);
      var offset = Math.ceil(bufferReader.offset / 4) * 4;
      var float32Array = new Float32Array(bufferReader.buffer, encodedMeshData.positions.start + offset, (encodedMeshData.positions.end - encodedMeshData.positions.start) / 4);
      var vertexCount = float32Array.length / 3;
      var positions = float32ArrayToVector3(float32Array, vertexCount);
      modelMesh.setPositions(positions);
      if (encodedMeshData.normals) {
        var float32Array1 = new Float32Array(bufferReader.buffer, encodedMeshData.normals.start + offset, (encodedMeshData.normals.end - encodedMeshData.normals.start) / 4);
        var normals = float32ArrayToVector3(float32Array1, vertexCount);
        modelMesh.setNormals(normals);
      }
      if (encodedMeshData.uvs) {
        var float32Array2 = new Float32Array(bufferReader.buffer, encodedMeshData.uvs.start + offset, (encodedMeshData.uvs.end - encodedMeshData.uvs.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(float32Array2, vertexCount));
      }
      if (encodedMeshData.uv1) {
        var float32Array3 = new Float32Array(bufferReader.buffer, encodedMeshData.uv1.start + offset, (encodedMeshData.uv1.end - encodedMeshData.uv1.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(float32Array3, vertexCount), 1);
      }
      if (encodedMeshData.uv2) {
        var float32Array4 = new Float32Array(bufferReader.buffer, encodedMeshData.uv2.start + offset, (encodedMeshData.uv2.end - encodedMeshData.uv2.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(float32Array4, vertexCount), 2);
      }
      if (encodedMeshData.uv3) {
        var float32Array5 = new Float32Array(bufferReader.buffer, encodedMeshData.uv3.start + offset, (encodedMeshData.uv3.end - encodedMeshData.uv3.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(float32Array5, vertexCount), 3);
      }
      if (encodedMeshData.uv4) {
        var float32Array6 = new Float32Array(bufferReader.buffer, encodedMeshData.uv4.start + offset, (encodedMeshData.uv4.end - encodedMeshData.uv4.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(float32Array6, vertexCount), 4);
      }
      if (encodedMeshData.uv5) {
        var float32Array7 = new Float32Array(bufferReader.buffer, encodedMeshData.uv5.start + offset, (encodedMeshData.uv5.end - encodedMeshData.uv5.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(float32Array7, vertexCount), 5);
      }
      if (encodedMeshData.uv6) {
        var float32Array8 = new Float32Array(bufferReader.buffer, encodedMeshData.uv6.start + offset, (encodedMeshData.uv6.end - encodedMeshData.uv6.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(float32Array8, vertexCount), 6);
      }
      if (encodedMeshData.uv7) {
        var float32Array9 = new Float32Array(bufferReader.buffer, encodedMeshData.uv7.start + offset, (encodedMeshData.uv7.end - encodedMeshData.uv7.start) / 4);
        modelMesh.setUVs(float32ArrayToVector2(float32Array9, vertexCount), 7);
      }
      if (encodedMeshData.colors) {
        var float32Array10 = new Float32Array(bufferReader.buffer, encodedMeshData.colors.start + offset, (encodedMeshData.colors.end - encodedMeshData.colors.start) / 4);
        modelMesh.setColors(float32ArrayToVColor(float32Array10, vertexCount));
      }
      if (encodedMeshData.boneWeights) {
        var float32Array11 = new Float32Array(bufferReader.buffer, encodedMeshData.boneWeights.start + offset, (encodedMeshData.boneWeights.end - encodedMeshData.boneWeights.start) / 4);
        modelMesh.setBoneWeights(float32ArrayToVector4(float32Array11, vertexCount));
      }
      if (encodedMeshData.boneIndices) {
        var float32Array12 = new Float32Array(bufferReader.buffer, encodedMeshData.boneIndices.start + offset, (encodedMeshData.boneIndices.end - encodedMeshData.boneIndices.start) / 4);
        modelMesh.setBoneIndices(float32ArrayToVector4(float32Array12, vertexCount));
      }
      if (encodedMeshData.blendShapes) {
        encodedMeshData.blendShapes.forEach(function(blendShapeData) {
          var blendShape = new BlendShape(blendShapeData.name);
          blendShapeData.frames.forEach(function(frameData) {
            var positionArray = new Float32Array(bufferReader.buffer, frameData.deltaPosition.start + offset, (frameData.deltaPosition.end - frameData.deltaPosition.start) / 4);
            var count = positionArray.length / 3;
            var deltaPosition = float32ArrayToVector3(positionArray, count);
            if (frameData.deltaNormals) {
              var normalsArray = new Float32Array(bufferReader.buffer, frameData.deltaNormals.start + offset, (frameData.deltaNormals.end - frameData.deltaNormals.start) / 4);
              float32ArrayToVector3(normalsArray, count);
            }
            if (frameData.deltaTangents) {
              var tangentsArray = new Float32Array(bufferReader.buffer, frameData.deltaTangents.start + offset, (frameData.deltaTangents.end - frameData.deltaTangents.start) / 4);
              float32ArrayToVector4(tangentsArray, count);
            }
            blendShape.addFrame(frameData.weight, deltaPosition);
          });
          modelMesh.addBlendShape(blendShape);
        });
      }
      if (encodedMeshData.indices) {
        var indices = null;
        if (encodedMeshData.indices.type === 0) {
          indices = new Uint16Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 2);
        } else {
          indices = new Uint32Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 4);
        }
        modelMesh.setIndices(indices);
      }
      encodedMeshData.subMeshes.forEach(function(subMesh) {
        return modelMesh.addSubMesh(subMesh);
      });
      modelMesh.uploadData(false);
      resolve(modelMesh);
    });
  };
  return MeshDecoder2;
}();
MeshDecoder = __decorate$1([
  decoder("Mesh")
], MeshDecoder);
function float32ArrayToVColor(float32Array, vertexCount) {
  var array = new Array(vertexCount);
  for (var i = 0; i < vertexCount; i++) {
    array[i] = new Color$1(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
  }
  return array;
}
function float32ArrayToVector4(float32Array, vertexCount) {
  var array = new Array(vertexCount);
  for (var i = 0; i < vertexCount; i++) {
    array[i] = new Vector4(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
  }
  return array;
}
function float32ArrayToVector3(float32Array, vertexCount) {
  var array = new Array(vertexCount);
  for (var i = 0; i < vertexCount; i++) {
    array[i] = new Vector3(float32Array[i * 3], float32Array[i * 3 + 1], float32Array[i * 3 + 2]);
  }
  return array;
}
function float32ArrayToVector2(float32Array, vertexCount) {
  var array = new Array(vertexCount);
  for (var i = 0; i < vertexCount; i++) {
    array[i] = new Vector2(float32Array[i * 2], float32Array[i * 2 + 1]);
  }
  return array;
}
var Texture2DDecoder = /* @__PURE__ */ function() {
  function Texture2DDecoder2() {
  }
  Texture2DDecoder2.decode = function decode2(engine, bufferReader) {
    return new Promise(function(resolve, reject) {
      var objectId = bufferReader.nextStr();
      var mipmap = !!bufferReader.nextUint8();
      var filterMode = bufferReader.nextUint8();
      var anisoLevel = bufferReader.nextUint8();
      var wrapModeU = bufferReader.nextUint8();
      var wrapModeV = bufferReader.nextUint8();
      var format = bufferReader.nextUint8();
      var width = bufferReader.nextUint16();
      var height = bufferReader.nextUint16();
      var isPixelBuffer = bufferReader.nextUint8();
      var mipCount = bufferReader.nextUint8();
      var imagesData = bufferReader.nextImagesData(mipCount);
      var texture2D = new Texture2D(engine, width, height, format, mipmap);
      texture2D.filterMode = filterMode;
      texture2D.anisoLevel = anisoLevel;
      texture2D.wrapModeU = wrapModeU;
      texture2D.wrapModeV = wrapModeV;
      if (isPixelBuffer) {
        var pixelBuffer = new Uint8Array(imagesData[0]);
        texture2D.setPixelBuffer(pixelBuffer);
        if (mipmap) {
          texture2D.generateMipmaps();
          for (var i = 1; i < mipCount; i++) {
            var pixelBuffer1 = new Uint8Array(imagesData[i]);
            texture2D.setPixelBuffer(pixelBuffer1, i);
          }
        }
        engine.resourceManager._objectPool[objectId] = texture2D;
        resolve(texture2D);
      } else {
        var blob = new window.Blob([
          imagesData[0]
        ]);
        var img = new Image();
        img.onload = function() {
          texture2D.setImageSource(img);
          var completedCount = 0;
          var onComplete = function() {
            completedCount++;
            if (completedCount >= mipCount) {
              resolve(texture2D);
            }
          };
          onComplete();
          if (mipmap) {
            var _loop = function(i3) {
              var blob2 = new window.Blob([
                imagesData[i3]
              ]);
              var img2 = new Image();
              img2.onload = function() {
                texture2D.setImageSource(img2, i3);
                onComplete();
              };
              img2.src = URL.createObjectURL(blob2);
            };
            texture2D.generateMipmaps();
            for (var i2 = 1; i2 < mipCount; i2++)
              _loop(i2);
          }
        };
        img.src = URL.createObjectURL(blob);
      }
    });
  };
  return Texture2DDecoder2;
}();
Texture2DDecoder = __decorate$1([
  decoder("Texture2D")
], Texture2DDecoder);
function _is_native_reflect_construct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_is_native_reflect_construct())
    _construct = Reflect.construct;
  else {
    _construct = function construct(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _set_prototype_of(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
var ReflectionParser = /* @__PURE__ */ function() {
  function ReflectionParser2() {
  }
  ReflectionParser2.registerCustomParseComponent = function registerCustomParseComponent(componentType, handle) {
    this.customParseComponentHandles[componentType] = handle;
  };
  ReflectionParser2.parseEntity = function parseEntity(entityConfig, engine) {
    return ReflectionParser2.getEntityByConfig(entityConfig, engine).then(function(entity) {
      var _entityConfig_isActive;
      entity.isActive = (_entityConfig_isActive = entityConfig.isActive) != null ? _entityConfig_isActive : true;
      var position = entityConfig.position, rotation = entityConfig.rotation, scale = entityConfig.scale;
      if (position)
        entity.transform.position.copyFrom(position);
      if (rotation)
        entity.transform.rotation.copyFrom(rotation);
      if (scale)
        entity.transform.scale.copyFrom(scale);
      return entity;
    });
  };
  ReflectionParser2.getEntityByConfig = function getEntityByConfig(entityConfig, engine) {
    var assetRefId = entityConfig.assetRefId;
    if (assetRefId) {
      return engine.resourceManager.getResourceByRef({
        refId: assetRefId,
        key: entityConfig.key,
        isClone: entityConfig.isClone
      }).then(function(entity2) {
        entity2.name = entityConfig.name;
        return entity2;
      });
    } else {
      var entity = new Entity(engine, entityConfig.name);
      return Promise.resolve(entity);
    }
  };
  ReflectionParser2.parseClassObject = function parseClassObject(item, engine, resourceManager) {
    if (resourceManager === void 0)
      resourceManager = engine.resourceManager;
    var Class = Loader.getClass(item.class);
    var _item_constructParams;
    var params = (_item_constructParams = item.constructParams) != null ? _item_constructParams : [];
    var instance = _construct(Class, [].concat(params));
    return this.parsePropsAndMethods(instance, item, engine, resourceManager);
  };
  ReflectionParser2.parseBasicType = function parseBasicType(value, engine, resourceManager) {
    if (resourceManager === void 0)
      resourceManager = engine.resourceManager;
    var _this = this;
    if (Array.isArray(value)) {
      return Promise.all(value.map(function(item) {
        return _this.parseBasicType(item, engine, resourceManager);
      }));
    } else if (typeof value === "object" && value != null) {
      if (this._isClass(value)) {
        return this.parseClassObject(value, engine, resourceManager);
      } else if (this._isRef(value)) {
        return resourceManager.getResourceByRef(value);
      } else {
        return Promise.resolve(value);
      }
    } else {
      return Promise.resolve(value);
    }
  };
  ReflectionParser2.parsePropsAndMethods = function parsePropsAndMethods(instance, item, engine, resourceManager) {
    if (resourceManager === void 0)
      resourceManager = engine.resourceManager;
    var _this = this;
    var promises = [];
    if (item.methods) {
      for (var methodName in item.methods) {
        var methodParams = item.methods[methodName];
        for (var i = 0, count = methodParams.length; i < count; i++) {
          var params = methodParams[i];
          var promise = this.parseMethod(instance, methodName, params, engine, resourceManager);
          promises.push(promise);
        }
      }
    }
    if (item.props) {
      var _this1 = this, _loop = function(key2) {
        var value = item.props[key2];
        var promise2 = _this1.parseBasicType(value, engine).then(function(v) {
          return instance[key2] = v;
        });
        promises.push(promise2);
      };
      for (var key in item.props)
        _loop(key);
    }
    return Promise.all(promises).then(function() {
      var handle = _this.customParseComponentHandles[instance.constructor.name];
      if (handle)
        return handle(instance, item, engine);
      else
        return instance;
    });
  };
  ReflectionParser2.parseMethod = function parseMethod(instance, methodName, methodParams, engine, resourceManager) {
    if (resourceManager === void 0)
      resourceManager = engine.resourceManager;
    var _this = this;
    return Promise.all(methodParams.map(function(param) {
      return _this.parseBasicType(param, engine, resourceManager);
    })).then(function(result2) {
      var _instance;
      return (_instance = instance)[methodName].apply(_instance, result2);
    });
  };
  ReflectionParser2._isClass = function _isClass(value) {
    return value["class"] != void 0;
  };
  ReflectionParser2._isRef = function _isRef(value) {
    return value["refId"] != void 0;
  };
  return ReflectionParser2;
}();
(function() {
  ReflectionParser.customParseComponentHandles = /* @__PURE__ */ new Map();
})();
var PrefabParser = /* @__PURE__ */ function() {
  function PrefabParser2() {
  }
  PrefabParser2.parseChildren = function parseChildren(entitiesConfig, entities, parentId) {
    var children = entitiesConfig.get(parentId).children;
    if (children && children.length > 0) {
      var parent = entities.get(parentId);
      for (var i = 0; i < children.length; i++) {
        var childId = children[i];
        var entity = entities.get(childId);
        parent.addChild(entity);
        this.parseChildren(entitiesConfig, entities, childId);
      }
    }
  };
  return PrefabParser2;
}();
var ComponentMap = {
  Transform,
  Animator,
  DirectLight,
  Camera,
  MeshRenderer,
  ParticleRenderer,
  PointLight,
  SpotLight,
  Script,
  SpriteMask,
  SpriteRenderer,
  TextRenderer
};
var InterpolableValueType;
(function(InterpolableValueType2) {
  InterpolableValueType2[InterpolableValueType2["Float"] = 0] = "Float";
  InterpolableValueType2[InterpolableValueType2["FloatArray"] = 1] = "FloatArray";
  InterpolableValueType2[InterpolableValueType2["Vector2"] = 2] = "Vector2";
  InterpolableValueType2[InterpolableValueType2["Vector3"] = 3] = "Vector3";
  InterpolableValueType2[InterpolableValueType2["Vector4"] = 4] = "Vector4";
  InterpolableValueType2[InterpolableValueType2["Quaternion"] = 5] = "Quaternion";
  InterpolableValueType2[InterpolableValueType2["Color"] = 6] = "Color";
  InterpolableValueType2[InterpolableValueType2["Array"] = 7] = "Array";
  InterpolableValueType2[InterpolableValueType2["Boolean"] = 8] = "Boolean";
})(InterpolableValueType || (InterpolableValueType = {}));
var AnimationClipDecoder = /* @__PURE__ */ function() {
  function AnimationClipDecoder2() {
  }
  AnimationClipDecoder2.decode = function decode2(engine, bufferReader) {
    return new Promise(function(resolve) {
      var name2 = bufferReader.nextStr();
      var clip = new AnimationClip(name2);
      var eventsLen = bufferReader.nextUint16();
      for (var i = 0; i < eventsLen; ++i) {
        var event = new AnimationEvent();
        event.time = bufferReader.nextFloat32();
        event.functionName = bufferReader.nextStr();
        event.parameter = JSON.parse(bufferReader.nextStr()).val;
        clip.addEvent(event);
      }
      var curveBindingsLen = bufferReader.nextUint16();
      for (var i1 = 0; i1 < curveBindingsLen; ++i1) {
        var relativePath = bufferReader.nextStr();
        var componentStr = bufferReader.nextStr();
        var componentType = ComponentMap[componentStr];
        var property = bufferReader.nextStr();
        var curve = void 0;
        var interpolation = bufferReader.nextUint8();
        var keysLen = bufferReader.nextUint16();
        var curveType = bufferReader.nextStr();
        switch (curveType) {
          case "AnimationFloatCurve": {
            curve = curve || new AnimationFloatCurve();
            curve.interpolation = interpolation;
            for (var j2 = 0; j2 < keysLen; ++j2) {
              var keyframe = new Keyframe();
              keyframe.time = bufferReader.nextFloat32();
              keyframe.value = bufferReader.nextFloat32();
              keyframe.inTangent = bufferReader.nextFloat32();
              keyframe.outTangent = bufferReader.nextFloat32();
              curve.addKey(keyframe);
            }
            break;
          }
          case "AnimationArrayCurve": {
            curve = curve || new AnimationArrayCurve();
            curve.interpolation = interpolation;
            for (var j1 = 0; j1 < keysLen; ++j1) {
              var keyframe1 = new Keyframe();
              keyframe1.time = bufferReader.nextFloat32();
              var len = bufferReader.nextUint16();
              keyframe1.value = Array.from(bufferReader.nextFloat32Array(len));
              keyframe1.inTangent = Array.from(bufferReader.nextFloat32Array(len));
              keyframe1.outTangent = Array.from(bufferReader.nextFloat32Array(len));
              curve.addKey(keyframe1);
            }
            break;
          }
          case "AnimationFloatArrayCurve": {
            curve = curve || new AnimationFloatArrayCurve();
            curve.interpolation = interpolation;
            for (var j22 = 0; j22 < keysLen; ++j22) {
              var keyframe2 = new Keyframe();
              keyframe2.time = bufferReader.nextFloat32();
              var len1 = bufferReader.nextUint16();
              keyframe2.value = bufferReader.nextFloat32Array(len1);
              keyframe2.inTangent = Array.from(bufferReader.nextFloat32Array(len1));
              keyframe2.outTangent = Array.from(bufferReader.nextFloat32Array(len1));
              curve.addKey(keyframe2);
            }
            break;
          }
          case "AnimationVector2Curve": {
            curve = curve || new AnimationVector2Curve();
            curve.interpolation = interpolation;
            for (var j3 = 0; j3 < keysLen; ++j3) {
              var keyframe3 = new Keyframe();
              keyframe3.time = bufferReader.nextFloat32();
              keyframe3.value = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
              keyframe3.inTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
              keyframe3.outTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
              curve.addKey(keyframe3);
            }
            break;
          }
          case "AnimationVector3Curve": {
            curve = curve || new AnimationVector3Curve();
            curve.interpolation = interpolation;
            for (var j4 = 0; j4 < keysLen; ++j4) {
              var keyframe4 = new Keyframe();
              keyframe4.time = bufferReader.nextFloat32();
              keyframe4.value = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
              keyframe4.inTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
              keyframe4.outTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
              curve.addKey(keyframe4);
            }
            break;
          }
          case "AnimationVector4Curve": {
            curve = curve || new AnimationVector4Curve();
            curve.interpolation = interpolation;
            var keyframe5 = new Keyframe();
            keyframe5.time = bufferReader.nextFloat32();
            keyframe5.value = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
            keyframe5.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
            keyframe5.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
            curve.addKey(keyframe5);
            break;
          }
          case "AnimationColorCurve": {
            curve = curve || new AnimationColorCurve();
            curve.interpolation = interpolation;
            for (var j5 = 0; j5 < keysLen; ++j5) {
              var keyframe6 = new Keyframe();
              keyframe6.time = bufferReader.nextFloat32();
              keyframe6.value = new Color$1(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
              keyframe6.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
              keyframe6.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
              curve.addKey(keyframe6);
            }
            break;
          }
          case "AnimationQuaternionCurve": {
            curve = curve || new AnimationQuaternionCurve();
            curve.interpolation = interpolation;
            for (var j6 = 0; j6 < keysLen; ++j6) {
              var keyframe7 = new Keyframe();
              keyframe7.time = bufferReader.nextFloat32();
              keyframe7.value = new Quaternion(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
              keyframe7.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
              keyframe7.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
              curve.addKey(keyframe7);
            }
            break;
          }
        }
        clip.addCurveBinding(relativePath, componentType, property, curve);
      }
      resolve(clip);
    });
  };
  return AnimationClipDecoder2;
}();
AnimationClipDecoder = __decorate$1([
  decoder("AnimationClip")
], AnimationClipDecoder);
var SpecularMode;
(function(SpecularMode2) {
  SpecularMode2["Sky"] = "Sky";
  SpecularMode2["Custom"] = "Custom";
})(SpecularMode || (SpecularMode = {}));
var SceneParserContext = /* @__PURE__ */ function() {
  function SceneParserContext2(originalData, scene) {
    this.originalData = originalData;
    this.scene = scene;
    this.entityMap = /* @__PURE__ */ new Map();
    this.components = /* @__PURE__ */ new Map();
    this.assets = /* @__PURE__ */ new Map();
    this.entityConfigMap = /* @__PURE__ */ new Map();
    this.rootIds = [];
  }
  var _proto = SceneParserContext2.prototype;
  _proto.destroy = function destroy2() {
    this.entityMap.clear();
    this.components.clear();
    this.assets.clear();
    this.entityConfigMap.clear();
    this.rootIds.length = 0;
  };
  return SceneParserContext2;
}();
var SceneParser = /* @__PURE__ */ function() {
  function SceneParser2(context) {
    var _this = this;
    this.context = context;
    this._engine = this.context.scene.engine;
    this._organizeEntities = this._organizeEntities.bind(this);
    this._parseComponents = this._parseComponents.bind(this);
    this._clearAndResolveScene = this._clearAndResolveScene.bind(this);
    this.promise = new Promise(function(resolve, reject) {
      _this._reject = reject;
      _this._resolve = resolve;
    });
  }
  var _proto = SceneParser2.prototype;
  _proto.start = function start() {
    this._parseEntities().then(this._organizeEntities).then(this._parseComponents).then(this._clearAndResolveScene).then(this._resolve).catch(this._reject);
  };
  _proto._parseEntities = function _parseEntities() {
    var entitiesConfig = this.context.originalData.entities;
    var entityConfigMap = this.context.entityConfigMap;
    var entitiesMap = this.context.entityMap;
    var rootIds = this.context.rootIds;
    var engine = this._engine;
    var promises = entitiesConfig.map(function(entityConfig) {
      entityConfigMap.set(entityConfig.id, entityConfig);
      if (!entityConfig.parent)
        rootIds.push(entityConfig.id);
      return ReflectionParser.parseEntity(entityConfig, engine);
    });
    return Promise.all(promises).then(function(entities) {
      for (var i = 0, l = entities.length; i < l; i++) {
        entitiesMap.set(entitiesConfig[i].id, entities[i]);
      }
      return entities;
    });
  };
  _proto._organizeEntities = function _organizeEntities() {
    var _this_context = this.context, entityConfigMap = _this_context.entityConfigMap, entityMap = _this_context.entityMap, scene = _this_context.scene, rootIds = _this_context.rootIds;
    for (var _iterator = _create_for_of_iterator_helper_loose(rootIds), _step; !(_step = _iterator()).done; ) {
      var rootId = _step.value;
      PrefabParser.parseChildren(entityConfigMap, entityMap, rootId);
    }
    var rootEntities = rootIds.map(function(id) {
      return entityMap.get(id);
    });
    for (var i = 0; i < rootEntities.length; i++) {
      scene.addRootEntity(rootEntities[i]);
    }
  };
  _proto._parseComponents = function _parseComponents() {
    var entitiesConfig = this.context.originalData.entities;
    var entityMap = this.context.entityMap;
    var promises = [];
    for (var i = 0, l = entitiesConfig.length; i < l; i++) {
      var entityConfig = entitiesConfig[i];
      var entity = entityMap.get(entityConfig.id);
      for (var i1 = 0; i1 < entityConfig.components.length; i1++) {
        var componentConfig = entityConfig.components[i1];
        var key = !componentConfig.refId ? componentConfig.class : componentConfig.refId;
        var component = void 0;
        if (key === "Animator") {
          component = entity.getComponent(Loader.getClass(key));
        }
        component = component || entity.addComponent(Loader.getClass(key));
        var promise = ReflectionParser.parsePropsAndMethods(component, componentConfig, entity.engine);
        promises.push(promise);
      }
    }
    return Promise.all(promises);
  };
  _proto._clearAndResolveScene = function _clearAndResolveScene() {
    var scene = this.context.scene;
    this.context.destroy();
    return scene;
  };
  SceneParser2.parse = function parse2(engine, sceneData) {
    var scene = new Scene$1(engine);
    var context = new SceneParserContext(sceneData, scene);
    var parser = new SceneParser2(context);
    parser.start();
    return parser.promise;
  };
  return SceneParser2;
}();
var MeshLoader$1 = /* @__PURE__ */ function(Loader2) {
  _inherits(MeshLoader2, Loader2);
  function MeshLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = MeshLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, {
        type: "arraybuffer"
      }).then(function(data) {
        decode(data, resourceManager.engine).then(function(mesh) {
          resolve(mesh);
        });
      }).catch(reject);
    });
  };
  return MeshLoader2;
}(Loader);
MeshLoader$1 = __decorate$1([
  resourceLoader("Mesh", [
    "prefab"
  ], true)
], MeshLoader$1);
var EditorTextureLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(EditorTextureLoader2, Loader2);
  function EditorTextureLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = EditorTextureLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, {
        type: "arraybuffer"
      }).then(function(data) {
        decode(data, resourceManager.engine).then(function(texture) {
          resolve(texture);
        });
      }).catch(reject);
    });
  };
  return EditorTextureLoader2;
}(Loader);
EditorTextureLoader = __decorate$1([
  resourceLoader("EditorTexture2D", [
    "prefab"
  ], true)
], EditorTextureLoader);
function decode(arrayBuffer, engine) {
  var header = FileHeader.decode(arrayBuffer);
  var bufferReader = new BufferReader(arrayBuffer, header.headerLength, header.dataLength);
  return decoderMap[header.type].decode(engine, bufferReader).then(function(object) {
    object.name = header.name;
    return object;
  });
}
var MeshLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(MeshLoader2, Loader2);
  function MeshLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = MeshLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _extends({}, item, {
        type: "arraybuffer"
      })).then(function(data) {
        return decode(data, resourceManager.engine);
      }).then(function(mesh) {
        resolve(mesh);
      }).catch(reject);
    });
  };
  return MeshLoader2;
}(Loader);
MeshLoader = __decorate$1([
  resourceLoader(AssetType.Mesh, [
    "mesh"
  ])
], MeshLoader);
var SourceFontLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(SourceFontLoader2, Loader2);
  function SourceFontLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = SourceFontLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      var url = item.url;
      _this._registerFont(url, url).then(function() {
        var font = new Font(resourceManager.engine, url);
        resolve(font);
      }).catch(function(e) {
        reject("load font " + url + " fail");
      });
    });
  };
  _proto._registerFont = function _registerFont(fontName, fontUrl) {
    return _async_to_generator(function() {
      var fontFace;
      return __generator(this, function(_state) {
        switch (_state.label) {
          case 0:
            fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
            return [
              4,
              fontFace.load()
            ];
          case 1:
            _state.sent();
            document.fonts.add(fontFace);
            return [
              2
            ];
        }
      });
    })();
  };
  return SourceFontLoader2;
}(Loader);
SourceFontLoader = __decorate$1([
  resourceLoader(AssetType.SourceFont, [
    "ttf",
    "otf",
    "woff"
  ], false)
], SourceFontLoader);
var SpriteAtlasLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(SpriteAtlasLoader2, Loader2);
  function SpriteAtlasLoader2() {
    var _this;
    _this = Loader2.apply(this, arguments) || this;
    _this._tempRect = new Rect();
    _this._tempVec2 = new Vector2();
    _this._tempVec4 = new Vector4();
    return _this;
  }
  var _proto = SpriteAtlasLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject, _2, onCancel) {
      var chainPromises = [];
      onCancel(function() {
        for (var i = 0; i < chainPromises.length; i++) {
          chainPromises[i].cancel();
        }
      });
      var configPromise = _this.request(item.url, _extends({}, item, {
        type: "json"
      }));
      chainPromises.push(configPromise);
      configPromise.then(function(atlasData) {
        var _loop = function(i2) {
          var atlasItem = atlasItems[i2];
          if (atlasItem.img) {
            chainPromises.push(resourceManager.load({
              url: Utils.resolveAbsoluteUrl(item.url, atlasItem.img),
              type: AssetType.Texture2D,
              params: {
                format,
                mipmap
              }
            }).then(function(texture) {
              anisoLevel && (texture.anisoLevel = anisoLevel);
              filterMode !== void 0 && (texture.filterMode = filterMode);
              wrapModeU !== void 0 && (texture.wrapModeU = wrapModeU);
              wrapModeV !== void 0 && (texture.wrapModeV = wrapModeV);
              for (var i3 = 0; i3 < atlasItem.sprites.length; i3++) {
                spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i3], texture));
              }
            }).catch(reject));
          } else {
            for (var i1 = 0; i1 < atlasItem.sprites.length; i1++) {
              spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i1]));
            }
          }
        };
        var atlasItems = atlasData.atlasItems, mipmap = atlasData.mipmap, anisoLevel = atlasData.anisoLevel, filterMode = atlasData.filterMode, wrapModeU = atlasData.wrapModeU, wrapModeV = atlasData.wrapModeV, format = atlasData.format;
        var atlasItemsLen = atlasItems ? atlasItems.length : 0;
        var engine = resourceManager.engine;
        var spriteAtlas = new SpriteAtlas(engine);
        if (atlasItemsLen < 0) {
          resolve(spriteAtlas);
          return;
        }
        chainPromises.length = 0;
        for (var i = 0; i < atlasItems.length; i++)
          _loop(i);
        AssetPromise.all(chainPromises).then(function() {
          resolve(spriteAtlas);
        }).catch(reject);
      }).catch(reject);
    });
  };
  _proto._makeSprite = function _makeSprite(engine, config, texture) {
    var region = config.region, atlasRegionOffset = config.atlasRegionOffset, atlasRegion = config.atlasRegion, pivot = config.pivot, border = config.border;
    var sprite = new Sprite(engine, texture, region ? this._tempRect.set(region.x, region.y, region.w, region.h) : void 0, pivot ? this._tempVec2.set(pivot.x, pivot.y) : void 0, border ? this._tempVec4.set(border.x, border.y, border.z, border.w) : void 0, config.name);
    if (texture) {
      var invW = 1 / texture.width;
      var invH = 1 / texture.height;
      sprite.atlasRegion.set(atlasRegion.x * invW, atlasRegion.y * invH, atlasRegion.w * invW, atlasRegion.h * invH);
      if (atlasRegionOffset) {
        var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
        sprite.atlasRegionOffset.set(offsetLeft * invW, offsetTop * invH, offsetRight * invW, offsetBottom * invH);
      }
      config.atlasRotated && (sprite.atlasRotated = true);
    }
    return sprite;
  };
  return SpriteAtlasLoader2;
}(Loader);
SpriteAtlasLoader = __decorate$1([
  resourceLoader(AssetType.SpriteAtlas, [
    "atlas"
  ], false)
], SpriteAtlasLoader);
var SpriteLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(SpriteLoader2, Loader2);
  function SpriteLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = SpriteLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _extends({}, item, {
        type: "json"
      })).then(function(data) {
        if (data.belongToAtlas) {
          resourceManager.getResourceByRef(data.belongToAtlas).then(function(atlas) {
            resolve(atlas.getSprite(data.fullPath));
          }).catch(reject);
        } else if (data.texture) {
          resourceManager.getResourceByRef(data.texture).then(function(texture) {
            resolve(new Sprite(resourceManager.engine, texture, data.region, data.pivot, data.border));
          }).catch(reject);
        } else {
          resolve(new Sprite(resourceManager.engine, null, data.region, data.pivot, data.border));
        }
      }).catch(reject);
    });
  };
  return SpriteLoader2;
}(Loader);
SpriteLoader = __decorate$1([
  resourceLoader(AssetType.Sprite, [
    "sprite"
  ], false)
], SpriteLoader);
var Texture2DContentRestorer = /* @__PURE__ */ function(ContentRestorer3) {
  _inherits(Texture2DContentRestorer2, ContentRestorer3);
  function Texture2DContentRestorer2(resource, url, requestConfig) {
    var _this;
    _this = ContentRestorer3.call(this, resource) || this;
    _this.url = url;
    _this.requestConfig = requestConfig;
    return _this;
  }
  var _proto = Texture2DContentRestorer2.prototype;
  _proto.restoreContent = function restoreContent() {
    var _this = this;
    return request(this.url, this.requestConfig).then(function(image) {
      var resource = _this.resource;
      resource.setImageSource(image);
      resource.generateMipmaps();
      return resource;
    });
  };
  return Texture2DContentRestorer2;
}(ContentRestorer);
var Texture2DLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(Texture2DLoader2, Loader2);
  function Texture2DLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = Texture2DLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      var url = item.url;
      var requestConfig = _extends({}, item, {
        type: "image"
      });
      _this.request(url, requestConfig).then(function(image) {
        var params = item.params;
        var texture = new Texture2D(resourceManager.engine, image.width, image.height, params == null ? void 0 : params.format, params == null ? void 0 : params.mipmap);
        texture.setImageSource(image);
        texture.generateMipmaps();
        if (url.indexOf("data:") !== 0) {
          var index = url.lastIndexOf("/");
          texture.name = url.substring(index + 1);
        }
        resourceManager.addContentRestorer(new Texture2DContentRestorer(texture, url, requestConfig));
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return Texture2DLoader2;
}(Loader);
Texture2DLoader = __decorate$1([
  resourceLoader(AssetType.Texture2D, [
    "png",
    "jpg",
    "webp",
    "jpeg"
  ])
], Texture2DLoader);
var TextureCubeContentRestorer = /* @__PURE__ */ function(ContentRestorer3) {
  _inherits(TextureCubeContentRestorer2, ContentRestorer3);
  function TextureCubeContentRestorer2(resource, urls, requestConfig) {
    var _this;
    _this = ContentRestorer3.call(this, resource) || this;
    _this.urls = urls;
    _this.requestConfig = requestConfig;
    return _this;
  }
  var _proto = TextureCubeContentRestorer2.prototype;
  _proto.restoreContent = function restoreContent() {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      Promise.all(_this.urls.map(function(url) {
        return request(url, _this.requestConfig);
      })).then(function(images) {
        var resource = _this.resource;
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          resource.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
        }
        resource.generateMipmaps();
        resolve(resource);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return TextureCubeContentRestorer2;
}(ContentRestorer);
var TextureCubeLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(TextureCubeLoader2, Loader2);
  function TextureCubeLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = TextureCubeLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      var urls = item.urls;
      var requestConfig = _extends({}, item, {
        type: "image"
      });
      Promise.all(urls.map(function(url) {
        return _this.request(url, requestConfig);
      })).then(function(images) {
        var _images_ = images[0], width = _images_.width, height = _images_.height;
        if (width !== height) {
          console.error("The cube texture must have the same width and height");
          return;
        }
        var texture = new TextureCube(resourceManager.engine, width);
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          texture.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
        }
        texture.generateMipmaps();
        resourceManager.addContentRestorer(new TextureCubeContentRestorer(texture, urls, requestConfig));
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return TextureCubeLoader2;
}(Loader);
TextureCubeLoader = __decorate$1([
  resourceLoader(AssetType.TextureCube, [
    ""
  ])
], TextureCubeLoader);
var AnimationClipLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(AnimationClipLoader2, Loader2);
  function AnimationClipLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = AnimationClipLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _extends({}, item, {
        type: "arraybuffer"
      })).then(function(data) {
        return decode(data, resourceManager.engine).then(resolve);
      }).catch(reject);
    });
  };
  return AnimationClipLoader2;
}(Loader);
AnimationClipLoader = __decorate$1([
  resourceLoader(AssetType.AnimationClip, [
    "ani"
  ])
], AnimationClipLoader);
var SceneLoader = /* @__PURE__ */ function(Loader2) {
  _inherits(SceneLoader2, Loader2);
  function SceneLoader2() {
    return Loader2.apply(this, arguments);
  }
  var _proto = SceneLoader2.prototype;
  _proto.load = function load2(item, resourceManager) {
    var _this = this;
    var engine = resourceManager.engine;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, {
        type: "json"
      }).then(function(data) {
        engine.resourceManager.initVirtualResources(data.files);
        return SceneParser.parse(engine, data).then(function(scene) {
          var promises = [];
          var ambient = data.scene.ambient;
          var useCustomAmbient = ambient.specularMode === "Custom";
          if (useCustomAmbient && ambient.customAmbientLight) {
            var customAmbientPromise = resourceManager.getResourceByRef(ambient.customAmbientLight).then(function(ambientLight) {
              scene.ambientLight = ambientLight;
              scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
              scene.ambientLight.specularIntensity = ambient.specularIntensity;
              scene.ambientLight.diffuseMode = ambient.diffuseMode;
              scene.ambientLight.diffuseSolidColor.copyFrom(ambient.diffuseSolidColor);
            });
            promises.push(customAmbientPromise);
          } else if (!useCustomAmbient && ambient.ambientLight) {
            var ambientLightPromise = resourceManager.getResourceByRef(ambient.ambientLight).then(function(ambientLight) {
              scene.ambientLight = ambientLight;
              scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
              scene.ambientLight.specularIntensity = ambient.specularIntensity;
              scene.ambientLight.diffuseMode = ambient.diffuseMode;
              scene.ambientLight.diffuseSolidColor.copyFrom(ambient.diffuseSolidColor);
            });
            promises.push(ambientLightPromise);
          } else {
            scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
            scene.ambientLight.specularIntensity = ambient.specularIntensity;
            scene.ambientLight.diffuseSolidColor.copyFrom(ambient.diffuseSolidColor);
          }
          var background = data.scene.background;
          scene.background.mode = background.mode;
          switch (scene.background.mode) {
            case BackgroundMode.SolidColor:
              scene.background.solidColor.copyFrom(background.color);
              break;
            case BackgroundMode.Sky:
              if (background.skyMesh && background.skyMaterial) {
                var skyMeshPromise = resourceManager.getResourceByRef(background.skyMesh).then(function(mesh) {
                  scene.background.sky.mesh = mesh;
                });
                var skyMaterialPromise = resourceManager.getResourceByRef(background.skyMaterial).then(function(material) {
                  scene.background.sky.material = material;
                });
                promises.push(skyMeshPromise, skyMaterialPromise);
              } else {
                Logger.warn("Sky background mode requires skyMesh and skyMaterial");
              }
              break;
            case BackgroundMode.Texture:
              if (background.texture) {
                var backgroundPromise = resourceManager.getResourceByRef(background.texture).then(function(texture) {
                  scene.background.texture = texture;
                });
                promises.push(backgroundPromise);
              }
              break;
          }
          var shadow = data.scene.shadow;
          if (shadow) {
            if (shadow.castShadows != void 0)
              scene.castShadows = shadow.castShadows;
            if (shadow.shadowResolution != void 0)
              scene.shadowResolution = shadow.shadowResolution;
            if (shadow.shadowDistance != void 0)
              scene.shadowDistance = shadow.shadowDistance;
            if (shadow.shadowCascades != void 0)
              scene.shadowCascades = shadow.shadowCascades;
          }
          return Promise.all(promises).then(function() {
            resolve(scene);
          });
        });
      }).catch(reject);
    });
  };
  return SceneLoader2;
}(Loader);
SceneLoader = __decorate$1([
  resourceLoader(AssetType.Scene, [
    "prefab"
  ], true)
], SceneLoader);
ReflectionParser.registerCustomParseComponent("TextRenderer", /* @__PURE__ */ _async_to_generator(function(instance, item, engine) {
  var props;
  return __generator(this, function(_state) {
    props = item.props;
    if (!props.font) {
      instance.font = Font.createFromOS(engine, props.fontFamily || "Arial");
    }
    return [
      2,
      instance
    ];
  });
}));
var _KHR_draco_mesh_compression;
var KHR_draco_mesh_compression = (_KHR_draco_mesh_compression = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(KHR_draco_mesh_compression1, GLTFExtensionParser2);
  function KHR_draco_mesh_compression1() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  var _proto = KHR_draco_mesh_compression1.prototype;
  _proto.initialize = function initialize() {
    if (!KHR_draco_mesh_compression._decoder) {
      KHR_draco_mesh_compression._decoder = new DRACODecoder();
    }
  };
  _proto.createAndParse = function createAndParse(context, schema, glTFPrimitive, glTFMesh) {
    var _this = this;
    var glTF = context.glTF, engine = context.glTFResource.engine;
    var bufferViews = glTF.bufferViews, accessors = glTF.accessors;
    var bufferViewIndex = schema.bufferView, gltfAttributeMap = schema.attributes;
    var attributeMap = {};
    var attributeTypeMap = {};
    for (var attributeName in gltfAttributeMap) {
      attributeMap[attributeName] = gltfAttributeMap[attributeName];
    }
    for (var attributeName1 in glTFPrimitive.attributes) {
      if (gltfAttributeMap[attributeName1] !== void 0) {
        var accessorDef = accessors[glTFPrimitive.attributes[attributeName1]];
        attributeTypeMap[attributeName1] = GLTFUtils.getComponentType(accessorDef.componentType).name;
      }
    }
    var indexAccessor = accessors[glTFPrimitive.indices];
    var indexType = GLTFUtils.getComponentType(indexAccessor.componentType).name;
    var taskConfig = {
      attributeIDs: attributeMap,
      attributeTypes: attributeTypeMap,
      useUniqueIDs: true,
      indexType
    };
    return context.getBuffers().then(function(buffers) {
      var buffer = GLTFUtils.getBufferViewData(bufferViews[bufferViewIndex], buffers);
      return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then(function(decodedGeometry) {
        var mesh = new ModelMesh(engine, glTFMesh.name);
        return _this._parseMeshFromGLTFPrimitiveDraco(mesh, glTFMesh, glTFPrimitive, glTF, function(attributeSemantic) {
          for (var j2 = 0; j2 < decodedGeometry.attributes.length; j2++) {
            if (decodedGeometry.attributes[j2].name === attributeSemantic) {
              return decodedGeometry.attributes[j2].array;
            }
          }
          return null;
        }, function(attributeSemantic, shapeIndex) {
          throw "BlendShape animation is not supported when using draco.";
        }, function() {
          return decodedGeometry.index.array;
        }, context.keepMeshData);
      });
    });
  };
  _proto._parseMeshFromGLTFPrimitiveDraco = function _parseMeshFromGLTFPrimitiveDraco(mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, keepMeshData) {
    var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
    var vertexCount;
    var accessors = gltf.accessors;
    var accessor = accessors[attributes["POSITION"]];
    var positionBuffer = getVertexBufferData("POSITION");
    var positions = GLTFUtils.floatBufferToVector3Array(positionBuffer);
    mesh.setPositions(positions);
    var bounds = mesh.bounds;
    vertexCount = accessor.count;
    if (accessor.min && accessor.max) {
      bounds.min.copyFromArray(accessor.min);
      bounds.max.copyFromArray(accessor.max);
    } else {
      var position = KHR_draco_mesh_compression._tempVector3;
      var min = bounds.min, max = bounds.max;
      min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
      var stride = positionBuffer.length / vertexCount;
      for (var j2 = 0; j2 < vertexCount; j2++) {
        var offset = j2 * stride;
        position.copyFromArray(positionBuffer, offset);
        Vector3.min(min, position, min);
        Vector3.max(max, position, max);
      }
    }
    for (var attributeSemantic in attributes) {
      if (attributeSemantic === "POSITION") {
        continue;
      }
      var bufferData = getVertexBufferData(attributeSemantic);
      switch (attributeSemantic) {
        case "NORMAL":
          var normals = GLTFUtils.floatBufferToVector3Array(bufferData);
          mesh.setNormals(normals);
          break;
        case "TEXCOORD_0":
          var texturecoords = GLTFUtils.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords, 0);
          break;
        case "TEXCOORD_1":
          var texturecoords1 = GLTFUtils.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords1, 1);
          break;
        case "TEXCOORD_2":
          var texturecoords2 = GLTFUtils.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords2, 2);
          break;
        case "TEXCOORD_3":
          var texturecoords3 = GLTFUtils.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords3, 3);
          break;
        case "TEXCOORD_4":
          var texturecoords4 = GLTFUtils.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords4, 4);
          break;
        case "TEXCOORD_5":
          var texturecoords5 = GLTFUtils.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords5, 5);
          break;
        case "TEXCOORD_6":
          var texturecoords6 = GLTFUtils.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords6, 6);
          break;
        case "TEXCOORD_7":
          var texturecoords7 = GLTFUtils.floatBufferToVector2Array(bufferData);
          mesh.setUVs(texturecoords7, 7);
          break;
        case "COLOR_0":
          var colors = GLTFUtils.floatBufferToColorArray(bufferData, accessors[attributes["COLOR_0"]].type === AccessorType.VEC3);
          mesh.setColors(colors);
          break;
        case "TANGENT":
          var tangents = GLTFUtils.floatBufferToVector4Array(bufferData);
          mesh.setTangents(tangents);
          break;
        case "JOINTS_0":
          var joints = GLTFUtils.floatBufferToVector4Array(bufferData);
          mesh.setBoneIndices(joints);
          break;
        case "WEIGHTS_0":
          var weights = GLTFUtils.floatBufferToVector4Array(bufferData);
          mesh.setBoneWeights(weights);
          break;
      }
    }
    if (indices !== void 0) {
      var indexAccessor = gltf.accessors[indices];
      var indexData = getIndexBufferData();
      mesh.setIndices(indexData);
      mesh.addSubMesh(0, indexAccessor.count, mode);
    } else {
      mesh.addSubMesh(0, vertexCount, mode);
    }
    targets && GLTFMeshParser._createBlendShape(mesh, null, gltfMesh, accessors, targets, getBlendShapeData);
    mesh.uploadData(!keepMeshData);
    return Promise.resolve(mesh);
  };
  return KHR_draco_mesh_compression1;
}(GLTFExtensionParser), function() {
  _KHR_draco_mesh_compression._tempVector3 = new Vector3();
}(), _KHR_draco_mesh_compression);
KHR_draco_mesh_compression = __decorate$1([
  registerGLTFExtension("KHR_draco_mesh_compression", GLTFExtensionMode.CreateAndParse)
], KHR_draco_mesh_compression);
var KHR_lights_punctual = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(KHR_lights_punctual2, GLTFExtensionParser2);
  function KHR_lights_punctual2() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  var _proto = KHR_lights_punctual2.prototype;
  _proto.additiveParse = function additiveParse(context, entity, extensionSchema) {
    var lightsSchema = context.glTF.extensions.KHR_lights_punctual.lights;
    var lightSchema = lightsSchema[extensionSchema.light];
    var color = lightSchema.color, _lightSchema_intensity = lightSchema.intensity, intensity = _lightSchema_intensity === void 0 ? 1 : _lightSchema_intensity, type = lightSchema.type, range = lightSchema.range, spot = lightSchema.spot;
    var glTFResource = context.glTFResource;
    var light;
    if (type === "directional") {
      light = entity.addComponent(DirectLight);
    } else if (type === "point") {
      light = entity.addComponent(PointLight);
    } else if (type === "spot") {
      light = entity.addComponent(SpotLight);
    }
    if (color) {
      light.color.set(color[0], color[1], color[2], 1);
    }
    light.intensity = intensity;
    if (range && !_instanceof(light, DirectLight)) {
      light.distance = range;
    }
    if (spot && _instanceof(light, SpotLight)) {
      var _spot_innerConeAngle = spot.innerConeAngle, innerConeAngle = _spot_innerConeAngle === void 0 ? 0 : _spot_innerConeAngle, _spot_outerConeAngle = spot.outerConeAngle, outerConeAngle = _spot_outerConeAngle === void 0 ? Math.PI / 4 : _spot_outerConeAngle;
      light.angle = innerConeAngle;
      light.penumbra = outerConeAngle - innerConeAngle;
    }
    if (!glTFResource.lights)
      glTFResource.lights = [];
    glTFResource.lights.push(light);
  };
  return KHR_lights_punctual2;
}(GLTFExtensionParser);
KHR_lights_punctual = __decorate$1([
  registerGLTFExtension("KHR_lights_punctual", GLTFExtensionMode.AdditiveParse)
], KHR_lights_punctual);
var KHR_materials_clearcoat = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(KHR_materials_clearcoat2, GLTFExtensionParser2);
  function KHR_materials_clearcoat2() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  var _proto = KHR_materials_clearcoat2.prototype;
  _proto.additiveParse = function additiveParse(context, material, schema) {
    var textures = context.glTFResource.textures;
    var _schema_clearcoatFactor = schema.clearcoatFactor, clearcoatFactor = _schema_clearcoatFactor === void 0 ? 0 : _schema_clearcoatFactor, clearcoatTexture = schema.clearcoatTexture, _schema_clearcoatRoughnessFactor = schema.clearcoatRoughnessFactor, clearcoatRoughnessFactor = _schema_clearcoatRoughnessFactor === void 0 ? 0 : _schema_clearcoatRoughnessFactor, clearcoatRoughnessTexture = schema.clearcoatRoughnessTexture, clearcoatNormalTexture = schema.clearcoatNormalTexture;
    material.clearCoat = clearcoatFactor;
    material.clearCoatRoughness = clearcoatRoughnessFactor;
    if (clearcoatTexture) {
      material.clearCoatTexture = textures[clearcoatTexture.index];
      GLTFMaterialParser._checkOtherTextureTransform(clearcoatTexture, "Clear coat");
    }
    if (clearcoatRoughnessTexture) {
      material.clearCoatRoughnessTexture = textures[clearcoatRoughnessTexture.index];
      GLTFMaterialParser._checkOtherTextureTransform(clearcoatRoughnessTexture, "Clear coat roughness");
    }
    if (clearcoatNormalTexture) {
      material.clearCoatNormalTexture = textures[clearcoatNormalTexture.index];
      GLTFMaterialParser._checkOtherTextureTransform(clearcoatNormalTexture, "Clear coat normal");
    }
  };
  return KHR_materials_clearcoat2;
}(GLTFExtensionParser);
KHR_materials_clearcoat = __decorate$1([
  registerGLTFExtension("KHR_materials_clearcoat", GLTFExtensionMode.AdditiveParse)
], KHR_materials_clearcoat);
var KHR_materials_ior = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(KHR_materials_ior2, GLTFExtensionParser2);
  function KHR_materials_ior2() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  var _proto = KHR_materials_ior2.prototype;
  _proto.additiveParse = function additiveParse(context, material, schema) {
    var _schema_ior = schema.ior, ior = _schema_ior === void 0 ? 1.5 : _schema_ior;
    material.ior = ior;
  };
  return KHR_materials_ior2;
}(GLTFExtensionParser);
KHR_materials_ior = __decorate$1([
  registerGLTFExtension("KHR_materials_ior", GLTFExtensionMode.AdditiveParse)
], KHR_materials_ior);
var KHR_materials_pbrSpecularGlossiness = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(KHR_materials_pbrSpecularGlossiness2, GLTFExtensionParser2);
  function KHR_materials_pbrSpecularGlossiness2() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  var _proto = KHR_materials_pbrSpecularGlossiness2.prototype;
  _proto.createAndParse = function createAndParse(context, schema, ownerSchema) {
    var _context_glTFResource = context.glTFResource, engine = _context_glTFResource.engine, textures = _context_glTFResource.textures;
    var material = new PBRSpecularMaterial(engine);
    var diffuseFactor = schema.diffuseFactor, diffuseTexture = schema.diffuseTexture, specularFactor = schema.specularFactor, glossinessFactor = schema.glossinessFactor, specularGlossinessTexture = schema.specularGlossinessTexture;
    if (diffuseFactor) {
      material.baseColor = new Color$1(Color$1.linearToGammaSpace(diffuseFactor[0]), Color$1.linearToGammaSpace(diffuseFactor[1]), Color$1.linearToGammaSpace(diffuseFactor[2]), diffuseFactor[3]);
    }
    if (diffuseTexture) {
      material.baseTexture = textures[diffuseTexture.index];
      GLTFParser.executeExtensionsAdditiveAndParse(diffuseTexture.extensions, context, material, diffuseTexture);
    }
    if (specularFactor) {
      material.specularColor = new Color$1(Color$1.linearToGammaSpace(specularFactor[0]), Color$1.linearToGammaSpace(specularFactor[1]), Color$1.linearToGammaSpace(specularFactor[2]));
    }
    if (glossinessFactor !== void 0) {
      material.glossiness = glossinessFactor;
    }
    if (specularGlossinessTexture) {
      material.specularGlossinessTexture = textures[specularGlossinessTexture.index];
      GLTFMaterialParser._checkOtherTextureTransform(specularGlossinessTexture, "Specular glossiness");
    }
    material.name = ownerSchema.name;
    GLTFMaterialParser._parseStandardProperty(context, material, ownerSchema);
    return material;
  };
  return KHR_materials_pbrSpecularGlossiness2;
}(GLTFExtensionParser);
KHR_materials_pbrSpecularGlossiness = __decorate$1([
  registerGLTFExtension("KHR_materials_pbrSpecularGlossiness", GLTFExtensionMode.CreateAndParse)
], KHR_materials_pbrSpecularGlossiness);
var KHR_materials_unlit = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(KHR_materials_unlit2, GLTFExtensionParser2);
  function KHR_materials_unlit2() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  var _proto = KHR_materials_unlit2.prototype;
  _proto.createAndParse = function createAndParse(context, _2, ownerSchema) {
    var engine = context.glTFResource.engine;
    var material = new UnlitMaterial(engine);
    material.name = ownerSchema.name;
    GLTFMaterialParser._parseStandardProperty(context, material, ownerSchema);
    return material;
  };
  return KHR_materials_unlit2;
}(GLTFExtensionParser);
KHR_materials_unlit = __decorate$1([
  registerGLTFExtension("KHR_materials_unlit", GLTFExtensionMode.CreateAndParse)
], KHR_materials_unlit);
var KHR_mesh_quantization = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(KHR_mesh_quantization2, GLTFExtensionParser2);
  function KHR_mesh_quantization2() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  return KHR_mesh_quantization2;
}(GLTFExtensionParser);
KHR_mesh_quantization = __decorate$1([
  registerGLTFExtension("KHR_mesh_quantization", GLTFExtensionMode.AdditiveParse)
], KHR_mesh_quantization);
var KHR_texture_transform = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(KHR_texture_transform2, GLTFExtensionParser2);
  function KHR_texture_transform2() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  var _proto = KHR_texture_transform2.prototype;
  _proto.additiveParse = function additiveParse(context, material, schema) {
    var offset = schema.offset, rotation = schema.rotation, scale = schema.scale, texCoord = schema.texCoord;
    if (offset) {
      material.tilingOffset.z = offset[0];
      material.tilingOffset.w = offset[1];
    }
    if (scale) {
      material.tilingOffset.x = scale[0];
      material.tilingOffset.y = scale[1];
    }
    if (rotation) {
      Logger.warn("rotation in KHR_texture_transform is not supported now");
    }
    if (texCoord) {
      Logger.warn("texCoord in KHR_texture_transform is not supported now");
    }
  };
  return KHR_texture_transform2;
}(GLTFExtensionParser);
KHR_texture_transform = __decorate$1([
  registerGLTFExtension("KHR_texture_transform", GLTFExtensionMode.AdditiveParse)
], KHR_texture_transform);
var GALACEAN_materials_remap = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(GALACEAN_materials_remap2, GLTFExtensionParser2);
  function GALACEAN_materials_remap2() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  var _proto = GALACEAN_materials_remap2.prototype;
  _proto.createAndParse = function createAndParse(context, schema) {
    var engine = context.glTFResource.engine;
    return engine.resourceManager.getResourceByRef(schema);
  };
  return GALACEAN_materials_remap2;
}(GLTFExtensionParser);
GALACEAN_materials_remap = __decorate$1([
  registerGLTFExtension("GALACEAN_materials_remap", GLTFExtensionMode.CreateAndParse)
], GALACEAN_materials_remap);
var GALACEAN_animation_event = /* @__PURE__ */ function(GLTFExtensionParser2) {
  _inherits(GALACEAN_animation_event2, GLTFExtensionParser2);
  function GALACEAN_animation_event2() {
    return GLTFExtensionParser2.apply(this, arguments);
  }
  var _proto = GALACEAN_animation_event2.prototype;
  _proto.additiveParse = function additiveParse(context, animationClip, schema) {
    context.glTFResource.engine;
    var events = schema.events;
    events.map(function(eventData) {
      var event = new AnimationEvent();
      event.functionName = eventData.functionName;
      event.time = eventData.time;
      event.parameter = eventData.parameter;
      animationClip.addEvent(event);
    });
  };
  return GALACEAN_animation_event2;
}(GLTFExtensionParser);
GALACEAN_animation_event = __decorate$1([
  registerGLTFExtension("GALACEAN_animation_event", GLTFExtensionMode.AdditiveParse)
], GALACEAN_animation_event);
var version = "1.0.4";
console.log("Galacean engine version: " + version);
for (var key in CoreObjects) {
  Loader.registerClass(key, CoreObjects[key]);
}
var ControlHandlerType;
(function(ControlHandlerType2) {
  ControlHandlerType2[ControlHandlerType2["None"] = 0] = "None";
  ControlHandlerType2[ControlHandlerType2["ROTATE"] = 1] = "ROTATE";
  ControlHandlerType2[ControlHandlerType2["ZOOM"] = 2] = "ZOOM";
  ControlHandlerType2[ControlHandlerType2["PAN"] = 4] = "PAN";
  ControlHandlerType2[ControlHandlerType2["All"] = 7] = "All";
})(ControlHandlerType || (ControlHandlerType = {}));
function StaticInterfaceImplement() {
  return function(constructor) {
  };
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
var ControlFreeKeyboard = /* @__PURE__ */ function() {
  function ControlFreeKeyboard2() {
  }
  ControlFreeKeyboard2.onUpdateHandler = function onUpdateHandler(input) {
    if (input.isKeyHeldDown(Keys.ArrowLeft) || input.isKeyHeldDown(Keys.KeyA) || input.isKeyHeldDown(Keys.ArrowUp) || input.isKeyHeldDown(Keys.KeyW) || input.isKeyHeldDown(Keys.ArrowDown) || input.isKeyHeldDown(Keys.KeyS) || input.isKeyHeldDown(Keys.ArrowRight) || input.isKeyHeldDown(Keys.KeyD)) {
      return ControlHandlerType.PAN;
    } else {
      return ControlHandlerType.None;
    }
  };
  ControlFreeKeyboard2.onUpdateDelta = function onUpdateDelta(control, outDelta) {
    var movementSpeed = control.movementSpeed, input = control.input;
    outDelta.x = outDelta.y = outDelta.z = 0;
    if (input.isKeyHeldDown(Keys.ArrowLeft) || input.isKeyHeldDown(Keys.KeyA)) {
      outDelta.x -= movementSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowRight) || input.isKeyHeldDown(Keys.KeyD)) {
      outDelta.x += movementSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowUp) || input.isKeyHeldDown(Keys.KeyW)) {
      outDelta.z -= movementSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowDown) || input.isKeyHeldDown(Keys.KeyS)) {
      outDelta.z += movementSpeed;
    }
  };
  return ControlFreeKeyboard2;
}();
ControlFreeKeyboard = __decorate([
  StaticInterfaceImplement()
], ControlFreeKeyboard);
var _ControlFreePointer;
var DeltaType$1;
(function(DeltaType2) {
  DeltaType2[DeltaType2["Moving"] = 0] = "Moving";
  DeltaType2[DeltaType2["Distance"] = 1] = "Distance";
  DeltaType2[DeltaType2["None"] = 2] = "None";
})(DeltaType$1 || (DeltaType$1 = {}));
var ControlFreePointer = (_ControlFreePointer = /* @__PURE__ */ function() {
  function ControlFreePointer2() {
  }
  ControlFreePointer2.onUpdateHandler = function onUpdateHandler(input) {
    ++this._frameIndex;
    if (input.pointers.length === 1) {
      if (input.isPointerHeldDown(PointerButton.Primary)) {
        this._updateType(ControlHandlerType.ROTATE, 0);
      } else {
        var deltaPosition = input.pointers[0].deltaPosition;
        if ((deltaPosition.x !== 0 || deltaPosition.y !== 0) && input.isPointerUp(PointerButton.Primary)) {
          this._updateType(ControlHandlerType.ROTATE, 0);
        } else {
          this._updateType(ControlHandlerType.None, 2);
        }
      }
    } else {
      this._updateType(ControlHandlerType.None, 2);
    }
    return this._handlerType;
  };
  ControlFreePointer2.onUpdateDelta = function onUpdateDelta(control, outDelta) {
    var _this = this, frameIndex = _this._frameIndex;
    switch (this._deltaType) {
      case 0:
        if (this._lastUsefulFrameIndex === frameIndex - 1) {
          var deltaPosition = control.input.pointers[0].deltaPosition;
          outDelta.x = deltaPosition.x;
          outDelta.y = deltaPosition.y;
        } else {
          outDelta.x = 0;
          outDelta.y = 0;
        }
        break;
    }
    this._lastUsefulFrameIndex = frameIndex;
  };
  ControlFreePointer2._updateType = function _updateType(handlerType, deltaType) {
    if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
      this._handlerType = handlerType;
      this._deltaType = deltaType;
      this._lastUsefulFrameIndex = -1;
    }
  };
  return ControlFreePointer2;
}(), function() {
  _ControlFreePointer._deltaType = 0;
}(), function() {
  _ControlFreePointer._handlerType = ControlHandlerType.None;
}(), function() {
  _ControlFreePointer._frameIndex = 0;
}(), function() {
  _ControlFreePointer._lastUsefulFrameIndex = -1;
}(), _ControlFreePointer);
ControlFreePointer = __decorate([
  StaticInterfaceImplement()
], ControlFreePointer);
var ESP = MathUtil$1.zeroTolerance;
var Spherical = /* @__PURE__ */ function() {
  function Spherical2(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    this._matrix = new Matrix();
    this._matrixInv = new Matrix();
    this.radius = radius !== void 0 ? radius : 1;
    this.phi = phi !== void 0 ? phi : 0;
    this.theta = theta !== void 0 ? theta : 0;
  }
  var _proto = Spherical2.prototype;
  _proto.makeSafe = function makeSafe() {
    var count = Math.floor(this.phi / Math.PI);
    this.phi = MathUtil$1.clamp(this.phi, count * Math.PI + ESP, (count + 1) * Math.PI - ESP);
    return this;
  };
  _proto.set = function set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  };
  _proto.setYAxis = function setYAxis(up) {
    var xAxis = Spherical2._xAxis, yAxis = Spherical2._yAxis, zAxis = Spherical2._zAxis;
    if (Vector3.equals(xAxis.set(1, 0, 0), yAxis.copyFrom(up).normalize())) {
      xAxis.set(0, 1, 0);
    }
    Vector3.cross(xAxis, yAxis, zAxis);
    zAxis.normalize();
    Vector3.cross(yAxis, zAxis, xAxis);
    var _this__matrix = this._matrix, es = _this__matrix.elements;
    es[0] = xAxis.x, es[1] = xAxis.y, es[2] = xAxis.z;
    es[4] = yAxis.x, es[5] = yAxis.y, es[6] = yAxis.z;
    es[8] = zAxis.x, es[9] = zAxis.y, es[10] = zAxis.z;
    var _this__matrixInv = this._matrixInv, eInv = _this__matrixInv.elements;
    eInv[0] = xAxis.x, eInv[4] = xAxis.y, eInv[8] = xAxis.z;
    eInv[1] = yAxis.x, eInv[5] = yAxis.y, eInv[9] = yAxis.z;
    eInv[2] = zAxis.x, eInv[6] = zAxis.y, eInv[10] = zAxis.z;
  };
  _proto.setFromVec3 = function setFromVec3(value, atTheBack) {
    if (atTheBack === void 0)
      atTheBack = false;
    value.transformNormal(this._matrixInv);
    this.radius = value.length();
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      if (atTheBack) {
        this.phi = 2 * Math.PI - Math.acos(MathUtil$1.clamp(value.y / this.radius, -1, 1));
        this.theta = Math.atan2(-value.x, -value.z);
      } else {
        this.phi = Math.acos(MathUtil$1.clamp(value.y / this.radius, -1, 1));
        this.theta = Math.atan2(value.x, value.z);
      }
    }
    return this;
  };
  _proto.setToVec3 = function setToVec3(value) {
    var _this = this, radius = _this.radius, phi = _this.phi, theta = _this.theta;
    var sinPhiRadius = Math.sin(phi) * radius;
    this.phi -= Math.floor(this.phi / Math.PI / 2) * Math.PI * 2;
    value.set(sinPhiRadius * Math.sin(theta), radius * Math.cos(phi), sinPhiRadius * Math.cos(theta));
    value.transformNormal(this._matrix);
    return this.phi > Math.PI;
  };
  return Spherical2;
}();
(function() {
  Spherical._xAxis = new Vector3();
})();
(function() {
  Spherical._yAxis = new Vector3();
})();
(function() {
  Spherical._zAxis = new Vector3();
})();
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var ControlKeyboard = /* @__PURE__ */ function() {
  function ControlKeyboard2() {
  }
  ControlKeyboard2.onUpdateHandler = function onUpdateHandler(input) {
    if (input.isKeyHeldDown(Keys.ArrowLeft) || input.isKeyHeldDown(Keys.ArrowRight) || input.isKeyHeldDown(Keys.ArrowUp) || input.isKeyHeldDown(Keys.ArrowDown)) {
      return ControlHandlerType.PAN;
    } else {
      return ControlHandlerType.None;
    }
  };
  ControlKeyboard2.onUpdateDelta = function onUpdateDelta(control, outDelta) {
    var keyPanSpeed = control.keyPanSpeed, input = control.input;
    outDelta.x = outDelta.y = 0;
    if (input.isKeyHeldDown(Keys.ArrowLeft)) {
      outDelta.x += keyPanSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowRight)) {
      outDelta.x -= keyPanSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowUp)) {
      outDelta.y += keyPanSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowDown)) {
      outDelta.y -= keyPanSpeed;
    }
  };
  return ControlKeyboard2;
}();
ControlKeyboard = __decorate([
  StaticInterfaceImplement()
], ControlKeyboard);
var _ControlPointer;
var DeltaType;
(function(DeltaType2) {
  DeltaType2[DeltaType2["Moving"] = 0] = "Moving";
  DeltaType2[DeltaType2["Distance"] = 1] = "Distance";
  DeltaType2[DeltaType2["None"] = 2] = "None";
})(DeltaType || (DeltaType = {}));
var ControlPointer = (_ControlPointer = /* @__PURE__ */ function() {
  function ControlPointer2() {
  }
  ControlPointer2.onUpdateHandler = function onUpdateHandler(input) {
    ++this._frameIndex;
    var pointers = input.pointers;
    switch (pointers.length) {
      case 1:
        if (input.isPointerHeldDown(PointerButton.Secondary)) {
          this._updateType(ControlHandlerType.PAN, 0);
        } else if (input.isPointerHeldDown(PointerButton.Auxiliary)) {
          this._updateType(ControlHandlerType.ZOOM, 0);
        } else if (input.isPointerHeldDown(PointerButton.Primary)) {
          this._updateType(ControlHandlerType.ROTATE, 0);
        } else {
          var deltaPosition = input.pointers[0].deltaPosition;
          if (deltaPosition.x !== 0 && deltaPosition.y !== 0) {
            if (input.isPointerUp(PointerButton.Secondary)) {
              this._updateType(ControlHandlerType.PAN, 0);
            } else if (input.isPointerUp(PointerButton.Auxiliary)) {
              this._updateType(ControlHandlerType.ZOOM, 0);
            } else if (input.isPointerUp(PointerButton.Primary)) {
              this._updateType(ControlHandlerType.ROTATE, 0);
            } else {
              this._updateType(ControlHandlerType.None, 2);
            }
          } else {
            this._updateType(ControlHandlerType.None, 2);
          }
        }
        break;
      case 2:
        this._updateType(ControlHandlerType.ZOOM, 1);
        break;
      case 3:
        this._updateType(ControlHandlerType.PAN, 0);
        break;
      default:
        this._updateType(ControlHandlerType.None, 2);
        break;
    }
    return this._handlerType;
  };
  ControlPointer2.onUpdateDelta = function onUpdateDelta(control, outDelta) {
    var _this = this, frameIndex = _this._frameIndex;
    switch (this._deltaType) {
      case 0:
        outDelta.x = 0;
        outDelta.y = 0;
        if (this._lastUsefulFrameIndex === frameIndex - 1) {
          var pointers = control.input.pointers;
          var length2 = pointers.length;
          for (var i = length2 - 1; i >= 0; i--) {
            var deltaPosition = pointers[i].deltaPosition;
            outDelta.x += deltaPosition.x;
            outDelta.y += deltaPosition.y;
          }
          outDelta.x /= length2;
          outDelta.y /= length2;
        }
        break;
      case 1:
        var pointers1 = control.input.pointers;
        var pointer1 = pointers1[0];
        var pointer2 = pointers1[1];
        var curDistance = Vector2.distance(pointer1.position, pointer2.position);
        if (this._lastUsefulFrameIndex === frameIndex - 1) {
          outDelta.set(0, this._distanceOfPointers - curDistance, 0);
        } else {
          outDelta.set(0, 0, 0);
        }
        this._distanceOfPointers = curDistance;
        break;
    }
    this._lastUsefulFrameIndex = frameIndex;
  };
  ControlPointer2._updateType = function _updateType(handlerType, deltaType) {
    if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
      this._handlerType = handlerType;
      this._deltaType = deltaType;
      this._lastUsefulFrameIndex = -1;
    }
  };
  return ControlPointer2;
}(), function() {
  _ControlPointer._deltaType = 2;
}(), function() {
  _ControlPointer._handlerType = ControlHandlerType.None;
}(), function() {
  _ControlPointer._frameIndex = 0;
}(), function() {
  _ControlPointer._lastUsefulFrameIndex = -1;
}(), function() {
  _ControlPointer._distanceOfPointers = 0;
}(), _ControlPointer);
ControlPointer = __decorate([
  StaticInterfaceImplement()
], ControlPointer);
var ControlWheel = /* @__PURE__ */ function() {
  function ControlWheel2() {
  }
  ControlWheel2.onUpdateHandler = function onUpdateHandler(input) {
    var wheelDelta = input.wheelDelta;
    if (wheelDelta.x === 0 && wheelDelta.y === 0 && wheelDelta.z === 0) {
      return ControlHandlerType.None;
    } else {
      return ControlHandlerType.ZOOM;
    }
  };
  ControlWheel2.onUpdateDelta = function onUpdateDelta(control, outDelta) {
    outDelta.copyFrom(control.input.wheelDelta);
  };
  return ControlWheel2;
}();
ControlWheel = __decorate([
  StaticInterfaceImplement()
], ControlWheel);
var OrbitControl = /* @__PURE__ */ function(Script2) {
  _inherits$3(OrbitControl2, Script2);
  function OrbitControl2() {
    var _this;
    _this = Script2.apply(this, arguments) || this;
    _this.inputDevices = [
      ControlKeyboard,
      ControlPointer,
      ControlWheel
    ];
    _this.autoRotate = false;
    _this.autoRotateSpeed = Math.PI;
    _this.enableDamping = true;
    _this.rotateSpeed = 1;
    _this.zoomSpeed = 1;
    _this.keyPanSpeed = 7;
    _this.dampingFactor = 0.1;
    _this.zoomFactor = 0.2;
    _this.minDistance = 0.1;
    _this.maxDistance = Infinity;
    _this.minZoom = 0;
    _this.maxZoom = Infinity;
    _this.minPolarAngle = 1 / 180 * Math.PI;
    _this.maxPolarAngle = 179 / 180 * Math.PI;
    _this.minAzimuthAngle = -Infinity;
    _this.maxAzimuthAngle = Infinity;
    _this._enableKeys = true;
    _this._up = new Vector3(0, 1, 0);
    _this._target = new Vector3();
    _this._atTheBack = false;
    _this._spherical = new Spherical();
    _this._sphericalDelta = new Spherical();
    _this._sphericalDump = new Spherical();
    _this._zoomFrag = 0;
    _this._scale = 1;
    _this._panOffset = new Vector3();
    _this._tempVec3 = new Vector3();
    _this._enableHandler = ControlHandlerType.All;
    return _this;
  }
  var _proto = OrbitControl2.prototype;
  _proto.onAwake = function onAwake() {
    var _this = this, engine = _this.engine, entity = _this.entity;
    this.canvas = engine.canvas;
    this.input = engine.inputManager;
    this.camera = entity.getComponent(Camera);
    this.cameraTransform = entity.transform;
    this._spherical.setYAxis(this._up);
    this._atTheBack = false;
  };
  _proto.onLateUpdate = function onLateUpdate(deltaTime) {
    this._updateInputDelta(deltaTime);
    this._updateTransform();
  };
  _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
    var curHandlerType = ControlHandlerType.None;
    var _this = this, delta = _this._tempVec3, enableHandler = _this._enableHandler;
    var _this1 = this, inputDevices = _this1.inputDevices, input = _this1.input;
    for (var i = inputDevices.length - 1; i >= 0; i--) {
      var handler = inputDevices[i];
      var handlerType = handler.onUpdateHandler(input);
      if (handlerType & enableHandler) {
        curHandlerType |= handlerType;
        handler.onUpdateDelta(this, delta);
        switch (handlerType) {
          case ControlHandlerType.ROTATE:
            this._rotate(delta);
            break;
          case ControlHandlerType.ZOOM:
            this._zoom(delta);
            break;
          case ControlHandlerType.PAN:
            this._pan(delta);
            break;
        }
      }
    }
    var _this2 = this, _sphericalDump = _this2._sphericalDump, _sphericalDelta = _this2._sphericalDelta;
    if (this.enableDamping) {
      if (enableHandler & ControlHandlerType.ZOOM && curHandlerType ^ ControlHandlerType.ZOOM) {
        this._zoomFrag *= 1 - this.zoomFactor;
      }
      if (enableHandler & ControlHandlerType.ROTATE && curHandlerType ^ ControlHandlerType.ROTATE) {
        _sphericalDelta.theta = _sphericalDump.theta *= 1 - this.dampingFactor;
        _sphericalDelta.phi = _sphericalDump.phi *= 1 - this.dampingFactor;
      }
    }
    if (curHandlerType === ControlHandlerType.None && this.autoRotate) {
      var rotateAngle = this.autoRotateSpeed * deltaTime;
      _sphericalDelta.theta -= rotateAngle;
    }
  };
  _proto._rotate = function _rotate(delta) {
    var radianLeft = 2 * Math.PI * delta.x / this.canvas.width * this.rotateSpeed;
    this._sphericalDelta.theta -= radianLeft;
    var radianUp = 2 * Math.PI * delta.y / this.canvas.height * this.rotateSpeed;
    this._sphericalDelta.phi -= radianUp;
    if (this.enableDamping) {
      this._sphericalDump.theta = -radianLeft;
      this._sphericalDump.phi = -radianUp;
    }
  };
  _proto._zoom = function _zoom(delta) {
    if (delta.y > 0) {
      this._scale /= Math.pow(0.95, this.zoomSpeed);
    } else if (delta.y < 0) {
      this._scale *= Math.pow(0.95, this.zoomSpeed);
    }
  };
  _proto._pan = function _pan(delta) {
    var cameraTransform = this.cameraTransform;
    var elements = cameraTransform.worldMatrix.elements;
    var height = this.canvas.height;
    var targetDistance = Vector3.distance(cameraTransform.position, this.target) * (this.camera.fieldOfView / 2) * (Math.PI / 180);
    var distanceLeft = -2 * delta.x * (targetDistance / height);
    var distanceUp = 2 * delta.y * (targetDistance / height);
    this._panOffset.x += elements[0] * distanceLeft + elements[4] * distanceUp;
    this._panOffset.y += elements[1] * distanceLeft + elements[5] * distanceUp;
    this._panOffset.z += elements[2] * distanceLeft + elements[6] * distanceUp;
  };
  _proto._updateTransform = function _updateTransform() {
    var _this = this, cameraTransform = _this.cameraTransform, target = _this.target, _tempVec3 = _this._tempVec3, _spherical = _this._spherical, _sphericalDelta = _this._sphericalDelta, _panOffset = _this._panOffset;
    _tempVec3.copyFrom(cameraTransform.worldUp);
    this._atTheBack = _tempVec3.y <= 0;
    Vector3.subtract(cameraTransform.position, target, _tempVec3);
    _spherical.setFromVec3(_tempVec3, this._atTheBack);
    _spherical.theta += _sphericalDelta.theta;
    _spherical.phi += _sphericalDelta.phi;
    _spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, _spherical.theta));
    _spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, _spherical.phi));
    _spherical.makeSafe();
    if (this._scale !== 1) {
      this._zoomFrag = _spherical.radius * (this._scale - 1);
    }
    _spherical.radius += this._zoomFrag;
    _spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, _spherical.radius));
    this._atTheBack = _spherical.setToVec3(_tempVec3);
    Vector3.add(target.add(_panOffset), _tempVec3, cameraTransform.worldPosition);
    cameraTransform.lookAt(target, _tempVec3.copyFrom(this.up).scale(this._atTheBack ? -1 : 1));
    this._zoomFrag = 0;
    this._scale = 1;
    _sphericalDelta.set(0, 0, 0);
    _panOffset.set(0, 0, 0);
  };
  _create_class(OrbitControl2, [
    {
      key: "enableKeys",
      get: function get3() {
        return this._enableKeys;
      },
      set: function set(value) {
        if (this._enableKeys !== value) {
          this._enableKeys = value;
          var inputDevices = this.inputDevices;
          if (value) {
            inputDevices.push(ControlKeyboard);
          } else {
            for (var i = inputDevices.length - 1; i >= 0; i--) {
              if (inputDevices[i] === ControlKeyboard) {
                inputDevices.splice(i, 1);
                break;
              }
            }
          }
        }
      }
    },
    {
      key: "up",
      get: function get3() {
        return this._up;
      },
      set: function set(value) {
        this._up.copyFrom(value);
        this._spherical.setYAxis(value);
        this._atTheBack = false;
      }
    },
    {
      key: "target",
      get: function get3() {
        return this._target;
      },
      set: function set(value) {
        this._target.copyFrom(value);
        this._atTheBack = false;
      }
    },
    {
      key: "enableRotate",
      get: function get3() {
        return (this._enableHandler & ControlHandlerType.ROTATE) !== 0;
      },
      set: function set(value) {
        if (value) {
          this._enableHandler |= ControlHandlerType.ROTATE;
        } else {
          this._enableHandler &= ~ControlHandlerType.ROTATE;
        }
      }
    },
    {
      key: "enableZoom",
      get: function get3() {
        return (this._enableHandler & ControlHandlerType.ZOOM) !== 0;
      },
      set: function set(value) {
        if (value) {
          this._enableHandler |= ControlHandlerType.ZOOM;
        } else {
          this._enableHandler &= ~ControlHandlerType.ZOOM;
        }
      }
    },
    {
      key: "enablePan",
      get: function get3() {
        return (this._enableHandler & ControlHandlerType.PAN) !== 0;
      },
      set: function set(value) {
        if (value) {
          this._enableHandler |= ControlHandlerType.PAN;
        } else {
          this._enableHandler &= ~ControlHandlerType.PAN;
        }
      }
    }
  ]);
  return OrbitControl2;
}(Script);
function M(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
  }
}
function A(t, e, r) {
  return e && M(t.prototype, e), r && M(t, r), t;
}
function T() {
  return T = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, T.apply(this, arguments);
}
function I(t, e) {
  return I = Object.setPrototypeOf || function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, I(t, e);
}
function R(t, e) {
  if ("function" != typeof e && null !== e)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), e && I(t, e);
}
function C(t, e, r, n) {
  var a, i = arguments.length, s = i < 3 ? e : null === n ? n = Object.getOwnPropertyDescriptor(e, r) : n;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    s = Reflect.decorate(t, e, r, n);
  else
    for (var o = t.length - 1; o >= 0; o--)
      (a = t[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, r, s) : a(e, r)) || s);
  return i > 3 && s && Object.defineProperty(e, r, s), s;
}
function k(t, e) {
  return null != e && "undefined" != typeof Symbol && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](t) : t instanceof e;
}
"function" == typeof SuppressedError && SuppressedError;
var V = function() {
  function t() {
    this.array = new Array();
  }
  var e = t.prototype;
  return e.add = function(t2) {
    var e2 = this.contains(t2);
    return this.array[0 | t2] = 0 | t2, !e2;
  }, e.contains = function(t2) {
    return null != this.array[0 | t2];
  }, e.remove = function(t2) {
    this.array[0 | t2] = void 0;
  }, e.clear = function() {
    this.array.length = 0;
  }, t;
}(), P = function() {
  function t(t2, e2, r, n) {
    void 0 === t2 && (t2 = 0), void 0 === e2 && (e2 = 0), void 0 === r && (r = 0), void 0 === n && (n = 0), this.r = t2, this.g = e2, this.b = r, this.a = n;
  }
  var e = t.prototype;
  return e.set = function(t2, e2, r, n) {
    return this.r = t2, this.g = e2, this.b = r, this.a = n, this.clamp(), this;
  }, e.setFromColor = function(t2) {
    return this.r = t2.r, this.g = t2.g, this.b = t2.b, this.a = t2.a, this;
  }, e.setFromString = function(t2) {
    return t2 = "#" == t2.charAt(0) ? t2.substr(1) : t2, this.r = parseInt(t2.substr(0, 2), 16) / 255, this.g = parseInt(t2.substr(2, 2), 16) / 255, this.b = parseInt(t2.substr(4, 2), 16) / 255, this.a = (8 != t2.length ? 255 : parseInt(t2.substr(6, 2), 16)) / 255, this;
  }, e.add = function(t2, e2, r, n) {
    return this.r += t2, this.g += e2, this.b += r, this.a += n, this.clamp(), this;
  }, e.clamp = function() {
    return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this;
  }, t.rgba8888ToColor = function(t2, e2) {
    t2.r = ((4278190080 & e2) >>> 24) / 255, t2.g = ((16711680 & e2) >>> 16) / 255, t2.b = ((65280 & e2) >>> 8) / 255, t2.a = (255 & e2) / 255;
  }, t.rgb888ToColor = function(t2, e2) {
    t2.r = ((16711680 & e2) >>> 16) / 255, t2.g = ((65280 & e2) >>> 8) / 255, t2.b = (255 & e2) / 255;
  }, t;
}();
P.WHITE = new P(1, 1, 1, 1), P.RED = new P(1, 0, 0, 1), P.GREEN = new P(0, 1, 0, 1), P.BLUE = new P(0, 0, 1, 1), P.MAGENTA = new P(1, 0, 1, 1);
var _ = function() {
  function t() {
  }
  return t.clamp = function(t2, e, r) {
    return t2 < e ? e : t2 > r ? r : t2;
  }, t.cosDeg = function(e) {
    return Math.cos(e * t.degRad);
  }, t.sinDeg = function(e) {
    return Math.sin(e * t.degRad);
  }, t.signum = function(t2) {
    return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
  }, t.toInt = function(t2) {
    return t2 > 0 ? Math.floor(t2) : Math.ceil(t2);
  }, t.cbrt = function(t2) {
    var e = Math.pow(Math.abs(t2), 1 / 3);
    return t2 < 0 ? -e : e;
  }, t.randomTriangular = function(e, r) {
    return t.randomTriangularWith(e, r, 0.5 * (e + r));
  }, t.randomTriangularWith = function(t2, e, r) {
    var n = Math.random(), a = e - t2;
    return n <= (r - t2) / a ? t2 + Math.sqrt(n * a * (r - t2)) : e - Math.sqrt((1 - n) * a * (e - r));
  }, t;
}();
_.PI = 3.1415927, _.PI2 = 2 * _.PI, _.radiansToDegrees = 180 / _.PI, _.radDeg = _.radiansToDegrees, _.degreesToRadians = _.PI / 180, _.degRad = _.degreesToRadians;
var F = function() {
  function t() {
  }
  return t.arrayCopy = function(t2, e, r, n, a) {
    for (var i = e, s = n; i < e + a; i++, s++)
      r[s] = t2[i];
  }, t.setArraySize = function(t2, e, r) {
    void 0 === r && (r = 0);
    var n = t2.length;
    if (n == e)
      return t2;
    if (t2.length = e, n < e)
      for (var a = n; a < e; a++)
        t2[a] = r;
    return t2;
  }, t.ensureArrayCapacity = function(e, r, n) {
    return void 0 === n && (n = 0), e.length >= r ? e : t.setArraySize(e, r, n);
  }, t.newArray = function(t2, e) {
    for (var r = new Array(t2), n = 0; n < t2; n++)
      r[n] = e;
    return r;
  }, t.newFloatArray = function(e) {
    if (t.SUPPORTS_TYPED_ARRAYS)
      return new Float32Array(e);
    for (var r = new Array(e), n = 0; n < r.length; n++)
      r[n] = 0;
    return r;
  }, t.newShortArray = function(e) {
    if (t.SUPPORTS_TYPED_ARRAYS)
      return new Int16Array(e);
    for (var r = new Array(e), n = 0; n < r.length; n++)
      r[n] = 0;
    return r;
  }, t.toFloatArray = function(e) {
    return t.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e;
  }, t.toSinglePrecision = function(e) {
    return t.SUPPORTS_TYPED_ARRAYS ? Math.fround(e) : e;
  }, t.webkit602BugfixHelper = function(t2, e) {
  }, t.contains = function(t2, e, r) {
    for (var n = 0; n < t2.length; n++)
      if (t2[n] == e)
        return true;
    return false;
  }, t;
}();
F.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array;
var N, O = function() {
  function t(t2) {
    this.items = new Array(), this.instantiator = t2;
  }
  var e = t.prototype;
  return e.obtain = function() {
    return this.items.length > 0 ? this.items.pop() : this.instantiator();
  }, e.free = function(t2) {
    t2.reset && t2.reset(), this.items.push(t2);
  }, e.freeAll = function(t2) {
    for (var e2 = 0; e2 < t2.length; e2++)
      this.free(t2[e2]);
  }, e.clear = function() {
    this.items.length = 0;
  }, t;
}(), L = function() {
  function t(t2, e2) {
    void 0 === t2 && (t2 = 0), void 0 === e2 && (e2 = 0), this.x = t2, this.y = e2;
  }
  var e = t.prototype;
  return e.set = function(t2, e2) {
    return this.x = t2, this.y = e2, this;
  }, e.length = function() {
    var t2 = this.x, e2 = this.y;
    return Math.sqrt(t2 * t2 + e2 * e2);
  }, e.normalize = function() {
    var t2 = this.length();
    return 0 != t2 && (this.x /= t2, this.y /= t2), this;
  }, t;
}(), X = function(t, e, r) {
  if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = 0, this.skinRequired = false, this.color = new P(), t < 0)
    throw new Error("index must be >= 0.");
  if (null == e)
    throw new Error("name cannot be null.");
  this.index = t, this.name = e, this.parent = r;
};
!function(t) {
  t[t.Normal = 0] = "Normal", t[t.OnlyTranslation = 1] = "OnlyTranslation", t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection", t[t.NoScale = 3] = "NoScale", t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection";
}(N || (N = {}));
var B, D, Y, U = function() {
  function t(t2, e2, r) {
    if (this.children = new Array(), this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.appliedValid = false, this.a = 0, this.b = 0, this.c = 0, this.d = 0, this.worldY = 0, this.worldX = 0, this.sorted = false, this.active = false, null == t2)
      throw new Error("data cannot be null.");
    if (null == e2)
      throw new Error("skeleton cannot be null.");
    this.data = t2, this.skeleton = e2, this.parent = r, this.setToSetupPose();
  }
  var e = t.prototype;
  return e.isActive = function() {
    return this.active;
  }, e.update = function() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }, e.updateWorldTransform = function() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }, e.updateWorldTransformWith = function(t2, e2, r, n, a, i, s) {
    this.ax = t2, this.ay = e2, this.arotation = r, this.ascaleX = n, this.ascaleY = a, this.ashearX = i, this.ashearY = s, this.appliedValid = true;
    var o = this.parent;
    if (null == o) {
      var h = this.skeleton, l = r + 90 + s, u = h.scaleX, c = h.scaleY;
      return this.a = _.cosDeg(r + i) * n * u, this.b = _.cosDeg(l) * a * u, this.c = _.sinDeg(r + i) * n * c, this.d = _.sinDeg(l) * a * c, this.worldX = t2 * u + h.x, void (this.worldY = e2 * c + h.y);
    }
    var d = o.a, f = o.b, v = o.c, p = o.d;
    switch (this.worldX = d * t2 + f * e2 + o.worldX, this.worldY = v * t2 + p * e2 + o.worldY, this.data.transformMode) {
      case N.Normal:
        var g = r + 90 + s, m = _.cosDeg(r + i) * n, w = _.cosDeg(g) * a, E = _.sinDeg(r + i) * n, x = _.sinDeg(g) * a;
        return this.a = d * m + f * E, this.b = d * w + f * x, this.c = v * m + p * E, void (this.d = v * w + p * x);
      case N.OnlyTranslation:
        var y = r + 90 + s;
        this.a = _.cosDeg(r + i) * n, this.b = _.cosDeg(y) * a, this.c = _.sinDeg(r + i) * n, this.d = _.sinDeg(y) * a;
        break;
      case N.NoRotationOrReflection:
        var b = d * d + v * v, S = 0;
        b > 1e-4 ? (b = Math.abs(d * p - f * v) / b, d /= this.skeleton.scaleX, f = (v /= this.skeleton.scaleY) * b, p = d * b, S = Math.atan2(v, d) * _.radDeg) : (d = 0, v = 0, S = 90 - Math.atan2(p, f) * _.radDeg);
        var M2 = r + i - S, A2 = r + s - S + 90, T2 = _.cosDeg(M2) * n, I2 = _.cosDeg(A2) * a, R2 = _.sinDeg(M2) * n, C2 = _.sinDeg(A2) * a;
        this.a = d * T2 - f * R2, this.b = d * I2 - f * C2, this.c = v * T2 + p * R2, this.d = v * I2 + p * C2;
        break;
      case N.NoScale:
      case N.NoScaleOrReflection:
        var k2 = _.cosDeg(r), V2 = _.sinDeg(r), P2 = (d * k2 + f * V2) / this.skeleton.scaleX, F2 = (v * k2 + p * V2) / this.skeleton.scaleY, O2 = Math.sqrt(P2 * P2 + F2 * F2);
        O2 > 1e-5 && (O2 = 1 / O2), P2 *= O2, F2 *= O2, O2 = Math.sqrt(P2 * P2 + F2 * F2), this.data.transformMode == N.NoScale && d * p - f * v < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (O2 = -O2);
        var L2 = Math.PI / 2 + Math.atan2(F2, P2), X2 = Math.cos(L2) * O2, B2 = Math.sin(L2) * O2, D2 = _.cosDeg(i) * n, Y2 = _.cosDeg(90 + s) * a, U2 = _.sinDeg(i) * n, W2 = _.sinDeg(90 + s) * a;
        this.a = P2 * D2 + X2 * U2, this.b = P2 * Y2 + X2 * W2, this.c = F2 * D2 + B2 * U2, this.d = F2 * Y2 + B2 * W2;
    }
    this.a *= this.skeleton.scaleX, this.b *= this.skeleton.scaleX, this.c *= this.skeleton.scaleY, this.d *= this.skeleton.scaleY;
  }, e.setToSetupPose = function() {
    var t2 = this.data;
    this.x = t2.x, this.y = t2.y, this.rotation = t2.rotation, this.scaleX = t2.scaleX, this.scaleY = t2.scaleY, this.shearX = t2.shearX, this.shearY = t2.shearY;
  }, e.getWorldRotationX = function() {
    return Math.atan2(this.c, this.a) * _.radDeg;
  }, e.getWorldRotationY = function() {
    return Math.atan2(this.d, this.b) * _.radDeg;
  }, e.getWorldScaleX = function() {
    return Math.sqrt(this.a * this.a + this.c * this.c);
  }, e.getWorldScaleY = function() {
    return Math.sqrt(this.b * this.b + this.d * this.d);
  }, e.updateAppliedTransform = function() {
    this.appliedValid = true;
    var t2 = this.parent;
    if (null == t2)
      return this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * _.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, void (this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * _.radDeg);
    var e2 = t2.a, r = t2.b, n = t2.c, a = t2.d, i = 1 / (e2 * a - r * n), s = this.worldX - t2.worldX, o = this.worldY - t2.worldY;
    this.ax = s * a * i - o * r * i, this.ay = o * e2 * i - s * n * i;
    var h = i * a, l = i * e2, u = i * r, c = i * n, d = h * this.a - u * this.c, f = h * this.b - u * this.d, v = l * this.c - c * this.a, p = l * this.d - c * this.b;
    if (this.ashearX = 0, this.ascaleX = Math.sqrt(d * d + v * v), this.ascaleX > 1e-4) {
      var g = d * p - f * v;
      this.ascaleY = g / this.ascaleX, this.ashearY = Math.atan2(d * f + v * p, g) * _.radDeg, this.arotation = Math.atan2(v, d) * _.radDeg;
    } else
      this.ascaleX = 0, this.ascaleY = Math.sqrt(f * f + p * p), this.ashearY = 0, this.arotation = 90 - Math.atan2(p, f) * _.radDeg;
  }, e.worldToLocal = function(t2) {
    var e2 = this.a, r = this.b, n = this.c, a = this.d, i = 1 / (e2 * a - r * n), s = t2.x - this.worldX, o = t2.y - this.worldY;
    return t2.x = s * a * i - o * r * i, t2.y = o * e2 * i - s * n * i, t2;
  }, e.localToWorld = function(t2) {
    var e2 = t2.x, r = t2.y;
    return t2.x = e2 * this.a + r * this.b + this.worldX, t2.y = e2 * this.c + r * this.d + this.worldY, t2;
  }, e.worldToLocalRotation = function(t2) {
    var e2 = _.sinDeg(t2), r = _.cosDeg(t2);
    return Math.atan2(this.a * e2 - this.c * r, this.d * r - this.b * e2) * _.radDeg + this.rotation - this.shearX;
  }, e.localToWorldRotation = function(t2) {
    t2 -= this.rotation - this.shearX;
    var e2 = _.sinDeg(t2), r = _.cosDeg(t2);
    return Math.atan2(r * this.c + e2 * this.d, r * this.a + e2 * this.b) * _.radDeg;
  }, e.rotateWorld = function(t2) {
    var e2 = this.a, r = this.b, n = this.c, a = this.d, i = _.cosDeg(t2), s = _.sinDeg(t2);
    this.a = i * e2 - s * n, this.b = i * r - s * a, this.c = s * e2 + i * n, this.d = s * r + i * a, this.appliedValid = false;
  }, t;
}(), W = function() {
  function t(t2, e2) {
    if (this.deform = new Array(), null == t2)
      throw new Error("data cannot be null.");
    if (null == e2)
      throw new Error("bone cannot be null.");
    this.data = t2, this.bone = e2, this.color = new P(), this.darkColor = null == t2.darkColor ? null : new P(), this.setToSetupPose();
  }
  var e = t.prototype;
  return e.getSkeleton = function() {
    return this.bone.skeleton;
  }, e.getAttachment = function() {
    return this.attachment;
  }, e.setAttachment = function(t2) {
    this.attachment != t2 && (this.attachment = t2, this.attachmentTime = this.bone.skeleton.time, this.deform.length = 0);
  }, e.setAttachmentTime = function(t2) {
    this.attachmentTime = this.bone.skeleton.time - t2;
  }, e.getAttachmentTime = function() {
    return this.bone.skeleton.time - this.attachmentTime;
  }, e.setToSetupPose = function() {
    this.color.setFromColor(this.data.color), null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor), null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)));
  }, t;
}(), q = function() {
  function t(t2, e2) {
    if (this.bendDirection = 0, this.compress = false, this.stretch = false, this.mix = 1, this.softness = 0, this.active = false, null == t2)
      throw new Error("data cannot be null.");
    if (null == e2)
      throw new Error("skeleton cannot be null.");
    this.data = t2, this.mix = t2.mix, this.softness = t2.softness, this.bendDirection = t2.bendDirection, this.compress = t2.compress, this.stretch = t2.stretch, this.bones = new Array();
    for (var r = 0; r < t2.bones.length; r++)
      this.bones.push(e2.findBone(t2.bones[r].name));
    this.target = e2.findBone(t2.target.name);
  }
  var e = t.prototype;
  return e.isActive = function() {
    return this.active;
  }, e.apply = function() {
    this.update();
  }, e.update = function() {
    var t2 = this.target, e2 = this.bones;
    switch (e2.length) {
      case 1:
        this.apply1(e2[0], t2.worldX, t2.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(e2[0], e2[1], t2.worldX, t2.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
    }
  }, e.apply1 = function(t2, e2, r, n, a, i, s) {
    t2.appliedValid || t2.updateAppliedTransform();
    var o = t2.parent, h = o.a, l = o.b, u = o.c, c = o.d, d = -t2.ashearX - t2.arotation, f = 0, v = 0;
    switch (t2.data.transformMode) {
      case N.OnlyTranslation:
        f = e2 - t2.worldX, v = r - t2.worldY;
        break;
      case N.NoRotationOrReflection:
        var p = Math.abs(h * c - l * u) / (h * h + u * u), g = h / t2.skeleton.scaleX, m = u / t2.skeleton.scaleY;
        l = -m * p * t2.skeleton.scaleX, c = g * p * t2.skeleton.scaleY, d += Math.atan2(m, g) * _.radDeg;
      default:
        var w = e2 - o.worldX, E = r - o.worldY, x = h * c - l * u;
        f = (w * c - E * l) / x - t2.ax, v = (E * h - w * u) / x - t2.ay;
    }
    d += Math.atan2(v, f) * _.radDeg, t2.ascaleX < 0 && (d += 180), d > 180 ? d -= 360 : d < -180 && (d += 360);
    var y = t2.ascaleX, b = t2.ascaleY;
    if (n || a) {
      switch (t2.data.transformMode) {
        case N.NoScale:
        case N.NoScaleOrReflection:
          f = e2 - t2.worldX, v = r - t2.worldY;
      }
      var S = t2.data.length * y, M2 = Math.sqrt(f * f + v * v);
      if (n && M2 < S || a && M2 > S && S > 1e-4) {
        var A2 = (M2 / S - 1) * s + 1;
        y *= A2, i && (b *= A2);
      }
    }
    t2.updateWorldTransformWith(t2.ax, t2.ay, t2.arotation + d * s, y, b, t2.ashearX, t2.ashearY);
  }, e.apply2 = function(t2, e2, r, n, a, i, s, o) {
    if (0 != o) {
      t2.appliedValid || t2.updateAppliedTransform(), e2.appliedValid || e2.updateAppliedTransform();
      var h = t2.ax, l = t2.ay, u = t2.ascaleX, c = u, d = t2.ascaleY, f = e2.ascaleX, v = 0, p = 0, g = 0;
      u < 0 ? (u = -u, v = 180, g = -1) : (v = 0, g = 1), d < 0 && (d = -d, g = -g), f < 0 ? (f = -f, p = 180) : p = 0;
      var m = e2.ax, w = 0, E = 0, x = 0, y = t2.a, b = t2.b, S = t2.c, M2 = t2.d, A2 = Math.abs(u - d) <= 1e-4;
      A2 ? (E = y * m + b * (w = e2.ay) + t2.worldX, x = S * m + M2 * w + t2.worldY) : (w = 0, E = y * m + t2.worldX, x = S * m + t2.worldY);
      var T2 = t2.parent;
      y = T2.a, b = T2.b, S = T2.c;
      var I2, R2, C2 = 1 / (y * (M2 = T2.d) - b * S), k2 = E - T2.worldX, V2 = x - T2.worldY, P2 = (k2 * M2 - V2 * b) * C2 - h, F2 = (V2 * y - k2 * S) * C2 - l, N2 = Math.sqrt(P2 * P2 + F2 * F2), O2 = e2.data.length * f;
      if (N2 < 1e-4)
        return this.apply1(t2, r, n, false, i, false, o), void e2.updateWorldTransformWith(m, w, 0, e2.ascaleX, e2.ascaleY, e2.ashearX, e2.ashearY);
      var L2 = ((k2 = r - T2.worldX) * M2 - (V2 = n - T2.worldY) * b) * C2 - h, X2 = (V2 * y - k2 * S) * C2 - l, B2 = L2 * L2 + X2 * X2;
      if (0 != s) {
        s *= u * (f + 1) / 2;
        var D2 = Math.sqrt(B2), Y2 = D2 - N2 - O2 * u + s;
        if (Y2 > 0) {
          var U2 = Math.min(1, Y2 / (2 * s)) - 1;
          B2 = (L2 -= (U2 = (Y2 - s * (1 - U2 * U2)) / D2) * L2) * L2 + (X2 -= U2 * X2) * X2;
        }
      }
      t:
        if (A2) {
          var W2 = (B2 - N2 * N2 - (O2 *= u) * O2) / (2 * N2 * O2);
          W2 < -1 ? W2 = -1 : W2 > 1 && (W2 = 1, i && (c *= (Math.sqrt(B2) / (N2 + O2) - 1) * o + 1)), R2 = Math.acos(W2) * a, y = N2 + O2 * W2, b = O2 * Math.sin(R2), I2 = Math.atan2(X2 * y - L2 * b, L2 * y + X2 * b);
        } else {
          var q2 = (y = u * O2) * y, H2 = (b = d * O2) * b, j2 = Math.atan2(X2, L2), G2 = -2 * H2 * N2, z2 = H2 - q2;
          if ((M2 = G2 * G2 - 4 * z2 * (S = H2 * N2 * N2 + q2 * B2 - q2 * H2)) >= 0) {
            var Z2 = Math.sqrt(M2);
            G2 < 0 && (Z2 = -Z2);
            var Q2 = (Z2 = -(G2 + Z2) / 2) / z2, J2 = S / Z2, K2 = Math.abs(Q2) < Math.abs(J2) ? Q2 : J2;
            if (K2 * K2 <= B2) {
              V2 = Math.sqrt(B2 - K2 * K2) * a, I2 = j2 - Math.atan2(V2, K2), R2 = Math.atan2(V2 / d, (K2 - N2) / u);
              break t;
            }
          }
          var $2 = _.PI, tt2 = N2 - y, et2 = tt2 * tt2, rt2 = 0, nt2 = 0, at2 = N2 + y, it2 = at2 * at2, st2 = 0;
          (S = -y * N2 / (q2 - H2)) >= -1 && S <= 1 && (S = Math.acos(S), (M2 = (k2 = y * Math.cos(S) + N2) * k2 + (V2 = b * Math.sin(S)) * V2) < et2 && ($2 = S, et2 = M2, tt2 = k2, rt2 = V2), M2 > it2 && (nt2 = S, it2 = M2, at2 = k2, st2 = V2)), B2 <= (et2 + it2) / 2 ? (I2 = j2 - Math.atan2(rt2 * a, tt2), R2 = $2 * a) : (I2 = j2 - Math.atan2(st2 * a, at2), R2 = nt2 * a);
        }
      var ot2 = Math.atan2(w, m) * g, ht2 = t2.arotation;
      (I2 = (I2 - ot2) * _.radDeg + v - ht2) > 180 ? I2 -= 360 : I2 < -180 && (I2 += 360), t2.updateWorldTransformWith(h, l, ht2 + I2 * o, c, t2.ascaleY, 0, 0), ht2 = e2.arotation, (R2 = ((R2 + ot2) * _.radDeg - e2.ashearX) * g + p - ht2) > 180 ? R2 -= 360 : R2 < -180 && (R2 += 360), e2.updateWorldTransformWith(m, w, ht2 + R2 * o, e2.ascaleX, e2.ascaleY, e2.ashearX, e2.ashearY);
    } else
      e2.updateWorldTransform();
  }, t;
}(), H = function() {
  function t(t2, e2) {
    if (this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.temp = new L(), this.active = false, null == t2)
      throw new Error("data cannot be null.");
    if (null == e2)
      throw new Error("skeleton cannot be null.");
    this.data = t2, this.rotateMix = t2.rotateMix, this.translateMix = t2.translateMix, this.scaleMix = t2.scaleMix, this.shearMix = t2.shearMix, this.bones = new Array();
    for (var r = 0; r < t2.bones.length; r++)
      this.bones.push(e2.findBone(t2.bones[r].name));
    this.target = e2.findBone(t2.target.name);
  }
  var e = t.prototype;
  return e.isActive = function() {
    return this.active;
  }, e.apply = function() {
    this.update();
  }, e.update = function() {
    this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld();
  }, e.applyAbsoluteWorld = function() {
    for (var t2 = this.rotateMix, e2 = this.translateMix, r = this.scaleMix, n = this.shearMix, a = this.target, i = a.a, s = a.b, o = a.c, h = a.d, l = i * h - s * o > 0 ? _.degRad : -_.degRad, u = this.data.offsetRotation * l, c = this.data.offsetShearY * l, d = this.bones, f = 0, v = d.length; f < v; f++) {
      var p = d[f], g = false;
      if (0 != t2) {
        var m = p.a, w = p.b, E = p.c, x = p.d, y = Math.atan2(o, i) - Math.atan2(E, m) + u;
        y > _.PI ? y -= _.PI2 : y < -_.PI && (y += _.PI2), y *= t2;
        var b = Math.cos(y), S = Math.sin(y);
        p.a = b * m - S * E, p.b = b * w - S * x, p.c = S * m + b * E, p.d = S * w + b * x, g = true;
      }
      if (0 != e2) {
        var M2 = this.temp;
        a.localToWorld(M2.set(this.data.offsetX, this.data.offsetY)), p.worldX += (M2.x - p.worldX) * e2, p.worldY += (M2.y - p.worldY) * e2, g = true;
      }
      if (r > 0) {
        var A2 = Math.sqrt(p.a * p.a + p.c * p.c), T2 = Math.sqrt(i * i + o * o);
        A2 > 1e-5 && (A2 = (A2 + (T2 - A2 + this.data.offsetScaleX) * r) / A2), p.a *= A2, p.c *= A2, A2 = Math.sqrt(p.b * p.b + p.d * p.d), T2 = Math.sqrt(s * s + h * h), A2 > 1e-5 && (A2 = (A2 + (T2 - A2 + this.data.offsetScaleY) * r) / A2), p.b *= A2, p.d *= A2, g = true;
      }
      if (n > 0) {
        var I2 = p.b, R2 = p.d, C2 = Math.atan2(R2, I2), k2 = Math.atan2(h, s) - Math.atan2(o, i) - (C2 - Math.atan2(p.c, p.a));
        k2 > _.PI ? k2 -= _.PI2 : k2 < -_.PI && (k2 += _.PI2), k2 = C2 + (k2 + c) * n;
        var V2 = Math.sqrt(I2 * I2 + R2 * R2);
        p.b = Math.cos(k2) * V2, p.d = Math.sin(k2) * V2, g = true;
      }
      g && (p.appliedValid = false);
    }
  }, e.applyRelativeWorld = function() {
    for (var t2 = this.rotateMix, e2 = this.translateMix, r = this.scaleMix, n = this.shearMix, a = this.target, i = a.a, s = a.b, o = a.c, h = a.d, l = i * h - s * o > 0 ? _.degRad : -_.degRad, u = this.data.offsetRotation * l, c = this.data.offsetShearY * l, d = this.bones, f = 0, v = d.length; f < v; f++) {
      var p = d[f], g = false;
      if (0 != t2) {
        var m = p.a, w = p.b, E = p.c, x = p.d, y = Math.atan2(o, i) + u;
        y > _.PI ? y -= _.PI2 : y < -_.PI && (y += _.PI2), y *= t2;
        var b = Math.cos(y), S = Math.sin(y);
        p.a = b * m - S * E, p.b = b * w - S * x, p.c = S * m + b * E, p.d = S * w + b * x, g = true;
      }
      if (0 != e2) {
        var M2 = this.temp;
        a.localToWorld(M2.set(this.data.offsetX, this.data.offsetY)), p.worldX += M2.x * e2, p.worldY += M2.y * e2, g = true;
      }
      if (r > 0) {
        var A2 = (Math.sqrt(i * i + o * o) - 1 + this.data.offsetScaleX) * r + 1;
        p.a *= A2, p.c *= A2, A2 = (Math.sqrt(s * s + h * h) - 1 + this.data.offsetScaleY) * r + 1, p.b *= A2, p.d *= A2, g = true;
      }
      if (n > 0) {
        var T2 = Math.atan2(h, s) - Math.atan2(o, i);
        T2 > _.PI ? T2 -= _.PI2 : T2 < -_.PI && (T2 += _.PI2);
        var I2 = p.b, R2 = p.d;
        T2 = Math.atan2(R2, I2) + (T2 - _.PI / 2 + c) * n;
        var C2 = Math.sqrt(I2 * I2 + R2 * R2);
        p.b = Math.cos(T2) * C2, p.d = Math.sin(T2) * C2, g = true;
      }
      g && (p.appliedValid = false);
    }
  }, e.applyAbsoluteLocal = function() {
    var t2 = this.rotateMix, e2 = this.translateMix, r = this.scaleMix, n = this.shearMix, a = this.target;
    a.appliedValid || a.updateAppliedTransform();
    for (var i = this.bones, s = 0, o = i.length; s < o; s++) {
      var h = i[s];
      h.appliedValid || h.updateAppliedTransform();
      var l = h.arotation;
      if (0 != t2) {
        var u = a.arotation - l + this.data.offsetRotation;
        l += (u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0))) * t2;
      }
      var c = h.ax, d = h.ay;
      0 != e2 && (c += (a.ax - c + this.data.offsetX) * e2, d += (a.ay - d + this.data.offsetY) * e2);
      var f = h.ascaleX, v = h.ascaleY;
      0 != r && (f > 1e-5 && (f = (f + (a.ascaleX - f + this.data.offsetScaleX) * r) / f), v > 1e-5 && (v = (v + (a.ascaleY - v + this.data.offsetScaleY) * r) / v));
      var p = h.ashearY;
      if (0 != n) {
        var g = a.ashearY - p + this.data.offsetShearY;
        g -= 360 * (16384 - (16384.499999999996 - g / 360 | 0)), h.shearY += g * n;
      }
      h.updateWorldTransformWith(c, d, l, f, v, h.ashearX, p);
    }
  }, e.applyRelativeLocal = function() {
    var t2 = this.rotateMix, e2 = this.translateMix, r = this.scaleMix, n = this.shearMix, a = this.target;
    a.appliedValid || a.updateAppliedTransform();
    for (var i = this.bones, s = 0, o = i.length; s < o; s++) {
      var h = i[s];
      h.appliedValid || h.updateAppliedTransform();
      var l = h.arotation;
      0 != t2 && (l += (a.arotation + this.data.offsetRotation) * t2);
      var u = h.ax, c = h.ay;
      0 != e2 && (u += (a.ax + this.data.offsetX) * e2, c += (a.ay + this.data.offsetY) * e2);
      var d = h.ascaleX, f = h.ascaleY;
      0 != r && (d > 1e-5 && (d *= (a.ascaleX - 1 + this.data.offsetScaleX) * r + 1), f > 1e-5 && (f *= (a.ascaleY - 1 + this.data.offsetScaleY) * r + 1));
      var v = h.ashearY;
      0 != n && (v += (a.ashearY + this.data.offsetShearY) * n), h.updateWorldTransformWith(u, c, l, d, f, h.ashearX, v);
    }
  }, t;
}(), j = function(t, e, r) {
  this.name = t, this.order = e, this.skinRequired = r;
}, G = function(t) {
  function e(e2) {
    var r;
    return (r = t.call(this, e2, 0, false) || this).bones = new Array(), r;
  }
  return R(e, t), e;
}(j);
!function(t) {
  t[t.Fixed = 0] = "Fixed", t[t.Percent = 1] = "Percent";
}(B || (B = {})), function(t) {
  t[t.Length = 0] = "Length", t[t.Fixed = 1] = "Fixed", t[t.Percent = 2] = "Percent";
}(D || (D = {})), function(t) {
  t[t.Tangent = 0] = "Tangent", t[t.Chain = 1] = "Chain", t[t.ChainScale = 2] = "ChainScale";
}(Y || (Y = {}));
var z = function(t) {
  if (null == t)
    throw new Error("name cannot be null.");
  this.name = t;
}, Z = function(t) {
  function e(r2) {
    var n;
    return (n = t.call(this, r2) || this).id = (65535 & e.nextID++) << 11, n.worldVerticesLength = 0, n.deformAttachment = function(t2) {
      if (void 0 === t2)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t2;
    }(n), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.computeWorldVertices = function(t2, e2, r2, n, a, i) {
    r2 = a + (r2 >> 1) * i;
    var s = t2.bone.skeleton, o = t2.deform, h = this.vertices, l = this.bones;
    if (null != l) {
      for (var u = 0, c = 0, d = 0; d < e2; d += 2) {
        var f = l[u];
        u += f + 1, c += f;
      }
      var v = s.bones;
      if (0 == o.length)
        for (var p = a, g = 3 * c; p < r2; p += i) {
          var m = 0, w = 0, E = l[u++];
          for (E += u; u < E; u++, g += 3) {
            var x = v[l[u]], y = h[g], b = h[g + 1], S = h[g + 2];
            m += (y * x.a + b * x.b + x.worldX) * S, w += (y * x.c + b * x.d + x.worldY) * S;
          }
          n[p] = m, n[p + 1] = w;
        }
      else
        for (var M2 = o, A2 = a, T2 = 3 * c, I2 = c << 1; A2 < r2; A2 += i) {
          var R2 = 0, C2 = 0, k2 = l[u++];
          for (k2 += u; u < k2; u++, T2 += 3, I2 += 2) {
            var V2 = v[l[u]], P2 = h[T2] + M2[I2], _2 = h[T2 + 1] + M2[I2 + 1], F2 = h[T2 + 2];
            R2 += (P2 * V2.a + _2 * V2.b + V2.worldX) * F2, C2 += (P2 * V2.c + _2 * V2.d + V2.worldY) * F2;
          }
          n[A2] = R2, n[A2 + 1] = C2;
        }
    } else {
      o.length > 0 && (h = o);
      for (var N2 = t2.bone, O2 = N2.worldX, L2 = N2.worldY, X2 = N2.a, B2 = N2.b, D2 = N2.c, Y2 = N2.d, U2 = e2, W2 = a; W2 < r2; U2 += 2, W2 += i) {
        var q2 = h[U2], H2 = h[U2 + 1];
        n[W2] = q2 * X2 + H2 * B2 + O2, n[W2 + 1] = q2 * D2 + H2 * Y2 + L2;
      }
    }
  }, r.copyTo = function(t2) {
    null != this.bones ? (t2.bones = new Array(this.bones.length), F.arrayCopy(this.bones, 0, t2.bones, 0, this.bones.length)) : t2.bones = null, null != this.vertices ? (t2.vertices = F.newFloatArray(this.vertices.length), F.arrayCopy(this.vertices, 0, t2.vertices, 0, this.vertices.length)) : t2.vertices = null, t2.worldVerticesLength = this.worldVerticesLength, t2.deformAttachment = this.deformAttachment;
  }, e;
}(z);
Z.nextID = 0;
var Q = function(t) {
  function e(e2) {
    var r;
    return (r = t.call(this, e2) || this).closed = false, r.constantSpeed = false, r.color = new P(1, 1, 1, 1), r;
  }
  return R(e, t), e.prototype.copy = function() {
    var t2 = new e(this.name);
    return this.copyTo(t2), t2.lengths = new Array(this.lengths.length), F.arrayCopy(this.lengths, 0, t2.lengths, 0, this.lengths.length), t2.closed = closed, t2.constantSpeed = this.constantSpeed, t2.color.setFromColor(this.color), t2;
  }, e;
}(Z), J = function() {
  function t(t2, e2) {
    if (this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, this.spaces = new Array(), this.positions = new Array(), this.world = new Array(), this.curves = new Array(), this.lengths = new Array(), this.segments = new Array(), this.active = false, null == t2)
      throw new Error("data cannot be null.");
    if (null == e2)
      throw new Error("skeleton cannot be null.");
    this.data = t2, this.bones = new Array();
    for (var r = 0, n = t2.bones.length; r < n; r++)
      this.bones.push(e2.findBone(t2.bones[r].name));
    this.target = e2.findSlot(t2.target.name), this.position = t2.position, this.spacing = t2.spacing, this.rotateMix = t2.rotateMix, this.translateMix = t2.translateMix;
  }
  var e = t.prototype;
  return e.isActive = function() {
    return this.active;
  }, e.apply = function() {
    this.update();
  }, e.update = function() {
    var e2 = this.target.getAttachment();
    if (k(e2, Q)) {
      var r = this.rotateMix, n = this.translateMix, a = r > 0;
      if (n > 0 || a) {
        var i = this.data, s = i.spacingMode == D.Percent, o = i.rotateMode, h = o == Y.Tangent, l = o == Y.ChainScale, u = this.bones.length, c = h ? u : u + 1, d = this.bones, f = F.setArraySize(this.spaces, c), v = null, p = this.spacing;
        if (l || !s) {
          l && (v = F.setArraySize(this.lengths, u));
          for (var g = i.spacingMode == D.Length, m = 0, w = c - 1; m < w; ) {
            var E = d[m], x = E.data.length;
            if (x < t.epsilon)
              l && (v[m] = 0), f[++m] = 0;
            else if (s) {
              if (l) {
                var y = x * E.a, b = x * E.c, S = Math.sqrt(y * y + b * b);
                v[m] = S;
              }
              f[++m] = p;
            } else {
              var M2 = x * E.a, A2 = x * E.c, T2 = Math.sqrt(M2 * M2 + A2 * A2);
              l && (v[m] = T2), f[++m] = (g ? x + p : p) * T2 / x;
            }
          }
        } else
          for (var I2 = 1; I2 < c; I2++)
            f[I2] = p;
        var R2 = this.computeWorldPositions(e2, c, h, i.positionMode == B.Percent, s), C2 = R2[0], V2 = R2[1], P2 = i.offsetRotation, N2 = false;
        if (0 == P2)
          N2 = o == Y.Chain;
        else {
          N2 = false;
          var O2 = this.target.bone;
          P2 *= O2.a * O2.d - O2.b * O2.c > 0 ? _.degRad : -_.degRad;
        }
        for (var L2 = 0, X2 = 3; L2 < u; L2++, X2 += 3) {
          var U2 = d[L2];
          U2.worldX += (C2 - U2.worldX) * n, U2.worldY += (V2 - U2.worldY) * n;
          var W2 = R2[X2], q2 = R2[X2 + 1], H2 = W2 - C2, j2 = q2 - V2;
          if (l) {
            var G2 = v[L2];
            if (0 != G2) {
              var z2 = (Math.sqrt(H2 * H2 + j2 * j2) / G2 - 1) * r + 1;
              U2.a *= z2, U2.c *= z2;
            }
          }
          if (C2 = W2, V2 = q2, a) {
            var Z2 = U2.a, J2 = U2.b, K2 = U2.c, $2 = U2.d, tt2 = 0, et2 = 0, rt2 = 0;
            if (tt2 = h ? R2[X2 - 1] : 0 == f[L2 + 1] ? R2[X2 + 2] : Math.atan2(j2, H2), tt2 -= Math.atan2(K2, Z2), N2) {
              et2 = Math.cos(tt2), rt2 = Math.sin(tt2);
              var nt2 = U2.data.length;
              C2 += (nt2 * (et2 * Z2 - rt2 * K2) - H2) * r, V2 += (nt2 * (rt2 * Z2 + et2 * K2) - j2) * r;
            } else
              tt2 += P2;
            tt2 > _.PI ? tt2 -= _.PI2 : tt2 < -_.PI && (tt2 += _.PI2), tt2 *= r, et2 = Math.cos(tt2), rt2 = Math.sin(tt2), U2.a = et2 * Z2 - rt2 * K2, U2.b = et2 * J2 - rt2 * $2, U2.c = rt2 * Z2 + et2 * K2, U2.d = rt2 * J2 + et2 * $2;
          }
          U2.appliedValid = false;
        }
      }
    }
  }, e.computeWorldPositions = function(e2, r, n, a, i) {
    var s = this.target, o = this.position, h = this.spaces, l = F.setArraySize(this.positions, 3 * r + 2), u = null, c = e2.closed, d = e2.worldVerticesLength, f = d / 6, v = t.NONE;
    if (!e2.constantSpeed) {
      var p = e2.lengths, g = p[f -= c ? 1 : 2];
      if (a && (o *= g), i)
        for (var m = 1; m < r; m++)
          h[m] *= g;
      u = F.setArraySize(this.world, 8);
      for (var w = 0, E = 0, x = 0; w < r; w++, E += 3) {
        var y = h[w], b = o += y;
        if (c)
          (b %= g) < 0 && (b += g), x = 0;
        else {
          if (b < 0) {
            v != t.BEFORE && (v = t.BEFORE, e2.computeWorldVertices(s, 2, 4, u, 0, 2)), this.addBeforePosition(b, u, 0, l, E);
            continue;
          }
          if (b > g) {
            v != t.AFTER && (v = t.AFTER, e2.computeWorldVertices(s, d - 6, 4, u, 0, 2)), this.addAfterPosition(b - g, u, 0, l, E);
            continue;
          }
        }
        for (; ; x++) {
          var S = p[x];
          if (!(b > S)) {
            if (0 == x)
              b /= S;
            else {
              var M2 = p[x - 1];
              b = (b - M2) / (S - M2);
            }
            break;
          }
        }
        x != v && (v = x, c && x == f ? (e2.computeWorldVertices(s, d - 4, 4, u, 0, 2), e2.computeWorldVertices(s, 0, 4, u, 4, 2)) : e2.computeWorldVertices(s, 6 * x + 2, 8, u, 0, 2)), this.addCurvePosition(b, u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], l, E, n || w > 0 && 0 == y);
      }
      return l;
    }
    c ? (d += 2, u = F.setArraySize(this.world, d), e2.computeWorldVertices(s, 2, d - 4, u, 0, 2), e2.computeWorldVertices(s, 0, 2, u, d - 4, 2), u[d - 2] = u[0], u[d - 1] = u[1]) : (f--, d -= 4, u = F.setArraySize(this.world, d), e2.computeWorldVertices(s, 2, d, u, 0, 2));
    for (var A2 = F.setArraySize(this.curves, f), T2 = 0, I2 = u[0], R2 = u[1], C2 = 0, k2 = 0, V2 = 0, P2 = 0, _2 = 0, N2 = 0, O2 = 0, L2 = 0, X2 = 0, B2 = 0, D2 = 0, Y2 = 0, U2 = 0, W2 = 0, q2 = 0, H2 = 2; q2 < f; q2++, H2 += 6)
      C2 = u[H2], k2 = u[H2 + 1], V2 = u[H2 + 2], P2 = u[H2 + 3], D2 = 2 * (O2 = 0.1875 * (I2 - 2 * C2 + V2)) + (X2 = 0.09375 * (3 * (C2 - V2) - I2 + (_2 = u[H2 + 4]))), Y2 = 2 * (L2 = 0.1875 * (R2 - 2 * k2 + P2)) + (B2 = 0.09375 * (3 * (k2 - P2) - R2 + (N2 = u[H2 + 5]))), U2 = 0.75 * (C2 - I2) + O2 + 0.16666667 * X2, W2 = 0.75 * (k2 - R2) + L2 + 0.16666667 * B2, T2 += Math.sqrt(U2 * U2 + W2 * W2), U2 += D2, W2 += Y2, D2 += X2, Y2 += B2, T2 += Math.sqrt(U2 * U2 + W2 * W2), U2 += D2, W2 += Y2, T2 += Math.sqrt(U2 * U2 + W2 * W2), U2 += D2 + X2, W2 += Y2 + B2, T2 += Math.sqrt(U2 * U2 + W2 * W2), A2[q2] = T2, I2 = _2, R2 = N2;
    if (o *= a ? T2 : T2 / e2.lengths[f - 1], i)
      for (var j2 = 1; j2 < r; j2++)
        h[j2] *= T2;
    for (var G2 = this.segments, z2 = 0, Z2 = 0, Q2 = 0, J2 = 0, K2 = 0; Z2 < r; Z2++, Q2 += 3) {
      var $2 = h[Z2], tt2 = o += $2;
      if (c)
        (tt2 %= T2) < 0 && (tt2 += T2), J2 = 0;
      else {
        if (tt2 < 0) {
          this.addBeforePosition(tt2, u, 0, l, Q2);
          continue;
        }
        if (tt2 > T2) {
          this.addAfterPosition(tt2 - T2, u, d - 4, l, Q2);
          continue;
        }
      }
      for (; ; J2++) {
        var et2 = A2[J2];
        if (!(tt2 > et2)) {
          if (0 == J2)
            tt2 /= et2;
          else {
            var rt2 = A2[J2 - 1];
            tt2 = (tt2 - rt2) / (et2 - rt2);
          }
          break;
        }
      }
      if (J2 != v) {
        v = J2;
        var nt2 = 6 * J2;
        for (I2 = u[nt2], R2 = u[nt2 + 1], C2 = u[nt2 + 2], k2 = u[nt2 + 3], V2 = u[nt2 + 4], P2 = u[nt2 + 5], D2 = 2 * (O2 = 0.03 * (I2 - 2 * C2 + V2)) + (X2 = 6e-3 * (3 * (C2 - V2) - I2 + (_2 = u[nt2 + 6]))), Y2 = 2 * (L2 = 0.03 * (R2 - 2 * k2 + P2)) + (B2 = 6e-3 * (3 * (k2 - P2) - R2 + (N2 = u[nt2 + 7]))), U2 = 0.3 * (C2 - I2) + O2 + 0.16666667 * X2, W2 = 0.3 * (k2 - R2) + L2 + 0.16666667 * B2, z2 = Math.sqrt(U2 * U2 + W2 * W2), G2[0] = z2, nt2 = 1; nt2 < 8; nt2++)
          U2 += D2, W2 += Y2, D2 += X2, Y2 += B2, z2 += Math.sqrt(U2 * U2 + W2 * W2), G2[nt2] = z2;
        U2 += D2, W2 += Y2, z2 += Math.sqrt(U2 * U2 + W2 * W2), G2[8] = z2, U2 += D2 + X2, W2 += Y2 + B2, z2 += Math.sqrt(U2 * U2 + W2 * W2), G2[9] = z2, K2 = 0;
      }
      for (tt2 *= z2; ; K2++) {
        var at2 = G2[K2];
        if (!(tt2 > at2)) {
          if (0 == K2)
            tt2 /= at2;
          else {
            var it2 = G2[K2 - 1];
            tt2 = K2 + (tt2 - it2) / (at2 - it2);
          }
          break;
        }
      }
      this.addCurvePosition(0.1 * tt2, I2, R2, C2, k2, V2, P2, _2, N2, l, Q2, n || Z2 > 0 && 0 == $2);
    }
    return l;
  }, e.addBeforePosition = function(t2, e2, r, n, a) {
    var i = e2[r], s = e2[r + 1], o = e2[r + 2] - i, h = e2[r + 3] - s, l = Math.atan2(h, o);
    n[a] = i + t2 * Math.cos(l), n[a + 1] = s + t2 * Math.sin(l), n[a + 2] = l;
  }, e.addAfterPosition = function(t2, e2, r, n, a) {
    var i = e2[r + 2], s = e2[r + 3], o = i - e2[r], h = s - e2[r + 1], l = Math.atan2(h, o);
    n[a] = i + t2 * Math.cos(l), n[a + 1] = s + t2 * Math.sin(l), n[a + 2] = l;
  }, e.addCurvePosition = function(t2, e2, r, n, a, i, s, o, h, l, u, c) {
    if (0 == t2 || isNaN(t2))
      return l[u] = e2, l[u + 1] = r, void (l[u + 2] = Math.atan2(a - r, n - e2));
    var d = t2 * t2, f = d * t2, v = 1 - t2, p = v * v, g = p * v, m = v * t2, w = 3 * m, E = v * w, x = w * t2, y = e2 * g + n * E + i * x + o * f, b = r * g + a * E + s * x + h * f;
    l[u] = y, l[u + 1] = b, c && (l[u + 2] = t2 < 1e-3 ? Math.atan2(a - r, n - e2) : Math.atan2(b - (r * p + a * m * 2 + s * d), y - (e2 * p + n * m * 2 + i * d)));
  }, t;
}();
J.NONE = -1, J.BEFORE = -2, J.AFTER = -3, J.epsilon = 1e-5;
var K = function(t) {
  function e(e2) {
    var r2;
    return (r2 = t.call(this, e2) || this).x = 0, r2.y = 0, r2.scaleX = 1, r2.scaleY = 1, r2.rotation = 0, r2.width = 0, r2.height = 0, r2.color = new P(1, 1, 1, 1), r2.offset = F.newFloatArray(8), r2.uvs = F.newFloatArray(8), r2.tempColor = new P(1, 1, 1, 1), r2;
  }
  R(e, t);
  var r = e.prototype;
  return r.updateOffset = function() {
    var t2 = this.width / this.region.originalWidth * this.scaleX, r2 = this.height / this.region.originalHeight * this.scaleY, n = -this.width / 2 * this.scaleX + this.region.offsetX * t2, a = -this.height / 2 * this.scaleY + this.region.offsetY * r2, i = n + this.region.width * t2, s = a + this.region.height * r2, o = this.rotation * Math.PI / 180, h = Math.cos(o), l = Math.sin(o), u = n * h + this.x, c = n * l, d = a * h + this.y, f = a * l, v = i * h + this.x, p = i * l, g = s * h + this.y, m = s * l, w = this.offset;
    w[e.OX1] = u - f, w[e.OY1] = d + c, w[e.OX2] = u - m, w[e.OY2] = g + c, w[e.OX3] = v - m, w[e.OY3] = g + p, w[e.OX4] = v - f, w[e.OY4] = d + p;
  }, r.setRegion = function(t2) {
    this.region = t2;
    var e2 = this.uvs;
    t2.rotate ? (e2[2] = t2.u, e2[3] = t2.v2, e2[4] = t2.u, e2[5] = t2.v, e2[6] = t2.u2, e2[7] = t2.v, e2[0] = t2.u2, e2[1] = t2.v2) : (e2[0] = t2.u, e2[1] = t2.v2, e2[2] = t2.u, e2[3] = t2.v, e2[4] = t2.u2, e2[5] = t2.v, e2[6] = t2.u2, e2[7] = t2.v2);
  }, r.computeWorldVertices = function(t2, r2, n, a) {
    var i = this.offset, s = t2.worldX, o = t2.worldY, h = t2.a, l = t2.b, u = t2.c, c = t2.d, d = 0, f = 0;
    d = i[e.OX1], f = i[e.OY1], r2[n] = d * h + f * l + s, r2[n + 1] = d * u + f * c + o, n += a, d = i[e.OX2], f = i[e.OY2], r2[n] = d * h + f * l + s, r2[n + 1] = d * u + f * c + o, n += a, d = i[e.OX3], f = i[e.OY3], r2[n] = d * h + f * l + s, r2[n + 1] = d * u + f * c + o, n += a, d = i[e.OX4], f = i[e.OY4], r2[n] = d * h + f * l + s, r2[n + 1] = d * u + f * c + o;
  }, r.copy = function() {
    var t2 = new e(this.name);
    return t2.region = this.region, t2.rendererObject = this.rendererObject, t2.path = this.path, t2.x = this.x, t2.y = this.y, t2.scaleX = this.scaleX, t2.scaleY = this.scaleY, t2.rotation = this.rotation, t2.width = this.width, t2.height = this.height, F.arrayCopy(this.uvs, 0, t2.uvs, 0, 8), F.arrayCopy(this.offset, 0, t2.offset, 0, 8), t2.color.setFromColor(this.color), t2;
  }, e;
}(z);
K.OX1 = 0, K.OY1 = 1, K.OX2 = 2, K.OY2 = 3, K.OX3 = 4, K.OY3 = 5, K.OX4 = 6, K.OY4 = 7, K.X1 = 0, K.Y1 = 1, K.C1R = 2, K.C1G = 3, K.C1B = 4, K.C1A = 5, K.U1 = 6, K.V1 = 7, K.X2 = 8, K.Y2 = 9, K.C2R = 10, K.C2G = 11, K.C2B = 12, K.C2A = 13, K.U2 = 14, K.V2 = 15, K.X3 = 16, K.Y3 = 17, K.C3R = 18, K.C3G = 19, K.C3B = 20, K.C3A = 21, K.U3 = 22, K.V3 = 23, K.X4 = 24, K.Y4 = 25, K.C4R = 26, K.C4G = 27, K.C4B = 28, K.C4A = 29, K.U4 = 30, K.V4 = 31;
var $, tt, et = function() {
  function t(t2) {
    this._image = t2;
  }
  return t.prototype.getImage = function() {
    return this._image;
  }, t.filterFromString = function(t2) {
    switch (t2.toLowerCase()) {
      case "nearest":
        return 9728;
      case "linear":
        return 9729;
      case "mipmap":
      case "mipmaplinearlinear":
        return 9987;
      case "mipmapnearestnearest":
        return 9984;
      case "mipmaplinearnearest":
        return 9985;
      case "mipmapnearestlinear":
        return 9986;
      default:
        throw new Error("Unknown texture filter " + t2);
    }
  }, t.wrapFromString = function(t2) {
    switch (t2.toLowerCase()) {
      case "mirroredtepeat":
        return 33648;
      case "clamptoedge":
        return 33071;
      case "repeat":
        return 10497;
      default:
        throw new Error("Unknown texture wrap " + t2);
    }
  }, t;
}();
!function(t) {
  t[t.Nearest = 9728] = "Nearest", t[t.Linear = 9729] = "Linear", t[t.MipMap = 9987] = "MipMap", t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest", t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest", t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear", t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear";
}($ || ($ = {})), function(t) {
  t[t.MirroredRepeat = 33648] = "MirroredRepeat", t[t.ClampToEdge = 33071] = "ClampToEdge", t[t.Repeat = 10497] = "Repeat";
}(tt || (tt = {}));
var rt, nt, at, it = function() {
  this.u = 0, this.v = 0, this.u2 = 0, this.v2 = 0, this.width = 0, this.height = 0, this.rotate = false, this.offsetX = 0, this.offsetY = 0, this.originalWidth = 0, this.originalHeight = 0;
}, st = function(t) {
  function e() {
    return t.apply(this, arguments);
  }
  R(e, t);
  var r = e.prototype;
  return r.setFilters = function(t2, e2) {
  }, r.setWraps = function(t2, e2) {
  }, r.dispose = function() {
  }, e;
}(et), ot = function() {
  function t(t2, e2) {
    this.pages = new Array(), this.regions = new Array(), this.load(t2, e2);
  }
  var e = t.prototype;
  return e.load = function(t2, e2) {
    if (null == e2)
      throw new Error("textureLoader cannot be null.");
    for (var r = new ht(t2), n = new Array(4), a = null; ; ) {
      var i = r.readLine();
      if (null == i)
        break;
      if (0 == (i = i.trim()).length)
        a = null;
      else if (a) {
        var s = new ut();
        s.name = i, s.page = a;
        var o = r.readValue();
        "true" == o.toLocaleLowerCase() ? s.degrees = 90 : "false" == o.toLocaleLowerCase() ? s.degrees = 0 : s.degrees = parseFloat(o), s.rotate = 90 == s.degrees, r.readTuple(n);
        var h = parseInt(n[0]), l = parseInt(n[1]);
        r.readTuple(n);
        var u = parseInt(n[0]), c = parseInt(n[1]);
        s.u = h / a.width, s.v = l / a.height, s.rotate ? (s.u2 = (h + c) / a.width, s.v2 = (l + u) / a.height) : (s.u2 = (h + u) / a.width, s.v2 = (l + c) / a.height), s.x = h, s.y = l, s.width = Math.abs(u), s.height = Math.abs(c), 4 == r.readTuple(n) && 4 == r.readTuple(n) && r.readTuple(n), s.originalWidth = parseInt(n[0]), s.originalHeight = parseInt(n[1]), r.readTuple(n), s.offsetX = parseInt(n[0]), s.offsetY = parseInt(n[1]), s.index = parseInt(r.readValue()), s.texture = a.texture, this.regions.push(s);
      } else {
        (a = new lt()).name = i, 2 == r.readTuple(n) && (a.width = parseInt(n[0]), a.height = parseInt(n[1]), r.readTuple(n)), r.readTuple(n), a.minFilter = et.filterFromString(n[0]), a.magFilter = et.filterFromString(n[1]);
        var d = r.readValue();
        a.uWrap = tt.ClampToEdge, a.vWrap = tt.ClampToEdge, "x" == d ? a.uWrap = tt.Repeat : "y" == d ? a.vWrap = tt.Repeat : "xy" == d && (a.uWrap = a.vWrap = tt.Repeat), a.texture = e2(i), a.texture.setFilters(a.minFilter, a.magFilter), a.texture.setWraps(a.uWrap, a.vWrap), a.width = a.texture.getImage().width, a.height = a.texture.getImage().height, this.pages.push(a);
      }
    }
  }, e.findRegion = function(t2) {
    for (var e2 = 0; e2 < this.regions.length; e2++)
      if (this.regions[e2].name == t2)
        return this.regions[e2];
    return null;
  }, e.dispose = function() {
    for (var t2 = 0; t2 < this.pages.length; t2++)
      this.pages[t2].texture.dispose();
  }, t;
}(), ht = function() {
  function t(t2) {
    this.index = 0, this.lines = t2.split(/\r\n|\r|\n/);
  }
  var e = t.prototype;
  return e.readLine = function() {
    return this.index >= this.lines.length ? null : this.lines[this.index++];
  }, e.readValue = function() {
    var t2 = this.readLine(), e2 = t2.indexOf(":");
    if (-1 == e2)
      throw new Error("Invalid line: " + t2);
    return t2.substring(e2 + 1).trim();
  }, e.readTuple = function(t2) {
    var e2 = this.readLine(), r = e2.indexOf(":");
    if (-1 == r)
      throw new Error("Invalid line: " + e2);
    for (var n = 0, a = r + 1; n < 3; n++) {
      var i = e2.indexOf(",", a);
      if (-1 == i)
        break;
      t2[n] = e2.substr(a, i - a).trim(), a = i + 1;
    }
    return t2[n] = e2.substring(a).trim(), n + 1;
  }, t;
}(), lt = function() {
}, ut = function(t) {
  function e() {
    return t.apply(this, arguments);
  }
  return R(e, t), e;
}(it), ct = function(t) {
  function e(e2) {
    var r2;
    return (r2 = t.call(this, e2) || this).color = new P(1, 1, 1, 1), r2.tempColor = new P(0, 0, 0, 0), r2;
  }
  R(e, t);
  var r = e.prototype;
  return r.updateUVs = function() {
    var t2 = this.regionUVs;
    null != this.uvs && this.uvs.length == t2.length || (this.uvs = F.newFloatArray(t2.length));
    var e2 = this.uvs, r2 = this.uvs.length, n = this.region.u, a = this.region.v, i = 0, s = 0;
    if (k(this.region, ut)) {
      var o = this.region, h = o.texture.getImage().width, l = o.texture.getImage().height;
      switch (o.degrees) {
        case 90:
          n -= (o.originalHeight - o.offsetY - o.height) / h, a -= (o.originalWidth - o.offsetX - o.width) / l, i = o.originalHeight / h, s = o.originalWidth / l;
          for (var u = 0; u < r2; u += 2)
            e2[u] = n + t2[u + 1] * i, e2[u + 1] = a + (1 - t2[u]) * s;
          return;
        case 180:
          n -= (o.originalWidth - o.offsetX - o.width) / h, a -= o.offsetY / l, i = o.originalWidth / h, s = o.originalHeight / l;
          for (var c = 0; c < r2; c += 2)
            e2[c] = n + (1 - t2[c]) * i, e2[c + 1] = a + (1 - t2[c + 1]) * s;
          return;
        case 270:
          n -= o.offsetY / h, a -= o.offsetX / l, i = o.originalHeight / h, s = o.originalWidth / l;
          for (var d = 0; d < r2; d += 2)
            e2[d] = n + (1 - t2[d + 1]) * i, e2[d + 1] = a + t2[d] * s;
          return;
      }
      n -= o.offsetX / h, a -= (o.originalHeight - o.offsetY - o.height) / l, i = o.originalWidth / h, s = o.originalHeight / l;
    } else
      null == this.region ? (n = a = 0, i = s = 1) : (i = this.region.u2 - n, s = this.region.v2 - a);
    for (var f = 0; f < r2; f += 2)
      e2[f] = n + t2[f] * i, e2[f + 1] = a + t2[f + 1] * s;
  }, r.getParentMesh = function() {
    return this.parentMesh;
  }, r.setParentMesh = function(t2) {
    this.parentMesh = t2, null != t2 && (this.bones = t2.bones, this.vertices = t2.vertices, this.worldVerticesLength = t2.worldVerticesLength, this.regionUVs = t2.regionUVs, this.triangles = t2.triangles, this.hullLength = t2.hullLength, this.worldVerticesLength = t2.worldVerticesLength);
  }, r.copy = function() {
    if (null != this.parentMesh)
      return this.newLinkedMesh();
    var t2 = new e(this.name);
    return t2.region = this.region, t2.path = this.path, t2.color.setFromColor(this.color), this.copyTo(t2), t2.regionUVs = new Array(this.regionUVs.length), F.arrayCopy(this.regionUVs, 0, t2.regionUVs, 0, this.regionUVs.length), t2.uvs = new Array(this.uvs.length), F.arrayCopy(this.uvs, 0, t2.uvs, 0, this.uvs.length), t2.triangles = new Array(this.triangles.length), F.arrayCopy(this.triangles, 0, t2.triangles, 0, this.triangles.length), t2.hullLength = this.hullLength, null != this.edges && (t2.edges = new Array(this.edges.length), F.arrayCopy(this.edges, 0, t2.edges, 0, this.edges.length)), t2.width = this.width, t2.height = this.height, t2;
  }, r.newLinkedMesh = function() {
    var t2 = new e(this.name);
    return t2.region = this.region, t2.path = this.path, t2.color.setFromColor(this.color), t2.deformAttachment = this.deformAttachment, t2.setParentMesh(null != this.parentMesh ? this.parentMesh : this), t2.updateUVs(), t2;
  }, e;
}(Z), dt = function() {
  function t(t2) {
    if (this._updateCache = new Array(), this.updateCacheReset = new Array(), this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, null == t2)
      throw new Error("data cannot be null.");
    this.data = t2, this.bones = new Array();
    for (var e2 = 0; e2 < t2.bones.length; e2++) {
      var r = t2.bones[e2], n = void 0;
      if (null == r.parent)
        n = new U(r, this, null);
      else {
        var a = this.bones[r.parent.index];
        n = new U(r, this, a), a.children.push(n);
      }
      this.bones.push(n);
    }
    this.slots = new Array(), this.drawOrder = new Array();
    for (var i = 0; i < t2.slots.length; i++) {
      var s = t2.slots[i], o = this.bones[s.boneData.index], h = new W(s, o);
      this.slots.push(h), this.drawOrder.push(h);
    }
    this.ikConstraints = new Array();
    for (var l = 0; l < t2.ikConstraints.length; l++) {
      var u = t2.ikConstraints[l];
      this.ikConstraints.push(new q(u, this));
    }
    this.transformConstraints = new Array();
    for (var c = 0; c < t2.transformConstraints.length; c++) {
      var d = t2.transformConstraints[c];
      this.transformConstraints.push(new H(d, this));
    }
    this.pathConstraints = new Array();
    for (var f = 0; f < t2.pathConstraints.length; f++) {
      var v = t2.pathConstraints[f];
      this.pathConstraints.push(new J(v, this));
    }
    this.color = new P(1, 1, 1, 1), this.updateCache();
  }
  var e = t.prototype;
  return e.updateCache = function() {
    var t2 = this._updateCache;
    t2.length = 0, this.updateCacheReset.length = 0;
    for (var e2 = this.bones, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      a.sorted = a.data.skinRequired, a.active = !a.sorted;
    }
    if (null != this.skin)
      for (var i = this.skin.bones, s = 0, o = this.skin.bones.length; s < o; s++) {
        var h = this.bones[i[s].index];
        do {
          h.sorted = false, h.active = true, h = h.parent;
        } while (null != h);
      }
    var l = this.ikConstraints, u = this.transformConstraints, c = this.pathConstraints, d = l.length, f = u.length, v = c.length, p = d + f + v;
    t:
      for (var g = 0; g < p; g++) {
        for (var m = 0; m < d; m++) {
          var w = l[m];
          if (w.data.order == g) {
            this.sortIkConstraint(w);
            continue t;
          }
        }
        for (var E = 0; E < f; E++) {
          var x = u[E];
          if (x.data.order == g) {
            this.sortTransformConstraint(x);
            continue t;
          }
        }
        for (var y = 0; y < v; y++) {
          var b = c[y];
          if (b.data.order == g) {
            this.sortPathConstraint(b);
            continue t;
          }
        }
      }
    for (var S = 0, M2 = e2.length; S < M2; S++)
      this.sortBone(e2[S]);
  }, e.sortIkConstraint = function(t2) {
    if (t2.active = t2.target.isActive() && (!t2.data.skinRequired || null != this.skin && F.contains(this.skin.constraints, t2.data, true)), t2.active) {
      var e2 = t2.target;
      this.sortBone(e2);
      var r = t2.bones, n = r[0];
      if (this.sortBone(n), r.length > 1) {
        var a = r[r.length - 1];
        this._updateCache.indexOf(a) > -1 || this.updateCacheReset.push(a);
      }
      this._updateCache.push(t2), this.sortReset(n.children), r[r.length - 1].sorted = true;
    }
  }, e.sortPathConstraint = function(t2) {
    if (t2.active = t2.target.bone.isActive() && (!t2.data.skinRequired || null != this.skin && F.contains(this.skin.constraints, t2.data, true)), t2.active) {
      var e2 = t2.target, r = e2.data.index, n = e2.bone;
      null != this.skin && this.sortPathConstraintAttachment(this.skin, r, n), null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, r, n);
      for (var a = 0, i = this.data.skins.length; a < i; a++)
        this.sortPathConstraintAttachment(this.data.skins[a], r, n);
      var s = e2.getAttachment();
      k(s, Q) && this.sortPathConstraintAttachmentWith(s, n);
      for (var o = t2.bones, h = o.length, l = 0; l < h; l++)
        this.sortBone(o[l]);
      this._updateCache.push(t2);
      for (var u = 0; u < h; u++)
        this.sortReset(o[u].children);
      for (var c = 0; c < h; c++)
        o[c].sorted = true;
    }
  }, e.sortTransformConstraint = function(t2) {
    if (t2.active = t2.target.isActive() && (!t2.data.skinRequired || null != this.skin && F.contains(this.skin.constraints, t2.data, true)), t2.active) {
      this.sortBone(t2.target);
      var e2 = t2.bones, r = e2.length;
      if (t2.data.local)
        for (var n = 0; n < r; n++) {
          var a = e2[n];
          this.sortBone(a.parent), this._updateCache.indexOf(a) > -1 || this.updateCacheReset.push(a);
        }
      else
        for (var i = 0; i < r; i++)
          this.sortBone(e2[i]);
      this._updateCache.push(t2);
      for (var s = 0; s < r; s++)
        this.sortReset(e2[s].children);
      for (var o = 0; o < r; o++)
        e2[o].sorted = true;
    }
  }, e.sortPathConstraintAttachment = function(t2, e2, r) {
    var n = t2.attachments[e2];
    if (n)
      for (var a in n)
        this.sortPathConstraintAttachmentWith(n[a], r);
  }, e.sortPathConstraintAttachmentWith = function(t2, e2) {
    if (k(t2, Q)) {
      var r = t2.bones;
      if (null == r)
        this.sortBone(e2);
      else
        for (var n = this.bones, a = 0; a < r.length; )
          for (var i = r[a++], s = a + i; a < s; a++) {
            var o = r[a];
            this.sortBone(n[o]);
          }
    }
  }, e.sortBone = function(t2) {
    if (!t2.sorted) {
      var e2 = t2.parent;
      null != e2 && this.sortBone(e2), t2.sorted = true, this._updateCache.push(t2);
    }
  }, e.sortReset = function(t2) {
    for (var e2 = 0, r = t2.length; e2 < r; e2++) {
      var n = t2[e2];
      n.active && (n.sorted && this.sortReset(n.children), n.sorted = false);
    }
  }, e.updateWorldTransform = function() {
    for (var t2 = this.updateCacheReset, e2 = 0, r = t2.length; e2 < r; e2++) {
      var n = t2[e2];
      n.ax = n.x, n.ay = n.y, n.arotation = n.rotation, n.ascaleX = n.scaleX, n.ascaleY = n.scaleY, n.ashearX = n.shearX, n.ashearY = n.shearY, n.appliedValid = true;
    }
    for (var a = this._updateCache, i = 0, s = a.length; i < s; i++)
      a[i].update();
  }, e.setToSetupPose = function() {
    this.setBonesToSetupPose(), this.setSlotsToSetupPose();
  }, e.setBonesToSetupPose = function() {
    for (var t2 = this.bones, e2 = 0, r = t2.length; e2 < r; e2++)
      t2[e2].setToSetupPose();
    for (var n = this.ikConstraints, a = 0, i = n.length; a < i; a++) {
      var s = n[a];
      s.mix = s.data.mix, s.softness = s.data.softness, s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, s.stretch = s.data.stretch;
    }
    for (var o = this.transformConstraints, h = 0, l = o.length; h < l; h++) {
      var u = o[h], c = u.data;
      u.rotateMix = c.rotateMix, u.translateMix = c.translateMix, u.scaleMix = c.scaleMix, u.shearMix = c.shearMix;
    }
    for (var d = this.pathConstraints, f = 0, v = d.length; f < v; f++) {
      var p = d[f], g = p.data;
      p.position = g.position, p.spacing = g.spacing, p.rotateMix = g.rotateMix, p.translateMix = g.translateMix;
    }
  }, e.setSlotsToSetupPose = function() {
    var t2 = this.slots;
    F.arrayCopy(t2, 0, this.drawOrder, 0, t2.length);
    for (var e2 = 0, r = t2.length; e2 < r; e2++)
      t2[e2].setToSetupPose();
  }, e.getRootBone = function() {
    return 0 == this.bones.length ? null : this.bones[0];
  }, e.findBone = function(t2) {
    if (null == t2)
      throw new Error("boneName cannot be null.");
    for (var e2 = this.bones, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.data.name == t2)
        return a;
    }
    return null;
  }, e.findBoneIndex = function(t2) {
    if (null == t2)
      throw new Error("boneName cannot be null.");
    for (var e2 = this.bones, r = 0, n = e2.length; r < n; r++)
      if (e2[r].data.name == t2)
        return r;
    return -1;
  }, e.findSlot = function(t2) {
    if (null == t2)
      throw new Error("slotName cannot be null.");
    for (var e2 = this.slots, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.data.name == t2)
        return a;
    }
    return null;
  }, e.findSlotIndex = function(t2) {
    if (null == t2)
      throw new Error("slotName cannot be null.");
    for (var e2 = this.slots, r = 0, n = e2.length; r < n; r++)
      if (e2[r].data.name == t2)
        return r;
    return -1;
  }, e.setSkinByName = function(t2) {
    var e2 = this.data.findSkin(t2);
    if (null == e2)
      throw new Error("Skin not found: " + t2);
    this.setSkin(e2);
  }, e.setSkin = function(t2) {
    if (t2 != this.skin) {
      if (null != t2)
        if (null != this.skin)
          t2.attachAll(this, this.skin);
        else
          for (var e2 = this.slots, r = 0, n = e2.length; r < n; r++) {
            var a = e2[r], i = a.data.attachmentName;
            if (null != i) {
              var s = t2.getAttachment(r, i);
              null != s && a.setAttachment(s);
            }
          }
      this.skin = t2, this.updateCache();
    }
  }, e.getAttachmentByName = function(t2, e2) {
    return this.getAttachment(this.data.findSlotIndex(t2), e2);
  }, e.getAttachment = function(t2, e2) {
    if (null == e2)
      throw new Error("attachmentName cannot be null.");
    if (null != this.skin) {
      var r = this.skin.getAttachment(t2, e2);
      if (null != r)
        return r;
    }
    return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t2, e2) : null;
  }, e.setAttachment = function(t2, e2) {
    if (null == t2)
      throw new Error("slotName cannot be null.");
    for (var r = this.slots, n = 0, a = r.length; n < a; n++) {
      var i = r[n];
      if (i.data.name == t2) {
        var s = null;
        if (null != e2 && null == (s = this.getAttachment(n, e2)))
          throw new Error("Attachment not found: " + e2 + ", for slot: " + t2);
        return void i.setAttachment(s);
      }
    }
    throw new Error("Slot not found: " + t2);
  }, e.findIkConstraint = function(t2) {
    if (null == t2)
      throw new Error("constraintName cannot be null.");
    for (var e2 = this.ikConstraints, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.data.name == t2)
        return a;
    }
    return null;
  }, e.findTransformConstraint = function(t2) {
    if (null == t2)
      throw new Error("constraintName cannot be null.");
    for (var e2 = this.transformConstraints, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.data.name == t2)
        return a;
    }
    return null;
  }, e.findPathConstraint = function(t2) {
    if (null == t2)
      throw new Error("constraintName cannot be null.");
    for (var e2 = this.pathConstraints, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.data.name == t2)
        return a;
    }
    return null;
  }, e.getBounds = function(t2, e2, r) {
    if (void 0 === r && (r = new Array(2)), null == t2)
      throw new Error("offset cannot be null.");
    if (null == e2)
      throw new Error("size cannot be null.");
    for (var n = this.drawOrder, a = Number.POSITIVE_INFINITY, i = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY, o = Number.NEGATIVE_INFINITY, h = 0, l = n.length; h < l; h++) {
      var u = n[h];
      if (u.bone.active) {
        var c = 0, d = null, f = u.getAttachment();
        if (k(f, K))
          c = 8, d = F.setArraySize(r, c, 0), f.computeWorldVertices(u.bone, d, 0, 2);
        else if (k(f, ct)) {
          var v = f;
          c = v.worldVerticesLength, d = F.setArraySize(r, c, 0), v.computeWorldVertices(u, 0, c, d, 0, 2);
        }
        if (null != d)
          for (var p = 0, g = d.length; p < g; p += 2) {
            var m = d[p], w = d[p + 1];
            a = Math.min(a, m), i = Math.min(i, w), s = Math.max(s, m), o = Math.max(o, w);
          }
      }
    }
    t2.set(a, i), e2.set(s - a, o - i);
  }, e.update = function(t2) {
    this.time += t2;
  }, t;
}(), ft = function() {
  function t(t2, e2, r) {
    if (null == t2)
      throw new Error("name cannot be null.");
    if (null == e2)
      throw new Error("timelines cannot be null.");
    this.name = t2, this.timelines = e2, this.timelineIds = [];
    for (var n = 0; n < e2.length; n++)
      this.timelineIds[e2[n].getPropertyId()] = true;
    this.duration = r;
  }
  var e = t.prototype;
  return e.hasTimeline = function(t2) {
    return 1 == this.timelineIds[t2];
  }, e.apply = function(t2, e2, r, n, a, i, s, o) {
    if (null == t2)
      throw new Error("skeleton cannot be null.");
    n && 0 != this.duration && (r %= this.duration, e2 > 0 && (e2 %= this.duration));
    for (var h = this.timelines, l = 0, u = h.length; l < u; l++)
      h[l].apply(t2, e2, r, a, i, s, o);
  }, t.binarySearch = function(t2, e2, r) {
    void 0 === r && (r = 1);
    var n = 0, a = t2.length / r - 2;
    if (0 == a)
      return r;
    for (var i = a >>> 1; ; ) {
      if (t2[(i + 1) * r] <= e2 ? n = i + 1 : a = i, n == a)
        return (n + 1) * r;
      i = n + a >>> 1;
    }
  }, t.linearSearch = function(t2, e2, r) {
    for (var n = 0, a = t2.length - r; n <= a; n += r)
      if (t2[n] > e2)
        return n;
    return -1;
  }, t;
}();
!function(t) {
  t[t.setup = 0] = "setup", t[t.first = 1] = "first", t[t.replace = 2] = "replace", t[t.add = 3] = "add";
}(rt || (rt = {})), function(t) {
  t[t.mixIn = 0] = "mixIn", t[t.mixOut = 1] = "mixOut";
}(nt || (nt = {})), function(t) {
  t[t.rotate = 0] = "rotate", t[t.translate = 1] = "translate", t[t.scale = 2] = "scale", t[t.shear = 3] = "shear", t[t.attachment = 4] = "attachment", t[t.color = 5] = "color", t[t.deform = 6] = "deform", t[t.event = 7] = "event", t[t.drawOrder = 8] = "drawOrder", t[t.ikConstraint = 9] = "ikConstraint", t[t.transformConstraint = 10] = "transformConstraint", t[t.pathConstraintPosition = 11] = "pathConstraintPosition", t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing", t[t.pathConstraintMix = 13] = "pathConstraintMix", t[t.twoColor = 14] = "twoColor";
}(at || (at = {}));
var vt = function() {
  function t(e2) {
    if (e2 <= 0)
      throw new Error("frameCount must be > 0: " + e2);
    this.curves = F.newFloatArray((e2 - 1) * t.BEZIER_SIZE);
  }
  var e = t.prototype;
  return e.getFrameCount = function() {
    return this.curves.length / t.BEZIER_SIZE + 1;
  }, e.setLinear = function(e2) {
    this.curves[e2 * t.BEZIER_SIZE] = t.LINEAR;
  }, e.setStepped = function(e2) {
    this.curves[e2 * t.BEZIER_SIZE] = t.STEPPED;
  }, e.getCurveType = function(e2) {
    var r = e2 * t.BEZIER_SIZE;
    if (r == this.curves.length)
      return t.LINEAR;
    var n = this.curves[r];
    return n == t.LINEAR ? t.LINEAR : n == t.STEPPED ? t.STEPPED : t.BEZIER;
  }, e.setCurve = function(e2, r, n, a, i) {
    var s = 0.03 * (2 * -r + a), o = 0.03 * (2 * -n + i), h = 6e-3 * (3 * (r - a) + 1), l = 6e-3 * (3 * (n - i) + 1), u = 2 * s + h, c = 2 * o + l, d = 0.3 * r + s + 0.16666667 * h, f = 0.3 * n + o + 0.16666667 * l, v = e2 * t.BEZIER_SIZE, p = this.curves;
    p[v++] = t.BEZIER;
    for (var g = d, m = f, w = v + t.BEZIER_SIZE - 1; v < w; v += 2)
      p[v] = g, p[v + 1] = m, d += u, f += c, u += h, c += l, g += d, m += f;
  }, e.getCurvePercent = function(e2, r) {
    r = _.clamp(r, 0, 1);
    var n = this.curves, a = e2 * t.BEZIER_SIZE, i = n[a];
    if (i == t.LINEAR)
      return r;
    if (i == t.STEPPED)
      return 0;
    for (var s = 0, o = ++a, h = a + t.BEZIER_SIZE - 1; a < h; a += 2)
      if ((s = n[a]) >= r) {
        var l = void 0, u = void 0;
        return a == o ? (l = 0, u = 0) : (l = n[a - 2], u = n[a - 1]), u + (n[a + 1] - u) * (r - l) / (s - l);
      }
    var c = n[a - 1];
    return c + (1 - c) * (r - s) / (1 - s);
  }, t;
}();
vt.LINEAR = 0, vt.STEPPED = 1, vt.BEZIER = 2, vt.BEZIER_SIZE = 19;
var pt = function(t) {
  function e(e2) {
    var r2;
    return (r2 = t.call(this, e2) || this).frames = F.newFloatArray(e2 << 1), r2;
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return 0 + this.boneIndex;
  }, r.setFrame = function(t2, r2, n) {
    t2 <<= 1, this.frames[t2] = r2, this.frames[t2 + e.ROTATION] = n;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = this.frames, l = t2.bones[this.boneIndex];
    if (l.active)
      if (n < h[0])
        switch (s) {
          case 0:
            return void (l.rotation = l.data.rotation);
          case 1:
            var u = l.data.rotation - l.rotation;
            l.rotation += (u - 360 * (16384 - (16384.499999999996 - u / 360 | 0))) * i;
        }
      else if (n >= h[h.length - e.ENTRIES]) {
        var c = h[h.length + e.PREV_ROTATION];
        switch (s) {
          case 0:
            l.rotation = l.data.rotation + c * i;
            break;
          case 1:
          case 2:
            c += l.data.rotation - l.rotation, c -= 360 * (16384 - (16384.499999999996 - c / 360 | 0));
          case 3:
            l.rotation += c * i;
        }
      } else {
        var d = ft.binarySearch(h, n, e.ENTRIES), f = h[d + e.PREV_ROTATION], v = h[d], p = this.getCurvePercent((d >> 1) - 1, 1 - (n - v) / (h[d + e.PREV_TIME] - v)), g = h[d + e.ROTATION] - f;
        switch (g = f + (g - 360 * (16384 - (16384.499999999996 - g / 360 | 0))) * p, s) {
          case 0:
            l.rotation = l.data.rotation + (g - 360 * (16384 - (16384.499999999996 - g / 360 | 0))) * i;
            break;
          case 1:
          case 2:
            g += l.data.rotation - l.rotation;
          case 3:
            l.rotation += (g - 360 * (16384 - (16384.499999999996 - g / 360 | 0))) * i;
        }
      }
  }, e;
}(vt);
pt.ENTRIES = 2, pt.PREV_TIME = -2, pt.PREV_ROTATION = -1, pt.ROTATION = 1;
var gt = function(t) {
  function e(r2) {
    var n;
    return (n = t.call(this, r2) || this).frames = F.newFloatArray(r2 * e.ENTRIES), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (1 << 24) + this.boneIndex;
  }, r.setFrame = function(t2, r2, n, a) {
    t2 *= e.ENTRIES, this.frames[t2] = r2, this.frames[t2 + e.X] = n, this.frames[t2 + e.Y] = a;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = this.frames, l = t2.bones[this.boneIndex];
    if (l.active)
      if (n < h[0])
        switch (s) {
          case 0:
            return l.x = l.data.x, void (l.y = l.data.y);
          case 1:
            l.x += (l.data.x - l.x) * i, l.y += (l.data.y - l.y) * i;
        }
      else {
        var u = 0, c = 0;
        if (n >= h[h.length - e.ENTRIES])
          u = h[h.length + e.PREV_X], c = h[h.length + e.PREV_Y];
        else {
          var d = ft.binarySearch(h, n, e.ENTRIES);
          u = h[d + e.PREV_X], c = h[d + e.PREV_Y];
          var f = h[d], v = this.getCurvePercent(d / e.ENTRIES - 1, 1 - (n - f) / (h[d + e.PREV_TIME] - f));
          u += (h[d + e.X] - u) * v, c += (h[d + e.Y] - c) * v;
        }
        switch (s) {
          case 0:
            l.x = l.data.x + u * i, l.y = l.data.y + c * i;
            break;
          case 1:
          case 2:
            l.x += (l.data.x + u - l.x) * i, l.y += (l.data.y + c - l.y) * i;
            break;
          case 3:
            l.x += u * i, l.y += c * i;
        }
      }
  }, e;
}(vt);
gt.ENTRIES = 3, gt.PREV_TIME = -3, gt.PREV_X = -2, gt.PREV_Y = -1, gt.X = 1, gt.Y = 2;
var mt = function(t) {
  function e(e2) {
    return t.call(this, e2);
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (2 << 24) + this.boneIndex;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = this.frames, l = t2.bones[this.boneIndex];
    if (l.active)
      if (n < h[0])
        switch (s) {
          case 0:
            return l.scaleX = l.data.scaleX, void (l.scaleY = l.data.scaleY);
          case 1:
            l.scaleX += (l.data.scaleX - l.scaleX) * i, l.scaleY += (l.data.scaleY - l.scaleY) * i;
        }
      else {
        var u = 0, c = 0;
        if (n >= h[h.length - e.ENTRIES])
          u = h[h.length + e.PREV_X] * l.data.scaleX, c = h[h.length + e.PREV_Y] * l.data.scaleY;
        else {
          var d = ft.binarySearch(h, n, e.ENTRIES);
          u = h[d + e.PREV_X], c = h[d + e.PREV_Y];
          var f = h[d], v = this.getCurvePercent(d / e.ENTRIES - 1, 1 - (n - f) / (h[d + e.PREV_TIME] - f));
          u = (u + (h[d + e.X] - u) * v) * l.data.scaleX, c = (c + (h[d + e.Y] - c) * v) * l.data.scaleY;
        }
        if (1 == i)
          3 == s ? (l.scaleX += u - l.data.scaleX, l.scaleY += c - l.data.scaleY) : (l.scaleX = u, l.scaleY = c);
        else {
          var p = 0, g = 0;
          if (1 == o)
            switch (s) {
              case 0:
                p = l.data.scaleX, g = l.data.scaleY, l.scaleX = p + (Math.abs(u) * _.signum(p) - p) * i, l.scaleY = g + (Math.abs(c) * _.signum(g) - g) * i;
                break;
              case 1:
              case 2:
                p = l.scaleX, g = l.scaleY, l.scaleX = p + (Math.abs(u) * _.signum(p) - p) * i, l.scaleY = g + (Math.abs(c) * _.signum(g) - g) * i;
                break;
              case 3:
                p = l.scaleX, g = l.scaleY, l.scaleX = p + (Math.abs(u) * _.signum(p) - l.data.scaleX) * i, l.scaleY = g + (Math.abs(c) * _.signum(g) - l.data.scaleY) * i;
            }
          else
            switch (s) {
              case 0:
                p = Math.abs(l.data.scaleX) * _.signum(u), g = Math.abs(l.data.scaleY) * _.signum(c), l.scaleX = p + (u - p) * i, l.scaleY = g + (c - g) * i;
                break;
              case 1:
              case 2:
                p = Math.abs(l.scaleX) * _.signum(u), g = Math.abs(l.scaleY) * _.signum(c), l.scaleX = p + (u - p) * i, l.scaleY = g + (c - g) * i;
                break;
              case 3:
                p = _.signum(u), g = _.signum(c), l.scaleX = Math.abs(l.scaleX) * p + (u - Math.abs(l.data.scaleX) * p) * i, l.scaleY = Math.abs(l.scaleY) * g + (c - Math.abs(l.data.scaleY) * g) * i;
            }
        }
      }
  }, e;
}(gt), wt = function(t) {
  function e(e2) {
    return t.call(this, e2);
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (3 << 24) + this.boneIndex;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = this.frames, l = t2.bones[this.boneIndex];
    if (l.active)
      if (n < h[0])
        switch (s) {
          case 0:
            return l.shearX = l.data.shearX, void (l.shearY = l.data.shearY);
          case 1:
            l.shearX += (l.data.shearX - l.shearX) * i, l.shearY += (l.data.shearY - l.shearY) * i;
        }
      else {
        var u = 0, c = 0;
        if (n >= h[h.length - e.ENTRIES])
          u = h[h.length + e.PREV_X], c = h[h.length + e.PREV_Y];
        else {
          var d = ft.binarySearch(h, n, e.ENTRIES);
          u = h[d + e.PREV_X], c = h[d + e.PREV_Y];
          var f = h[d], v = this.getCurvePercent(d / e.ENTRIES - 1, 1 - (n - f) / (h[d + e.PREV_TIME] - f));
          u += (h[d + e.X] - u) * v, c += (h[d + e.Y] - c) * v;
        }
        switch (s) {
          case 0:
            l.shearX = l.data.shearX + u * i, l.shearY = l.data.shearY + c * i;
            break;
          case 1:
          case 2:
            l.shearX += (l.data.shearX + u - l.shearX) * i, l.shearY += (l.data.shearY + c - l.shearY) * i;
            break;
          case 3:
            l.shearX += u * i, l.shearY += c * i;
        }
      }
  }, e;
}(gt), Et = function(t) {
  function e(r2) {
    var n;
    return (n = t.call(this, r2) || this).frames = F.newFloatArray(r2 * e.ENTRIES), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (5 << 24) + this.slotIndex;
  }, r.setFrame = function(t2, r2, n, a, i, s) {
    t2 *= e.ENTRIES, this.frames[t2] = r2, this.frames[t2 + e.R] = n, this.frames[t2 + e.G] = a, this.frames[t2 + e.B] = i, this.frames[t2 + e.A] = s;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = t2.slots[this.slotIndex];
    if (h.bone.active) {
      var l = this.frames;
      if (n < l[0])
        switch (s) {
          case 0:
            return void h.color.setFromColor(h.data.color);
          case 1:
            var u = h.color, c = h.data.color;
            u.add((c.r - u.r) * i, (c.g - u.g) * i, (c.b - u.b) * i, (c.a - u.a) * i);
        }
      else {
        var d = 0, f = 0, v = 0, p = 0;
        if (n >= l[l.length - e.ENTRIES]) {
          var g = l.length;
          d = l[g + e.PREV_R], f = l[g + e.PREV_G], v = l[g + e.PREV_B], p = l[g + e.PREV_A];
        } else {
          var m = ft.binarySearch(l, n, e.ENTRIES);
          d = l[m + e.PREV_R], f = l[m + e.PREV_G], v = l[m + e.PREV_B], p = l[m + e.PREV_A];
          var w = l[m], E = this.getCurvePercent(m / e.ENTRIES - 1, 1 - (n - w) / (l[m + e.PREV_TIME] - w));
          d += (l[m + e.R] - d) * E, f += (l[m + e.G] - f) * E, v += (l[m + e.B] - v) * E, p += (l[m + e.A] - p) * E;
        }
        if (1 == i)
          h.color.set(d, f, v, p);
        else {
          var x = h.color;
          0 == s && x.setFromColor(h.data.color), x.add((d - x.r) * i, (f - x.g) * i, (v - x.b) * i, (p - x.a) * i);
        }
      }
    }
  }, e;
}(vt);
Et.ENTRIES = 5, Et.PREV_TIME = -5, Et.PREV_R = -4, Et.PREV_G = -3, Et.PREV_B = -2, Et.PREV_A = -1, Et.R = 1, Et.G = 2, Et.B = 3, Et.A = 4;
var xt = function(t) {
  function e(r2) {
    var n;
    return (n = t.call(this, r2) || this).frames = F.newFloatArray(r2 * e.ENTRIES), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (14 << 24) + this.slotIndex;
  }, r.setFrame = function(t2, r2, n, a, i, s, o, h, l) {
    t2 *= e.ENTRIES, this.frames[t2] = r2, this.frames[t2 + e.R] = n, this.frames[t2 + e.G] = a, this.frames[t2 + e.B] = i, this.frames[t2 + e.A] = s, this.frames[t2 + e.R2] = o, this.frames[t2 + e.G2] = h, this.frames[t2 + e.B2] = l;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = t2.slots[this.slotIndex];
    if (h.bone.active) {
      var l = this.frames;
      if (n < l[0])
        switch (s) {
          case 0:
            return h.color.setFromColor(h.data.color), void h.darkColor.setFromColor(h.data.darkColor);
          case 1:
            var u = h.color, c = h.darkColor, d = h.data.color, f = h.data.darkColor;
            u.add((d.r - u.r) * i, (d.g - u.g) * i, (d.b - u.b) * i, (d.a - u.a) * i), c.add((f.r - c.r) * i, (f.g - c.g) * i, (f.b - c.b) * i, 0);
        }
      else {
        var v = 0, p = 0, g = 0, m = 0, w = 0, E = 0, x = 0;
        if (n >= l[l.length - e.ENTRIES]) {
          var y = l.length;
          v = l[y + e.PREV_R], p = l[y + e.PREV_G], g = l[y + e.PREV_B], m = l[y + e.PREV_A], w = l[y + e.PREV_R2], E = l[y + e.PREV_G2], x = l[y + e.PREV_B2];
        } else {
          var b = ft.binarySearch(l, n, e.ENTRIES);
          v = l[b + e.PREV_R], p = l[b + e.PREV_G], g = l[b + e.PREV_B], m = l[b + e.PREV_A], w = l[b + e.PREV_R2], E = l[b + e.PREV_G2], x = l[b + e.PREV_B2];
          var S = l[b], M2 = this.getCurvePercent(b / e.ENTRIES - 1, 1 - (n - S) / (l[b + e.PREV_TIME] - S));
          v += (l[b + e.R] - v) * M2, p += (l[b + e.G] - p) * M2, g += (l[b + e.B] - g) * M2, m += (l[b + e.A] - m) * M2, w += (l[b + e.R2] - w) * M2, E += (l[b + e.G2] - E) * M2, x += (l[b + e.B2] - x) * M2;
        }
        if (1 == i)
          h.color.set(v, p, g, m), h.darkColor.set(w, E, x, 1);
        else {
          var A2 = h.color, T2 = h.darkColor;
          0 == s && (A2.setFromColor(h.data.color), T2.setFromColor(h.data.darkColor)), A2.add((v - A2.r) * i, (p - A2.g) * i, (g - A2.b) * i, (m - A2.a) * i), T2.add((w - T2.r) * i, (E - T2.g) * i, (x - T2.b) * i, 0);
        }
      }
    }
  }, e;
}(vt);
xt.ENTRIES = 8, xt.PREV_TIME = -8, xt.PREV_R = -7, xt.PREV_G = -6, xt.PREV_B = -5, xt.PREV_A = -4, xt.PREV_R2 = -3, xt.PREV_G2 = -2, xt.PREV_B2 = -1, xt.R = 1, xt.G = 2, xt.B = 3, xt.A = 4, xt.R2 = 5, xt.G2 = 6, xt.B2 = 7;
var yt = function() {
  function t(t2) {
    this.frames = F.newFloatArray(t2), this.attachmentNames = new Array(t2);
  }
  var e = t.prototype;
  return e.getPropertyId = function() {
    return (4 << 24) + this.slotIndex;
  }, e.getFrameCount = function() {
    return this.frames.length;
  }, e.setFrame = function(t2, e2, r) {
    this.frames[t2] = e2, this.attachmentNames[t2] = r;
  }, e.apply = function(t2, e2, r, n, a, i, s) {
    var o = t2.slots[this.slotIndex];
    if (o.bone.active)
      if (1 != s) {
        var h = this.frames;
        if (r < h[0])
          0 != i && 1 != i || this.setAttachment(t2, o, o.data.attachmentName);
        else {
          var l = 0;
          l = r >= h[h.length - 1] ? h.length - 1 : ft.binarySearch(h, r, 1) - 1;
          var u = this.attachmentNames[l];
          t2.slots[this.slotIndex].setAttachment(null == u ? null : t2.getAttachment(this.slotIndex, u));
        }
      } else
        0 == i && this.setAttachment(t2, o, o.data.attachmentName);
  }, e.setAttachment = function(t2, e2, r) {
    e2.attachment = null == r ? null : t2.getAttachment(this.slotIndex, r);
  }, t;
}(), bt = null, St = function(t) {
  function e(e2) {
    var r2;
    return (r2 = t.call(this, e2) || this).frames = F.newFloatArray(e2), r2.frameVertices = new Array(e2), null == bt && (bt = F.newFloatArray(64)), r2;
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (6 << 27) + +this.attachment.id + this.slotIndex;
  }, r.setFrame = function(t2, e2, r2) {
    this.frames[t2] = e2, this.frameVertices[t2] = r2;
  }, r.apply = function(t2, e2, r2, n, a, i, s) {
    var o = t2.slots[this.slotIndex];
    if (o.bone.active) {
      var h = o.getAttachment();
      if (k(h, Z) && h.deformAttachment == this.attachment) {
        var l = o.deform;
        0 == l.length && (i = 0);
        var u = this.frameVertices, c = u[0].length, d = this.frames;
        if (r2 < d[0]) {
          var f = h;
          switch (i) {
            case 0:
              return void (l.length = 0);
            case 1:
              if (1 == a) {
                l.length = 0;
                break;
              }
              var v = F.setArraySize(l, c);
              if (null == f.bones)
                for (var p = f.vertices, g = 0; g < c; g++)
                  v[g] += (p[g] - v[g]) * a;
              else {
                a = 1 - a;
                for (g = 0; g < c; g++)
                  v[g] *= a;
              }
          }
        } else {
          var m = F.setArraySize(l, c);
          if (r2 >= d[d.length - 1]) {
            var w = u[d.length - 1];
            if (1 == a)
              if (3 == i) {
                var E = h;
                if (null == E.bones)
                  for (var x = E.vertices, y = 0; y < c; y++)
                    m[y] += w[y] - x[y];
                else
                  for (var b = 0; b < c; b++)
                    m[b] += w[b];
              } else
                F.arrayCopy(w, 0, m, 0, c);
            else
              switch (i) {
                case 0:
                  var S = h;
                  if (null == S.bones)
                    for (var M2 = S.vertices, A2 = 0; A2 < c; A2++) {
                      var T2 = M2[A2];
                      m[A2] = T2 + (w[A2] - T2) * a;
                    }
                  else
                    for (var I2 = 0; I2 < c; I2++)
                      m[I2] = w[I2] * a;
                  break;
                case 1:
                case 2:
                  for (var R2 = 0; R2 < c; R2++)
                    m[R2] += (w[R2] - m[R2]) * a;
                  break;
                case 3:
                  var C2 = h;
                  if (null == C2.bones)
                    for (var V2 = C2.vertices, P2 = 0; P2 < c; P2++)
                      m[P2] += (w[P2] - V2[P2]) * a;
                  else
                    for (var _2 = 0; _2 < c; _2++)
                      m[_2] += w[_2] * a;
              }
          } else {
            var N2 = ft.binarySearch(d, r2), O2 = u[N2 - 1], L2 = u[N2], X2 = d[N2], B2 = this.getCurvePercent(N2 - 1, 1 - (r2 - X2) / (d[N2 - 1] - X2));
            if (1 == a)
              if (3 == i) {
                var D2 = h;
                if (null == D2.bones)
                  for (var Y2 = D2.vertices, U2 = 0; U2 < c; U2++) {
                    var W2 = O2[U2];
                    m[U2] += W2 + (L2[U2] - W2) * B2 - Y2[U2];
                  }
                else
                  for (var q2 = 0; q2 < c; q2++) {
                    var H2 = O2[q2];
                    m[q2] += H2 + (L2[q2] - H2) * B2;
                  }
              } else
                for (var j2 = 0; j2 < c; j2++) {
                  var G2 = O2[j2];
                  m[j2] = G2 + (L2[j2] - G2) * B2;
                }
            else
              switch (i) {
                case 0:
                  var z2 = h;
                  if (null == z2.bones)
                    for (var Q2 = z2.vertices, J2 = 0; J2 < c; J2++) {
                      var K2 = O2[J2], $2 = Q2[J2];
                      m[J2] = $2 + (K2 + (L2[J2] - K2) * B2 - $2) * a;
                    }
                  else
                    for (var tt2 = 0; tt2 < c; tt2++) {
                      var et2 = O2[tt2];
                      m[tt2] = (et2 + (L2[tt2] - et2) * B2) * a;
                    }
                  break;
                case 1:
                case 2:
                  for (var rt2 = 0; rt2 < c; rt2++) {
                    var nt2 = O2[rt2];
                    m[rt2] += (nt2 + (L2[rt2] - nt2) * B2 - m[rt2]) * a;
                  }
                  break;
                case 3:
                  var at2 = h;
                  if (null == at2.bones)
                    for (var it2 = at2.vertices, st2 = 0; st2 < c; st2++) {
                      var ot2 = O2[st2];
                      m[st2] += (ot2 + (L2[st2] - ot2) * B2 - it2[st2]) * a;
                    }
                  else
                    for (var ht2 = 0; ht2 < c; ht2++) {
                      var lt2 = O2[ht2];
                      m[ht2] += (lt2 + (L2[ht2] - lt2) * B2) * a;
                    }
              }
          }
        }
      }
    }
  }, e;
}(vt), Mt = function() {
  function t(t2) {
    this.frames = F.newFloatArray(t2), this.events = new Array(t2);
  }
  var e = t.prototype;
  return e.getPropertyId = function() {
    return 7 << 24;
  }, e.getFrameCount = function() {
    return this.frames.length;
  }, e.setFrame = function(t2, e2) {
    this.frames[t2] = e2.time, this.events[t2] = e2;
  }, e.apply = function(t2, e2, r, n, a, i, s) {
    if (null != n) {
      var o = this.frames, h = this.frames.length;
      if (e2 > r)
        this.apply(t2, e2, Number.MAX_VALUE, n, a, i, s), e2 = -1;
      else if (e2 >= o[h - 1])
        return;
      if (!(r < o[0])) {
        var l = 0;
        if (e2 < o[0])
          l = 0;
        else
          for (var u = o[l = ft.binarySearch(o, e2)]; l > 0 && o[l - 1] == u; )
            l--;
        for (; l < h && r >= o[l]; l++)
          n.push(this.events[l]);
      }
    }
  }, t;
}(), At = function() {
  function t(t2) {
    this.frames = F.newFloatArray(t2), this.drawOrders = new Array(t2);
  }
  var e = t.prototype;
  return e.getPropertyId = function() {
    return 8 << 24;
  }, e.getFrameCount = function() {
    return this.frames.length;
  }, e.setFrame = function(t2, e2, r) {
    this.frames[t2] = e2, this.drawOrders[t2] = r;
  }, e.apply = function(t2, e2, r, n, a, i, s) {
    var o = t2.drawOrder, h = t2.slots;
    if (1 != s) {
      var l = this.frames;
      if (r < l[0])
        0 != i && 1 != i || F.arrayCopy(t2.slots, 0, t2.drawOrder, 0, t2.slots.length);
      else {
        var u = 0;
        u = r >= l[l.length - 1] ? l.length - 1 : ft.binarySearch(l, r) - 1;
        var c = this.drawOrders[u];
        if (null == c)
          F.arrayCopy(h, 0, o, 0, h.length);
        else
          for (var d = 0, f = c.length; d < f; d++)
            o[d] = h[c[d]];
      }
    } else
      0 == i && F.arrayCopy(t2.slots, 0, t2.drawOrder, 0, t2.slots.length);
  }, t;
}(), Tt = function(t) {
  function e(r2) {
    var n;
    return (n = t.call(this, r2) || this).frames = F.newFloatArray(r2 * e.ENTRIES), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (9 << 24) + this.ikConstraintIndex;
  }, r.setFrame = function(t2, r2, n, a, i, s, o) {
    t2 *= e.ENTRIES, this.frames[t2] = r2, this.frames[t2 + e.MIX] = n, this.frames[t2 + e.SOFTNESS] = a, this.frames[t2 + e.BEND_DIRECTION] = i, this.frames[t2 + e.COMPRESS] = s ? 1 : 0, this.frames[t2 + e.STRETCH] = o ? 1 : 0;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = this.frames, l = t2.ikConstraints[this.ikConstraintIndex];
    if (l.active)
      if (n < h[0])
        switch (s) {
          case 0:
            return l.mix = l.data.mix, l.softness = l.data.softness, l.bendDirection = l.data.bendDirection, l.compress = l.data.compress, void (l.stretch = l.data.stretch);
          case 1:
            l.mix += (l.data.mix - l.mix) * i, l.softness += (l.data.softness - l.softness) * i, l.bendDirection = l.data.bendDirection, l.compress = l.data.compress, l.stretch = l.data.stretch;
        }
      else if (n >= h[h.length - e.ENTRIES])
        0 == s ? (l.mix = l.data.mix + (h[h.length + e.PREV_MIX] - l.data.mix) * i, l.softness = l.data.softness + (h[h.length + e.PREV_SOFTNESS] - l.data.softness) * i, 1 == o ? (l.bendDirection = l.data.bendDirection, l.compress = l.data.compress, l.stretch = l.data.stretch) : (l.bendDirection = h[h.length + e.PREV_BEND_DIRECTION], l.compress = 0 != h[h.length + e.PREV_COMPRESS], l.stretch = 0 != h[h.length + e.PREV_STRETCH])) : (l.mix += (h[h.length + e.PREV_MIX] - l.mix) * i, l.softness += (h[h.length + e.PREV_SOFTNESS] - l.softness) * i, 0 == o && (l.bendDirection = h[h.length + e.PREV_BEND_DIRECTION], l.compress = 0 != h[h.length + e.PREV_COMPRESS], l.stretch = 0 != h[h.length + e.PREV_STRETCH]));
      else {
        var u = ft.binarySearch(h, n, e.ENTRIES), c = h[u + e.PREV_MIX], d = h[u + e.PREV_SOFTNESS], f = h[u], v = this.getCurvePercent(u / e.ENTRIES - 1, 1 - (n - f) / (h[u + e.PREV_TIME] - f));
        0 == s ? (l.mix = l.data.mix + (c + (h[u + e.MIX] - c) * v - l.data.mix) * i, l.softness = l.data.softness + (d + (h[u + e.SOFTNESS] - d) * v - l.data.softness) * i, 1 == o ? (l.bendDirection = l.data.bendDirection, l.compress = l.data.compress, l.stretch = l.data.stretch) : (l.bendDirection = h[u + e.PREV_BEND_DIRECTION], l.compress = 0 != h[u + e.PREV_COMPRESS], l.stretch = 0 != h[u + e.PREV_STRETCH])) : (l.mix += (c + (h[u + e.MIX] - c) * v - l.mix) * i, l.softness += (d + (h[u + e.SOFTNESS] - d) * v - l.softness) * i, 0 == o && (l.bendDirection = h[u + e.PREV_BEND_DIRECTION], l.compress = 0 != h[u + e.PREV_COMPRESS], l.stretch = 0 != h[u + e.PREV_STRETCH]));
      }
  }, e;
}(vt);
Tt.ENTRIES = 6, Tt.PREV_TIME = -6, Tt.PREV_MIX = -5, Tt.PREV_SOFTNESS = -4, Tt.PREV_BEND_DIRECTION = -3, Tt.PREV_COMPRESS = -2, Tt.PREV_STRETCH = -1, Tt.MIX = 1, Tt.SOFTNESS = 2, Tt.BEND_DIRECTION = 3, Tt.COMPRESS = 4, Tt.STRETCH = 5;
var It = function(t) {
  function e(r2) {
    var n;
    return (n = t.call(this, r2) || this).frames = F.newFloatArray(r2 * e.ENTRIES), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (10 << 24) + this.transformConstraintIndex;
  }, r.setFrame = function(t2, r2, n, a, i, s) {
    t2 *= e.ENTRIES, this.frames[t2] = r2, this.frames[t2 + e.ROTATE] = n, this.frames[t2 + e.TRANSLATE] = a, this.frames[t2 + e.SCALE] = i, this.frames[t2 + e.SHEAR] = s;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = this.frames, l = t2.transformConstraints[this.transformConstraintIndex];
    if (l.active)
      if (n < h[0]) {
        var u = l.data;
        switch (s) {
          case 0:
            return l.rotateMix = u.rotateMix, l.translateMix = u.translateMix, l.scaleMix = u.scaleMix, void (l.shearMix = u.shearMix);
          case 1:
            l.rotateMix += (u.rotateMix - l.rotateMix) * i, l.translateMix += (u.translateMix - l.translateMix) * i, l.scaleMix += (u.scaleMix - l.scaleMix) * i, l.shearMix += (u.shearMix - l.shearMix) * i;
        }
      } else {
        var c = 0, d = 0, f = 0, v = 0;
        if (n >= h[h.length - e.ENTRIES]) {
          var p = h.length;
          c = h[p + e.PREV_ROTATE], d = h[p + e.PREV_TRANSLATE], f = h[p + e.PREV_SCALE], v = h[p + e.PREV_SHEAR];
        } else {
          var g = ft.binarySearch(h, n, e.ENTRIES);
          c = h[g + e.PREV_ROTATE], d = h[g + e.PREV_TRANSLATE], f = h[g + e.PREV_SCALE], v = h[g + e.PREV_SHEAR];
          var m = h[g], w = this.getCurvePercent(g / e.ENTRIES - 1, 1 - (n - m) / (h[g + e.PREV_TIME] - m));
          c += (h[g + e.ROTATE] - c) * w, d += (h[g + e.TRANSLATE] - d) * w, f += (h[g + e.SCALE] - f) * w, v += (h[g + e.SHEAR] - v) * w;
        }
        if (0 == s) {
          var E = l.data;
          l.rotateMix = E.rotateMix + (c - E.rotateMix) * i, l.translateMix = E.translateMix + (d - E.translateMix) * i, l.scaleMix = E.scaleMix + (f - E.scaleMix) * i, l.shearMix = E.shearMix + (v - E.shearMix) * i;
        } else
          l.rotateMix += (c - l.rotateMix) * i, l.translateMix += (d - l.translateMix) * i, l.scaleMix += (f - l.scaleMix) * i, l.shearMix += (v - l.shearMix) * i;
      }
  }, e;
}(vt);
It.ENTRIES = 5, It.PREV_TIME = -5, It.PREV_ROTATE = -4, It.PREV_TRANSLATE = -3, It.PREV_SCALE = -2, It.PREV_SHEAR = -1, It.ROTATE = 1, It.TRANSLATE = 2, It.SCALE = 3, It.SHEAR = 4;
var Rt = function(t) {
  function e(r2) {
    var n;
    return (n = t.call(this, r2) || this).frames = F.newFloatArray(r2 * e.ENTRIES), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (11 << 24) + this.pathConstraintIndex;
  }, r.setFrame = function(t2, r2, n) {
    t2 *= e.ENTRIES, this.frames[t2] = r2, this.frames[t2 + e.VALUE] = n;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = this.frames, l = t2.pathConstraints[this.pathConstraintIndex];
    if (l.active)
      if (n < h[0])
        switch (s) {
          case 0:
            return void (l.position = l.data.position);
          case 1:
            l.position += (l.data.position - l.position) * i;
        }
      else {
        var u = 0;
        if (n >= h[h.length - e.ENTRIES])
          u = h[h.length + e.PREV_VALUE];
        else {
          var c = ft.binarySearch(h, n, e.ENTRIES);
          u = h[c + e.PREV_VALUE];
          var d = h[c], f = this.getCurvePercent(c / e.ENTRIES - 1, 1 - (n - d) / (h[c + e.PREV_TIME] - d));
          u += (h[c + e.VALUE] - u) * f;
        }
        0 == s ? l.position = l.data.position + (u - l.data.position) * i : l.position += (u - l.position) * i;
      }
  }, e;
}(vt);
Rt.ENTRIES = 2, Rt.PREV_TIME = -2, Rt.PREV_VALUE = -1, Rt.VALUE = 1;
var Ct = function(t) {
  function e(e2) {
    return t.call(this, e2);
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (12 << 24) + this.pathConstraintIndex;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = this.frames, l = t2.pathConstraints[this.pathConstraintIndex];
    if (l.active)
      if (n < h[0])
        switch (s) {
          case 0:
            return void (l.spacing = l.data.spacing);
          case 1:
            l.spacing += (l.data.spacing - l.spacing) * i;
        }
      else {
        var u = 0;
        if (n >= h[h.length - e.ENTRIES])
          u = h[h.length + e.PREV_VALUE];
        else {
          var c = ft.binarySearch(h, n, e.ENTRIES);
          u = h[c + e.PREV_VALUE];
          var d = h[c], f = this.getCurvePercent(c / e.ENTRIES - 1, 1 - (n - d) / (h[c + e.PREV_TIME] - d));
          u += (h[c + e.VALUE] - u) * f;
        }
        0 == s ? l.spacing = l.data.spacing + (u - l.data.spacing) * i : l.spacing += (u - l.spacing) * i;
      }
  }, e;
}(Rt), kt = function(t) {
  function e(r2) {
    var n;
    return (n = t.call(this, r2) || this).frames = F.newFloatArray(r2 * e.ENTRIES), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.getPropertyId = function() {
    return (13 << 24) + this.pathConstraintIndex;
  }, r.setFrame = function(t2, r2, n, a) {
    t2 *= e.ENTRIES, this.frames[t2] = r2, this.frames[t2 + e.ROTATE] = n, this.frames[t2 + e.TRANSLATE] = a;
  }, r.apply = function(t2, r2, n, a, i, s, o) {
    var h = this.frames, l = t2.pathConstraints[this.pathConstraintIndex];
    if (l.active)
      if (n < h[0])
        switch (s) {
          case 0:
            return l.rotateMix = l.data.rotateMix, void (l.translateMix = l.data.translateMix);
          case 1:
            l.rotateMix += (l.data.rotateMix - l.rotateMix) * i, l.translateMix += (l.data.translateMix - l.translateMix) * i;
        }
      else {
        var u = 0, c = 0;
        if (n >= h[h.length - e.ENTRIES])
          u = h[h.length + e.PREV_ROTATE], c = h[h.length + e.PREV_TRANSLATE];
        else {
          var d = ft.binarySearch(h, n, e.ENTRIES);
          u = h[d + e.PREV_ROTATE], c = h[d + e.PREV_TRANSLATE];
          var f = h[d], v = this.getCurvePercent(d / e.ENTRIES - 1, 1 - (n - f) / (h[d + e.PREV_TIME] - f));
          u += (h[d + e.ROTATE] - u) * v, c += (h[d + e.TRANSLATE] - c) * v;
        }
        0 == s ? (l.rotateMix = l.data.rotateMix + (u - l.data.rotateMix) * i, l.translateMix = l.data.translateMix + (c - l.data.translateMix) * i) : (l.rotateMix += (u - l.rotateMix) * i, l.translateMix += (c - l.translateMix) * i);
      }
  }, e;
}(vt);
kt.ENTRIES = 3, kt.PREV_TIME = -3, kt.PREV_ROTATE = -2, kt.PREV_TRANSLATE = -1, kt.ROTATE = 1, kt.TRANSLATE = 2;
var Vt = function() {
  function t(t2) {
    this.tracks = new Array(), this.timeScale = 1, this.unkeyedState = 0, this.events = new Array(), this.listeners = new Array(), this.queue = new Ft(this), this.propertyIDs = new V(), this.animationsChanged = false, this.trackEntryPool = new O(function() {
      return new _t();
    }), this.data = t2;
  }
  var e = t.prototype;
  return e.update = function(t2) {
    t2 *= this.timeScale;
    for (var e2 = this.tracks, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (null != a) {
        a.animationLast = a.nextAnimationLast, a.trackLast = a.nextTrackLast;
        var i = t2 * a.timeScale;
        if (a.delay > 0) {
          if (a.delay -= i, a.delay > 0)
            continue;
          i = -a.delay, a.delay = 0;
        }
        var s = a.next;
        if (null != s) {
          var o = a.trackLast - s.delay;
          if (o >= 0) {
            for (s.delay = 0, s.trackTime += 0 == a.timeScale ? 0 : (o / a.timeScale + t2) * s.timeScale, a.trackTime += i, this.setCurrent(r, s, true); null != s.mixingFrom; )
              s.mixTime += t2, s = s.mixingFrom;
            continue;
          }
        } else if (a.trackLast >= a.trackEnd && null == a.mixingFrom) {
          e2[r] = null, this.queue.end(a), this.disposeNext(a);
          continue;
        }
        if (null != a.mixingFrom && this.updateMixingFrom(a, t2)) {
          var h = a.mixingFrom;
          for (a.mixingFrom = null, null != h && (h.mixingTo = null); null != h; )
            this.queue.end(h), h = h.mixingFrom;
        }
        a.trackTime += i;
      }
    }
    this.queue.drain();
  }, e.updateMixingFrom = function(t2, e2) {
    var r = t2.mixingFrom;
    if (null == r)
      return true;
    var n = this.updateMixingFrom(r, e2);
    return r.animationLast = r.nextAnimationLast, r.trackLast = r.nextTrackLast, t2.mixTime > 0 && t2.mixTime >= t2.mixDuration ? (0 != r.totalAlpha && 0 != t2.mixDuration || (t2.mixingFrom = r.mixingFrom, null != r.mixingFrom && (r.mixingFrom.mixingTo = t2), t2.interruptAlpha = r.interruptAlpha, this.queue.end(r)), n) : (r.trackTime += e2 * r.timeScale, t2.mixTime += e2, false);
  }, e.apply = function(e2) {
    if (null == e2)
      throw new Error("skeleton cannot be null.");
    this.animationsChanged && this._animationsChanged();
    for (var r = this.events, n = this.tracks, a = false, i = 0, s = n.length; i < s; i++) {
      var o = n[i];
      if (!(null == o || o.delay > 0)) {
        a = true;
        var h = 0 == i ? rt.first : o.mixBlend, l = o.alpha;
        null != o.mixingFrom ? l *= this.applyMixingFrom(o, e2, h) : o.trackTime >= o.trackEnd && null == o.next && (l = 0);
        var u = o.animationLast, c = o.getAnimationTime(), d = o.animation.timelines.length, f = o.animation.timelines;
        if (0 == i && 1 == l || h == rt.add)
          for (var v = 0; v < d; v++) {
            F.webkit602BugfixHelper(l, h);
            var p = f[v];
            k(p, yt) ? this.applyAttachmentTimeline(p, e2, c, h, true) : p.apply(e2, u, c, r, l, h, nt.mixIn);
          }
        else {
          var g = o.timelineMode, m = 0 == o.timelinesRotation.length;
          m && F.setArraySize(o.timelinesRotation, d << 1, null);
          for (var w = o.timelinesRotation, E = 0; E < d; E++) {
            var x = f[E], y = g[E] == t.SUBSEQUENT ? h : rt.setup;
            k(x, pt) ? this.applyRotateTimeline(x, e2, c, l, y, w, E << 1, m) : k(x, yt) ? this.applyAttachmentTimeline(x, e2, c, h, true) : (F.webkit602BugfixHelper(l, h), x.apply(e2, u, c, r, l, y, nt.mixIn));
          }
        }
        this.queueEvents(o, c), r.length = 0, o.nextAnimationLast = c, o.nextTrackLast = o.trackTime;
      }
    }
    for (var b = this.unkeyedState + t.SETUP, S = e2.slots, M2 = 0, A2 = e2.slots.length; M2 < A2; M2++) {
      var T2 = S[M2];
      if (T2.attachmentState == b) {
        var I2 = T2.data.attachmentName;
        T2.attachment = null == I2 ? null : e2.getAttachment(T2.data.index, I2);
      }
    }
    return this.unkeyedState += 2, this.queue.drain(), a;
  }, e.applyMixingFrom = function(e2, r, n) {
    var a = e2.mixingFrom;
    null != a.mixingFrom && this.applyMixingFrom(a, r, n);
    var i = 0;
    0 == e2.mixDuration ? (i = 1, n == rt.first && (n = rt.setup)) : ((i = e2.mixTime / e2.mixDuration) > 1 && (i = 1), n != rt.first && (n = a.mixBlend));
    var s = i < a.eventThreshold ? this.events : null, o = i < a.attachmentThreshold, h = i < a.drawOrderThreshold, l = a.animationLast, u = a.getAnimationTime(), c = a.animation.timelines.length, d = a.animation.timelines, f = a.alpha * e2.interruptAlpha, v = f * (1 - i);
    if (n == rt.add)
      for (var p = 0; p < c; p++)
        d[p].apply(r, l, u, s, v, n, nt.mixOut);
    else {
      var g = a.timelineMode, m = a.timelineHoldMix, w = 0 == a.timelinesRotation.length;
      w && F.setArraySize(a.timelinesRotation, c << 1, null);
      var E = a.timelinesRotation;
      a.totalAlpha = 0;
      for (var x = 0; x < c; x++) {
        var y = d[x], b = nt.mixOut, S = void 0, M2 = 0;
        switch (g[x]) {
          case t.SUBSEQUENT:
            if (!h && k(y, At))
              continue;
            S = n, M2 = v;
            break;
          case t.FIRST:
            S = rt.setup, M2 = v;
            break;
          case t.HOLD_SUBSEQUENT:
            S = n, M2 = f;
            break;
          case t.HOLD_FIRST:
            S = rt.setup, M2 = f;
            break;
          default:
            S = rt.setup;
            var A2 = m[x];
            M2 = f * Math.max(0, 1 - A2.mixTime / A2.mixDuration);
        }
        a.totalAlpha += M2, k(y, pt) ? this.applyRotateTimeline(y, r, u, M2, S, E, x << 1, w) : k(y, yt) ? this.applyAttachmentTimeline(y, r, u, S, o) : (F.webkit602BugfixHelper(M2, n), h && k(y, At) && S == rt.setup && (b = nt.mixIn), y.apply(r, l, u, s, M2, S, b));
      }
    }
    return e2.mixDuration > 0 && this.queueEvents(a, u), this.events.length = 0, a.nextAnimationLast = u, a.nextTrackLast = a.trackTime, i;
  }, e.applyAttachmentTimeline = function(e2, r, n, a, i) {
    var s = r.slots[e2.slotIndex];
    if (s.bone.active) {
      var o, h = e2.frames;
      if (n < h[0])
        a != rt.setup && a != rt.first || this.setAttachment(r, s, s.data.attachmentName, i);
      else
        o = n >= h[h.length - 1] ? h.length - 1 : ft.binarySearch(h, n) - 1, this.setAttachment(r, s, e2.attachmentNames[o], i);
      s.attachmentState <= this.unkeyedState && (s.attachmentState = this.unkeyedState + t.SETUP);
    }
  }, e.setAttachment = function(e2, r, n, a) {
    r.attachment = null == n ? null : e2.getAttachment(r.data.index, n), a && (r.attachmentState = this.unkeyedState + t.CURRENT);
  }, e.applyRotateTimeline = function(t2, e2, r, n, a, i, s, o) {
    if (o && (i[s] = 0), 1 != n) {
      var h = t2, l = h.frames, u = e2.bones[h.boneIndex];
      if (u.active) {
        var c = 0, d = 0;
        if (r < l[0])
          switch (a) {
            case rt.setup:
              u.rotation = u.data.rotation;
            default:
              return;
            case rt.first:
              c = u.rotation, d = u.data.rotation;
          }
        else if (c = a == rt.setup ? u.data.rotation : u.rotation, r >= l[l.length - pt.ENTRIES])
          d = u.data.rotation + l[l.length + pt.PREV_ROTATION];
        else {
          var f = ft.binarySearch(l, r, pt.ENTRIES), v = l[f + pt.PREV_ROTATION], p = l[f], g = h.getCurvePercent((f >> 1) - 1, 1 - (r - p) / (l[f + pt.PREV_TIME] - p));
          d = l[f + pt.ROTATION] - v, d = v + (d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0))) * g + u.data.rotation, d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0));
        }
        var m = 0, w = d - c;
        if (0 == (w -= 360 * (16384 - (16384.499999999996 - w / 360 | 0))))
          m = i[s];
        else {
          var E = 0, x = 0;
          o ? (E = 0, x = w) : (E = i[s], x = i[s + 1]);
          var y = w > 0, b = E >= 0;
          _.signum(x) != _.signum(w) && Math.abs(x) <= 90 && (Math.abs(E) > 180 && (E += 360 * _.signum(E)), b = y), m = w + E - E % 360, b != y && (m += 360 * _.signum(E)), i[s] = m;
        }
        i[s + 1] = w, c += m * n, u.rotation = c - 360 * (16384 - (16384.499999999996 - c / 360 | 0));
      }
    } else
      t2.apply(e2, 0, r, null, 1, a, nt.mixIn);
  }, e.queueEvents = function(t2, e2) {
    for (var r = t2.animationStart, n = t2.animationEnd, a = n - r, i = t2.trackLast % a, s = this.events, o = 0, h = s.length; o < h; o++) {
      var l = s[o];
      if (l.time < i)
        break;
      l.time > n || this.queue.event(t2, l);
    }
    for ((t2.loop ? 0 == a || i > t2.trackTime % a : e2 >= n && t2.animationLast < n) && this.queue.complete(t2); o < h; o++) {
      s[o].time < r || this.queue.event(t2, s[o]);
    }
  }, e.clearTracks = function() {
    var t2 = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (var e2 = 0, r = this.tracks.length; e2 < r; e2++)
      this.clearTrack(e2);
    this.tracks.length = 0, this.queue.drainDisabled = t2, this.queue.drain();
  }, e.clearTrack = function(t2) {
    if (!(t2 >= this.tracks.length)) {
      var e2 = this.tracks[t2];
      if (null != e2) {
        this.queue.end(e2), this.disposeNext(e2);
        for (var r = e2; ; ) {
          var n = r.mixingFrom;
          if (null == n)
            break;
          this.queue.end(n), r.mixingFrom = null, r.mixingTo = null, r = n;
        }
        this.tracks[e2.trackIndex] = null, this.queue.drain();
      }
    }
  }, e.setCurrent = function(t2, e2, r) {
    var n = this.expandToIndex(t2);
    this.tracks[t2] = e2, null != n && (r && this.queue.interrupt(n), e2.mixingFrom = n, n.mixingTo = e2, e2.mixTime = 0, null != n.mixingFrom && n.mixDuration > 0 && (e2.interruptAlpha *= Math.min(1, n.mixTime / n.mixDuration)), n.timelinesRotation.length = 0), this.queue.start(e2);
  }, e.setAnimation = function(t2, e2, r) {
    var n = this.data.skeletonData.findAnimation(e2);
    if (null == n)
      throw new Error("Animation not found: " + e2);
    return this.setAnimationWith(t2, n, r);
  }, e.setAnimationWith = function(t2, e2, r) {
    if (null == e2)
      throw new Error("animation cannot be null.");
    var n = true, a = this.expandToIndex(t2);
    null != a && (-1 == a.nextTrackLast ? (this.tracks[t2] = a.mixingFrom, this.queue.interrupt(a), this.queue.end(a), this.disposeNext(a), a = a.mixingFrom, n = false) : this.disposeNext(a));
    var i = this.trackEntry(t2, e2, r, a);
    return this.setCurrent(t2, i, n), this.queue.drain(), i;
  }, e.addAnimation = function(t2, e2, r, n) {
    var a = this.data.skeletonData.findAnimation(e2);
    if (null == a)
      throw new Error("Animation not found: " + e2);
    return this.addAnimationWith(t2, a, r, n);
  }, e.addAnimationWith = function(t2, e2, r, n) {
    if (null == e2)
      throw new Error("animation cannot be null.");
    var a = this.expandToIndex(t2);
    if (null != a)
      for (; null != a.next; )
        a = a.next;
    var i = this.trackEntry(t2, e2, r, a);
    if (null == a)
      this.setCurrent(t2, i, true), this.queue.drain();
    else if (a.next = i, n <= 0) {
      var s = a.animationEnd - a.animationStart;
      0 != s ? (a.loop ? n += s * (1 + (a.trackTime / s | 0)) : n += Math.max(s, a.trackTime), n -= this.data.getMix(a.animation, e2)) : n = a.trackTime;
    }
    return i.delay = n, i;
  }, e.setEmptyAnimation = function(e2, r) {
    var n = this.setAnimationWith(e2, t.emptyAnimation, false);
    return n.mixDuration = r, n.trackEnd = r, n;
  }, e.addEmptyAnimation = function(e2, r, n) {
    n <= 0 && (n -= r);
    var a = this.addAnimationWith(e2, t.emptyAnimation, false, n);
    return a.mixDuration = r, a.trackEnd = r, a;
  }, e.setEmptyAnimations = function(t2) {
    var e2 = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (var r = 0, n = this.tracks.length; r < n; r++) {
      var a = this.tracks[r];
      null != a && this.setEmptyAnimation(a.trackIndex, t2);
    }
    this.queue.drainDisabled = e2, this.queue.drain();
  }, e.expandToIndex = function(t2) {
    return t2 < this.tracks.length ? this.tracks[t2] : (F.ensureArrayCapacity(this.tracks, t2 + 1, null), this.tracks.length = t2 + 1, null);
  }, e.trackEntry = function(t2, e2, r, n) {
    var a = this.trackEntryPool.obtain();
    return a.trackIndex = t2, a.animation = e2, a.loop = r, a.holdPrevious = false, a.eventThreshold = 0, a.attachmentThreshold = 0, a.drawOrderThreshold = 0, a.animationStart = 0, a.animationEnd = e2.duration, a.animationLast = -1, a.nextAnimationLast = -1, a.delay = 0, a.trackTime = 0, a.trackLast = -1, a.nextTrackLast = -1, a.trackEnd = Number.MAX_VALUE, a.timeScale = 1, a.alpha = 1, a.interruptAlpha = 1, a.mixTime = 0, a.mixDuration = null == n ? 0 : this.data.getMix(n.animation, e2), a.mixBlend = rt.replace, a;
  }, e.disposeNext = function(t2) {
    for (var e2 = t2.next; null != e2; )
      this.queue.dispose(e2), e2 = e2.next;
    t2.next = null;
  }, e._animationsChanged = function() {
    this.animationsChanged = false, this.propertyIDs.clear();
    for (var t2 = 0, e2 = this.tracks.length; t2 < e2; t2++) {
      var r = this.tracks[t2];
      if (null != r) {
        for (; null != r.mixingFrom; )
          r = r.mixingFrom;
        do {
          null != r.mixingFrom && r.mixBlend == rt.add || this.computeHold(r), r = r.mixingTo;
        } while (null != r);
      }
    }
  }, e.computeHold = function(e2) {
    var r = e2.mixingTo, n = e2.animation.timelines, a = e2.animation.timelines.length, i = F.setArraySize(e2.timelineMode, a);
    e2.timelineHoldMix.length = 0;
    var s = F.setArraySize(e2.timelineHoldMix, a), o = this.propertyIDs;
    if (null != r && r.holdPrevious)
      for (var h = 0; h < a; h++)
        i[h] = o.add(n[h].getPropertyId()) ? t.HOLD_FIRST : t.HOLD_SUBSEQUENT;
    else
      t:
        for (var l = 0; l < a; l++) {
          var u = n[l], c = u.getPropertyId();
          if (o.add(c))
            if (null == r || k(u, yt) || k(u, At) || k(u, Mt) || !r.animation.hasTimeline(c))
              i[l] = t.FIRST;
            else {
              for (var d = r.mixingTo; null != d; d = d.mixingTo)
                if (!d.animation.hasTimeline(c)) {
                  if (e2.mixDuration > 0) {
                    i[l] = t.HOLD_MIX, s[l] = d;
                    continue t;
                  }
                  break;
                }
              i[l] = t.HOLD_FIRST;
            }
          else
            i[l] = t.SUBSEQUENT;
        }
  }, e.getCurrent = function(t2) {
    return t2 >= this.tracks.length ? null : this.tracks[t2];
  }, e.addListener = function(t2) {
    if (null == t2)
      throw new Error("listener cannot be null.");
    this.listeners.push(t2);
  }, e.removeListener = function(t2) {
    var e2 = this.listeners.indexOf(t2);
    e2 >= 0 && this.listeners.splice(e2, 1);
  }, e.clearListeners = function() {
    this.listeners.length = 0;
  }, e.clearListenerNotifications = function() {
    this.queue.clear();
  }, t;
}();
Vt.emptyAnimation = new ft("<empty>", [], 0), Vt.SUBSEQUENT = 0, Vt.FIRST = 1, Vt.HOLD_SUBSEQUENT = 2, Vt.HOLD_FIRST = 3, Vt.HOLD_MIX = 4, Vt.SETUP = 1, Vt.CURRENT = 2;
var Pt, _t = function() {
  function t() {
    this.mixBlend = rt.replace, this.timelineMode = new Array(), this.timelineHoldMix = new Array(), this.timelinesRotation = new Array();
  }
  var e = t.prototype;
  return e.reset = function() {
    this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0;
  }, e.getAnimationTime = function() {
    if (this.loop) {
      var t2 = this.animationEnd - this.animationStart;
      return 0 == t2 ? this.animationStart : this.trackTime % t2 + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }, e.setAnimationLast = function(t2) {
    this.animationLast = t2, this.nextAnimationLast = t2;
  }, e.isComplete = function() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }, e.resetRotationDirections = function() {
    this.timelinesRotation.length = 0;
  }, t;
}(), Ft = function() {
  function t(t2) {
    this.objects = [], this.drainDisabled = false, this.animState = t2;
  }
  var e = t.prototype;
  return e.start = function(t2) {
    this.objects.push(0), this.objects.push(t2), this.animState.animationsChanged = true;
  }, e.interrupt = function(t2) {
    this.objects.push(1), this.objects.push(t2);
  }, e.end = function(t2) {
    this.objects.push(2), this.objects.push(t2), this.animState.animationsChanged = true;
  }, e.dispose = function(t2) {
    this.objects.push(3), this.objects.push(t2);
  }, e.complete = function(t2) {
    this.objects.push(4), this.objects.push(t2);
  }, e.event = function(t2, e2) {
    this.objects.push(5), this.objects.push(t2), this.objects.push(e2);
  }, e.drain = function() {
    if (!this.drainDisabled) {
      this.drainDisabled = true;
      for (var t2 = this.objects, e2 = this.animState.listeners, r = 0; r < t2.length; r += 2) {
        var n = t2[r], a = t2[r + 1];
        switch (n) {
          case 0:
            null != a.listener && a.listener.start && a.listener.start(a);
            for (var i = 0; i < e2.length; i++)
              e2[i].start && e2[i].start(a);
            break;
          case 1:
            null != a.listener && a.listener.interrupt && a.listener.interrupt(a);
            for (var s = 0; s < e2.length; s++)
              e2[s].interrupt && e2[s].interrupt(a);
            break;
          case 2:
            null != a.listener && a.listener.end && a.listener.end(a);
            for (var o = 0; o < e2.length; o++)
              e2[o].end && e2[o].end(a);
          case 3:
            null != a.listener && a.listener.dispose && a.listener.dispose(a);
            for (var h = 0; h < e2.length; h++)
              e2[h].dispose && e2[h].dispose(a);
            this.animState.trackEntryPool.free(a);
            break;
          case 4:
            null != a.listener && a.listener.complete && a.listener.complete(a);
            for (var l = 0; l < e2.length; l++)
              e2[l].complete && e2[l].complete(a);
            break;
          case 5:
            var u = t2[2 + r++];
            null != a.listener && a.listener.event && a.listener.event(a, u);
            for (var c = 0; c < e2.length; c++)
              e2[c].event && e2[c].event(a, u);
        }
      }
      this.clear(), this.drainDisabled = false;
    }
  }, e.clear = function() {
    this.objects.length = 0;
  }, t;
}();
!function(t) {
  t[t.start = 0] = "start", t[t.interrupt = 1] = "interrupt", t[t.end = 2] = "end", t[t.dispose = 3] = "dispose", t[t.complete = 4] = "complete", t[t.event = 5] = "event";
}(Pt || (Pt = {}));
var Nt = function() {
  function t(t2) {
    if (this.animationToMixTime = {}, this.defaultMix = 0, null == t2)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = t2;
  }
  var e = t.prototype;
  return e.setMix = function(t2, e2, r) {
    var n = this.skeletonData.findAnimation(t2);
    if (null == n)
      throw new Error("Animation not found: " + t2);
    var a = this.skeletonData.findAnimation(e2);
    if (null == a)
      throw new Error("Animation not found: " + e2);
    this.setMixWith(n, a, r);
  }, e.setMixWith = function(t2, e2, r) {
    if (null == t2)
      throw new Error("from cannot be null.");
    if (null == e2)
      throw new Error("to cannot be null.");
    var n = t2.name + "." + e2.name;
    this.animationToMixTime[n] = r;
  }, e.getMix = function(t2, e2) {
    var r = t2.name + "." + e2.name, n = this.animationToMixTime[r];
    return void 0 === n ? this.defaultMix : n;
  }, t;
}(), Ot = function(t) {
  function e(e2) {
    var r;
    return (r = t.call(this, e2) || this).color = new P(0.2275, 0.2275, 0.8078, 1), r;
  }
  return R(e, t), e.prototype.copy = function() {
    var t2 = new e(this.name);
    return this.copyTo(t2), t2.endSlot = this.endSlot, t2.color.setFromColor(this.color), t2;
  }, e;
}(Z), Lt = function() {
  function t() {
    this.convexPolygons = new Array(), this.convexPolygonsIndices = new Array(), this.indicesArray = new Array(), this.isConcaveArray = new Array(), this.triangles = new Array(), this.polygonPool = new O(function() {
      return new Array();
    }), this.polygonIndicesPool = new O(function() {
      return new Array();
    });
  }
  var e = t.prototype;
  return e.triangulate = function(e2) {
    var r = e2, n = e2.length >> 1, a = this.indicesArray;
    a.length = 0;
    for (var i = 0; i < n; i++)
      a[i] = i;
    var s = this.isConcaveArray;
    s.length = 0;
    for (var o = 0, h = n; o < h; ++o)
      s[o] = t.isConcave(o, n, r, a);
    var l = this.triangles;
    for (l.length = 0; n > 3; ) {
      for (var u = n - 1, c = 0, d = 1; ; ) {
        t:
          if (!s[c]) {
            for (var f = a[u] << 1, v = a[c] << 1, p = a[d] << 1, g = r[f], m = r[f + 1], w = r[v], E = r[v + 1], x = r[p], y = r[p + 1], b = (d + 1) % n; b != u; b = (b + 1) % n)
              if (s[b]) {
                var S = a[b] << 1, M2 = r[S], A2 = r[S + 1];
                if (t.positiveArea(x, y, g, m, M2, A2) && t.positiveArea(g, m, w, E, M2, A2) && t.positiveArea(w, E, x, y, M2, A2))
                  break t;
              }
            break;
          }
        if (0 == d) {
          do {
            if (!s[c])
              break;
            c--;
          } while (c > 0);
          break;
        }
        u = c, c = d, d = (d + 1) % n;
      }
      l.push(a[(n + c - 1) % n]), l.push(a[c]), l.push(a[(c + 1) % n]), a.splice(c, 1), s.splice(c, 1);
      var T2 = (--n + c - 1) % n, I2 = c == n ? 0 : c;
      s[T2] = t.isConcave(T2, n, r, a), s[I2] = t.isConcave(I2, n, r, a);
    }
    return 3 == n && (l.push(a[2]), l.push(a[0]), l.push(a[1])), l;
  }, e.decompose = function(e2, r) {
    var n = e2, a = this.convexPolygons;
    this.polygonPool.freeAll(a), a.length = 0;
    var i = this.convexPolygonsIndices;
    this.polygonIndicesPool.freeAll(i), i.length = 0;
    var s = this.polygonIndicesPool.obtain();
    s.length = 0;
    var o = this.polygonPool.obtain();
    o.length = 0;
    for (var h = -1, l = 0, u = 0, c = r.length; u < c; u += 3) {
      var d = r[u] << 1, f = r[u + 1] << 1, v = r[u + 2] << 1, p = n[d], g = n[d + 1], m = n[f], w = n[f + 1], E = n[v], x = n[v + 1], y = false;
      if (h == d) {
        var b = o.length - 4, S = t.winding(o[b], o[b + 1], o[b + 2], o[b + 3], E, x), M2 = t.winding(E, x, o[0], o[1], o[2], o[3]);
        S == l && M2 == l && (o.push(E), o.push(x), s.push(v), y = true);
      }
      y || (o.length > 0 ? (a.push(o), i.push(s)) : (this.polygonPool.free(o), this.polygonIndicesPool.free(s)), (o = this.polygonPool.obtain()).length = 0, o.push(p), o.push(g), o.push(m), o.push(w), o.push(E), o.push(x), (s = this.polygonIndicesPool.obtain()).length = 0, s.push(d), s.push(f), s.push(v), l = t.winding(p, g, m, w, E, x), h = d);
    }
    o.length > 0 && (a.push(o), i.push(s));
    for (var A2 = 0, T2 = a.length; A2 < T2; A2++)
      if (0 != (s = i[A2]).length) {
        for (var I2 = s[0], R2 = s[s.length - 1], C2 = (o = a[A2]).length - 4, k2 = o[C2], V2 = o[C2 + 1], P2 = o[C2 + 2], _2 = o[C2 + 3], F2 = o[0], N2 = o[1], O2 = o[2], L2 = o[3], X2 = t.winding(k2, V2, P2, _2, F2, N2), B2 = 0; B2 < T2; B2++)
          if (B2 != A2) {
            var D2 = i[B2];
            if (3 == D2.length) {
              var Y2 = D2[0], U2 = D2[1], W2 = D2[2], q2 = a[B2], H2 = q2[q2.length - 2], j2 = q2[q2.length - 1];
              if (Y2 == I2 && U2 == R2) {
                var G2 = t.winding(k2, V2, P2, _2, H2, j2), z2 = t.winding(H2, j2, F2, N2, O2, L2);
                G2 == X2 && z2 == X2 && (q2.length = 0, D2.length = 0, o.push(H2), o.push(j2), s.push(W2), k2 = P2, V2 = _2, P2 = H2, _2 = j2, B2 = 0);
              }
            }
          }
      }
    for (var Z2 = a.length - 1; Z2 >= 0; Z2--)
      0 == (o = a[Z2]).length && (a.splice(Z2, 1), this.polygonPool.free(o), s = i[Z2], i.splice(Z2, 1), this.polygonIndicesPool.free(s));
    return a;
  }, t.isConcave = function(t2, e2, r, n) {
    var a = n[(e2 + t2 - 1) % e2] << 1, i = n[t2] << 1, s = n[(t2 + 1) % e2] << 1;
    return !this.positiveArea(r[a], r[a + 1], r[i], r[i + 1], r[s], r[s + 1]);
  }, t.positiveArea = function(t2, e2, r, n, a, i) {
    return t2 * (i - n) + r * (e2 - i) + a * (n - e2) >= 0;
  }, t.winding = function(t2, e2, r, n, a, i) {
    var s = r - t2, o = n - e2;
    return a * o - i * s + s * e2 - t2 * o >= 0 ? 1 : -1;
  }, t;
}(), Xt = function() {
  function t() {
    this.triangulator = new Lt(), this.clippingPolygon = new Array(), this.clipOutput = new Array(), this.clippedVertices = new Array(), this.clippedTriangles = new Array(), this.scratch = new Array();
  }
  var e = t.prototype;
  return e.clipStart = function(e2, r) {
    if (null != this.clipAttachment)
      return 0;
    this.clipAttachment = r;
    var n = r.worldVerticesLength, a = F.setArraySize(this.clippingPolygon, n);
    r.computeWorldVertices(e2, 0, n, a, 0, 2);
    var i = this.clippingPolygon;
    t.makeClockwise(i);
    for (var s = this.clippingPolygons = this.triangulator.decompose(i, this.triangulator.triangulate(i)), o = 0, h = s.length; o < h; o++) {
      var l = s[o];
      t.makeClockwise(l), l.push(l[0]), l.push(l[1]);
    }
    return s.length;
  }, e.clipEndWithSlot = function(t2) {
    null != this.clipAttachment && this.clipAttachment.endSlot == t2.data && this.clipEnd();
  }, e.clipEnd = function() {
    null != this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0);
  }, e.isClipping = function() {
    return null != this.clipAttachment;
  }, e.clipTriangles = function(t2, e2, r, n, a, i, s, o) {
    var h = this.clipOutput, l = this.clippedVertices, u = this.clippedTriangles, c = this.clippingPolygons, d = this.clippingPolygons.length, f = o ? 12 : 8, v = 0;
    l.length = 0, u.length = 0;
    t:
      for (var p = 0; p < n; p += 3)
        for (var g = r[p] << 1, m = t2[g], w = t2[g + 1], E = a[g], x = a[g + 1], y = t2[g = r[p + 1] << 1], b = t2[g + 1], S = a[g], M2 = a[g + 1], A2 = t2[g = r[p + 2] << 1], T2 = t2[g + 1], I2 = a[g], R2 = a[g + 1], C2 = 0; C2 < d; C2++) {
          var k2 = l.length;
          if (!this.clip(m, w, y, b, A2, T2, c[C2], h)) {
            var V2 = F.setArraySize(l, k2 + 3 * f);
            V2[k2] = m, V2[k2 + 1] = w, V2[k2 + 2] = i.r, V2[k2 + 3] = i.g, V2[k2 + 4] = i.b, V2[k2 + 5] = i.a, o ? (V2[k2 + 6] = E, V2[k2 + 7] = x, V2[k2 + 8] = s.r, V2[k2 + 9] = s.g, V2[k2 + 10] = s.b, V2[k2 + 11] = s.a, V2[k2 + 12] = y, V2[k2 + 13] = b, V2[k2 + 14] = i.r, V2[k2 + 15] = i.g, V2[k2 + 16] = i.b, V2[k2 + 17] = i.a, V2[k2 + 18] = S, V2[k2 + 19] = M2, V2[k2 + 20] = s.r, V2[k2 + 21] = s.g, V2[k2 + 22] = s.b, V2[k2 + 23] = s.a, V2[k2 + 24] = A2, V2[k2 + 25] = T2, V2[k2 + 26] = i.r, V2[k2 + 27] = i.g, V2[k2 + 28] = i.b, V2[k2 + 29] = i.a, V2[k2 + 30] = I2, V2[k2 + 31] = R2, V2[k2 + 32] = s.r, V2[k2 + 33] = s.g, V2[k2 + 34] = s.b, V2[k2 + 35] = s.a) : (V2[k2 + 6] = E, V2[k2 + 7] = x, V2[k2 + 8] = y, V2[k2 + 9] = b, V2[k2 + 10] = i.r, V2[k2 + 11] = i.g, V2[k2 + 12] = i.b, V2[k2 + 13] = i.a, V2[k2 + 14] = S, V2[k2 + 15] = M2, V2[k2 + 16] = A2, V2[k2 + 17] = T2, V2[k2 + 18] = i.r, V2[k2 + 19] = i.g, V2[k2 + 20] = i.b, V2[k2 + 21] = i.a, V2[k2 + 22] = I2, V2[k2 + 23] = R2), k2 = u.length;
            var P2 = F.setArraySize(u, k2 + 3);
            P2[k2] = v, P2[k2 + 1] = v + 1, P2[k2 + 2] = v + 2, v += 3;
            continue t;
          }
          var _2 = h.length;
          if (0 != _2) {
            for (var N2 = b - T2, O2 = A2 - y, L2 = m - A2, X2 = T2 - w, B2 = 1 / (N2 * L2 + O2 * (w - T2)), D2 = _2 >> 1, Y2 = this.clipOutput, U2 = F.setArraySize(l, k2 + D2 * f), W2 = 0; W2 < _2; W2 += 2) {
              var q2 = Y2[W2], H2 = Y2[W2 + 1];
              U2[k2] = q2, U2[k2 + 1] = H2, U2[k2 + 2] = i.r, U2[k2 + 3] = i.g, U2[k2 + 4] = i.b, U2[k2 + 5] = i.a;
              var j2 = q2 - A2, G2 = H2 - T2, z2 = (N2 * j2 + O2 * G2) * B2, Z2 = (X2 * j2 + L2 * G2) * B2, Q2 = 1 - z2 - Z2;
              U2[k2 + 6] = E * z2 + S * Z2 + I2 * Q2, U2[k2 + 7] = x * z2 + M2 * Z2 + R2 * Q2, o && (U2[k2 + 8] = s.r, U2[k2 + 9] = s.g, U2[k2 + 10] = s.b, U2[k2 + 11] = s.a), k2 += f;
            }
            k2 = u.length;
            var J2 = F.setArraySize(u, k2 + 3 * (D2 - 2));
            D2--;
            for (var K2 = 1; K2 < D2; K2++)
              J2[k2] = v, J2[k2 + 1] = v + K2, J2[k2 + 2] = v + K2 + 1, k2 += 3;
            v += D2 + 1;
          }
        }
  }, e.clip = function(t2, e2, r, n, a, i, s, o) {
    var h = o, l = false, u = null;
    s.length % 4 >= 2 ? (u = o, o = this.scratch) : u = this.scratch, u.length = 0, u.push(t2), u.push(e2), u.push(r), u.push(n), u.push(a), u.push(i), u.push(t2), u.push(e2), o.length = 0;
    for (var c = s, d = s.length - 4, f = 0; ; f += 2) {
      for (var v = c[f], p = c[f + 1], g = c[f + 2], m = c[f + 3], w = v - g, E = p - m, x = u, y = u.length - 2, b = o.length, S = 0; S < y; S += 2) {
        var M2 = x[S], A2 = x[S + 1], T2 = x[S + 2], I2 = x[S + 3], R2 = w * (I2 - m) - E * (T2 - g) > 0;
        if (w * (A2 - m) - E * (M2 - g) > 0) {
          if (R2) {
            o.push(T2), o.push(I2);
            continue;
          }
          var C2 = I2 - A2, k2 = T2 - M2, V2 = C2 * (g - v) - k2 * (m - p);
          if (Math.abs(V2) > 1e-6) {
            var P2 = (k2 * (p - A2) - C2 * (v - M2)) / V2;
            o.push(v + (g - v) * P2), o.push(p + (m - p) * P2);
          } else
            o.push(v), o.push(p);
        } else if (R2) {
          var _2 = I2 - A2, F2 = T2 - M2, N2 = _2 * (g - v) - F2 * (m - p);
          if (Math.abs(N2) > 1e-6) {
            var O2 = (F2 * (p - A2) - _2 * (v - M2)) / N2;
            o.push(v + (g - v) * O2), o.push(p + (m - p) * O2);
          } else
            o.push(v), o.push(p);
          o.push(T2), o.push(I2);
        }
        l = true;
      }
      if (b == o.length)
        return h.length = 0, true;
      if (o.push(o[0]), o.push(o[1]), f == d)
        break;
      var L2 = o;
      (o = u).length = 0, u = L2;
    }
    if (h != o) {
      h.length = 0;
      for (var X2 = 0, B2 = o.length - 2; X2 < B2; X2++)
        h[X2] = o[X2];
    } else
      h.length = h.length - 2;
    return l;
  }, t.makeClockwise = function(t2) {
    for (var e2 = t2, r = t2.length, n = e2[r - 2] * e2[1] - e2[0] * e2[r - 1], a = 0, i = 0, s = 0, o = 0, h = r - 3; o < h; o += 2)
      a = e2[o], i = e2[o + 1], s = e2[o + 2], n += a * e2[o + 3] - s * i;
    if (!(n < 0))
      for (var l = 0, u = r - 2, c = r >> 1; l < c; l += 2) {
        var d = e2[l], f = e2[l + 1], v = u - l;
        e2[l] = e2[v], e2[l + 1] = e2[v + 1], e2[v] = d, e2[v + 1] = f;
      }
  }, t;
}(), Bt = function() {
  function o() {
  }
  var h = o.prototype;
  return h.initialize = function(o2, h2) {
    var l = this._mesh = new BufferMesh(o2), u = [new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0), new VertexElement("COLOR_0", 12, VertexElementFormat.Vector4, 0), new VertexElement("TEXCOORD_0", 28, VertexElementFormat.Vector2, 0)], c = 4 * Dt.VERTEX_STRIDE, d = c * h2, f = new Buffer(o2, BufferBindFlag.VertexBuffer, d, BufferUsage.Dynamic), v = new Buffer(o2, BufferBindFlag.IndexBuffer, 2 * h2, BufferUsage.Dynamic);
    this._indexBuffer = v, this._vertexBuffer = f, l.setVertexBufferBinding(f, c), l.setIndexBufferBinding(v, IndexFormat.UInt16), l.setVertexElements(u), l.addSubMesh(0, h2);
  }, h.changeBuffer = function(t, e) {
    var r = 4 * Dt.VERTEX_STRIDE, o2 = r * e, h2 = new Buffer(t, BufferBindFlag.VertexBuffer, o2, BufferUsage.Dynamic), l = new Buffer(t, BufferBindFlag.IndexBuffer, 2 * e, BufferUsage.Dynamic), u = this._mesh;
    this._indexBuffer = l, this._vertexBuffer = h2, u.setVertexBufferBinding(h2, r), u.setIndexBufferBinding(l, IndexFormat.UInt16);
  }, A(o, [{ key: "mesh", get: function() {
    return this._mesh;
  } }, { key: "indexBuffer", get: function() {
    return this._indexBuffer;
  } }, { key: "vertexBuffer", get: function() {
    return this._vertexBuffer;
  } }]), o;
}(), Dt = function() {
  function t(t2, e2) {
    this._clipper = new Xt(), this._spineMesh = new Bt(), this._needResize = false, this._subMeshItems = [], this.separateSlots = [], this._engine = t2, this._entity = e2;
  }
  var e = t.prototype;
  return e.initialize = function(e2, r) {
    if (e2) {
      var n = this._entity.getComponent(MeshRenderer);
      if (n) {
        this._meshRenderer = n, r && (this._setting = r);
        for (var a = e2.defaultSkin.attachments, i = 0, s = t.QUAD_TRIANGLES.length, h = 0, l = a.length; h < l; h++) {
          var u = a[h];
          for (var c in u) {
            var d = u[c];
            if (d)
              if (k(d, K))
                i += s;
              else {
                if (!k(d, ct))
                  continue;
                i += d.triangles.length;
              }
          }
        }
        this._vertexCount = i, this._prepareBufferData(this._vertexCount);
        var f = this._spineMesh;
        f.initialize(this._engine, this._vertexCount), n.mesh = f.mesh;
      } else
        console.warn("You need add MeshRenderer component to entity first");
    }
  }, e.buildMesh = function(e2) {
    var r = this._setting || {}, n = r.useClipping, a = void 0 === n || n, i = r.zSpacing, s = void 0 === i ? 0.01 : i, o = 0, l = 0;
    this._subMeshItems.length = 0;
    for (var u, c, d = this._meshRenderer, f = e2.drawOrder, v = f.length, p = this._clipper, g = this._spineMesh, m = g.mesh, w = this._subMeshItems, E = this._vertices, x = 0, y = 0, b = 0; b < v; b += 1) {
      var S = f[b];
      if (S.bone.active) {
        var M2 = S.getAttachment(), A2 = null, T2 = null, I2 = s * b, R2 = 0, C2 = p.isClipping() ? 2 : t.VERTEX_SIZE;
        if (k(M2, K)) {
          var V2 = M2;
          A2 = V2.color, E = this._vertices, R2 = 4 * C2, V2.computeWorldVertices(S.bone, E, 0, C2), u = t.QUAD_TRIANGLES, c = V2.uvs, T2 = V2.region.renderObject.texture;
        } else if (k(M2, ct)) {
          var P2 = M2;
          A2 = P2.color, E = this._vertices, (R2 = (P2.worldVerticesLength >> 1) * C2) > E.length && (E = this._vertices = new Float32Array(R2)), P2.computeWorldVertices(S, 0, P2.worldVerticesLength, E, 0, C2), u = P2.triangles, c = P2.uvs, T2 = P2.region.renderObject.texture;
        } else if (k(M2, Ot)) {
          if (a) {
            var _2 = M2;
            p.clipStart(S, _2);
            continue;
          }
        } else if (a) {
          p.clipEndWithSlot(S);
          continue;
        }
        if (null != T2) {
          var F2 = void 0, N2 = void 0, O2 = void 0, L2 = void 0, X2 = S.bone.skeleton.color, B2 = S.color, D2 = X2.a * B2.a * A2.a, Y2 = t.tempColor;
          if (Y2.set(X2.r * B2.r * A2.r, X2.g * B2.g * A2.g, X2.b * B2.b * A2.b, D2), p.isClipping()) {
            p.clipTriangles(E, R2, u, u.length, c, Y2, null, false);
            var U2 = p.clippedVertices, W2 = p.clippedTriangles;
            F2 = U2, N2 = U2.length, O2 = W2, L2 = W2.length;
          } else {
            for (var q2 = E, H2 = 2, j2 = 0, G2 = R2; H2 < G2; H2 += C2, j2 += 2)
              q2[H2] = Y2.r, q2[H2 + 1] = Y2.g, q2[H2 + 2] = Y2.b, q2[H2 + 3] = Y2.a, q2[H2 + 4] = c[j2], q2[H2 + 5] = c[j2 + 1];
            F2 = E, N2 = R2, O2 = u, L2 = u.length;
          }
          for (var z2 = o / t.VERTEX_STRIDE, Z2 = this._verticesWithZ, Q2 = o, J2 = 0; J2 < N2; )
            Z2[Q2++] = F2[J2++], Z2[Q2++] = F2[J2++], Z2[Q2++] = I2, Z2[Q2++] = F2[J2++], Z2[Q2++] = F2[J2++], Z2[Q2++] = F2[J2++], Z2[Q2++] = F2[J2++], Z2[Q2++] = F2[J2++], Z2[Q2++] = F2[J2++];
          o = Q2;
          var $2 = this._indices;
          for (Q2 = l, J2 = 0; J2 < L2; Q2++, J2++)
            $2[Q2] = O2[J2] + z2;
          var tt2 = S.data.name;
          if (this.separateSlots.includes(tt2)) {
            var et2 = new SubMesh(l, L2);
            if (w.push({ name: tt2, subMesh: et2 }), y > 0) {
              var rt2 = new SubMesh(x, y);
              w.push({ name: "default", subMesh: rt2 }), y = 0;
            }
            x = l + L2;
          } else
            y += L2;
          l += L2;
          for (var nt2 = d.getMaterials(), at2 = nt2.length, it2 = 0; it2 < at2; it2 += 1) {
            var st2 = nt2[it2];
            st2.shaderData.getTexture("material_SpineTexture") || st2.shaderData.setTexture("material_SpineTexture", T2.texture);
          }
        }
        p.clipEndWithSlot(S);
      } else
        p.clipEndWithSlot(S);
    }
    if (p.clipEnd(), y > 0) {
      var ot2 = new SubMesh(x, y);
      w.push({ name: "default", subMesh: ot2 }), y = 0;
    }
    if (w.sort(function(t2, e3) {
      return t2.subMesh.start - e3.subMesh.start;
    }), l > 0 && l !== this._vertexCount && l > this._vertexCount)
      return this._vertexCount = l, this._prepareBufferData(this._vertexCount), void (this._needResize = true);
    m.clearSubMesh();
    for (var ht2 = w.length, lt2 = 0; lt2 < ht2; lt2 += 1)
      m.addSubMesh(w[lt2].subMesh);
    this._needResize && (g.vertexBuffer.resize(this._verticesWithZ.byteLength), g.indexBuffer.resize(this._indices.byteLength), this._needResize = false), g.vertexBuffer.setData(this._verticesWithZ), g.indexBuffer.setData(this._indices);
  }, e.addSeparateSlot = function(t2) {
    this.separateSlots.push(t2);
  }, e._prepareBufferData = function(e2) {
    this._vertices = new Float32Array(e2 * t.VERTEX_SIZE), this._verticesWithZ = new Float32Array(e2 * t.VERTEX_STRIDE), this._indices = new Uint16Array(e2);
  }, A(t, [{ key: "mesh", get: function() {
    return this._spineMesh.mesh;
  } }, { key: "subMeshItems", get: function() {
    return this._subMeshItems;
  } }]), t;
}();
Dt.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0], Dt.VERTEX_SIZE = 8, Dt.VERTEX_STRIDE = 9, Dt.tempColor = new P();
var Yt = function(t) {
  function e(r) {
    var n, a = Shader.find("galacean-spine-shader") || Shader.create("galacean-spine-shader", e._spineVS, e._spineFS), i = (n = t.call(this, r, a) || this).renderState, s = i.blendState.targetBlendState;
    return s.enabled = true, s.sourceColorBlendFactor = BlendFactor.SourceAlpha, s.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha, s.sourceAlphaBlendFactor = BlendFactor.One, s.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha, s.colorBlendOperation = s.alphaBlendOperation = BlendOperation.Add, i.depthState.writeEnabled = false, i.rasterState.cullMode = CullMode.Off, i.renderQueueType = RenderQueueType.Transparent, n;
  }
  return R(e, t), e;
}(Material);
Yt._spineVS = "\n    uniform mat4 renderer_MVPMat;\n\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n    \n    varying vec2 v_uv;\n    varying vec4 v_color;\n    \n    void main()\n    {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n    \n      v_uv = TEXCOORD_0;\n      v_color = COLOR_0;\n    }\n  ", Yt._spineFS = "\n    uniform sampler2D material_SpineTexture;\n\n    varying vec2 v_uv;\n    varying vec4 v_color;\n    \n    void main()\n    {\n        vec4 baseColor = texture2D(material_SpineTexture, v_uv);\n        gl_FragColor = baseColor * v_color;\n    }\n   ";
var Ut = function(t) {
  function e(e2) {
    var r2;
    return (r2 = t.call(this, e2) || this)._tempOffset = new L(), r2._tempSize = new L(), r2._tempArray = [0, 0], r2.autoUpdate = true, r2.autoUpdateBounds = false, r2._meshGenerator = new Dt(r2.engine, e2), r2;
  }
  R(e, t);
  var r = e.prototype;
  return r.setSkeletonData = function(t2, e2) {
    t2 || console.error("SkeletonData is undefined"), this.setting = e2, this._skeletonData = t2, this._skeleton = new dt(t2);
    var r2 = new Nt(t2);
    this._state = new Vt(r2), this._meshGenerator.initialize(t2, this.setting);
  }, r.addSeparateSlot = function(t2) {
    this.skeleton || console.error("Skeleton not found!");
    var r2 = this.entity.getComponent(MeshRenderer);
    if (r2 || console.warn("You need add MeshRenderer component to entity first"), this.skeleton.findSlot(t2)) {
      this._meshGenerator.addSeparateSlot(t2);
      var n = e._defaultMaterial.clone(), a = e._defaultMaterial.clone(), i = r2.materialCount;
      r2.setMaterial(i, n), r2.setMaterial(i + 1, a);
    } else
      console.warn("Slot: " + t2 + " not find.");
  }, r.hackSeparateSlotTexture = function(t2, e2) {
    this._meshGenerator.buildMesh(this._skeleton);
    var r2 = this._meshGenerator, n = r2.separateSlots, a = r2.subMeshItems;
    if (0 !== n.length)
      if (n.includes(t2)) {
        var i = this.entity.getComponent(MeshRenderer), s = a.findIndex(function(e3) {
          return e3.name === t2;
        });
        i.getMaterial(s).shaderData.setTexture("material_SpineTexture", e2);
      } else
        console.warn("Slot " + t2 + " is not separated. You should use addSeparateSlot to separate it");
    else
      console.warn("You need add separate slot");
  }, r.onUpdate = function(t2) {
    this.autoUpdate && this.updateState(t2);
  }, r.updateState = function(t2) {
    if (this._skeleton && this.state) {
      var e2 = this._state, r2 = this._skeleton;
      e2.update(t2), e2.apply(r2), r2.updateWorldTransform(), this.updateGeometry();
    }
  }, r.updateGeometry = function() {
    this._skeleton && (this._meshGenerator.buildMesh(this._skeleton), this.autoUpdateBounds && this.updateBounds());
  }, r.updateBounds = function() {
    var t2, e2 = this.entity.getComponent(MeshRenderer).bounds, r2 = this._tempOffset, n = this._tempSize, a = this._tempArray, i = (null == (t2 = this.setting) ? void 0 : t2.zSpacing) || 0.01, s = this._skeleton;
    s.getBounds(r2, n, a);
    var h = s.drawOrder;
    e2.min.set(r2.x, r2.y, 0), e2.max.set(r2.x + n.x, r2.y + n.y, h.length * i);
  }, r._cloneTo = function(t2) {
    t2.setSkeletonData(this.skeletonData);
    var e2 = T({}, this.setting);
    t2.setting = e2;
  }, r._disposeCurrentSkeleton = function() {
    this._skeletonData = null, this._skeleton = null, this._state = null;
  }, r.onDestroy = function() {
    this._disposeCurrentSkeleton(), this._meshGenerator = null, this.setting = null;
  }, e.getDefaultMaterial = function(t2) {
    return this._defaultMaterial || (this._defaultMaterial = new Yt(t2), this._defaultMaterial.isGCIgnored = true), this._defaultMaterial.clone();
  }, A(e, [{ key: "skeletonData", get: function() {
    return this._skeletonData;
  } }, { key: "skeleton", get: function() {
    return this._skeleton;
  } }, { key: "state", get: function() {
    return this._state;
  } }, { key: "mesh", get: function() {
    return this._meshGenerator.mesh;
  } }, { key: "scale", set: function(t2) {
    this._skeleton && (this._skeleton.scaleX = t2, this._skeleton.scaleY = t2);
  } }]), e;
}(Script);
function Wt(t, e) {
  (null == e || e > t.length) && (e = t.length);
  for (var r = 0, n = new Array(e); r < e; r++)
    n[r] = t[r];
  return n;
}
function qt(t, e) {
  var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
  if (r)
    return (r = r.call(t)).next.bind(r);
  if (Array.isArray(t) || (r = function(t2, e2) {
    if (t2) {
      if ("string" == typeof t2)
        return Wt(t2, e2);
      var r2 = Object.prototype.toString.call(t2).slice(8, -1);
      return "Object" === r2 && t2.constructor && (r2 = t2.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(r2) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? Wt(t2, e2) : void 0;
    }
  }(t)) || e && t && "number" == typeof t.length) {
    r && (t = r);
    var n = 0;
    return function() {
      return n >= t.length ? { done: true } : { done: false, value: t[n++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
C([ignoreClone], Ut.prototype, "_skeletonData", void 0), C([ignoreClone], Ut.prototype, "_skeleton", void 0), C([ignoreClone], Ut.prototype, "_state", void 0), C([ignoreClone], Ut.prototype, "_tempOffset", void 0), C([ignoreClone], Ut.prototype, "_tempSize", void 0), C([ignoreClone], Ut.prototype, "_tempArray", void 0), C([ignoreClone], Ut.prototype, "_meshGenerator", void 0), C([ignoreClone], Ut.prototype, "setting", void 0);
var Ht, jt = function() {
  function t(t2, e2) {
    this.assets = {}, this.errors = {}, this.toLoad = 0, this.loaded = 0, this.rawDataUris = {}, this.pathPrefix = t2 || "", this.textureLoader = e2;
  }
  var e = t.prototype;
  return e.downloadText = function(t2, e2, r) {
    request(t2, { type: "text" }).then(function(t3) {
      e2(t3);
    }).catch(function(t3) {
      r(t3);
    });
  }, e.downloadBinary = function(t2, e2, r) {
    var n = new XMLHttpRequest();
    this.rawDataUris[t2] && (t2 = this.rawDataUris[t2]), n.open("GET", t2, true), n.responseType = "arraybuffer", n.onload = function() {
      200 == n.status ? e2(new Uint8Array(n.response)) : r(n.status, n.responseText);
    }, n.onerror = function() {
      r(n.status, n.responseText);
    }, n.send();
  }, e.setRawDataURI = function(t2, e2) {
    this.rawDataUris[this.pathPrefix + t2] = e2;
  }, e.loadBinary = function(t2, e2, r) {
    void 0 === e2 && (e2 = null), void 0 === r && (r = null);
    var n = this;
    t2 = this.pathPrefix + t2, this.toLoad++, this.downloadBinary(t2, function(r2) {
      n.assets[t2] = r2, e2 && e2(t2, r2), n.onLoad(), n.loaded++;
    }, function(e3, a) {
      n.errors[t2] = "Couldn't load binary " + t2 + ": status " + status + ", " + a, r && r("Couldn't load binary " + t2 + ": status " + status + ", " + a), n.onLoad(), n.loaded++;
    });
  }, e.loadText = function(t2, e2, r) {
    void 0 === e2 && (e2 = null), void 0 === r && (r = null);
    var n = this;
    t2 = this.pathPrefix + t2, this.toLoad++, this.downloadText(t2, function(r2) {
      n.assets[t2] = r2, e2 && e2(t2, r2), n.onLoad(), n.loaded++;
    }, function(e3) {
      n.errors[t2] = "Couldn't load text " + t2 + ": " + JSON.stringify(e3), r && r("Couldn't load text " + t2 + ": " + JSON.stringify(e3)), n.onLoad(), n.loaded++;
    });
  }, e.loadImage = function(t2, e2, r) {
    void 0 === e2 && (e2 = null), void 0 === r && (r = null);
    var n = this, a = t2 = this.pathPrefix + t2;
    this.toLoad++;
    var i = new Image();
    i.crossOrigin = "anonymous", i.onload = function(r2) {
      n.assets[a] = i, n.onLoad(), n.loaded++, e2 && e2(t2, i);
    }, i.onerror = function(e3) {
      n.errors[t2] = "Couldn't load image " + t2, n.onLoad(), n.loaded++, r && r("Couldn't load image " + t2);
    }, this.rawDataUris[t2] && (t2 = this.rawDataUris[t2]), i.src = t2;
  }, e.loadTexture = function(t2, e2, r) {
    void 0 === e2 && (e2 = null), void 0 === r && (r = null);
    var n = this, a = t2 = this.pathPrefix + t2;
    this.toLoad++, this.rawDataUris[t2] && (t2 = this.rawDataUris[t2]), request(t2, { type: "image" }).then(function(r2) {
      var i = n.textureLoader(r2);
      n.assets[a] = i, n.onLoad(), n.loaded++, e2 && e2(t2, i);
    }).catch(function(t3) {
      r(t3);
    });
  }, e.loadTextureAtlas = function(t2, e2, r) {
    void 0 === e2 && (e2 = null), void 0 === r && (r = null);
    var n = this, a = t2.lastIndexOf("/") >= 0 ? t2.substring(0, t2.lastIndexOf("/")) : "";
    t2 = this.pathPrefix + t2, this.toLoad++, this.downloadText(t2, function(i) {
      var s = function() {
        var s2 = u.value, l2 = false;
        n.loadTexture(s2, function(s3, u2) {
          if (o.count++, o.count == h.length)
            if (l2)
              n.errors[t2] = "Couldn't load texture atlas page " + s3 + "} of atlas " + t2, r && r("Couldn't load texture atlas page " + s3 + " of atlas " + t2), n.onLoad(), n.loaded++;
            else
              try {
                var c2 = new ot(i, function(t3) {
                  return n.get("" == a ? t3 : a + "/" + t3);
                });
                n.assets[t2] = c2, e2 && e2(t2, c2), n.onLoad(), n.loaded++;
              } catch (e3) {
                var d = e3;
                n.errors[t2] = "Couldn't load texture atlas " + t2 + ": " + d.message, r && r("Couldn't load texture atlas " + t2 + ": " + d.message), n.onLoad(), n.loaded++;
              }
        }, function(e3) {
          l2 = true, o.count++, o.count == h.length && (n.errors[t2] = "Couldn't load texture atlas page " + e3 + "} of atlas " + t2, r && r("Couldn't load texture atlas page " + e3 + " of atlas " + t2), n.onLoad(), n.loaded++);
        });
      }, o = { count: 0 }, h = new Array();
      try {
        new ot(i, function(t3) {
          h.push("" == a ? t3 : a + "/" + t3);
          var e3 = document.createElement("img");
          return e3.width = 16, e3.height = 16, new st(e3);
        });
      } catch (e3) {
        var l = e3;
        return n.errors[t2] = "Couldn't load texture atlas " + t2 + ": " + l.message, r && r("Couldn't load texture atlas " + t2 + ": " + l.message), n.onLoad(), void n.loaded++;
      }
      for (var u, c = qt(h); !(u = c()).done; )
        s();
    }, function(e3) {
      n.errors[t2] = "Couldn't load texture atlas " + t2 + ": " + JSON.stringify(e3), r && r("Couldn't load texture atlas " + t2 + ": " + JSON.stringify(e3)), n.onLoad(), n.loaded++;
    });
  }, e.get = function(t2) {
    return t2 = this.pathPrefix + t2, this.assets[t2];
  }, e.remove = function(t2) {
    t2 = this.pathPrefix + t2;
    var e2 = this.assets[t2];
    e2.dispose && e2.dispose(), this.assets[t2] = null;
  }, e.removeAll = function() {
    for (var t2 in this.assets) {
      var e2 = this.assets[t2];
      e2.dispose && e2.dispose();
    }
    this.assets = {};
  }, e.isLoadingComplete = function() {
    return 0 == this.toLoad;
  }, e.onLoad = function() {
    this.toLoad--, 0 === this.toLoad && this.onLoadComplete();
  }, e.getToLoad = function() {
    return this.toLoad;
  }, e.getLoaded = function() {
    return this.loaded;
  }, e.dispose = function() {
    this.removeAll();
  }, e.hasErrors = function() {
    return Object.keys(this.errors).length > 0;
  }, e.getErrors = function() {
    return this.errors;
  }, t;
}(), Gt = function(t) {
  function e(e2) {
    var r;
    return (r = t.call(this, e2) || this).color = new P(1, 1, 1, 1), r;
  }
  return R(e, t), e.prototype.copy = function() {
    var t2 = new e(this.name);
    return this.copyTo(t2), t2.color.setFromColor(this.color), t2;
  }, e;
}(Z), zt = function(t) {
  function e(e2) {
    var r2;
    return (r2 = t.call(this, e2) || this).color = new P(0.38, 0.94, 0, 1), r2.name = e2, r2;
  }
  R(e, t);
  var r = e.prototype;
  return r.computeWorldPosition = function(t2, e2) {
    return e2.x = this.x * t2.a + this.y * t2.b + t2.worldX, e2.y = this.x * t2.c + this.y * t2.d + t2.worldY, e2;
  }, r.computeWorldRotation = function(t2) {
    var e2 = _.cosDeg(this.rotation), r2 = _.sinDeg(this.rotation), n = e2 * t2.a + r2 * t2.b, a = e2 * t2.c + r2 * t2.d;
    return Math.atan2(a, n) * _.radDeg;
  }, r.copy = function() {
    var t2 = new e(this.name);
    return t2.x = this.x, t2.y = this.y, t2.rotation = this.rotation, t2.color.setFromColor(this.color), t2;
  }, e;
}(Z), Zt = function() {
  function t(t2) {
    this.atlas = t2;
  }
  var e = t.prototype;
  return e.newRegionAttachment = function(t2, e2, r) {
    var n = this.atlas.findRegion(r);
    if (null == n)
      throw new Error("Region not found in atlas: " + r + " (region attachment: " + e2 + ")");
    n.renderObject = n;
    var a = new K(e2);
    return a.setRegion(n), a;
  }, e.newMeshAttachment = function(t2, e2, r) {
    var n = this.atlas.findRegion(r);
    if (null == n)
      throw new Error("Region not found in atlas: " + r + " (mesh attachment: " + e2 + ")");
    n.renderObject = n;
    var a = new ct(e2);
    return a.region = n, a;
  }, e.newBoundingBoxAttachment = function(t2, e2) {
    return new Gt(e2);
  }, e.newPathAttachment = function(t2, e2) {
    return new Q(e2);
  }, e.newPointAttachment = function(t2, e2) {
    return new zt(e2);
  }, e.newClippingAttachment = function(t2, e2) {
    return new Ot(e2);
  }, t;
}(), Qt = function() {
  function t() {
    this.bones = new Array(), this.slots = new Array(), this.skins = new Array(), this.events = new Array(), this.animations = new Array(), this.ikConstraints = new Array(), this.transformConstraints = new Array(), this.pathConstraints = new Array(), this.fps = 0;
  }
  var e = t.prototype;
  return e.findBone = function(t2) {
    if (null == t2)
      throw new Error("boneName cannot be null.");
    for (var e2 = this.bones, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.name == t2)
        return a;
    }
    return null;
  }, e.findBoneIndex = function(t2) {
    if (null == t2)
      throw new Error("boneName cannot be null.");
    for (var e2 = this.bones, r = 0, n = e2.length; r < n; r++)
      if (e2[r].name == t2)
        return r;
    return -1;
  }, e.findSlot = function(t2) {
    if (null == t2)
      throw new Error("slotName cannot be null.");
    for (var e2 = this.slots, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.name == t2)
        return a;
    }
    return null;
  }, e.findSlotIndex = function(t2) {
    if (null == t2)
      throw new Error("slotName cannot be null.");
    for (var e2 = this.slots, r = 0, n = e2.length; r < n; r++)
      if (e2[r].name == t2)
        return r;
    return -1;
  }, e.findSkin = function(t2) {
    if (null == t2)
      throw new Error("skinName cannot be null.");
    for (var e2 = this.skins, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.name == t2)
        return a;
    }
    return null;
  }, e.findEvent = function(t2) {
    if (null == t2)
      throw new Error("eventDataName cannot be null.");
    for (var e2 = this.events, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.name == t2)
        return a;
    }
    return null;
  }, e.findAnimation = function(t2) {
    if (null == t2)
      throw new Error("animationName cannot be null.");
    for (var e2 = this.animations, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.name == t2)
        return a;
    }
    return null;
  }, e.findIkConstraint = function(t2) {
    if (null == t2)
      throw new Error("constraintName cannot be null.");
    for (var e2 = this.ikConstraints, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.name == t2)
        return a;
    }
    return null;
  }, e.findTransformConstraint = function(t2) {
    if (null == t2)
      throw new Error("constraintName cannot be null.");
    for (var e2 = this.transformConstraints, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.name == t2)
        return a;
    }
    return null;
  }, e.findPathConstraint = function(t2) {
    if (null == t2)
      throw new Error("constraintName cannot be null.");
    for (var e2 = this.pathConstraints, r = 0, n = e2.length; r < n; r++) {
      var a = e2[r];
      if (a.name == t2)
        return a;
    }
    return null;
  }, e.findPathConstraintIndex = function(t2) {
    if (null == t2)
      throw new Error("pathConstraintName cannot be null.");
    for (var e2 = this.pathConstraints, r = 0, n = e2.length; r < n; r++)
      if (e2[r].name == t2)
        return r;
    return -1;
  }, t;
}(), Jt = function(t, e, r) {
  if (this.color = new P(1, 1, 1, 1), t < 0)
    throw new Error("index must be >= 0.");
  if (null == e)
    throw new Error("name cannot be null.");
  if (null == r)
    throw new Error("boneData cannot be null.");
  this.index = t, this.name = e, this.boneData = r;
}, Kt = function(t) {
  function e(e2) {
    var r;
    return (r = t.call(this, e2, 0, false) || this).bones = new Array(), r.bendDirection = 1, r.compress = false, r.stretch = false, r.uniform = false, r.mix = 1, r.softness = 0, r;
  }
  return R(e, t), e;
}(j), $t = function(t) {
  function e(e2) {
    var r;
    return (r = t.call(this, e2, 0, false) || this).bones = new Array(), r.rotateMix = 0, r.translateMix = 0, r.scaleMix = 0, r.shearMix = 0, r.offsetRotation = 0, r.offsetX = 0, r.offsetY = 0, r.offsetScaleX = 0, r.offsetScaleY = 0, r.offsetShearY = 0, r.relative = false, r.local = false, r;
  }
  return R(e, t), e;
}(j), te = function(t, e, r) {
  this.slotIndex = t, this.name = e, this.attachment = r;
}, ee = function() {
  function t(t2) {
    if (this.attachments = new Array(), this.bones = Array(), this.constraints = new Array(), null == t2)
      throw new Error("name cannot be null.");
    this.name = t2;
  }
  var e = t.prototype;
  return e.setAttachment = function(t2, e2, r) {
    if (null == r)
      throw new Error("attachment cannot be null.");
    var n = this.attachments;
    t2 >= n.length && (n.length = t2 + 1), n[t2] || (n[t2] = {}), n[t2][e2] = r;
  }, e.addSkin = function(t2) {
    for (var e2 = 0; e2 < t2.bones.length; e2++) {
      for (var r = t2.bones[e2], n = false, a = 0; a < this.bones.length; a++)
        if (this.bones[a] == r) {
          n = true;
          break;
        }
      n || this.bones.push(r);
    }
    for (var i = 0; i < t2.constraints.length; i++) {
      for (var s = t2.constraints[i], o = false, h = 0; h < this.constraints.length; h++)
        if (this.constraints[h] == s) {
          o = true;
          break;
        }
      o || this.constraints.push(s);
    }
    for (var l = t2.getAttachments(), u = 0; u < l.length; u++) {
      var c = l[u];
      this.setAttachment(c.slotIndex, c.name, c.attachment);
    }
  }, e.copySkin = function(t2) {
    for (var e2 = 0; e2 < t2.bones.length; e2++) {
      for (var r = t2.bones[e2], n = false, a = 0; a < this.bones.length; a++)
        if (this.bones[a] == r) {
          n = true;
          break;
        }
      n || this.bones.push(r);
    }
    for (var i = 0; i < t2.constraints.length; i++) {
      for (var s = t2.constraints[i], o = false, h = 0; h < this.constraints.length; h++)
        if (this.constraints[h] == s) {
          o = true;
          break;
        }
      o || this.constraints.push(s);
    }
    for (var l = t2.getAttachments(), u = 0; u < l.length; u++) {
      var c = l[u];
      null != c.attachment && (k(c.attachment, ct) ? (c.attachment = c.attachment.newLinkedMesh(), this.setAttachment(c.slotIndex, c.name, c.attachment)) : (c.attachment = c.attachment.copy(), this.setAttachment(c.slotIndex, c.name, c.attachment)));
    }
  }, e.getAttachment = function(t2, e2) {
    var r = this.attachments[t2];
    return r ? r[e2] : null;
  }, e.removeAttachment = function(t2, e2) {
    var r = this.attachments[t2];
    r && (r[e2] = null);
  }, e.getAttachments = function() {
    for (var t2 = new Array(), e2 = 0; e2 < this.attachments.length; e2++) {
      var r = this.attachments[e2];
      if (r)
        for (var n in r) {
          var a = r[n];
          a && t2.push(new te(e2, n, a));
        }
    }
    return t2;
  }, e.getAttachmentsForSlot = function(t2, e2) {
    var r = this.attachments[t2];
    if (r)
      for (var n in r) {
        var a = r[n];
        a && e2.push(new te(t2, n, a));
      }
  }, e.clear = function() {
    this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0;
  }, e.attachAll = function(t2, e2) {
    for (var r = 0, n = 0; n < t2.slots.length; n++) {
      var a = t2.slots[n], i = a.getAttachment();
      if (i && r < e2.attachments.length) {
        var s = e2.attachments[r];
        for (var o in s) {
          if (i == s[o]) {
            var h = this.getAttachment(r, o);
            null != h && a.setAttachment(h);
            break;
          }
        }
      }
      r++;
    }
  }, t;
}(), re = function(t) {
  this.name = t;
};
!function(t) {
  t[t.Normal = 0] = "Normal", t[t.Additive = 1] = "Additive", t[t.Multiply = 2] = "Multiply", t[t.Screen = 3] = "Screen";
}(Ht || (Ht = {}));
var ne, ae = function(t, e) {
  if (null == e)
    throw new Error("data cannot be null.");
  this.time = t, this.data = e;
}, ie = function() {
  function t(t2) {
    this.scale = 1, this.linkedMeshes = new Array(), this.attachmentLoader = t2;
  }
  var e = t.prototype;
  return e.readSkeletonData = function(e2) {
    var r = this.scale, n = new Qt(), a = "string" == typeof e2 ? JSON.parse(e2) : e2, i = a.skeleton;
    if (null != i) {
      if (n.hash = i.hash, n.version = i.spine, "3.8.75" == n.version)
        throw new Error("Unsupported skeleton data, please export with a newer version of Spine.");
      n.x = i.x, n.y = i.y, n.width = i.width, n.height = i.height, n.fps = i.fps, n.imagesPath = i.images;
    }
    if (a.bones)
      for (var s = 0; s < a.bones.length; s++) {
        var o = a.bones[s], h = null, l = this.getValue(o, "parent", null);
        if (null != l && null == (h = n.findBone(l)))
          throw new Error("Parent bone not found: " + l);
        var u = new X(n.bones.length, o.name, h);
        u.length = this.getValue(o, "length", 0) * r, u.x = this.getValue(o, "x", 0) * r, u.y = this.getValue(o, "y", 0) * r, u.rotation = this.getValue(o, "rotation", 0), u.scaleX = this.getValue(o, "scaleX", 1), u.scaleY = this.getValue(o, "scaleY", 1), u.shearX = this.getValue(o, "shearX", 0), u.shearY = this.getValue(o, "shearY", 0), u.transformMode = t.transformModeFromString(this.getValue(o, "transform", "normal")), u.skinRequired = this.getValue(o, "skin", false), n.bones.push(u);
      }
    if (a.slots)
      for (var c = 0; c < a.slots.length; c++) {
        var d = a.slots[c], f = d.name, v = d.bone, p = n.findBone(v);
        if (null == p)
          throw new Error("Slot bone not found: " + v);
        var g = new Jt(n.slots.length, f, p), m = this.getValue(d, "color", null);
        null != m && g.color.setFromString(m);
        var w = this.getValue(d, "dark", null);
        null != w && (g.darkColor = new P(1, 1, 1, 1), g.darkColor.setFromString(w)), g.attachmentName = this.getValue(d, "attachment", null), g.blendMode = t.blendModeFromString(this.getValue(d, "blend", "normal")), n.slots.push(g);
      }
    if (a.ik)
      for (var E = 0; E < a.ik.length; E++) {
        var x = a.ik[E], y = new Kt(x.name);
        y.order = this.getValue(x, "order", 0), y.skinRequired = this.getValue(x, "skin", false);
        for (var b = 0; b < x.bones.length; b++) {
          var S = x.bones[b], M2 = n.findBone(S);
          if (null == M2)
            throw new Error("IK bone not found: " + S);
          y.bones.push(M2);
        }
        var A2 = x.target;
        if (y.target = n.findBone(A2), null == y.target)
          throw new Error("IK target bone not found: " + A2);
        y.mix = this.getValue(x, "mix", 1), y.softness = this.getValue(x, "softness", 0) * r, y.bendDirection = this.getValue(x, "bendPositive", true) ? 1 : -1, y.compress = this.getValue(x, "compress", false), y.stretch = this.getValue(x, "stretch", false), y.uniform = this.getValue(x, "uniform", false), n.ikConstraints.push(y);
      }
    if (a.transform)
      for (var T2 = 0; T2 < a.transform.length; T2++) {
        var I2 = a.transform[T2], R2 = new $t(I2.name);
        R2.order = this.getValue(I2, "order", 0), R2.skinRequired = this.getValue(I2, "skin", false);
        for (var C2 = 0; C2 < I2.bones.length; C2++) {
          var k2 = I2.bones[C2], V2 = n.findBone(k2);
          if (null == V2)
            throw new Error("Transform constraint bone not found: " + k2);
          R2.bones.push(V2);
        }
        var _2 = I2.target;
        if (R2.target = n.findBone(_2), null == R2.target)
          throw new Error("Transform constraint target bone not found: " + _2);
        R2.local = this.getValue(I2, "local", false), R2.relative = this.getValue(I2, "relative", false), R2.offsetRotation = this.getValue(I2, "rotation", 0), R2.offsetX = this.getValue(I2, "x", 0) * r, R2.offsetY = this.getValue(I2, "y", 0) * r, R2.offsetScaleX = this.getValue(I2, "scaleX", 0), R2.offsetScaleY = this.getValue(I2, "scaleY", 0), R2.offsetShearY = this.getValue(I2, "shearY", 0), R2.rotateMix = this.getValue(I2, "rotateMix", 1), R2.translateMix = this.getValue(I2, "translateMix", 1), R2.scaleMix = this.getValue(I2, "scaleMix", 1), R2.shearMix = this.getValue(I2, "shearMix", 1), n.transformConstraints.push(R2);
      }
    if (a.path)
      for (var F2 = 0; F2 < a.path.length; F2++) {
        var N2 = a.path[F2], O2 = new G(N2.name);
        O2.order = this.getValue(N2, "order", 0), O2.skinRequired = this.getValue(N2, "skin", false);
        for (var L2 = 0; L2 < N2.bones.length; L2++) {
          var Y2 = N2.bones[L2], U2 = n.findBone(Y2);
          if (null == U2)
            throw new Error("Transform constraint bone not found: " + Y2);
          O2.bones.push(U2);
        }
        var W2 = N2.target;
        if (O2.target = n.findSlot(W2), null == O2.target)
          throw new Error("Path target slot not found: " + W2);
        O2.positionMode = t.positionModeFromString(this.getValue(N2, "positionMode", "percent")), O2.spacingMode = t.spacingModeFromString(this.getValue(N2, "spacingMode", "length")), O2.rotateMode = t.rotateModeFromString(this.getValue(N2, "rotateMode", "tangent")), O2.offsetRotation = this.getValue(N2, "rotation", 0), O2.position = this.getValue(N2, "position", 0), O2.positionMode == B.Fixed && (O2.position *= r), O2.spacing = this.getValue(N2, "spacing", 0), O2.spacingMode != D.Length && O2.spacingMode != D.Fixed || (O2.spacing *= r), O2.rotateMix = this.getValue(N2, "rotateMix", 1), O2.translateMix = this.getValue(N2, "translateMix", 1), n.pathConstraints.push(O2);
      }
    if (a.skins)
      for (var q2 = 0; q2 < a.skins.length; q2++) {
        var H2 = a.skins[q2], j2 = new ee(H2.name);
        if (H2.bones)
          for (var z2 = 0; z2 < H2.bones.length; z2++) {
            var Z2 = n.findBone(H2.bones[z2]);
            if (null == Z2)
              throw new Error("Skin bone not found: " + H2.bones[q2]);
            j2.bones.push(Z2);
          }
        if (H2.ik)
          for (var Q2 = 0; Q2 < H2.ik.length; Q2++) {
            var J2 = n.findIkConstraint(H2.ik[Q2]);
            if (null == J2)
              throw new Error("Skin IK constraint not found: " + H2.ik[q2]);
            j2.constraints.push(J2);
          }
        if (H2.transform)
          for (var K2 = 0; K2 < H2.transform.length; K2++) {
            var $2 = n.findTransformConstraint(H2.transform[K2]);
            if (null == $2)
              throw new Error("Skin transform constraint not found: " + H2.transform[q2]);
            j2.constraints.push($2);
          }
        if (H2.path)
          for (var tt2 = 0; tt2 < H2.path.length; tt2++) {
            var et2 = n.findPathConstraint(H2.path[tt2]);
            if (null == et2)
              throw new Error("Skin path constraint not found: " + H2.path[q2]);
            j2.constraints.push(et2);
          }
        for (var rt2 in H2.attachments) {
          var nt2 = n.findSlot(rt2);
          if (null == nt2)
            throw new Error("Slot not found: " + rt2);
          var at2 = H2.attachments[rt2];
          for (var it2 in at2) {
            var st2 = this.readAttachment(at2[it2], j2, nt2.index, it2, n);
            null != st2 && j2.setAttachment(nt2.index, it2, st2);
          }
        }
        n.skins.push(j2), "default" == j2.name && (n.defaultSkin = j2);
      }
    for (var ot2 = 0, ht2 = this.linkedMeshes.length; ot2 < ht2; ot2++) {
      var lt2 = this.linkedMeshes[ot2], ut2 = null == lt2.skin ? n.defaultSkin : n.findSkin(lt2.skin);
      if (null == ut2)
        throw new Error("Skin not found: " + lt2.skin);
      var ct2 = ut2.getAttachment(lt2.slotIndex, lt2.parent);
      if (null == ct2)
        throw new Error("Parent mesh not found: " + lt2.parent);
      lt2.mesh.deformAttachment = lt2.inheritDeform ? ct2 : lt2.mesh, lt2.mesh.setParentMesh(ct2), lt2.mesh.updateUVs();
    }
    if (this.linkedMeshes.length = 0, a.events)
      for (var dt2 in a.events) {
        var ft2 = a.events[dt2], vt2 = new re(dt2);
        vt2.intValue = this.getValue(ft2, "int", 0), vt2.floatValue = this.getValue(ft2, "float", 0), vt2.stringValue = this.getValue(ft2, "string", ""), vt2.audioPath = this.getValue(ft2, "audio", null), null != vt2.audioPath && (vt2.volume = this.getValue(ft2, "volume", 1), vt2.balance = this.getValue(ft2, "balance", 0)), n.events.push(vt2);
      }
    if (a.animations)
      for (var pt2 in a.animations) {
        var gt2 = a.animations[pt2];
        this.readAnimation(gt2, pt2, n);
      }
    return n;
  }, e.readAttachment = function(t2, e2, r, n, a) {
    var i = this.scale;
    switch (n = this.getValue(t2, "name", n), this.getValue(t2, "type", "region")) {
      case "region":
        var s = this.getValue(t2, "path", n), o = this.attachmentLoader.newRegionAttachment(e2, n, s);
        if (null == o)
          return null;
        o.path = s, o.x = this.getValue(t2, "x", 0) * i, o.y = this.getValue(t2, "y", 0) * i, o.scaleX = this.getValue(t2, "scaleX", 1), o.scaleY = this.getValue(t2, "scaleY", 1), o.rotation = this.getValue(t2, "rotation", 0), o.width = t2.width * i, o.height = t2.height * i;
        var h = this.getValue(t2, "color", null);
        return null != h && o.color.setFromString(h), o.updateOffset(), o;
      case "boundingbox":
        var l = this.attachmentLoader.newBoundingBoxAttachment(e2, n);
        if (null == l)
          return null;
        this.readVertices(t2, l, t2.vertexCount << 1);
        var u = this.getValue(t2, "color", null);
        return null != u && l.color.setFromString(u), l;
      case "mesh":
      case "linkedmesh":
        var c = this.getValue(t2, "path", n), d = this.attachmentLoader.newMeshAttachment(e2, n, c);
        if (null == d)
          return null;
        d.path = c;
        var f = this.getValue(t2, "color", null);
        null != f && d.color.setFromString(f), d.width = this.getValue(t2, "width", 0) * i, d.height = this.getValue(t2, "height", 0) * i;
        var v = this.getValue(t2, "parent", null);
        if (null != v)
          return this.linkedMeshes.push(new se(d, this.getValue(t2, "skin", null), r, v, this.getValue(t2, "deform", true))), d;
        var p = t2.uvs;
        return this.readVertices(t2, d, p.length), d.triangles = t2.triangles, d.regionUVs = p, d.updateUVs(), d.edges = this.getValue(t2, "edges", null), d.hullLength = 2 * this.getValue(t2, "hull", 0), d;
      case "path":
        var g = this.attachmentLoader.newPathAttachment(e2, n);
        if (null == g)
          return null;
        g.closed = this.getValue(t2, "closed", false), g.constantSpeed = this.getValue(t2, "constantSpeed", true);
        var m = t2.vertexCount;
        this.readVertices(t2, g, m << 1);
        for (var w = F.newArray(m / 3, 0), E = 0; E < t2.lengths.length; E++)
          w[E] = t2.lengths[E] * i;
        g.lengths = w;
        var x = this.getValue(t2, "color", null);
        return null != x && g.color.setFromString(x), g;
      case "point":
        var y = this.attachmentLoader.newPointAttachment(e2, n);
        if (null == y)
          return null;
        y.x = this.getValue(t2, "x", 0) * i, y.y = this.getValue(t2, "y", 0) * i, y.rotation = this.getValue(t2, "rotation", 0);
        var b = this.getValue(t2, "color", null);
        return null != b && y.color.setFromString(b), y;
      case "clipping":
        var S = this.attachmentLoader.newClippingAttachment(e2, n);
        if (null == S)
          return null;
        var M2 = this.getValue(t2, "end", null);
        if (null != M2) {
          var A2 = a.findSlot(M2);
          if (null == A2)
            throw new Error("Clipping end slot not found: " + M2);
          S.endSlot = A2;
        }
        var T2 = t2.vertexCount;
        this.readVertices(t2, S, T2 << 1);
        var I2 = this.getValue(t2, "color", null);
        return null != I2 && S.color.setFromString(I2), S;
    }
    return null;
  }, e.readVertices = function(t2, e2, r) {
    var n = this.scale;
    e2.worldVerticesLength = r;
    var a = t2.vertices;
    if (r != a.length) {
      for (var i = new Array(), s = new Array(), o = 0, h = a.length; o < h; ) {
        var l = a[o++];
        s.push(l);
        for (var u = o + 4 * l; o < u; o += 4)
          s.push(a[o]), i.push(a[o + 1] * n), i.push(a[o + 2] * n), i.push(a[o + 3]);
      }
      e2.bones = s, e2.vertices = F.toFloatArray(i);
    } else {
      var c = F.toFloatArray(a);
      if (1 != n)
        for (var d = 0, f = a.length; d < f; d++)
          c[d] *= n;
      e2.vertices = c;
    }
  }, e.readAnimation = function(t2, e2, r) {
    var n = this.scale, a = new Array(), i = 0;
    if (t2.slots)
      for (var s in t2.slots) {
        var o = t2.slots[s], h = r.findSlotIndex(s);
        if (-1 == h)
          throw new Error("Slot not found: " + s);
        for (var l in o) {
          var u = o[l];
          if ("attachment" == l) {
            var c = new yt(u.length);
            c.slotIndex = h;
            for (var d = 0, f = 0; f < u.length; f++) {
              var v = u[f];
              c.setFrame(d++, this.getValue(v, "time", 0), v.name);
            }
            a.push(c), i = Math.max(i, c.frames[c.getFrameCount() - 1]);
          } else if ("color" == l) {
            var p = new Et(u.length);
            p.slotIndex = h;
            for (var g = 0, m = 0; m < u.length; m++) {
              var w = u[m], E = new P();
              E.setFromString(w.color), p.setFrame(g, this.getValue(w, "time", 0), E.r, E.g, E.b, E.a), this.readCurve(w, p, g), g++;
            }
            a.push(p), i = Math.max(i, p.frames[(p.getFrameCount() - 1) * Et.ENTRIES]);
          } else {
            if ("twoColor" != l)
              throw new Error("Invalid timeline type for a slot: " + l + " (" + s + ")");
            var x = new xt(u.length);
            x.slotIndex = h;
            for (var y = 0, b = 0; b < u.length; b++) {
              var S = u[b], M2 = new P(), A2 = new P();
              M2.setFromString(S.light), A2.setFromString(S.dark), x.setFrame(y, this.getValue(S, "time", 0), M2.r, M2.g, M2.b, M2.a, A2.r, A2.g, A2.b), this.readCurve(S, x, y), y++;
            }
            a.push(x), i = Math.max(i, x.frames[(x.getFrameCount() - 1) * xt.ENTRIES]);
          }
        }
      }
    if (t2.bones)
      for (var T2 in t2.bones) {
        var I2 = t2.bones[T2], R2 = r.findBoneIndex(T2);
        if (-1 == R2)
          throw new Error("Bone not found: " + T2);
        for (var C2 in I2) {
          var k2 = I2[C2];
          if ("rotate" === C2) {
            var V2 = new pt(k2.length);
            V2.boneIndex = R2;
            for (var _2 = 0, N2 = 0; N2 < k2.length; N2++) {
              var O2 = k2[N2];
              V2.setFrame(_2, this.getValue(O2, "time", 0), this.getValue(O2, "angle", 0)), this.readCurve(O2, V2, _2), _2++;
            }
            a.push(V2), i = Math.max(i, V2.frames[(V2.getFrameCount() - 1) * pt.ENTRIES]);
          } else {
            if ("translate" !== C2 && "scale" !== C2 && "shear" !== C2)
              throw new Error("Invalid timeline type for a bone: " + C2 + " (" + T2 + ")");
            var L2 = null, X2 = 1, Y2 = 0;
            "scale" === C2 ? (L2 = new mt(k2.length), Y2 = 1) : "shear" === C2 ? L2 = new wt(k2.length) : (L2 = new gt(k2.length), X2 = n), L2.boneIndex = R2;
            for (var U2 = 0, W2 = 0; W2 < k2.length; W2++) {
              var q2 = k2[W2], H2 = this.getValue(q2, "x", Y2), j2 = this.getValue(q2, "y", Y2);
              L2.setFrame(U2, this.getValue(q2, "time", 0), H2 * X2, j2 * X2), this.readCurve(q2, L2, U2), U2++;
            }
            a.push(L2), i = Math.max(i, L2.frames[(L2.getFrameCount() - 1) * gt.ENTRIES]);
          }
        }
      }
    if (t2.ik)
      for (var G2 in t2.ik) {
        var z2 = t2.ik[G2], Z2 = r.findIkConstraint(G2), Q2 = new Tt(z2.length);
        Q2.ikConstraintIndex = r.ikConstraints.indexOf(Z2);
        for (var J2 = 0, K2 = 0; K2 < z2.length; K2++) {
          var $2 = z2[K2];
          Q2.setFrame(J2, this.getValue($2, "time", 0), this.getValue($2, "mix", 1), this.getValue($2, "softness", 0) * n, this.getValue($2, "bendPositive", true) ? 1 : -1, this.getValue($2, "compress", false), this.getValue($2, "stretch", false)), this.readCurve($2, Q2, J2), J2++;
        }
        a.push(Q2), i = Math.max(i, Q2.frames[(Q2.getFrameCount() - 1) * Tt.ENTRIES]);
      }
    if (t2.transform)
      for (var tt2 in t2.transform) {
        var et2 = t2.transform[tt2], rt2 = r.findTransformConstraint(tt2), nt2 = new It(et2.length);
        nt2.transformConstraintIndex = r.transformConstraints.indexOf(rt2);
        for (var at2 = 0, it2 = 0; it2 < et2.length; it2++) {
          var st2 = et2[it2];
          nt2.setFrame(at2, this.getValue(st2, "time", 0), this.getValue(st2, "rotateMix", 1), this.getValue(st2, "translateMix", 1), this.getValue(st2, "scaleMix", 1), this.getValue(st2, "shearMix", 1)), this.readCurve(st2, nt2, at2), at2++;
        }
        a.push(nt2), i = Math.max(i, nt2.frames[(nt2.getFrameCount() - 1) * It.ENTRIES]);
      }
    if (t2.path)
      for (var ot2 in t2.path) {
        var ht2 = t2.path[ot2], lt2 = r.findPathConstraintIndex(ot2);
        if (-1 == lt2)
          throw new Error("Path constraint not found: " + ot2);
        var ut2 = r.pathConstraints[lt2];
        for (var ct2 in ht2) {
          var dt2 = ht2[ct2];
          if ("position" === ct2 || "spacing" === ct2) {
            var vt2 = null, bt2 = 1;
            "spacing" === ct2 ? (vt2 = new Ct(dt2.length), ut2.spacingMode != D.Length && ut2.spacingMode != D.Fixed || (bt2 = n)) : (vt2 = new Rt(dt2.length), ut2.positionMode == B.Fixed && (bt2 = n)), vt2.pathConstraintIndex = lt2;
            for (var Vt2 = 0, Pt2 = 0; Pt2 < dt2.length; Pt2++) {
              var _t2 = dt2[Pt2];
              vt2.setFrame(Vt2, this.getValue(_t2, "time", 0), this.getValue(_t2, ct2, 0) * bt2), this.readCurve(_t2, vt2, Vt2), Vt2++;
            }
            a.push(vt2), i = Math.max(i, vt2.frames[(vt2.getFrameCount() - 1) * Rt.ENTRIES]);
          } else if ("mix" === ct2) {
            var Ft2 = new kt(dt2.length);
            Ft2.pathConstraintIndex = lt2;
            for (var Nt2 = 0, Ot2 = 0; Ot2 < dt2.length; Ot2++) {
              var Lt2 = dt2[Ot2];
              Ft2.setFrame(Nt2, this.getValue(Lt2, "time", 0), this.getValue(Lt2, "rotateMix", 1), this.getValue(Lt2, "translateMix", 1)), this.readCurve(Lt2, Ft2, Nt2), Nt2++;
            }
            a.push(Ft2), i = Math.max(i, Ft2.frames[(Ft2.getFrameCount() - 1) * kt.ENTRIES]);
          }
        }
      }
    if (t2.deform)
      for (var Xt2 in t2.deform) {
        var Bt2 = t2.deform[Xt2], Dt2 = r.findSkin(Xt2);
        if (null == Dt2)
          throw new Error("Skin not found: " + Xt2);
        for (var Yt2 in Bt2) {
          var Ut2 = Bt2[Yt2], Wt2 = r.findSlotIndex(Yt2);
          if (-1 == Wt2)
            throw new Error("Slot not found: " + Ut2.name);
          for (var qt2 in Ut2) {
            var Ht2 = Ut2[qt2], jt2 = Dt2.getAttachment(Wt2, qt2);
            if (null == jt2)
              throw new Error("Deform attachment not found: " + Ht2.name);
            var Gt2 = null != jt2.bones, zt2 = jt2.vertices, Zt2 = Gt2 ? zt2.length / 3 * 2 : zt2.length, Qt2 = new St(Ht2.length);
            Qt2.slotIndex = Wt2, Qt2.attachment = jt2;
            for (var Jt2 = 0, Kt2 = 0; Kt2 < Ht2.length; Kt2++) {
              var $t2 = Ht2[Kt2], te2 = void 0, ee2 = this.getValue($t2, "vertices", null);
              if (null == ee2)
                te2 = Gt2 ? F.newFloatArray(Zt2) : zt2;
              else {
                te2 = F.newFloatArray(Zt2);
                var re2 = this.getValue($t2, "offset", 0);
                if (F.arrayCopy(ee2, 0, te2, re2, ee2.length), 1 != n)
                  for (var ne2 = re2, ie2 = ne2 + ee2.length; ne2 < ie2; ne2++)
                    te2[ne2] *= n;
                if (!Gt2)
                  for (var se2 = 0; se2 < Zt2; se2++)
                    te2[se2] += zt2[se2];
              }
              Qt2.setFrame(Jt2, this.getValue($t2, "time", 0), te2), this.readCurve($t2, Qt2, Jt2), Jt2++;
            }
            a.push(Qt2), i = Math.max(i, Qt2.frames[Qt2.getFrameCount() - 1]);
          }
        }
      }
    var oe2 = t2.drawOrder;
    if (null == oe2 && (oe2 = t2.draworder), null != oe2) {
      for (var he2 = new At(oe2.length), le2 = r.slots.length, ue2 = 0, ce2 = 0; ce2 < oe2.length; ce2++) {
        var de2 = oe2[ce2], fe2 = null, ve2 = this.getValue(de2, "offsets", null);
        if (null != ve2) {
          fe2 = F.newArray(le2, -1);
          for (var pe2 = F.newArray(le2 - ve2.length, 0), ge = 0, me = 0, we = 0; we < ve2.length; we++) {
            var Ee = ve2[we], xe = r.findSlotIndex(Ee.slot);
            if (-1 == xe)
              throw new Error("Slot not found: " + Ee.slot);
            for (; ge != xe; )
              pe2[me++] = ge++;
            fe2[ge + Ee.offset] = ge++;
          }
          for (; ge < le2; )
            pe2[me++] = ge++;
          for (var ye = le2 - 1; ye >= 0; ye--)
            -1 == fe2[ye] && (fe2[ye] = pe2[--me]);
        }
        he2.setFrame(ue2++, this.getValue(de2, "time", 0), fe2);
      }
      a.push(he2), i = Math.max(i, he2.frames[he2.getFrameCount() - 1]);
    }
    if (t2.events) {
      for (var be = new Mt(t2.events.length), Se = 0, Me = 0; Me < t2.events.length; Me++) {
        var Ae = t2.events[Me], Te = r.findEvent(Ae.name);
        if (null == Te)
          throw new Error("Event not found: " + Ae.name);
        var Ie = new ae(F.toSinglePrecision(this.getValue(Ae, "time", 0)), Te);
        Ie.intValue = this.getValue(Ae, "int", Te.intValue), Ie.floatValue = this.getValue(Ae, "float", Te.floatValue), Ie.stringValue = this.getValue(Ae, "string", Te.stringValue), null != Ie.data.audioPath && (Ie.volume = this.getValue(Ae, "volume", 1), Ie.balance = this.getValue(Ae, "balance", 0)), be.setFrame(Se++, Ie);
      }
      a.push(be), i = Math.max(i, be.frames[be.getFrameCount() - 1]);
    }
    if (isNaN(i))
      throw new Error("Error while parsing animation, duration is NaN");
    r.animations.push(new ft(e2, a, i));
  }, e.readCurve = function(t2, e2, r) {
    if (t2.hasOwnProperty("curve"))
      if ("stepped" == t2.curve)
        e2.setStepped(r);
      else {
        var n = t2.curve;
        e2.setCurve(r, n, this.getValue(t2, "c2", 0), this.getValue(t2, "c3", 1), this.getValue(t2, "c4", 1));
      }
  }, e.getValue = function(t2, e2, r) {
    return void 0 !== t2[e2] ? t2[e2] : r;
  }, t.blendModeFromString = function(t2) {
    if ("normal" == (t2 = t2.toLowerCase()))
      return Ht.Normal;
    if ("additive" == t2)
      return Ht.Additive;
    if ("multiply" == t2)
      return Ht.Multiply;
    if ("screen" == t2)
      return Ht.Screen;
    throw new Error("Unknown blend mode: " + t2);
  }, t.positionModeFromString = function(t2) {
    if ("fixed" == (t2 = t2.toLowerCase()))
      return B.Fixed;
    if ("percent" == t2)
      return B.Percent;
    throw new Error("Unknown position mode: " + t2);
  }, t.spacingModeFromString = function(t2) {
    if ("length" == (t2 = t2.toLowerCase()))
      return D.Length;
    if ("fixed" == t2)
      return D.Fixed;
    if ("percent" == t2)
      return D.Percent;
    throw new Error("Unknown position mode: " + t2);
  }, t.rotateModeFromString = function(t2) {
    if ("tangent" == (t2 = t2.toLowerCase()))
      return Y.Tangent;
    if ("chain" == t2)
      return Y.Chain;
    if ("chainscale" == t2)
      return Y.ChainScale;
    throw new Error("Unknown rotate mode: " + t2);
  }, t.transformModeFromString = function(t2) {
    if ("normal" == (t2 = t2.toLowerCase()))
      return N.Normal;
    if ("onlytranslation" == t2)
      return N.OnlyTranslation;
    if ("norotationorreflection" == t2)
      return N.NoRotationOrReflection;
    if ("noscale" == t2)
      return N.NoScale;
    if ("noscaleorreflection" == t2)
      return N.NoScaleOrReflection;
    throw new Error("Unknown transform mode: " + t2);
  }, t;
}(), se = function(t, e, r, n, a) {
  this.mesh = t, this.skin = e, this.slotIndex = r, this.parent = n, this.inheritDeform = a;
};
!function(t) {
  t[t.Region = 0] = "Region", t[t.BoundingBox = 1] = "BoundingBox", t[t.Mesh = 2] = "Mesh", t[t.LinkedMesh = 3] = "LinkedMesh", t[t.Path = 4] = "Path", t[t.Point = 5] = "Point", t[t.Clipping = 6] = "Clipping";
}(ne || (ne = {}));
var oe = function() {
  function t(t2) {
    this.scale = 1, this.linkedMeshes = new Array(), this.attachmentLoader = t2;
  }
  var e = t.prototype;
  return e.readSkeletonData = function(e2) {
    var r = this.scale, n = new Qt();
    n.name = "";
    var a = new he(e2);
    if (n.hash = a.readString(), n.version = a.readString(), "3.8.75" == n.version)
      throw new Error("Unsupported skeleton data, please export with a newer version of Spine.");
    n.x = a.readFloat(), n.y = a.readFloat(), n.width = a.readFloat(), n.height = a.readFloat();
    var i = a.readBoolean();
    i && (n.fps = a.readFloat(), n.imagesPath = a.readString(), n.audioPath = a.readString());
    var s = 0;
    s = a.readInt(true);
    for (var o = 0; o < s; o++)
      a.strings.push(a.readString());
    s = a.readInt(true);
    for (var h = 0; h < s; h++) {
      var l = a.readString(), u = 0 == h ? null : n.bones[a.readInt(true)], c = new X(h, l, u);
      c.rotation = a.readFloat(), c.x = a.readFloat() * r, c.y = a.readFloat() * r, c.scaleX = a.readFloat(), c.scaleY = a.readFloat(), c.shearX = a.readFloat(), c.shearY = a.readFloat(), c.length = a.readFloat() * r, c.transformMode = t.TransformModeValues[a.readInt(true)], c.skinRequired = a.readBoolean(), i && P.rgba8888ToColor(c.color, a.readInt32()), n.bones.push(c);
    }
    s = a.readInt(true);
    for (var d = 0; d < s; d++) {
      var f = a.readString(), v = n.bones[a.readInt(true)], p = new Jt(d, f, v);
      P.rgba8888ToColor(p.color, a.readInt32());
      var g = a.readInt32();
      -1 != g && P.rgb888ToColor(p.darkColor = new P(), g), p.attachmentName = a.readStringRef(), p.blendMode = t.BlendModeValues[a.readInt(true)], n.slots.push(p);
    }
    s = a.readInt(true);
    for (var m, w = 0; w < s; w++) {
      var E = new Kt(a.readString());
      E.order = a.readInt(true), E.skinRequired = a.readBoolean(), m = a.readInt(true);
      for (var x = 0; x < m; x++)
        E.bones.push(n.bones[a.readInt(true)]);
      E.target = n.bones[a.readInt(true)], E.mix = a.readFloat(), E.softness = a.readFloat() * r, E.bendDirection = a.readByte(), E.compress = a.readBoolean(), E.stretch = a.readBoolean(), E.uniform = a.readBoolean(), n.ikConstraints.push(E);
    }
    s = a.readInt(true);
    for (var y, b = 0; b < s; b++) {
      var S = new $t(a.readString());
      S.order = a.readInt(true), S.skinRequired = a.readBoolean(), y = a.readInt(true);
      for (var M2 = 0; M2 < y; M2++)
        S.bones.push(n.bones[a.readInt(true)]);
      S.target = n.bones[a.readInt(true)], S.local = a.readBoolean(), S.relative = a.readBoolean(), S.offsetRotation = a.readFloat(), S.offsetX = a.readFloat() * r, S.offsetY = a.readFloat() * r, S.offsetScaleX = a.readFloat(), S.offsetScaleY = a.readFloat(), S.offsetShearY = a.readFloat(), S.rotateMix = a.readFloat(), S.translateMix = a.readFloat(), S.scaleMix = a.readFloat(), S.shearMix = a.readFloat(), n.transformConstraints.push(S);
    }
    s = a.readInt(true);
    for (var A2, T2 = 0; T2 < s; T2++) {
      var I2 = new G(a.readString());
      I2.order = a.readInt(true), I2.skinRequired = a.readBoolean(), A2 = a.readInt(true);
      for (var R2 = 0; R2 < A2; R2++)
        I2.bones.push(n.bones[a.readInt(true)]);
      I2.target = n.slots[a.readInt(true)], I2.positionMode = t.PositionModeValues[a.readInt(true)], I2.spacingMode = t.SpacingModeValues[a.readInt(true)], I2.rotateMode = t.RotateModeValues[a.readInt(true)], I2.offsetRotation = a.readFloat(), I2.position = a.readFloat(), I2.positionMode == B.Fixed && (I2.position *= r), I2.spacing = a.readFloat(), I2.spacingMode != D.Length && I2.spacingMode != D.Fixed || (I2.spacing *= r), I2.rotateMix = a.readFloat(), I2.translateMix = a.readFloat(), n.pathConstraints.push(I2);
    }
    var C2 = this.readSkin(a, n, true, i);
    null != C2 && (n.defaultSkin = C2, n.skins.push(C2));
    var k2 = n.skins.length;
    for (F.setArraySize(n.skins, s = k2 + a.readInt(true)); k2 < s; k2++)
      n.skins[k2] = this.readSkin(a, n, false, i);
    s = this.linkedMeshes.length;
    for (var V2 = 0; V2 < s; V2++) {
      var _2 = this.linkedMeshes[V2], N2 = null == _2.skin ? n.defaultSkin : n.findSkin(_2.skin);
      if (null == N2)
        throw new Error("Skin not found: " + _2.skin);
      var O2 = N2.getAttachment(_2.slotIndex, _2.parent);
      if (null == O2)
        throw new Error("Parent mesh not found: " + _2.parent);
      _2.mesh.deformAttachment = _2.inheritDeform ? O2 : _2.mesh, _2.mesh.setParentMesh(O2), _2.mesh.updateUVs();
    }
    this.linkedMeshes.length = 0, s = a.readInt(true);
    for (var L2 = 0; L2 < s; L2++) {
      var Y2 = new re(a.readStringRef());
      Y2.intValue = a.readInt(false), Y2.floatValue = a.readFloat(), Y2.stringValue = a.readString(), Y2.audioPath = a.readString(), null != Y2.audioPath && (Y2.volume = a.readFloat(), Y2.balance = a.readFloat()), n.events.push(Y2);
    }
    s = a.readInt(true);
    for (var U2 = 0; U2 < s; U2++)
      n.animations.push(this.readAnimation(a, a.readString(), n));
    return n;
  }, e.readSkin = function(t2, e2, r, n) {
    var a = null, i = 0;
    if (r) {
      if (0 == (i = t2.readInt(true)))
        return null;
      a = new ee("default");
    } else {
      (a = new ee(t2.readStringRef())).bones.length = t2.readInt(true);
      for (var s = 0, o = a.bones.length; s < o; s++)
        a.bones[s] = e2.bones[t2.readInt(true)];
      for (var h = 0, l = t2.readInt(true); h < l; h++)
        a.constraints.push(e2.ikConstraints[t2.readInt(true)]);
      for (var u = 0, c = t2.readInt(true); u < c; u++)
        a.constraints.push(e2.transformConstraints[t2.readInt(true)]);
      for (var d = 0, f = t2.readInt(true); d < f; d++)
        a.constraints.push(e2.pathConstraints[t2.readInt(true)]);
      i = t2.readInt(true);
    }
    for (var v = 0; v < i; v++)
      for (var p = t2.readInt(true), g = 0, m = t2.readInt(true); g < m; g++) {
        var w = t2.readStringRef(), E = this.readAttachment(t2, e2, a, p, w, n);
        null != E && a.setAttachment(p, w, E);
      }
    return a;
  }, e.readAttachment = function(e2, r, n, a, i, s) {
    var o = this.scale, h = e2.readStringRef();
    null == h && (h = i);
    var l = e2.readByte();
    switch (t.AttachmentTypeValues[l]) {
      case ne.Region:
        var u = e2.readStringRef(), c = e2.readFloat(), d = e2.readFloat(), f = e2.readFloat(), v = e2.readFloat(), p = e2.readFloat(), g = e2.readFloat(), m = e2.readFloat(), w = e2.readInt32();
        null == u && (u = h);
        var E = this.attachmentLoader.newRegionAttachment(n, h, u);
        return null == E ? null : (E.path = u, E.x = d * o, E.y = f * o, E.scaleX = v, E.scaleY = p, E.rotation = c, E.width = g * o, E.height = m * o, P.rgba8888ToColor(E.color, w), E.updateOffset(), E);
      case ne.BoundingBox:
        var x = e2.readInt(true), y = this.readVertices(e2, x), b = s ? e2.readInt32() : 0, S = this.attachmentLoader.newBoundingBoxAttachment(n, h);
        return null == S ? null : (S.worldVerticesLength = x << 1, S.vertices = y.vertices, S.bones = y.bones, s && P.rgba8888ToColor(S.color, b), S);
      case ne.Mesh:
        var M2 = e2.readStringRef(), A2 = e2.readInt32(), T2 = e2.readInt(true), I2 = this.readFloatArray(e2, T2 << 1, 1), R2 = this.readShortArray(e2), C2 = this.readVertices(e2, T2), k2 = e2.readInt(true), V2 = null, _2 = 0, N2 = 0;
        s && (V2 = this.readShortArray(e2), _2 = e2.readFloat(), N2 = e2.readFloat()), null == M2 && (M2 = h);
        var O2 = this.attachmentLoader.newMeshAttachment(n, h, M2);
        return null == O2 ? null : (O2.path = M2, P.rgba8888ToColor(O2.color, A2), O2.bones = C2.bones, O2.vertices = C2.vertices, O2.worldVerticesLength = T2 << 1, O2.triangles = R2, O2.regionUVs = I2, O2.updateUVs(), O2.hullLength = k2 << 1, s && (O2.edges = V2, O2.width = _2 * o, O2.height = N2 * o), O2);
      case ne.LinkedMesh:
        var L2 = e2.readStringRef(), X2 = e2.readInt32(), B2 = e2.readStringRef(), D2 = e2.readStringRef(), Y2 = e2.readBoolean(), U2 = 0, W2 = 0;
        s && (U2 = e2.readFloat(), W2 = e2.readFloat()), null == L2 && (L2 = h);
        var q2 = this.attachmentLoader.newMeshAttachment(n, h, L2);
        return null == q2 ? null : (q2.path = L2, P.rgba8888ToColor(q2.color, X2), s && (q2.width = U2 * o, q2.height = W2 * o), this.linkedMeshes.push(new le(q2, B2, a, D2, Y2)), q2);
      case ne.Path:
        for (var H2 = e2.readBoolean(), j2 = e2.readBoolean(), G2 = e2.readInt(true), z2 = this.readVertices(e2, G2), Z2 = F.newArray(G2 / 3, 0), Q2 = 0, J2 = Z2.length; Q2 < J2; Q2++)
          Z2[Q2] = e2.readFloat() * o;
        var K2 = s ? e2.readInt32() : 0, $2 = this.attachmentLoader.newPathAttachment(n, h);
        return null == $2 ? null : ($2.closed = H2, $2.constantSpeed = j2, $2.worldVerticesLength = G2 << 1, $2.vertices = z2.vertices, $2.bones = z2.bones, $2.lengths = Z2, s && P.rgba8888ToColor($2.color, K2), $2);
      case ne.Point:
        var tt2 = e2.readFloat(), et2 = e2.readFloat(), rt2 = e2.readFloat(), nt2 = s ? e2.readInt32() : 0, at2 = this.attachmentLoader.newPointAttachment(n, h);
        return null == at2 ? null : (at2.x = et2 * o, at2.y = rt2 * o, at2.rotation = tt2, s && P.rgba8888ToColor(at2.color, nt2), at2);
      case ne.Clipping:
        var it2 = e2.readInt(true), st2 = e2.readInt(true), ot2 = this.readVertices(e2, st2), ht2 = s ? e2.readInt32() : 0, lt2 = this.attachmentLoader.newClippingAttachment(n, h);
        return null == lt2 ? null : (lt2.endSlot = r.slots[it2], lt2.worldVerticesLength = st2 << 1, lt2.vertices = ot2.vertices, lt2.bones = ot2.bones, s && P.rgba8888ToColor(lt2.color, ht2), lt2);
    }
    return null;
  }, e.readVertices = function(t2, e2) {
    var r = e2 << 1, n = new ue(), a = this.scale;
    if (!t2.readBoolean())
      return n.vertices = this.readFloatArray(t2, r, a), n;
    for (var i = new Array(), s = new Array(), o = 0; o < e2; o++) {
      var h = t2.readInt(true);
      s.push(h);
      for (var l = 0; l < h; l++)
        s.push(t2.readInt(true)), i.push(t2.readFloat() * a), i.push(t2.readFloat() * a), i.push(t2.readFloat());
    }
    return n.vertices = F.toFloatArray(i), n.bones = s, n;
  }, e.readFloatArray = function(t2, e2, r) {
    var n = new Array(e2);
    if (1 == r)
      for (var a = 0; a < e2; a++)
        n[a] = t2.readFloat();
    else
      for (var i = 0; i < e2; i++)
        n[i] = t2.readFloat() * r;
    return n;
  }, e.readShortArray = function(t2) {
    for (var e2 = t2.readInt(true), r = new Array(e2), n = 0; n < e2; n++)
      r[n] = t2.readShort();
    return r;
  }, e.readAnimation = function(e2, r, n) {
    for (var a = new Array(), i = this.scale, s = 0, o = new P(), h = new P(), l = 0, u = e2.readInt(true); l < u; l++)
      for (var c = e2.readInt(true), d = 0, f = e2.readInt(true); d < f; d++) {
        var v = e2.readByte(), p = e2.readInt(true);
        switch (v) {
          case t.SLOT_ATTACHMENT:
            var g = new yt(p);
            g.slotIndex = c;
            for (var m = 0; m < p; m++)
              g.setFrame(m, e2.readFloat(), e2.readStringRef());
            a.push(g), s = Math.max(s, g.frames[p - 1]);
            break;
          case t.SLOT_COLOR:
            var w = new Et(p);
            w.slotIndex = c;
            for (var E = 0; E < p; E++) {
              var x = e2.readFloat();
              P.rgba8888ToColor(o, e2.readInt32()), w.setFrame(E, x, o.r, o.g, o.b, o.a), E < p - 1 && this.readCurve(e2, E, w);
            }
            a.push(w), s = Math.max(s, w.frames[(p - 1) * Et.ENTRIES]);
            break;
          case t.SLOT_TWO_COLOR:
            var y = new xt(p);
            y.slotIndex = c;
            for (var b = 0; b < p; b++) {
              var S = e2.readFloat();
              P.rgba8888ToColor(o, e2.readInt32()), P.rgb888ToColor(h, e2.readInt32()), y.setFrame(b, S, o.r, o.g, o.b, o.a, h.r, h.g, h.b), b < p - 1 && this.readCurve(e2, b, y);
            }
            a.push(y), s = Math.max(s, y.frames[(p - 1) * xt.ENTRIES]);
        }
      }
    for (var M2 = 0, A2 = e2.readInt(true); M2 < A2; M2++)
      for (var T2 = e2.readInt(true), I2 = 0, R2 = e2.readInt(true); I2 < R2; I2++) {
        var C2 = e2.readByte(), k2 = e2.readInt(true);
        switch (C2) {
          case t.BONE_ROTATE:
            var V2 = new pt(k2);
            V2.boneIndex = T2;
            for (var _2 = 0; _2 < k2; _2++)
              V2.setFrame(_2, e2.readFloat(), e2.readFloat()), _2 < k2 - 1 && this.readCurve(e2, _2, V2);
            a.push(V2), s = Math.max(s, V2.frames[(k2 - 1) * pt.ENTRIES]);
            break;
          case t.BONE_TRANSLATE:
          case t.BONE_SCALE:
          case t.BONE_SHEAR:
            var N2 = void 0, O2 = 1;
            C2 == t.BONE_SCALE ? N2 = new mt(k2) : C2 == t.BONE_SHEAR ? N2 = new wt(k2) : (N2 = new gt(k2), O2 = i), N2.boneIndex = T2;
            for (var L2 = 0; L2 < k2; L2++)
              N2.setFrame(L2, e2.readFloat(), e2.readFloat() * O2, e2.readFloat() * O2), L2 < k2 - 1 && this.readCurve(e2, L2, N2);
            a.push(N2), s = Math.max(s, N2.frames[(k2 - 1) * gt.ENTRIES]);
        }
      }
    for (var X2 = 0, Y2 = e2.readInt(true); X2 < Y2; X2++) {
      var U2 = e2.readInt(true), W2 = e2.readInt(true), q2 = new Tt(W2);
      q2.ikConstraintIndex = U2;
      for (var H2 = 0; H2 < W2; H2++)
        q2.setFrame(H2, e2.readFloat(), e2.readFloat(), e2.readFloat() * i, e2.readByte(), e2.readBoolean(), e2.readBoolean()), H2 < W2 - 1 && this.readCurve(e2, H2, q2);
      a.push(q2), s = Math.max(s, q2.frames[(W2 - 1) * Tt.ENTRIES]);
    }
    for (var j2 = 0, G2 = e2.readInt(true); j2 < G2; j2++) {
      var z2 = e2.readInt(true), Z2 = e2.readInt(true), Q2 = new It(Z2);
      Q2.transformConstraintIndex = z2;
      for (var J2 = 0; J2 < Z2; J2++)
        Q2.setFrame(J2, e2.readFloat(), e2.readFloat(), e2.readFloat(), e2.readFloat(), e2.readFloat()), J2 < Z2 - 1 && this.readCurve(e2, J2, Q2);
      a.push(Q2), s = Math.max(s, Q2.frames[(Z2 - 1) * It.ENTRIES]);
    }
    for (var K2 = 0, $2 = e2.readInt(true); K2 < $2; K2++)
      for (var tt2 = e2.readInt(true), et2 = n.pathConstraints[tt2], rt2 = 0, nt2 = e2.readInt(true); rt2 < nt2; rt2++) {
        var at2 = e2.readByte(), it2 = e2.readInt(true);
        switch (at2) {
          case t.PATH_POSITION:
          case t.PATH_SPACING:
            var st2 = void 0, ot2 = 1;
            at2 == t.PATH_SPACING ? (st2 = new Ct(it2), et2.spacingMode != D.Length && et2.spacingMode != D.Fixed || (ot2 = i)) : (st2 = new Rt(it2), et2.positionMode == B.Fixed && (ot2 = i)), st2.pathConstraintIndex = tt2;
            for (var ht2 = 0; ht2 < it2; ht2++)
              st2.setFrame(ht2, e2.readFloat(), e2.readFloat() * ot2), ht2 < it2 - 1 && this.readCurve(e2, ht2, st2);
            a.push(st2), s = Math.max(s, st2.frames[(it2 - 1) * Rt.ENTRIES]);
            break;
          case t.PATH_MIX:
            var lt2 = new kt(it2);
            lt2.pathConstraintIndex = tt2;
            for (var ut2 = 0; ut2 < it2; ut2++)
              lt2.setFrame(ut2, e2.readFloat(), e2.readFloat(), e2.readFloat()), ut2 < it2 - 1 && this.readCurve(e2, ut2, lt2);
            a.push(lt2), s = Math.max(s, lt2.frames[(it2 - 1) * kt.ENTRIES]);
        }
      }
    for (var ct2 = 0, dt2 = e2.readInt(true); ct2 < dt2; ct2++)
      for (var vt2 = n.skins[e2.readInt(true)], bt2 = 0, Vt2 = e2.readInt(true); bt2 < Vt2; bt2++)
        for (var Pt2 = e2.readInt(true), _t2 = 0, Ft2 = e2.readInt(true); _t2 < Ft2; _t2++) {
          var Nt2 = vt2.getAttachment(Pt2, e2.readStringRef()), Ot2 = null != Nt2.bones, Lt2 = Nt2.vertices, Xt2 = Ot2 ? Lt2.length / 3 * 2 : Lt2.length, Bt2 = e2.readInt(true), Dt2 = new St(Bt2);
          Dt2.slotIndex = Pt2, Dt2.attachment = Nt2;
          for (var Yt2 = 0; Yt2 < Bt2; Yt2++) {
            var Ut2 = e2.readFloat(), Wt2 = void 0, qt2 = e2.readInt(true);
            if (0 == qt2)
              Wt2 = Ot2 ? F.newFloatArray(Xt2) : Lt2;
            else {
              Wt2 = F.newFloatArray(Xt2);
              var Ht2 = e2.readInt(true);
              if (qt2 += Ht2, 1 == i)
                for (var jt2 = Ht2; jt2 < qt2; jt2++)
                  Wt2[jt2] = e2.readFloat();
              else
                for (var Gt2 = Ht2; Gt2 < qt2; Gt2++)
                  Wt2[Gt2] = e2.readFloat() * i;
              if (!Ot2)
                for (var zt2 = 0, Zt2 = Wt2.length; zt2 < Zt2; zt2++)
                  Wt2[zt2] += Lt2[zt2];
            }
            Dt2.setFrame(Yt2, Ut2, Wt2), Yt2 < Bt2 - 1 && this.readCurve(e2, Yt2, Dt2);
          }
          a.push(Dt2), s = Math.max(s, Dt2.frames[Bt2 - 1]);
        }
    var Qt2 = e2.readInt(true);
    if (Qt2 > 0) {
      for (var Jt2 = new At(Qt2), Kt2 = n.slots.length, $t2 = 0; $t2 < Qt2; $t2++) {
        for (var te2 = e2.readFloat(), ee2 = e2.readInt(true), re2 = F.newArray(Kt2, 0), ne2 = Kt2 - 1; ne2 >= 0; ne2--)
          re2[ne2] = -1;
        for (var ie2 = F.newArray(Kt2 - ee2, 0), se2 = 0, oe2 = 0, he2 = 0; he2 < ee2; he2++) {
          for (var le2 = e2.readInt(true); se2 != le2; )
            ie2[oe2++] = se2++;
          re2[se2 + e2.readInt(true)] = se2++;
        }
        for (; se2 < Kt2; )
          ie2[oe2++] = se2++;
        for (var ue2 = Kt2 - 1; ue2 >= 0; ue2--)
          -1 == re2[ue2] && (re2[ue2] = ie2[--oe2]);
        Jt2.setFrame($t2, te2, re2);
      }
      a.push(Jt2), s = Math.max(s, Jt2.frames[Qt2 - 1]);
    }
    var ce2 = e2.readInt(true);
    if (ce2 > 0) {
      for (var de2 = new Mt(ce2), fe2 = 0; fe2 < ce2; fe2++) {
        var ve2 = e2.readFloat(), pe2 = n.events[e2.readInt(true)], ge = new ae(ve2, pe2);
        ge.intValue = e2.readInt(false), ge.floatValue = e2.readFloat(), ge.stringValue = e2.readBoolean() ? e2.readString() : pe2.stringValue, null != ge.data.audioPath && (ge.volume = e2.readFloat(), ge.balance = e2.readFloat()), de2.setFrame(fe2, ge);
      }
      a.push(de2), s = Math.max(s, de2.frames[ce2 - 1]);
    }
    return new ft(r, a, s);
  }, e.readCurve = function(e2, r, n) {
    switch (e2.readByte()) {
      case t.CURVE_STEPPED:
        n.setStepped(r);
        break;
      case t.CURVE_BEZIER:
        this.setCurve(n, r, e2.readFloat(), e2.readFloat(), e2.readFloat(), e2.readFloat());
    }
  }, e.setCurve = function(t2, e2, r, n, a, i) {
    t2.setCurve(e2, r, n, a, i);
  }, t;
}();
oe.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6], oe.TransformModeValues = [N.Normal, N.OnlyTranslation, N.NoRotationOrReflection, N.NoScale, N.NoScaleOrReflection], oe.PositionModeValues = [B.Fixed, B.Percent], oe.SpacingModeValues = [D.Length, D.Fixed, D.Percent], oe.RotateModeValues = [Y.Tangent, Y.Chain, Y.ChainScale], oe.BlendModeValues = [Ht.Normal, Ht.Additive, Ht.Multiply, Ht.Screen], oe.BONE_ROTATE = 0, oe.BONE_TRANSLATE = 1, oe.BONE_SCALE = 2, oe.BONE_SHEAR = 3, oe.SLOT_ATTACHMENT = 0, oe.SLOT_COLOR = 1, oe.SLOT_TWO_COLOR = 2, oe.PATH_POSITION = 0, oe.PATH_SPACING = 1, oe.PATH_MIX = 2, oe.CURVE_LINEAR = 0, oe.CURVE_STEPPED = 1, oe.CURVE_BEZIER = 2;
var he = function() {
  function t(t2, e2, r, n) {
    void 0 === e2 && (e2 = new Array()), void 0 === r && (r = 0), void 0 === n && (n = new DataView(t2.buffer)), this.strings = e2, this.index = r, this.buffer = n;
  }
  var e = t.prototype;
  return e.readByte = function() {
    return this.buffer.getInt8(this.index++);
  }, e.readShort = function() {
    var t2 = this.buffer.getInt16(this.index);
    return this.index += 2, t2;
  }, e.readInt32 = function() {
    var t2 = this.buffer.getInt32(this.index);
    return this.index += 4, t2;
  }, e.readInt = function(t2) {
    var e2 = this.readByte(), r = 127 & e2;
    return 0 != (128 & e2) && (r |= (127 & (e2 = this.readByte())) << 7, 0 != (128 & e2) && (r |= (127 & (e2 = this.readByte())) << 14, 0 != (128 & e2) && (r |= (127 & (e2 = this.readByte())) << 21, 0 != (128 & e2) && (r |= (127 & (e2 = this.readByte())) << 28)))), t2 ? r : r >>> 1 ^ -(1 & r);
  }, e.readStringRef = function() {
    var t2 = this.readInt(true);
    return 0 == t2 ? null : this.strings[t2 - 1];
  }, e.readString = function() {
    var t2 = this.readInt(true);
    switch (t2) {
      case 0:
        return null;
      case 1:
        return "";
    }
    t2--;
    for (var e2 = "", r = 0; r < t2; ) {
      var n = this.readByte();
      switch (n >> 4) {
        case 12:
        case 13:
          e2 += String.fromCharCode((31 & n) << 6 | 63 & this.readByte()), r += 2;
          break;
        case 14:
          e2 += String.fromCharCode((15 & n) << 12 | (63 & this.readByte()) << 6 | 63 & this.readByte()), r += 3;
          break;
        default:
          e2 += String.fromCharCode(n), r++;
      }
    }
    return e2;
  }, e.readFloat = function() {
    var t2 = this.buffer.getFloat32(this.index);
    return this.index += 4, t2;
  }, e.readBoolean = function() {
    return 0 != this.readByte();
  }, t;
}(), le = function(t, e, r, n, a) {
  this.mesh = t, this.skin = e, this.slotIndex = r, this.parent = n, this.inheritDeform = a;
}, ue = function(t, e) {
  void 0 === t && (t = null), void 0 === e && (e = null), this.bones = t, this.vertices = e;
}, ce = function(t) {
  function e() {
    return t.apply(this, arguments);
  }
  R(e, t);
  var r = e.prototype;
  return r.load = function(t2, e2) {
    var r2 = this;
    return new AssetPromise(function(n, a) {
      var i, s = e2.engine;
      "spine" !== t2.type && a("Asset type must be spine."), !t2.urls && t2.url && r2.checkUrl(t2.url) && (i = r2.getResouceFromUrl(t2.url)), t2.urls && r2.checkUrls(t2.urls) && (i = r2.getResouceFromUrls(t2.urls));
      var h, l = false;
      h = new jt(null, function(t3) {
        return r2.createAdaptiveTexture(t3, s);
      });
      var u = i.skeletonFile, c = i.atlasFile, d = i.textureFile;
      h.onLoadComplete = function() {
        try {
          var t3;
          if (l)
            t3 = h.get(c);
          else {
            var e3 = h.get(c);
            t3 = new ot(e3, r2.textureAssetPicker.bind(r2, h, d));
          }
          var i2 = new Zt(t3), f2 = (r2.isBinFile(u) ? new oe(i2) : new ie(i2)).readSkeletonData(h.get(u)), v = new Entity(s), p = v.addComponent(MeshRenderer), g = Ut.getDefaultMaterial(s);
          p.setMaterial(g), v.addComponent(Ut).setSkeletonData(f2), n(v);
        } catch (t4) {
          a(t4);
        }
      };
      var f = r2.isBinFile(u);
      u && c && d ? (f ? h.loadBinary(u, null, a) : h.loadText(u, null, a), h.loadText(c, null, a), h.loadTexture(d, null, a)) : u && c && !d ? (l = true, f ? h.loadBinary(u, null, a) : h.loadText(u, null, a), h.loadTextureAtlas(c, null, a)) : a("Resouce param error");
    });
  }, r.textureAssetPicker = function(t2, e2) {
    return t2.get(e2);
  }, r.createAdaptiveTexture = function(t2, e2) {
    return new de(t2, e2);
  }, r.isBinFile = function(t2) {
    return "bin" === this.getExtFromUrl(t2);
  }, r.checkUrl = function(t2) {
    var e2 = this.getExtFromUrl(t2);
    return "json" === e2 || "bin" === e2 || (console.error("When use url as params, url must be json or bin file"), false);
  }, r.getResouceFromUrl = function(t2) {
    var e2 = t2, r2 = t2, n = r2.indexOf("?");
    return n > 0 && (r2 = r2.substr(0, n)), { skeletonFile: e2, atlasFile: r2 = r2.substr(0, r2.lastIndexOf(".")) + ".atlas" };
  }, r.checkUrls = function(t2) {
    if (t2.length < 2)
      return console.error("When use urls as params, urls should at least contain: json/bin and atlas"), false;
    if (t2.length > 3)
      return console.error("Spine runtime dont support multiple texture now"), false;
    var e2 = this.getResouceFromUrls(t2), r2 = e2.skeletonFile, n = e2.atlasFile;
    return e2.textureFile, !(!r2 || !n) || (console.error("Lack " + (r2 ? "" : "skeletonFile") + (n ? " atlasFile" : "")), false);
  }, r.getResouceFromUrls = function(t2) {
    for (var e2, r2, n, a = 0; a < t2.length; a += 1) {
      var i = t2[a], s = this.getExtFromUrl(i);
      "json" !== s && "bin" !== s || (e2 = i), "atlas" === s && (r2 = i);
      ["png", "jpg", "webp", "jpeg"].includes(s) && (n = i);
    }
    return { skeletonFile: e2, atlasFile: r2, textureFile: n };
  }, r.getExtFromUrl = function(t2) {
    return t2.split(/[#?]/)[0].split(".").pop().trim();
  }, e;
}(Loader);
ce = C([resourceLoader("spine", ["json", "bin"])], ce);
var de = function(t) {
  function e(e2, r2) {
    var n;
    return (n = t.call(this, e2) || this).texture = new Texture2D(r2, e2.width, e2.height), n.texture.setImageSource(e2), n.texture.generateMipmaps(), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.setFilters = function(t2, e2) {
    t2 === $.Nearest ? this.texture.filterMode = TextureFilterMode.Point : e2 === $.MipMapLinearLinear ? this.texture.filterMode = TextureFilterMode.Trilinear : this.texture.filterMode = TextureFilterMode.Bilinear;
  }, r.setWraps = function(t2, e2) {
    this.texture.wrapModeU = t2, this.texture.wrapModeV = e2;
  }, r.dispose = function() {
  }, e;
}(et), fe = function(t) {
  function e() {
    return t.apply(this, arguments);
  }
  R(e, t);
  var r = e.prototype;
  return r.load = function(t2, e2) {
    var r2 = this;
    return new AssetPromise(function(n, a) {
      var i = e2.engine;
      if (t2.url)
        if (r2.checkUrl(t2.url)) {
          var s, h, l, u, c, d = t2.url;
          u = new jt(null, function(t3) {
            return r2.createAdaptiveTexture(t3, i);
          }), (c = d, new Promise(function(t3, e3) {
            var r3 = new XMLHttpRequest();
            r3.responseType = "json", r3.open("GET", c, true), r3.onload = function() {
              200 == r3.status ? t3(r3.response) : e3("status:" + r3.status + ", " + r3.responseText);
            }, r3.onerror = function() {
              e3("status:" + r3.status + ", " + r3.responseText);
            }, r3.send();
          })).then(function(t3) {
            if (l = t3, t3._ext) {
              var e3 = t3._ext, r3 = e3.atlas, n2 = e3.images, i2 = n2[Object.keys(n2)[0]];
              s = r3, h = i2, u.loadText(r3), u.loadTexture(i2);
            } else
              a("AntG spine json must have ext data");
          }).catch(function() {
            a("Resouce json load fail");
          }), u.onLoadComplete = function() {
            var t3, e3 = u.get(s);
            t3 = new ot(e3, r2.textureAssetPicker.bind(r2, u, h));
            var a2 = new Zt(t3), c2 = new ie(a2).readSkeletonData(l), d2 = new Entity(i), f = d2.addComponent(MeshRenderer);
            f.shaderData.enableMacro("USE_MODEL_MATRIX"), f.shaderData.enableMacro("USE_CUSTOM_TEXTURE");
            var v = i._spriteDefaultMaterial.clone();
            f.setMaterial(v), d2.addComponent(Ut).setSkeletonData(c2), n(d2);
          };
        } else
          a("AntG asset must be a json url.");
      else
        a("AntG asset must be a json url.");
    });
  }, r.textureAssetPicker = function(t2, e2) {
    return t2.get(e2);
  }, r.createAdaptiveTexture = function(t2, e2) {
    return new ve(t2, e2);
  }, r.checkUrl = function(t2) {
    return "json" === this.getExtFromUrl(t2) || (console.error("When use url as params, url must be a json file"), false);
  }, r.getExtFromUrl = function(t2) {
    return t2.split(/[#?]/)[0].split(".").pop().trim();
  }, e;
}(Loader);
fe = C([resourceLoader("antg_spine", ["json", "bin"])], fe);
var ve = function(t) {
  function e(e2, r2) {
    var n;
    return (n = t.call(this, e2) || this).texture = new Texture2D(r2, e2.width, e2.height), n.texture.setImageSource(e2), n.texture.generateMipmaps(), n;
  }
  R(e, t);
  var r = e.prototype;
  return r.setFilters = function(t2, e2) {
    t2 === $.Nearest ? this.texture.filterMode = TextureFilterMode.Point : e2 === $.MipMapLinearLinear ? this.texture.filterMode = TextureFilterMode.Trilinear : this.texture.filterMode = TextureFilterMode.Bilinear;
  }, r.setWraps = function(t2, e2) {
    this.texture.wrapModeU = t2, this.texture.wrapModeV = e2;
  }, r.dispose = function() {
  }, e;
}(et);
var pe = "1.0.0-beta.1";
console.log("Galacean spine version :" + pe);
function getFileUrl(type, path, modelName, fileType) {
  return `${path}/${type}/${modelName}/${modelName}.${fileType}`;
}
function getSceneFileUrl(path, modelName, fileName, fileType) {
  return `${path}/scene/${modelName}/${fileName}.${fileType}`;
}
function readFile(path, file, type = "json") {
  let url = getFileUrl("spine", path, file, type);
  let context = loadFile(url);
  if (context === null) {
    return null;
  } else {
    switch (type) {
      case "json":
        return JSON.parse(context);
      case "text":
        return context;
      default:
        return null;
    }
  }
}
function loadFile(url) {
  const xhr = new XMLHttpRequest();
  const okStatus = document.location.protocol === "file:" ? 0 : 200;
  xhr.open("GET", url, false);
  xhr.overrideMimeType("text/html; charset=utf-8");
  xhr.send(null);
  return xhr.status === okStatus ? xhr.responseText : null;
}
class SpineModel {
  constructor(_engine, _rootEntity, _path, _modelList, _modelFolder, _guiMap) {
    this.engine = _engine;
    this.rootEntity = _rootEntity;
    this.path = _path;
    this.modelList = _modelList;
    this.modelFolder = _modelFolder;
    this.guiMap = _guiMap;
    this.model = this.modelList[0];
    this.spineEntity = new Entity(this.engine, void 0);
    this.skinController = null;
    this.actionController = null;
  }
  loadModelByName(model) {
    let atlasPath = getFileUrl("spine", this.path, model, "atlas");
    let jsonPath = getFileUrl("spine", this.path, model, "json");
    let pngPath = getFileUrl("spine", this.path, model, "png");
    this.engine.resourceManager.load({
      urls: [jsonPath, atlasPath, pngPath],
      type: "spine"
    }).then((spineEntity) => {
      this.rootEntity.removeChild(this.spineEntity);
      this.spineEntity.destroy();
      spineEntity.transform.setPosition(0, -0.4, 16);
      this.rootEntity.addChild(spineEntity);
      this.spineEntity = spineEntity;
      const spineAnimation = spineEntity.getComponent(Ut);
      spineAnimation.scale = 2e-3;
      const { skeleton, state } = spineAnimation;
      const { skinList, actionList } = this.loadModelResource(model);
      skeleton.setSkinByName(skinList[0]);
      state.setAnimation(0, actionList[0], true);
      state.apply(skeleton);
      return { state, skeleton, skinList, actionList };
    }).then(({ state, skeleton, skinList, actionList }) => {
      this.modelModifyGui(state, skeleton, skinList, actionList);
    });
  }
  loadModelResource(model) {
    let modelJson = readFile(this.path, model, "json");
    let skinList = modelJson.skins.map((skin) => skin.name).slice(1);
    let actionList = Object.keys(modelJson.animations);
    return { skinList, actionList };
  }
  modelSelectGui() {
    this.guiMap.spineName = this.model;
    this.modelFolder.add(this.guiMap, "spineName", this.modelList).name("\u6A21\u578B\u540D\u79F0").onChange((v) => {
      this.loadModelByName(v);
    });
    this.modelFolder.open();
    this.loadModelByName(this.model);
  }
  modelModifyGui(state, skeleton, skinList, actionList) {
    this.guiMap.spineSkin = skinList[0];
    this.guiMap.spineAction = actionList[0];
    if (this.skinController && this.actionController) {
      this.modelFolder.remove(this.skinController);
      this.modelFolder.remove(this.actionController);
    }
    this.skinController = this.modelFolder.add(this.guiMap, "spineSkin", skinList).name("\u6A21\u578B\u76AE\u80A4").onChange((v) => {
      skeleton.setSkinByName(v);
      state.apply(skeleton);
    });
    this.actionController = this.modelFolder.add(this.guiMap, "spineAction", actionList).name("\u6A21\u578B\u52A8\u4F5C").onChange((v) => {
      state.setAnimation(0, v, true);
    });
  }
}
class GltfModel {
  constructor(_engine, _rootEntity, _path) {
    this.engine = _engine;
    this.rootEntity = _rootEntity;
    this.path = _path;
    this.gltfEntity = new Entity(this.engine, void 0);
    this.gltfController = null;
  }
  loadGui(_modelList, _modelFolder, _guiMap) {
    this.modelList = _modelList;
    this.model = this.modelList[0];
    this.modelFolder = _modelFolder;
    this.guiMap = _guiMap;
  }
  loadModelByName(model) {
    let gltfPath = getFileUrl("gltf", this.path, model, "gltf");
    this.engine.resourceManager.load(
      gltfPath
    ).then((gltf) => {
      const { animations, materials, defaultSceneRoot } = gltf;
      this.gltfEntity = defaultSceneRoot;
      this.gltfEntity.transform.setPosition(0, -2, 20);
      this.rootEntity.addChild(this.gltfEntity);
      const animator = defaultSceneRoot.getComponent(Animator);
      if (model === "lion") {
        let lightEntity = this.rootEntity.createChild("direct_light");
        let light = lightEntity.addComponent(DirectLight);
        light.color = new Color$1(1, 1, 1);
        light.intensity = 0.8;
        animator.play(animations == null ? void 0 : animations.at(-1).name);
        materials == null ? void 0 : materials.forEach((material) => {
          material.emissiveColor = new Color$1(0, 0, 0);
        });
      } else {
        animator.play(animations[0].name);
      }
      console.log(this.gltfEntity);
    });
  }
  modelSelectGui() {
    this.modelFolder.add(this.guiMap, "gltfOn", false).name("gltf\u6A21\u578B\u5F00\u5173").onChange((v) => {
      if (v) {
        this.guiMap.gltfName = "";
        this.gltfController = this.modelFolder.add(this.guiMap, "gltfName", this.modelList).name("\u6A21\u578B\u540D\u79F0").onChange((v2) => {
          this.rootEntity.removeChild(this.gltfEntity);
          this.loadModelByName(v2);
        });
      } else {
        if (this.gltfController) {
          this.rootEntity.removeChild(this.gltfEntity);
          this.modelFolder.remove(this.gltfController);
        }
      }
    });
  }
}
function createText(rootEntity, text, pos = new Vector3(0, 0.25, 0), color = new Color$1(0, 0, 0, 1), fontFamily = "Arial", fontSize = 26, bold = false, italic = false) {
  const textEntity = rootEntity.createChild("text");
  textEntity.transform.position = pos;
  textEntity.transform.setScale(10, 10, 10);
  const renderer = textEntity.addComponent(TextRenderer);
  renderer.color = color;
  renderer.text = text;
  renderer.font = Font.createFromOS(textEntity.engine, fontFamily);
  renderer.fontSize = fontSize;
  bold && (renderer.fontStyle |= FontStyle.Bold);
  italic && (renderer.fontStyle |= FontStyle.Italic);
  return textEntity;
}
function __variableDynamicImportRuntime1__(path) {
  switch (path) {
    case "../lottie/box.ts":
      return import("./box.js");
    case "../lottie/card.ts":
      return import("./card.js");
    case "../lottie/lion.ts":
      return import("./lion.js");
    case "../lottie/logo.ts":
      return import("./logo.js");
    default:
      return new Promise(function(resolve, reject) {
        (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
          reject.bind(null, new Error("Unknown variable dynamic import: " + path))
        );
      });
  }
}
function __variableDynamicImportRuntime0__(path) {
  switch (path) {
    case "../particle/food.ts":
      return import("./food.js");
    case "../particle/red.ts":
      return import("./red.js");
    case "../particle/snow.ts":
      return import("./snow.js");
    default:
      return new Promise(function(resolve, reject) {
        (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
          reject.bind(null, new Error("Unknown variable dynamic import: " + path))
        );
      });
  }
}
class Item {
  constructor(_engine, _rootEntity, _path) {
    this.engine = _engine;
    this.rootEntity = _rootEntity;
    this.path = _path;
    this.particleList = [];
    this.particleEntity = new Entity(this.engine, void 0);
    this.particleController = null;
    this.lottieList = [];
    this.lottieEntity = new Entity(this.engine, void 0);
    this.lottieController = null;
    this.textEntity = new Entity(this.engine, void 0);
  }
  loadGui(_itemFolder, _guiMap) {
    this.itemFolder = _itemFolder;
    this.guiMap = _guiMap;
  }
  loadParticleList(particleList) {
    this.particleList = particleList;
  }
  loadParticleByName(particle) {
    let particleSrc = getFileUrl("particle", this.path, particle, "png");
    this.engine.resourceManager.load({
      url: particleSrc,
      type: AssetType.Texture2D
    }).then((resource) => {
      __variableDynamicImportRuntime0__(
        `../particle/${particle}.ts`
      ).then((entity) => {
        let particleFunc = entity.default;
        this.particleEntity = particleFunc(this.rootEntity, resource);
      }).catch((err) => {
        console.error(err);
      });
    });
  }
  loadLottieList(lottieList) {
    this.lottieList = lottieList;
  }
  async loadLottieByName(lottie) {
    let jsonPath = getFileUrl("lottie", this.path, lottie, "json");
    let atlasPath = getFileUrl("lottie", this.path, lottie, "atlas");
    let item = await __variableDynamicImportRuntime1__(`../lottie/${lottie}.ts`);
    this.engine.resourceManager.load({
      urls: [
        jsonPath,
        atlasPath
      ],
      type: "lottie"
    }).then((lottieEntity) => {
      let itemFunc = item.default;
      this.lottieEntity = itemFunc(this.rootEntity, lottieEntity);
    });
  }
  loadText(text) {
    this.textEntity = createText(this.rootEntity, text);
  }
  particleSelectGui() {
    const particleFolder = this.itemFolder.addFolder("\u7C92\u5B50\u6548\u679C");
    particleFolder.add(this.guiMap, "particleOn", false).name("\u7C92\u5B50\u6548\u679C\u5F00\u5173").onChange((v) => {
      if (v) {
        this.guiMap.particle = "";
        this.particleController = particleFolder.add(this.guiMap, "particle", this.particleList).name("\u7C92\u5B50\u6548\u679C\u540D\u79F0").onChange((v2) => {
          this.rootEntity.removeChild(this.particleEntity);
          this.particleEntity.destroy();
          this.loadParticleByName(v2);
        });
      } else {
        if (this.particleController) {
          this.rootEntity.removeChild(this.particleEntity);
          this.particleEntity.destroy();
          particleFolder.remove(this.particleController);
        }
      }
    });
  }
  lottieSelectGui() {
    const lottieFolder = this.itemFolder.addFolder("lottie\u6548\u679C");
    lottieFolder.add(this.guiMap, "lottieOn", false).name("lottie\u5F00\u5173").onChange((v) => {
      if (v) {
        this.guiMap.lottie = "";
        this.lottieController = lottieFolder.add(this.guiMap, "lottie", this.lottieList).name("lottie\u540D\u79F0").onChange(async (v2) => {
          this.rootEntity.removeChild(this.lottieEntity);
          this.lottieEntity.destroy();
          this.loadLottieByName(v2);
        });
      } else {
        this.rootEntity.removeChild(this.lottieEntity);
        this.lottieEntity.destroy();
        lottieFolder.remove(this.lottieController);
      }
    });
  }
  textOnGui() {
    const textFolder = this.itemFolder.addFolder("\u6587\u5B57\u6548\u679C");
    textFolder.add(this.guiMap, "textOn", false).name("\u6587\u5B57\u5F00\u5173").onChange((v) => {
      if (v) {
        this.loadText("Hello World!");
      } else {
        this.rootEntity.removeChild(this.textEntity);
        this.textEntity.destroy();
      }
    });
  }
}
class Scene {
  constructor(_engine, _background, _path) {
    this.engine = _engine;
    this.background = _background;
    this.path = _path;
    this.skyMaterial = this.background.sky.material = new SkyBoxMaterial(this.engine);
    this.textureList = [];
    this.textureController = null;
    this.fitModeController = null;
    this.skyList = [];
    this.skyController = null;
    this.colorController = null;
    this.colorController2 = null;
    this.sceneType = this.background.mode = 2;
  }
  loadGui(_sceneFolder, _guiMap) {
    this.sceneFolder = _sceneFolder;
    this.guiMap = _guiMap;
  }
  loadTextureList(textureList) {
    this.textureList = textureList;
  }
  loadTextureByName(texture, fitMode) {
    this.background.mode = BackgroundMode.Texture;
    let textureSrc = getSceneFileUrl(this.path, "Texture2D", texture, "png");
    this.engine.resourceManager.load({
      url: textureSrc,
      type: AssetType.Texture2D
    }).then((texture2) => {
      this.background.texture = texture2;
      this.background.textureFillMode = fitMode;
    });
  }
  loadSkyList(skyList) {
    this.skyList = skyList;
  }
  loadSkyByName(sky, skyType) {
    this.background.mode = BackgroundMode.Sky;
    this.background.sky.mesh = PrimitiveMesh.createCuboid(this.engine, 2, 2, 2);
    let skySrcs = [];
    let skySrc = "";
    let load2;
    if (skyType === "six") {
      for (let i = 1; i <= 6; i++) {
        skySrcs.push(getSceneFileUrl(this.path, sky, "" + i, "jpeg"));
      }
      load2 = {
        urls: skySrcs,
        type: AssetType.TextureCube
      };
    } else {
      skySrc = getSceneFileUrl(this.path, "bin", sky, "bin");
      load2 = {
        url: skySrc,
        type: AssetType.HDR
      };
    }
    this.engine.resourceManager.load(load2).then((cubeMap) => {
      if (skyType === "hdr") {
        this.skyMaterial.textureDecodeRGBM = true;
      } else {
        this.skyMaterial.textureDecodeRGBM = false;
      }
      this.skyMaterial.texture = cubeMap;
    });
  }
  loadColorByRGBA(color) {
    this.background.mode = BackgroundMode.SolidColor;
    this.background.solidColor.set(color[0], color[1], color[2], color[3]);
  }
  textureSelectGui() {
    if (this.sceneType === 2) {
      this.guiMap.texture = this.textureList[0];
      this.guiMap.fitMode = 0;
      this.textureController = this.sceneFolder.add(this.guiMap, "texture", this.textureList).name("\u7EB9\u7406\u540D\u79F0").onChange((v) => {
        this.loadTextureByName(this.guiMap.texture, parseInt(this.guiMap.fitMode));
      });
      this.fitModeController = this.sceneFolder.add(this.guiMap, "fitMode", { AspectFitWidth: 0, AspectFitHeight: 1, Fill: 2 }).name("\u7EB9\u7406\u9002\u914D\u6A21\u5F0F").onChange((v) => {
        this.loadTextureByName(this.guiMap.texture, parseInt(this.guiMap.fitMode));
      });
      this.loadTextureByName(this.guiMap.texture, parseInt(this.guiMap.fitMode));
    } else {
      if (this.textureController) {
        this.sceneFolder.remove(this.textureController);
        this.textureController = null;
      }
      if (this.fitModeController) {
        this.sceneFolder.remove(this.fitModeController);
        this.fitModeController = null;
      }
    }
  }
  skySelectGui() {
    if (this.sceneType === 1) {
      this.guiMap.sky = this.skyList[0];
      this.skyController = this.sceneFolder.add(this.guiMap, "sky", this.skyList).name("\u5929\u7A7A\u76D2\u540D\u79F0").onChange((v) => {
        this.loadSkyByName(this.guiMap.sky.split("-")[0], this.guiMap.sky.split("-")[1]);
      });
      this.loadSkyByName(this.guiMap.sky.split("-")[0], this.guiMap.sky.split("-")[1]);
    } else {
      if (this.skyController) {
        this.sceneFolder.remove(this.skyController);
        this.skyController = null;
      }
    }
  }
  colorSelectGui() {
    if (this.sceneType === 0) {
      const solidColor = this.background.solidColor;
      let colorObj = {
        color: [
          solidColor.r,
          solidColor.g,
          solidColor.b
        ]
      };
      let color = { a: 0.5 };
      colorObj.color = [100, 100, 100];
      this.colorController = this.sceneFolder.addColor(colorObj, "color").name("\u989C\u8272").onChange((v) => {
        this.loadColorByRGBA([colorObj.color[0] / 255, colorObj.color[1] / 255, colorObj.color[2] / 255, color.a]);
      });
      this.colorController2 = this.sceneFolder.add(color, "a", 0, 1).name("\u900F\u660E\u5EA6").onChange((v2) => {
        this.loadColorByRGBA([colorObj.color[0] / 255, colorObj.color[1] / 255, colorObj.color[2] / 255, color.a]);
      });
      this.loadColorByRGBA([colorObj.color[0] / 255, colorObj.color[1] / 255, colorObj.color[2] / 255, color.a]);
    } else {
      if (this.colorController) {
        this.sceneFolder.remove(this.colorController);
        this.colorController = null;
      }
      if (this.colorController2) {
        this.sceneFolder.remove(this.colorController2);
        this.colorController2 = null;
      }
    }
  }
  sceneSelectGui() {
    this.sceneFolder.add(this.background, "mode", {
      Sky: BackgroundMode.Sky,
      SolidColor: BackgroundMode.SolidColor,
      Texture: BackgroundMode.Texture
    }).name("\u80CC\u666F\u7C7B\u578B").onChange((v) => {
      this.sceneType = this.background.mode = parseInt(v);
      this.textureSelectGui();
      this.skySelectGui();
      this.colorSelectGui();
    });
    this.textureSelectGui();
    this.skySelectGui();
    this.colorSelectGui();
  }
}
Logger.enable();
const gui = new GUI$1({ width: 350 });
const guiMap = {
  spineName: "",
  spineSkin: "",
  spineAction: "",
  gltfOn: false,
  gltfName: "",
  particleOn: false,
  particle: "",
  lottieOn: false,
  lottie: "",
  textOn: false,
  texture: "",
  fitMode: null
};
async function createRuntime(canvas = "canvas", path, spineModelList, gltfModelList, particleList, lottieList, textureList, skyList) {
  const engine = await WebGLEngine.create({ canvas });
  engine.canvas.resizeByClientSize();
  const scene = engine.sceneManager.activeScene;
  const rootEntity = scene.createRootEntity();
  const cameraEntity = rootEntity.createChild("camera");
  cameraEntity.addComponent(Camera);
  cameraEntity.addComponent(OrbitControl);
  cameraEntity.transform.position = new Vector3(0, 0, 20);
  const spineModelFolder = gui.addFolder("spine\u6A21\u578B");
  const spineModel = new SpineModel(engine, rootEntity, path, spineModelList, spineModelFolder, guiMap);
  spineModel.modelSelectGui();
  const gltfModelFolder = gui.addFolder("gltf\u6A21\u578B");
  gltfModelFolder.open();
  const gltfModel = new GltfModel(engine, rootEntity, path);
  gltfModel.loadGui(gltfModelList, gltfModelFolder, guiMap);
  gltfModel.modelSelectGui();
  const itemFolder = gui.addFolder("\u5143\u7D20");
  itemFolder.open();
  const item = new Item(engine, rootEntity, path);
  item.loadGui(itemFolder, guiMap);
  item.loadParticleList(particleList);
  item.loadLottieList(lottieList);
  item.particleSelectGui();
  item.lottieSelectGui();
  item.textOnGui();
  const { background } = scene;
  const sceneFolder = gui.addFolder("\u80CC\u666F");
  sceneFolder.open();
  const scenec = new Scene(engine, background, path);
  scenec.loadGui(sceneFolder, guiMap);
  scenec.loadTextureList(textureList);
  scenec.loadSkyList(skyList);
  scenec.sceneSelectGui();
  engine.run();
}
export { AssetType as A, Color$1 as C, Entity as E, Font as F, Loader as L, ParticleRenderer as P, Renderer as R, SpriteRenderer as S, TextureWrapMode$1 as T, Vector2 as V, TextRenderer as a, Logger as b, Engine as c, Layer as d, Script as e, AssetPromise as f, EngineObject as g, Sprite as h, ignoreClone as i, Vector3 as j, ParticleRendererBlendMode as k, createRuntime as l, resourceLoader as r };
